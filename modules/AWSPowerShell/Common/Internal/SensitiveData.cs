/*******************************************************************************
 *  Copyright 2012-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 *  this file except in compliance with the License. A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 *  or in the "license" file accompanying this file.
 *  This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 *  CONDITIONS OF ANY KIND, either express or implied. See the License for the
 *  specific language governing permissions and limitations under the License.
 * *****************************************************************************
 *
 *  AWS Tools for Windows (TM) PowerShell (TM)
 *
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Amazon.PowerShell.Common.Internal
{
    /// <summary>
    /// Helper class for redacting data that is marked Sensitive.
    /// </summary>
    internal class SensitiveData
    {

        /// <summary>
        /// GetSanitizedData redacts data that is marked Sensitive. This specifically handles Request and Response classes generated by SDK
        /// The public properties of the Request and Response classes are of type Value types, MemoryStream, Stream, List<>, Dictionary<> and Classes under Amazon namespace
        /// See aws-sdk-net/generator/ServiceClientGeneratorLib/Member.cs class DetermineType for the types of the properties.
        /// </summary>
        internal static object GetSanitizedData(object data)
        {
            if (data == null)
            {
                return default;
            }

            Type type = data.GetType();

            if (type.IsValueType || type == typeof(string))
            {
                return data;
            }

            // return null if no empty constructor
            if (type.GetConstructor(Type.EmptyTypes) == null)
            {
                return null;
            }

            if (data is IList listData)
            {
                IList sanitizedListData = (IList)Activator.CreateInstance(data.GetType());
                foreach (var item in listData)
                {
                    sanitizedListData.Add(GetSanitizedData(item));
                }
                return sanitizedListData;
            }

            if (data is IDictionary dictionaryData)
            {
                IDictionary sanitizedDictionaryData = (IDictionary)Activator.CreateInstance(data.GetType());
                foreach (DictionaryEntry item in dictionaryData)
                {
                    sanitizedDictionaryData.Add(GetSanitizedData(item.Key), GetSanitizedData(item.Value));
                }
                return sanitizedDictionaryData;
            }

            object sanitizedData = Activator.CreateInstance(data.GetType());
            // Ignore properties that don't have a setter 
            var properties = type.GetProperties().Where(p => p.GetSetMethod(nonPublic: true) != null);
            foreach (PropertyInfo propertyInfo in properties)
            {
              if (!IsPropertySensitive(propertyInfo))
                {
                    if (TypeContainsSensitiveData(propertyInfo.PropertyType))
                    {
                        // non-sensitive property that contains nested sensitive property
                        var originalPropertyValue = propertyInfo.GetValue(data);
                        propertyInfo.SetValue(sanitizedData, GetSanitizedData(originalPropertyValue));
                    }
                    else
                    {
                        // non-sensitive property. Copy the original value
                        var originalPropertyValue = propertyInfo.GetValue(data);
                        propertyInfo.SetValue(sanitizedData, originalPropertyValue);
                    }
                }
            }
            return sanitizedData;
        }

        internal static bool IsPropertySensitive(PropertyInfo propertyInfo)
        {
            bool isPropertySensitive = false;
            var awsPropertyAttributePre = propertyInfo.GetCustomAttributes()
                .Where(attribute => attribute.GetType().FullName == "Amazon.Runtime.Internal.AWSPropertyAttribute").SingleOrDefault();
            if (awsPropertyAttributePre != null)
            {
                var sensitiveProperty = awsPropertyAttributePre.GetType().GetProperty("Sensitive");
                var sensitivePropertyValue = sensitiveProperty.GetValue(awsPropertyAttributePre);
                if (sensitivePropertyValue != null)
                {
                    isPropertySensitive = (bool)sensitivePropertyValue;
                }
            }
            return isPropertySensitive;
        }

        internal static bool TypeContainsSensitiveData(Type type, HashSet<Type> visitedTypes = null)
        {
            if (visitedTypes == null)
                visitedTypes = new HashSet<Type>();

            if (visitedTypes.Contains(type))
                return false;

            visitedTypes.Add(type);

            foreach (var childProperty in type.GetProperties())
            {
                if (IsPropertySensitive(childProperty))
                {
                    return true;
                }
                // Only recurse if the type of property is in the Amazon. namespace
                else if (childProperty.PropertyType.FullName.Contains("Amazon.") && TypeContainsSensitiveData(childProperty.PropertyType, visitedTypes))
                {
                    return true;
                }
            }
            return false;
        }

    }
}
