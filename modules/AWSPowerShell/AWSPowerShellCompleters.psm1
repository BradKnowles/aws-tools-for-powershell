# Auto-generated argument completers for parameters of SDK ConstantClass-derived type used in cmdlets.
# Do not modify this file; it may be overwritten during version upgrades.

$psMajorVersion = $PSVersionTable.PSVersion.Major
if ($psMajorVersion -eq 2) 
{ 
	Write-Verbose "Dynamic argument completion not supported in PowerShell version 2; skipping load."
	return 
}

# PowerShell's native Register-ArgumentCompleter cmdlet is available on v5.0 or higher. For lower
# version, we can use the version in the TabExpansion++ module if installed.
$registrationCmdletAvailable = ($psMajorVersion -ge 5) -Or !((Get-Command Register-ArgumentCompleter -ea Ignore) -eq $null)

# internal function to perform the registration using either cmdlet or manipulation
# of the options table
function _awsArgumentCompleterRegistration()
{
    param
    (
        [scriptblock]$scriptBlock,
        [hashtable]$param2CmdletsMap
    )

    if ($registrationCmdletAvailable)
    {
        foreach ($paramName in $param2CmdletsMap.Keys)
        {
             $args = @{
                "ScriptBlock" = $scriptBlock
                "Parameter" = $paramName
            }

            $cmdletNames = $param2CmdletsMap[$paramName]
            if ($cmdletNames -And $cmdletNames.Length -gt 0)
            {
                $args["Command"] = $cmdletNames
            }

            Register-ArgumentCompleter @args
        }
    }
    else
    {
        if (-not $global:options) { $global:options = @{ CustomArgumentCompleters = @{ }; NativeArgumentCompleters = @{ } } }

        foreach ($paramName in $param2CmdletsMap.Keys)
        {
            $cmdletNames = $param2CmdletsMap[$paramName]

            if ($cmdletNames -And $cmdletNames.Length -gt 0)
            {
                foreach ($cn in $cmdletNames)
                {
                    $fqn =  [string]::Concat($cn, ":", $paramName)
                    $global:options['CustomArgumentCompleters'][$fqn] = $scriptBlock
                }
            }
            else
            {
                $global:options['CustomArgumentCompleters'][$paramName] = $scriptBlock
            }
        }

        $function:tabexpansion2 = $function:tabexpansion2 -replace 'End\r\n{', 'End { if ($null -ne $options) { $options += $global:options} else {$options = $global:options}'
    }
}

# To allow for same-name parameters of different ConstantClass-derived types 
# each completer function checks on command name concatenated with parameter name.
# Additionally, the standard code pattern for completers is to pipe through 
# sort-object after filtering against $wordToComplete but we omit this as our members 
# are already sorted.

# Argument completions for service AWS IAM Access Analyzer


$IAMAA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AccessAnalyzer.FindingStatusUpdate
        "Update-IAMAAFinding/Status"
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }

        # Amazon.AccessAnalyzer.Locale
        "Use-IAMAAPolicyValidation/Locale"
        {
            $v = "DE","EN","ES","FR","IT","JA","KO","PT_BR","ZH_CN","ZH_TW"
            break
        }

        # Amazon.AccessAnalyzer.OrderBy
        "Get-IAMAAFindingList/Sort_OrderBy"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.AccessAnalyzer.PolicyType
        "Use-IAMAAPolicyValidation/PolicyType"
        {
            $v = "IDENTITY_POLICY","RESOURCE_POLICY","SERVICE_CONTROL_POLICY"
            break
        }

        # Amazon.AccessAnalyzer.ResourceType
        "Get-IAMAAAnalyzedResourceList/ResourceType"
        {
            $v = "AWS::EC2::Snapshot","AWS::ECR::Repository","AWS::EFS::FileSystem","AWS::IAM::Role","AWS::KMS::Key","AWS::Lambda::Function","AWS::Lambda::LayerVersion","AWS::RDS::DBClusterSnapshot","AWS::RDS::DBSnapshot","AWS::S3::Bucket","AWS::SecretsManager::Secret","AWS::SNS::Topic","AWS::SQS::Queue"
            break
        }

        # Amazon.AccessAnalyzer.Type
        {
            ($_ -eq "Get-IAMAAAnalyzerList/Type") -Or
            ($_ -eq "New-IAMAAAnalyzer/Type")
        }
        {
            $v = "ACCOUNT","ORGANIZATION"
            break
        }

        # Amazon.AccessAnalyzer.ValidatePolicyResourceType
        "Use-IAMAAPolicyValidation/ValidatePolicyResourceType"
        {
            $v = "AWS::IAM::AssumeRolePolicyDocument","AWS::S3::AccessPoint","AWS::S3::Bucket","AWS::S3::MultiRegionAccessPoint","AWS::S3ObjectLambda::AccessPoint"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMAA_map = @{
    "Locale"=@("Use-IAMAAPolicyValidation")
    "PolicyType"=@("Use-IAMAAPolicyValidation")
    "ResourceType"=@("Get-IAMAAAnalyzedResourceList")
    "Sort_OrderBy"=@("Get-IAMAAFindingList")
    "Status"=@("Update-IAMAAFinding")
    "Type"=@("Get-IAMAAAnalyzerList","New-IAMAAAnalyzer")
    "ValidatePolicyResourceType"=@("Use-IAMAAPolicyValidation")
}

_awsArgumentCompleterRegistration $IAMAA_Completers $IAMAA_map

$IAMAA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IAMAA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMAA_SelectMap = @{
    "Select"=@("Start-IAMAAArchiveRule",
               "Stop-IAMAAPolicyGeneration",
               "New-IAMAAAccessPreview",
               "New-IAMAAAnalyzer",
               "New-IAMAAArchiveRule",
               "Remove-IAMAAAnalyzer",
               "Remove-IAMAAArchiveRule",
               "Get-IAMAAAccessPreview",
               "Get-IAMAAAnalyzedResource",
               "Get-IAMAAAnalyzer",
               "Get-IAMAAArchiveRule",
               "Get-IAMAAFinding",
               "Get-IAMAAGeneratedPolicy",
               "Get-IAMAAAccessPreviewFindingList",
               "Get-IAMAAAccessPreviewList",
               "Get-IAMAAAnalyzedResourceList",
               "Get-IAMAAAnalyzerList",
               "Get-IAMAAArchiveRuleList",
               "Get-IAMAAFindingList",
               "Get-IAMAAPolicyGenerationList",
               "Get-IAMAAResourceTag",
               "Start-IAMAAPolicyGeneration",
               "Start-IAMAAResourceScan",
               "Add-IAMAAResourceTag",
               "Remove-IAMAAResourceTag",
               "Update-IAMAAArchiveRule",
               "Update-IAMAAFinding",
               "Use-IAMAAPolicyValidation")
}

_awsArgumentCompleterRegistration $IAMAA_SelectCompleters $IAMAA_SelectMap
# Argument completions for service AWS Account


$ACCT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Account.AlternateContactType
        {
            ($_ -eq "Get-ACCTAlternateContact/AlternateContactType") -Or
            ($_ -eq "Remove-ACCTAlternateContact/AlternateContactType") -Or
            ($_ -eq "Write-ACCTAlternateContact/AlternateContactType")
        }
        {
            $v = "BILLING","OPERATIONS","SECURITY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACCT_map = @{
    "AlternateContactType"=@("Get-ACCTAlternateContact","Remove-ACCTAlternateContact","Write-ACCTAlternateContact")
}

_awsArgumentCompleterRegistration $ACCT_Completers $ACCT_map

$ACCT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACCT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACCT_SelectMap = @{
    "Select"=@("Remove-ACCTAlternateContact",
               "Get-ACCTAlternateContact",
               "Get-ACCTContactInformation",
               "Write-ACCTAlternateContact",
               "Write-ACCTContactInformation")
}

_awsArgumentCompleterRegistration $ACCT_SelectCompleters $ACCT_SelectMap
# Argument completions for service AWS Certificate Manager


$ACM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CertificateManager.CertificateTransparencyLoggingPreference
        {
            ($_ -eq "New-ACMCertificate/Options_CertificateTransparencyLoggingPreference") -Or
            ($_ -eq "Update-ACMCertificateOption/Options_CertificateTransparencyLoggingPreference")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.CertificateManager.KeyAlgorithm
        "New-ACMCertificate/KeyAlgorithm"
        {
            $v = "EC_prime256v1","EC_secp384r1","EC_secp521r1","RSA_1024","RSA_2048","RSA_3072","RSA_4096"
            break
        }

        # Amazon.CertificateManager.SortBy
        "Get-ACMCertificateList/SortBy"
        {
            $v = "CREATED_AT"
            break
        }

        # Amazon.CertificateManager.SortOrder
        "Get-ACMCertificateList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.CertificateManager.ValidationMethod
        "New-ACMCertificate/ValidationMethod"
        {
            $v = "DNS","EMAIL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACM_map = @{
    "KeyAlgorithm"=@("New-ACMCertificate")
    "Options_CertificateTransparencyLoggingPreference"=@("New-ACMCertificate","Update-ACMCertificateOption")
    "SortBy"=@("Get-ACMCertificateList")
    "SortOrder"=@("Get-ACMCertificateList")
    "ValidationMethod"=@("New-ACMCertificate")
}

_awsArgumentCompleterRegistration $ACM_Completers $ACM_map

$ACM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACM_SelectMap = @{
    "Select"=@("Add-ACMCertificateTag",
               "Remove-ACMCertificate",
               "Get-ACMCertificateDetail",
               "Export-ACMCertificate",
               "Get-ACMAccountConfiguration",
               "Get-ACMCertificate",
               "Import-ACMCertificate",
               "Get-ACMCertificateList",
               "Get-ACMCertificateTagList",
               "Write-ACMAccountConfiguration",
               "Remove-ACMCertificateTag",
               "Invoke-ACMCertificateRenewal",
               "New-ACMCertificate",
               "Send-ACMValidationEmail",
               "Update-ACMCertificateOption")
}

_awsArgumentCompleterRegistration $ACM_SelectCompleters $ACM_SelectMap
# Argument completions for service AWS Certificate Manager Private Certificate Authority


$PCA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ACMPCA.AuditReportResponseFormat
        "New-PCACertificateAuthorityAuditReport/AuditReportResponseFormat"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.ACMPCA.CertificateAuthorityStatus
        "Update-PCACertificateAuthority/Status"
        {
            $v = "ACTIVE","CREATING","DELETED","DISABLED","EXPIRED","FAILED","PENDING_CERTIFICATE"
            break
        }

        # Amazon.ACMPCA.CertificateAuthorityType
        "New-PCACertificateAuthority/CertificateAuthorityType"
        {
            $v = "ROOT","SUBORDINATE"
            break
        }

        # Amazon.ACMPCA.CertificateAuthorityUsageMode
        "New-PCACertificateAuthority/UsageMode"
        {
            $v = "GENERAL_PURPOSE","SHORT_LIVED_CERTIFICATE"
            break
        }

        # Amazon.ACMPCA.KeyStorageSecurityStandard
        "New-PCACertificateAuthority/KeyStorageSecurityStandard"
        {
            $v = "FIPS_140_2_LEVEL_2_OR_HIGHER","FIPS_140_2_LEVEL_3_OR_HIGHER"
            break
        }

        # Amazon.ACMPCA.ResourceOwner
        "Get-PCACertificateAuthorityList/ResourceOwner"
        {
            $v = "OTHER_ACCOUNTS","SELF"
            break
        }

        # Amazon.ACMPCA.RevocationReason
        "Revoke-PCACertificate/RevocationReason"
        {
            $v = "AFFILIATION_CHANGED","A_A_COMPROMISE","CERTIFICATE_AUTHORITY_COMPROMISE","CESSATION_OF_OPERATION","KEY_COMPROMISE","PRIVILEGE_WITHDRAWN","SUPERSEDED","UNSPECIFIED"
            break
        }

        # Amazon.ACMPCA.SigningAlgorithm
        "New-PCACertificate/SigningAlgorithm"
        {
            $v = "SHA256WITHECDSA","SHA256WITHRSA","SHA384WITHECDSA","SHA384WITHRSA","SHA512WITHECDSA","SHA512WITHRSA"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PCA_map = @{
    "AuditReportResponseFormat"=@("New-PCACertificateAuthorityAuditReport")
    "CertificateAuthorityType"=@("New-PCACertificateAuthority")
    "KeyStorageSecurityStandard"=@("New-PCACertificateAuthority")
    "ResourceOwner"=@("Get-PCACertificateAuthorityList")
    "RevocationReason"=@("Revoke-PCACertificate")
    "SigningAlgorithm"=@("New-PCACertificate")
    "Status"=@("Update-PCACertificateAuthority")
    "UsageMode"=@("New-PCACertificateAuthority")
}

_awsArgumentCompleterRegistration $PCA_Completers $PCA_map

$PCA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PCA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PCA_SelectMap = @{
    "Select"=@("New-PCACertificateAuthority",
               "New-PCACertificateAuthorityAuditReport",
               "New-PCAPermission",
               "Remove-PCACertificateAuthority",
               "Remove-PCAPermission",
               "Remove-PCAPolicy",
               "Get-PCACertificateAuthority",
               "Get-PCACertificateAuthorityAuditReport",
               "Get-PCACertificate",
               "Get-PCACertificateAuthorityCertificate",
               "Get-PCACertificateAuthorityCsr",
               "Get-PCAPolicy",
               "Import-PCACertificateAuthorityCertificate",
               "New-PCACertificate",
               "Get-PCACertificateAuthorityList",
               "Get-PCAPermissionList",
               "Get-PCACertificateAuthorityTagList",
               "Set-PCAPolicy",
               "Restore-PCACertificateAuthority",
               "Revoke-PCACertificate",
               "Add-PCACertificateAuthorityTag",
               "Remove-PCACertificateAuthorityTag",
               "Update-PCACertificateAuthority")
}

_awsArgumentCompleterRegistration $PCA_SelectCompleters $PCA_SelectMap
# Argument completions for service Alexa For Business


$ALXB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AlexaForBusiness.BusinessReportFormat
        {
            ($_ -eq "New-ALXBBusinessReportSchedule/Format") -Or
            ($_ -eq "Update-ALXBBusinessReportSchedule/Format")
        }
        {
            $v = "CSV","CSV_ZIP"
            break
        }

        # Amazon.AlexaForBusiness.BusinessReportInterval
        "New-ALXBBusinessReportSchedule/ContentRange_Interval"
        {
            $v = "ONE_DAY","ONE_WEEK","THIRTY_DAYS"
            break
        }

        # Amazon.AlexaForBusiness.CommsProtocol
        {
            ($_ -eq "New-ALXBConferenceProvider/IPDialIn_CommsProtocol") -Or
            ($_ -eq "Update-ALXBConferenceProvider/IPDialIn_CommsProtocol")
        }
        {
            $v = "H323","SIP","SIPS"
            break
        }

        # Amazon.AlexaForBusiness.ConferenceProviderType
        {
            ($_ -eq "New-ALXBConferenceProvider/ConferenceProviderType") -Or
            ($_ -eq "Update-ALXBConferenceProvider/ConferenceProviderType")
        }
        {
            $v = "BLUEJEANS","CHIME","CUSTOM","FUZE","GOOGLE_HANGOUTS","POLYCOM","RINGCENTRAL","SKYPE_FOR_BUSINESS","WEBEX","ZOOM"
            break
        }

        # Amazon.AlexaForBusiness.DeviceEventType
        "Get-ALXBDeviceEventList/EventType"
        {
            $v = "CONNECTION_STATUS","DEVICE_STATUS"
            break
        }

        # Amazon.AlexaForBusiness.DeviceUsageType
        "Remove-ALXBDeviceUsageData/DeviceUsageType"
        {
            $v = "VOICE"
            break
        }

        # Amazon.AlexaForBusiness.DistanceUnit
        {
            ($_ -eq "New-ALXBProfile/DistanceUnit") -Or
            ($_ -eq "Update-ALXBProfile/DistanceUnit")
        }
        {
            $v = "IMPERIAL","METRIC"
            break
        }

        # Amazon.AlexaForBusiness.EnablementTypeFilter
        "Get-ALXBSkillList/EnablementType"
        {
            $v = "ENABLED","PENDING"
            break
        }

        # Amazon.AlexaForBusiness.EndOfMeetingReminderType
        {
            ($_ -eq "New-ALXBProfile/MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType") -Or
            ($_ -eq "Update-ALXBProfile/MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType")
        }
        {
            $v = "ANNOUNCEMENT_TIME_CHECK","ANNOUNCEMENT_VARIABLE_TIME_LEFT","CHIME","KNOCK"
            break
        }

        # Amazon.AlexaForBusiness.NetworkEapMethod
        "New-ALXBNetworkProfile/EapMethod"
        {
            $v = "EAP_TLS"
            break
        }

        # Amazon.AlexaForBusiness.NetworkSecurityType
        "New-ALXBNetworkProfile/SecurityType"
        {
            $v = "OPEN","WEP","WPA2_ENTERPRISE","WPA2_PSK","WPA_PSK"
            break
        }

        # Amazon.AlexaForBusiness.RequirePin
        {
            ($_ -eq "New-ALXBConferenceProvider/MeetingSetting_RequirePin") -Or
            ($_ -eq "Update-ALXBConferenceProvider/MeetingSetting_RequirePin")
        }
        {
            $v = "NO","OPTIONAL","YES"
            break
        }

        # Amazon.AlexaForBusiness.SkillTypeFilter
        "Get-ALXBSkillList/SkillType"
        {
            $v = "ALL","PRIVATE","PUBLIC"
            break
        }

        # Amazon.AlexaForBusiness.TemperatureUnit
        {
            ($_ -eq "New-ALXBProfile/TemperatureUnit") -Or
            ($_ -eq "Update-ALXBProfile/TemperatureUnit")
        }
        {
            $v = "CELSIUS","FAHRENHEIT"
            break
        }

        # Amazon.AlexaForBusiness.WakeWord
        {
            ($_ -eq "New-ALXBProfile/WakeWord") -Or
            ($_ -eq "Update-ALXBProfile/WakeWord")
        }
        {
            $v = "ALEXA","AMAZON","COMPUTER","ECHO"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ALXB_map = @{
    "ConferenceProviderType"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "ContentRange_Interval"=@("New-ALXBBusinessReportSchedule")
    "DeviceUsageType"=@("Remove-ALXBDeviceUsageData")
    "DistanceUnit"=@("New-ALXBProfile","Update-ALXBProfile")
    "EapMethod"=@("New-ALXBNetworkProfile")
    "EnablementType"=@("Get-ALXBSkillList")
    "EventType"=@("Get-ALXBDeviceEventList")
    "Format"=@("New-ALXBBusinessReportSchedule","Update-ALXBBusinessReportSchedule")
    "IPDialIn_CommsProtocol"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType"=@("New-ALXBProfile","Update-ALXBProfile")
    "MeetingSetting_RequirePin"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "SecurityType"=@("New-ALXBNetworkProfile")
    "SkillType"=@("Get-ALXBSkillList")
    "TemperatureUnit"=@("New-ALXBProfile","Update-ALXBProfile")
    "WakeWord"=@("New-ALXBProfile","Update-ALXBProfile")
}

_awsArgumentCompleterRegistration $ALXB_Completers $ALXB_map

$ALXB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ALXB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ALXB_SelectMap = @{
    "Select"=@("Approve-ALXBSkill",
               "Add-ALXBContactToAddressBook",
               "Add-ALXBDeviceToNetworkProfile",
               "Add-ALXBDeviceToRoom",
               "Add-ALXBSkillGroupToRoom",
               "Add-ALXBSkillToSkillGroup",
               "Add-ALXBSkillToUser",
               "New-ALXBAddressBook",
               "New-ALXBBusinessReportSchedule",
               "New-ALXBConferenceProvider",
               "New-ALXBContact",
               "New-ALXBGatewayGroup",
               "New-ALXBNetworkProfile",
               "New-ALXBProfile",
               "New-ALXBRoom",
               "New-ALXBSkillGroup",
               "New-ALXBUser",
               "Remove-ALXBAddressBook",
               "Remove-ALXBBusinessReportSchedule",
               "Remove-ALXBConferenceProvider",
               "Remove-ALXBContact",
               "Remove-ALXBDevice",
               "Remove-ALXBDeviceUsageData",
               "Remove-ALXBGatewayGroup",
               "Remove-ALXBNetworkProfile",
               "Remove-ALXBProfile",
               "Remove-ALXBRoom",
               "Remove-ALXBRoomSkillParameter",
               "Remove-ALXBSkillAuthorization",
               "Remove-ALXBSkillGroup",
               "Remove-ALXBUser",
               "Remove-ALXBContactFromAddressBook",
               "Remove-ALXBDeviceFromRoom",
               "Remove-ALXBSkillFromSkillGroup",
               "Remove-ALXBSkillFromUser",
               "Remove-ALXBSkillGroupFromRoom",
               "Remove-ALXBSmartHomeAppliance",
               "Get-ALXBAddressBook",
               "Get-ALXBConferencePreference",
               "Get-ALXBConferenceProvider",
               "Get-ALXBContact",
               "Get-ALXBDevice",
               "Get-ALXBGateway",
               "Get-ALXBGatewayGroup",
               "Get-ALXBInvitationConfiguration",
               "Get-ALXBNetworkProfile",
               "Get-ALXBProfile",
               "Get-ALXBRoom",
               "Get-ALXBRoomSkillParameter",
               "Get-ALXBSkillGroup",
               "Get-ALXBBusinessReportScheduleList",
               "Get-ALXBConferenceProviderList",
               "Get-ALXBDeviceEventList",
               "Get-ALXBGatewayGroupList",
               "Get-ALXBGatewayList",
               "Get-ALXBSkillList",
               "Get-ALXBSkillsStoreCategoryList",
               "Get-ALXBSkillsStoreSkillListByCategory",
               "Get-ALXBSmartHomeApplianceList",
               "Get-ALXBTagList",
               "Write-ALXBConferencePreference",
               "Write-ALXBInvitationConfiguration",
               "Set-ALXBRoomSkillParameter",
               "Write-ALXBSkillAuthorization",
               "Register-ALXBAVSDevice",
               "Deny-ALXBSkill",
               "Resolve-ALXBRoom",
               "Revoke-ALXBInvitation",
               "Search-ALXBAddressBook",
               "Search-ALXBContact",
               "Find-ALXBDevice",
               "Search-ALXBNetworkProfile",
               "Find-ALXBProfile",
               "Find-ALXBRoom",
               "Find-ALXBSkillGroup",
               "Find-ALXBUser",
               "Send-ALXBAnnouncement",
               "Send-ALXBInvitation",
               "Start-ALXBDeviceSync",
               "Start-ALXBSmartHomeApplianceDiscovery",
               "Add-ALXBResourceTag",
               "Remove-ALXBResourceTag",
               "Update-ALXBAddressBook",
               "Update-ALXBBusinessReportSchedule",
               "Update-ALXBConferenceProvider",
               "Update-ALXBContact",
               "Update-ALXBDevice",
               "Update-ALXBGateway",
               "Update-ALXBGatewayGroup",
               "Update-ALXBNetworkProfile",
               "Update-ALXBProfile",
               "Update-ALXBRoom",
               "Update-ALXBSkillGroup")
}

_awsArgumentCompleterRegistration $ALXB_SelectCompleters $ALXB_SelectMap
# Argument completions for service AWS Amplify


$AMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Amplify.JobType
        "Start-AMPJob/JobType"
        {
            $v = "MANUAL","RELEASE","RETRY","WEB_HOOK"
            break
        }

        # Amazon.Amplify.Platform
        {
            ($_ -eq "New-AMPApp/Platform") -Or
            ($_ -eq "Update-AMPApp/Platform")
        }
        {
            $v = "WEB","WEB_DYNAMIC"
            break
        }

        # Amazon.Amplify.Stage
        {
            ($_ -eq "New-AMPApp/AutoBranchCreationConfig_Stage") -Or
            ($_ -eq "Update-AMPApp/AutoBranchCreationConfig_Stage") -Or
            ($_ -eq "New-AMPBranch/Stage") -Or
            ($_ -eq "Update-AMPBranch/Stage")
        }
        {
            $v = "BETA","DEVELOPMENT","EXPERIMENTAL","PRODUCTION","PULL_REQUEST"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMP_map = @{
    "AutoBranchCreationConfig_Stage"=@("New-AMPApp","Update-AMPApp")
    "JobType"=@("Start-AMPJob")
    "Platform"=@("New-AMPApp","Update-AMPApp")
    "Stage"=@("New-AMPBranch","Update-AMPBranch")
}

_awsArgumentCompleterRegistration $AMP_Completers $AMP_map

$AMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMP_SelectMap = @{
    "Select"=@("New-AMPApp",
               "New-AMPBackendEnvironment",
               "New-AMPBranch",
               "New-AMPDeployment",
               "New-AMPDomainAssociation",
               "New-AMPWebhook",
               "Remove-AMPApp",
               "Remove-AMPBackendEnvironment",
               "Remove-AMPBranch",
               "Remove-AMPDomainAssociation",
               "Remove-AMPJob",
               "Remove-AMPWebhook",
               "New-AMPAccessLog",
               "Get-AMPApp",
               "Get-AMPArtifactUrl",
               "Get-AMPBackendEnvironment",
               "Get-AMPBranch",
               "Get-AMPDomainAssociation",
               "Get-AMPJob",
               "Get-AMPWebhook",
               "Get-AMPAppList",
               "Get-AMPArtifactList",
               "Get-AMPBackendEnvironmentList",
               "Get-AMPBranchList",
               "Get-AMPDomainAssociationList",
               "Get-AMPJobList",
               "Get-AMPResourceTag",
               "Get-AMPWebhookList",
               "Start-AMPDeployment",
               "Start-AMPJob",
               "Stop-AMPJob",
               "Add-AMPResourceTag",
               "Remove-AMPResourceTag",
               "Update-AMPApp",
               "Update-AMPBranch",
               "Update-AMPDomainAssociation",
               "Update-AMPWebhook")
}

_awsArgumentCompleterRegistration $AMP_SelectCompleters $AMP_SelectMap
# Argument completions for service Amplify Backend


$AMPB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AmplifyBackend.AuthResources
        {
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_AuthResources") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_AuthResources")
        }
        {
            $v = "IDENTITY_POOL_AND_USER_POOL","USER_POOL_ONLY"
            break
        }

        # Amazon.AmplifyBackend.DeliveryMethod
        {
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_ForgotPassword_DeliveryMethod") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_ForgotPassword_DeliveryMethod") -Or
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_VerificationMessage_DeliveryMethod") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_VerificationMessage_DeliveryMethod")
        }
        {
            $v = "EMAIL","SMS"
            break
        }

        # Amazon.AmplifyBackend.MFAMode
        {
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_Mfa_MFAMode") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_Mfa_MFAMode")
        }
        {
            $v = "OFF","ON","OPTIONAL"
            break
        }

        # Amazon.AmplifyBackend.Mode
        {
            ($_ -eq "Get-AMPBBackendAPI/ResourceConfig_DefaultAuthType_Mode") -Or
            ($_ -eq "New-AMPBBackendAPI/ResourceConfig_DefaultAuthType_Mode") -Or
            ($_ -eq "Remove-AMPBBackendAPI/ResourceConfig_DefaultAuthType_Mode") -Or
            ($_ -eq "Update-AMPBBackendAPI/ResourceConfig_DefaultAuthType_Mode")
        }
        {
            $v = "AMAZON_COGNITO_USER_POOLS","API_KEY","AWS_IAM","OPENID_CONNECT"
            break
        }

        # Amazon.AmplifyBackend.OAuthGrantType
        {
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_OAuth_OAuthGrantType") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_OAuth_OAuthGrantType")
        }
        {
            $v = "CODE","IMPLICIT"
            break
        }

        # Amazon.AmplifyBackend.ResolutionStrategy
        {
            ($_ -eq "Get-AMPBBackendAPI/ResourceConfig_ConflictResolution_ResolutionStrategy") -Or
            ($_ -eq "New-AMPBBackendAPI/ResourceConfig_ConflictResolution_ResolutionStrategy") -Or
            ($_ -eq "Remove-AMPBBackendAPI/ResourceConfig_ConflictResolution_ResolutionStrategy") -Or
            ($_ -eq "Update-AMPBBackendAPI/ResourceConfig_ConflictResolution_ResolutionStrategy")
        }
        {
            $v = "AUTOMERGE","LAMBDA","NONE","OPTIMISTIC_CONCURRENCY"
            break
        }

        # Amazon.AmplifyBackend.Service
        {
            ($_ -eq "New-AMPBBackendAuth/ResourceConfig_Service") -Or
            ($_ -eq "Update-AMPBBackendAuth/ResourceConfig_Service")
        }
        {
            $v = "COGNITO"
            break
        }

        # Amazon.AmplifyBackend.ServiceName
        {
            ($_ -eq "New-AMPBBackendStorage/ResourceConfig_ServiceName") -Or
            ($_ -eq "Update-AMPBBackendStorage/ResourceConfig_ServiceName") -Or
            ($_ -eq "Import-AMPBBackendStorage/ServiceName") -Or
            ($_ -eq "Remove-AMPBBackendStorage/ServiceName")
        }
        {
            $v = "S3"
            break
        }

        # Amazon.AmplifyBackend.SignInMethod
        "New-AMPBBackendAuth/ResourceConfig_UserPoolConfigs_SignInMethod"
        {
            $v = "EMAIL","EMAIL_AND_PHONE_NUMBER","PHONE_NUMBER","USERNAME"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMPB_map = @{
    "ResourceConfig_AuthResources"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ResourceConfig_ConflictResolution_ResolutionStrategy"=@("Get-AMPBBackendAPI","New-AMPBBackendAPI","Remove-AMPBBackendAPI","Update-AMPBBackendAPI")
    "ResourceConfig_DefaultAuthType_Mode"=@("Get-AMPBBackendAPI","New-AMPBBackendAPI","Remove-AMPBBackendAPI","Update-AMPBBackendAPI")
    "ResourceConfig_Service"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ResourceConfig_ServiceName"=@("New-AMPBBackendStorage","Update-AMPBBackendStorage")
    "ResourceConfig_UserPoolConfigs_ForgotPassword_DeliveryMethod"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ResourceConfig_UserPoolConfigs_Mfa_MFAMode"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ResourceConfig_UserPoolConfigs_OAuth_OAuthGrantType"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ResourceConfig_UserPoolConfigs_SignInMethod"=@("New-AMPBBackendAuth")
    "ResourceConfig_UserPoolConfigs_VerificationMessage_DeliveryMethod"=@("New-AMPBBackendAuth","Update-AMPBBackendAuth")
    "ServiceName"=@("Import-AMPBBackendStorage","Remove-AMPBBackendStorage")
}

_awsArgumentCompleterRegistration $AMPB_Completers $AMPB_map

$AMPB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMPB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMPB_SelectMap = @{
    "Select"=@("Copy-AMPBBackend",
               "New-AMPBBackend",
               "New-AMPBBackendAPI",
               "New-AMPBBackendAuth",
               "New-AMPBBackendConfig",
               "New-AMPBBackendStorage",
               "New-AMPBToken",
               "Remove-AMPBBackend",
               "Remove-AMPBBackendAPI",
               "Remove-AMPBBackendAuth",
               "Remove-AMPBBackendStorage",
               "Remove-AMPBToken",
               "New-AMPBBackendAPIModel",
               "Get-AMPBBackend",
               "Get-AMPBBackendAPI",
               "Get-AMPBBackendAPIModel",
               "Get-AMPBBackendAuth",
               "Get-AMPBBackendJob",
               "Get-AMPBBackendStorage",
               "Get-AMPBToken",
               "Import-AMPBBackendAuth",
               "Import-AMPBBackendStorage",
               "Get-AMPBBackendJobList",
               "Get-AMPBS3BucketList",
               "Remove-AMPBAllBackend",
               "Remove-AMPBBackendConfig",
               "Update-AMPBBackendAPI",
               "Update-AMPBBackendAuth",
               "Update-AMPBBackendConfig",
               "Update-AMPBBackendJob",
               "Update-AMPBBackendStorage")
}

_awsArgumentCompleterRegistration $AMPB_SelectCompleters $AMPB_SelectMap
# Argument completions for service AWS Amplify UI Builder


$AMPUI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AmplifyUIBuilder.FixedPosition
        {
            ($_ -eq "New-AMPUIForm/FormToCreate_Cta_Cancel_Position_Fixed") -Or
            ($_ -eq "New-AMPUIForm/FormToCreate_Cta_Clear_Position_Fixed") -Or
            ($_ -eq "New-AMPUIForm/FormToCreate_Cta_Submit_Position_Fixed") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_Cta_Cancel_Position_Fixed") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_Cta_Clear_Position_Fixed") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_Cta_Submit_Position_Fixed")
        }
        {
            $v = "first"
            break
        }

        # Amazon.AmplifyUIBuilder.FormActionType
        {
            ($_ -eq "New-AMPUIForm/FormToCreate_FormActionType") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_FormActionType")
        }
        {
            $v = "create","update"
            break
        }

        # Amazon.AmplifyUIBuilder.FormButtonsPosition
        {
            ($_ -eq "New-AMPUIForm/FormToCreate_Cta_Position") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_Cta_Position")
        }
        {
            $v = "bottom","top","top_and_bottom"
            break
        }

        # Amazon.AmplifyUIBuilder.FormDataSourceType
        {
            ($_ -eq "New-AMPUIForm/FormToCreate_DataType_DataSourceType") -Or
            ($_ -eq "Update-AMPUIForm/UpdatedForm_DataType_DataSourceType")
        }
        {
            $v = "Custom","DataStore"
            break
        }

        # Amazon.AmplifyUIBuilder.TokenProviders
        {
            ($_ -eq "Convert-AMPUICodeForToken/Provider") -Or
            ($_ -eq "Update-AMPUIToken/Provider")
        }
        {
            $v = "figma"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMPUI_map = @{
    "FormToCreate_Cta_Cancel_Position_Fixed"=@("New-AMPUIForm")
    "FormToCreate_Cta_Clear_Position_Fixed"=@("New-AMPUIForm")
    "FormToCreate_Cta_Position"=@("New-AMPUIForm")
    "FormToCreate_Cta_Submit_Position_Fixed"=@("New-AMPUIForm")
    "FormToCreate_DataType_DataSourceType"=@("New-AMPUIForm")
    "FormToCreate_FormActionType"=@("New-AMPUIForm")
    "Provider"=@("Convert-AMPUICodeForToken","Update-AMPUIToken")
    "UpdatedForm_Cta_Cancel_Position_Fixed"=@("Update-AMPUIForm")
    "UpdatedForm_Cta_Clear_Position_Fixed"=@("Update-AMPUIForm")
    "UpdatedForm_Cta_Position"=@("Update-AMPUIForm")
    "UpdatedForm_Cta_Submit_Position_Fixed"=@("Update-AMPUIForm")
    "UpdatedForm_DataType_DataSourceType"=@("Update-AMPUIForm")
    "UpdatedForm_FormActionType"=@("Update-AMPUIForm")
}

_awsArgumentCompleterRegistration $AMPUI_Completers $AMPUI_map

$AMPUI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMPUI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMPUI_SelectMap = @{
    "Select"=@("New-AMPUIComponent",
               "New-AMPUIForm",
               "New-AMPUITheme",
               "Remove-AMPUIComponent",
               "Remove-AMPUIForm",
               "Remove-AMPUITheme",
               "Convert-AMPUICodeForToken",
               "Export-AMPUIComponent",
               "Export-AMPUIForm",
               "Export-AMPUITheme",
               "Get-AMPUIComponent",
               "Get-AMPUIForm",
               "Get-AMPUIMetadata",
               "Get-AMPUITheme",
               "Get-AMPUIComponentList",
               "Get-AMPUIFormList",
               "Get-AMPUIThemeList",
               "Write-AMPUIMetadataFlag",
               "Update-AMPUIToken",
               "Update-AMPUIComponent",
               "Update-AMPUIForm",
               "Update-AMPUITheme")
}

_awsArgumentCompleterRegistration $AMPUI_SelectCompleters $AMPUI_SelectMap
# Argument completions for service Amazon API Gateway


$AG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.APIGateway.ApiKeysFormat
        "Import-AGApiKey/Format"
        {
            $v = "csv"
            break
        }

        # Amazon.APIGateway.ApiKeySourceType
        "New-AGRestApi/ApiKeySource"
        {
            $v = "AUTHORIZER","HEADER"
            break
        }

        # Amazon.APIGateway.AuthorizerType
        "New-AGAuthorizer/Type"
        {
            $v = "COGNITO_USER_POOLS","REQUEST","TOKEN"
            break
        }

        # Amazon.APIGateway.CacheClusterSize
        {
            ($_ -eq "New-AGDeployment/CacheClusterSize") -Or
            ($_ -eq "New-AGStage/CacheClusterSize")
        }
        {
            $v = "0.5","1.6","118","13.5","237","28.4","58.2","6.1"
            break
        }

        # Amazon.APIGateway.ConnectionType
        "Write-AGIntegration/ConnectionType"
        {
            $v = "INTERNET","VPC_LINK"
            break
        }

        # Amazon.APIGateway.ContentHandlingStrategy
        {
            ($_ -eq "Write-AGIntegration/ContentHandling") -Or
            ($_ -eq "Write-AGIntegrationResponse/ContentHandling")
        }
        {
            $v = "CONVERT_TO_BINARY","CONVERT_TO_TEXT"
            break
        }

        # Amazon.APIGateway.DocumentationPartType
        {
            ($_ -eq "New-AGDocumentationPart/Location_Type") -Or
            ($_ -eq "Get-AGDocumentationPartList/Type")
        }
        {
            $v = "API","AUTHORIZER","METHOD","MODEL","PATH_PARAMETER","QUERY_PARAMETER","REQUEST_BODY","REQUEST_HEADER","RESOURCE","RESPONSE","RESPONSE_BODY","RESPONSE_HEADER"
            break
        }

        # Amazon.APIGateway.GatewayResponseType
        {
            ($_ -eq "Get-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Remove-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Update-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Write-AGGatewayResponse/ResponseType")
        }
        {
            $v = "ACCESS_DENIED","API_CONFIGURATION_ERROR","AUTHORIZER_CONFIGURATION_ERROR","AUTHORIZER_FAILURE","BAD_REQUEST_BODY","BAD_REQUEST_PARAMETERS","DEFAULT_4XX","DEFAULT_5XX","EXPIRED_TOKEN","INTEGRATION_FAILURE","INTEGRATION_TIMEOUT","INVALID_API_KEY","INVALID_SIGNATURE","MISSING_AUTHENTICATION_TOKEN","QUOTA_EXCEEDED","REQUEST_TOO_LARGE","RESOURCE_NOT_FOUND","THROTTLED","UNAUTHORIZED","UNSUPPORTED_MEDIA_TYPE","WAF_FILTERED"
            break
        }

        # Amazon.APIGateway.IntegrationType
        "Write-AGIntegration/Type"
        {
            $v = "AWS","AWS_PROXY","HTTP","HTTP_PROXY","MOCK"
            break
        }

        # Amazon.APIGateway.LocationStatusType
        "Get-AGDocumentationPartList/LocationStatus"
        {
            $v = "DOCUMENTED","UNDOCUMENTED"
            break
        }

        # Amazon.APIGateway.PutMode
        {
            ($_ -eq "Import-AGDocumentationPartList/Mode") -Or
            ($_ -eq "Write-AGRestApi/Mode")
        }
        {
            $v = "merge","overwrite"
            break
        }

        # Amazon.APIGateway.QuotaPeriodType
        "New-AGUsagePlan/Quota_Period"
        {
            $v = "DAY","MONTH","WEEK"
            break
        }

        # Amazon.APIGateway.SecurityPolicy
        "New-AGDomainName/SecurityPolicy"
        {
            $v = "TLS_1_0","TLS_1_2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG_map = @{
    "ApiKeySource"=@("New-AGRestApi")
    "CacheClusterSize"=@("New-AGDeployment","New-AGStage")
    "ConnectionType"=@("Write-AGIntegration")
    "ContentHandling"=@("Write-AGIntegration","Write-AGIntegrationResponse")
    "Format"=@("Import-AGApiKey")
    "Location_Type"=@("New-AGDocumentationPart")
    "LocationStatus"=@("Get-AGDocumentationPartList")
    "Mode"=@("Import-AGDocumentationPartList","Write-AGRestApi")
    "Quota_Period"=@("New-AGUsagePlan")
    "ResponseType"=@("Get-AGGatewayResponse","Remove-AGGatewayResponse","Update-AGGatewayResponse","Write-AGGatewayResponse")
    "SecurityPolicy"=@("New-AGDomainName")
    "Type"=@("Get-AGDocumentationPartList","New-AGAuthorizer","Write-AGIntegration")
}

_awsArgumentCompleterRegistration $AG_Completers $AG_map

$AG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG_SelectMap = @{
    "Select"=@("New-AGApiKey",
               "New-AGAuthorizer",
               "New-AGBasePathMapping",
               "New-AGDeployment",
               "New-AGDocumentationPart",
               "New-AGDocumentationVersion",
               "New-AGDomainName",
               "New-AGModel",
               "New-AGRequestValidator",
               "New-AGResource",
               "New-AGRestApi",
               "New-AGStage",
               "New-AGUsagePlan",
               "New-AGUsagePlanKey",
               "New-AGVpcLink",
               "Remove-AGApiKey",
               "Remove-AGAuthorizer",
               "Remove-AGBasePathMapping",
               "Remove-AGClientCertificate",
               "Remove-AGDeployment",
               "Remove-AGDocumentationPart",
               "Remove-AGDocumentationVersion",
               "Remove-AGDomainName",
               "Remove-AGGatewayResponse",
               "Remove-AGIntegration",
               "Remove-AGIntegrationResponse",
               "Remove-AGMethod",
               "Remove-AGMethodResponse",
               "Remove-AGModel",
               "Remove-AGRequestValidator",
               "Remove-AGResource",
               "Remove-AGRestApi",
               "Remove-AGStage",
               "Remove-AGUsagePlan",
               "Remove-AGUsagePlanKey",
               "Remove-AGVpcLink",
               "Clear-AGStageAuthorizersCache",
               "Clear-AGStageCache",
               "New-AGClientCertificate",
               "Get-AGAccount",
               "Get-AGApiKey",
               "Get-AGApiKeyList",
               "Get-AGAuthorizer",
               "Get-AGAuthorizerList",
               "Get-AGBasePathMapping",
               "Get-AGBasePathMappingList",
               "Get-AGClientCertificate",
               "Get-AGClientCertificateList",
               "Get-AGDeployment",
               "Get-AGDeploymentList",
               "Get-AGDocumentationPart",
               "Get-AGDocumentationPartList",
               "Get-AGDocumentationVersion",
               "Get-AGDocumentationVersionList",
               "Get-AGDomainName",
               "Get-AGDomainNameList",
               "Get-AGExport",
               "Get-AGGatewayResponse",
               "Get-AGGatewayResponseList",
               "Get-AGIntegration",
               "Get-AGIntegrationResponse",
               "Get-AGMethod",
               "Get-AGMethodResponse",
               "Get-AGModel",
               "Get-AGModelList",
               "Get-AGModelTemplate",
               "Get-AGRequestValidator",
               "Get-AGValidatorList",
               "Get-AGResource",
               "Get-AGResourceList",
               "Get-AGRestApi",
               "Get-AGRestApiList",
               "Get-AGSdk",
               "Get-AGSdkType",
               "Get-AGSdkTypeList",
               "Get-AGStage",
               "Get-AGStageList",
               "Get-AGResourceTag",
               "Get-AGUsage",
               "Get-AGUsagePlan",
               "Get-AGUsagePlanKey",
               "Get-AGUsagePlanKeyList",
               "Get-AGUsagePlanList",
               "Get-AGVpcLink",
               "Get-AGVpcLinkList",
               "Import-AGApiKey",
               "Import-AGDocumentationPartList",
               "Import-AGRestApi",
               "Write-AGGatewayResponse",
               "Write-AGIntegration",
               "Write-AGIntegrationResponse",
               "Write-AGMethod",
               "Write-AGMethodResponse",
               "Write-AGRestApi",
               "Add-AGResourceTag",
               "Test-AGInvokeAuthorizer",
               "Test-AGInvokeMethod",
               "Remove-AGResourceTag",
               "Update-AGAccount",
               "Update-AGApiKey",
               "Update-AGAuthorizer",
               "Update-AGBasePathMapping",
               "Update-AGClientCertificate",
               "Update-AGDeployment",
               "Update-AGDocumentationPart",
               "Update-AGDocumentationVersion",
               "Update-AGDomainName",
               "Update-AGGatewayResponse",
               "Update-AGIntegration",
               "Update-AGIntegrationResponse",
               "Update-AGMethod",
               "Update-AGMethodResponse",
               "Update-AGModel",
               "Update-AGRequestValidator",
               "Update-AGResource",
               "Update-AGRestApi",
               "Update-AGStage",
               "Update-AGUsage",
               "Update-AGUsagePlan",
               "Update-AGVpcLink")
}

_awsArgumentCompleterRegistration $AG_SelectCompleters $AG_SelectMap
# Argument completions for service Amazon API Gateway Management API


$AGM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AGM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AGM_SelectMap = @{
    "Select"=@("Remove-AGMConnection",
               "Get-AGMConnection",
               "Send-AGMDataToConnection")
}

_awsArgumentCompleterRegistration $AGM_SelectCompleters $AGM_SelectMap
# Argument completions for service Amazon API Gateway V2


$AG2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApiGatewayV2.AuthorizationType
        {
            ($_ -eq "New-AG2Route/AuthorizationType") -Or
            ($_ -eq "Update-AG2Route/AuthorizationType")
        }
        {
            $v = "AWS_IAM","CUSTOM","JWT","NONE"
            break
        }

        # Amazon.ApiGatewayV2.AuthorizerType
        {
            ($_ -eq "New-AG2Authorizer/AuthorizerType") -Or
            ($_ -eq "Update-AG2Authorizer/AuthorizerType")
        }
        {
            $v = "JWT","REQUEST"
            break
        }

        # Amazon.ApiGatewayV2.ConnectionType
        {
            ($_ -eq "New-AG2Integration/ConnectionType") -Or
            ($_ -eq "Update-AG2Integration/ConnectionType")
        }
        {
            $v = "INTERNET","VPC_LINK"
            break
        }

        # Amazon.ApiGatewayV2.ContentHandlingStrategy
        {
            ($_ -eq "New-AG2Integration/ContentHandlingStrategy") -Or
            ($_ -eq "New-AG2IntegrationResponse/ContentHandlingStrategy") -Or
            ($_ -eq "Update-AG2Integration/ContentHandlingStrategy") -Or
            ($_ -eq "Update-AG2IntegrationResponse/ContentHandlingStrategy")
        }
        {
            $v = "CONVERT_TO_BINARY","CONVERT_TO_TEXT"
            break
        }

        # Amazon.ApiGatewayV2.IntegrationType
        {
            ($_ -eq "New-AG2Integration/IntegrationType") -Or
            ($_ -eq "Update-AG2Integration/IntegrationType")
        }
        {
            $v = "AWS","AWS_PROXY","HTTP","HTTP_PROXY","MOCK"
            break
        }

        # Amazon.ApiGatewayV2.LoggingLevel
        {
            ($_ -eq "New-AG2Stage/DefaultRouteSettings_LoggingLevel") -Or
            ($_ -eq "Update-AG2Stage/DefaultRouteSettings_LoggingLevel")
        }
        {
            $v = "ERROR","INFO","OFF"
            break
        }

        # Amazon.ApiGatewayV2.PassthroughBehavior
        {
            ($_ -eq "New-AG2Integration/PassthroughBehavior") -Or
            ($_ -eq "Update-AG2Integration/PassthroughBehavior")
        }
        {
            $v = "NEVER","WHEN_NO_MATCH","WHEN_NO_TEMPLATES"
            break
        }

        # Amazon.ApiGatewayV2.ProtocolType
        "New-AG2Api/ProtocolType"
        {
            $v = "HTTP","WEBSOCKET"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG2_map = @{
    "AuthorizationType"=@("New-AG2Route","Update-AG2Route")
    "AuthorizerType"=@("New-AG2Authorizer","Update-AG2Authorizer")
    "ConnectionType"=@("New-AG2Integration","Update-AG2Integration")
    "ContentHandlingStrategy"=@("New-AG2Integration","New-AG2IntegrationResponse","Update-AG2Integration","Update-AG2IntegrationResponse")
    "DefaultRouteSettings_LoggingLevel"=@("New-AG2Stage","Update-AG2Stage")
    "IntegrationType"=@("New-AG2Integration","Update-AG2Integration")
    "PassthroughBehavior"=@("New-AG2Integration","Update-AG2Integration")
    "ProtocolType"=@("New-AG2Api")
}

_awsArgumentCompleterRegistration $AG2_Completers $AG2_map

$AG2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AG2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG2_SelectMap = @{
    "Select"=@("New-AG2Api",
               "New-AG2ApiMapping",
               "New-AG2Authorizer",
               "New-AG2Deployment",
               "New-AG2DomainName",
               "New-AG2Integration",
               "New-AG2IntegrationResponse",
               "New-AG2Model",
               "New-AG2Route",
               "New-AG2RouteResponse",
               "New-AG2Stage",
               "New-AG2VpcLink",
               "Remove-AG2AccessLogSetting",
               "Remove-AG2Api",
               "Remove-AG2ApiMapping",
               "Remove-AG2Authorizer",
               "Remove-AG2CorsConfiguration",
               "Remove-AG2Deployment",
               "Remove-AG2DomainName",
               "Remove-AG2Integration",
               "Remove-AG2IntegrationResponse",
               "Remove-AG2Model",
               "Remove-AG2Route",
               "Remove-AG2RouteRequestParameter",
               "Remove-AG2RouteResponse",
               "Remove-AG2RouteSetting",
               "Remove-AG2Stage",
               "Remove-AG2VpcLink",
               "Export-AG2Api",
               "Get-AG2Api",
               "Get-AG2ApiMapping",
               "Get-AG2ApiMappingList",
               "Get-AG2ApiList",
               "Get-AG2Authorizer",
               "Get-AG2AuthorizerList",
               "Get-AG2Deployment",
               "Get-AG2DeploymentList",
               "Get-AG2DomainName",
               "Get-AG2DomainNameList",
               "Get-AG2Integration",
               "Get-AG2IntegrationResponse",
               "Get-AG2IntegrationResponseList",
               "Get-AG2IntegrationList",
               "Get-AG2Model",
               "Get-AG2ModelList",
               "Get-AG2ModelTemplate",
               "Get-AG2Route",
               "Get-AG2RouteResponse",
               "Get-AG2RouteResponseList",
               "Get-AG2RouteList",
               "Get-AG2Stage",
               "Get-AG2StageList",
               "Get-AG2Tag",
               "Get-AG2VpcLink",
               "Get-AG2VpcLinkList",
               "Import-AG2Api",
               "Update-AG2ApiImport",
               "Reset-AG2AuthorizersCache",
               "Add-AG2ResourceTag",
               "Remove-AG2ResourceTag",
               "Update-AG2Api",
               "Update-AG2ApiMapping",
               "Update-AG2Authorizer",
               "Update-AG2Deployment",
               "Update-AG2DomainName",
               "Update-AG2Integration",
               "Update-AG2IntegrationResponse",
               "Update-AG2Model",
               "Update-AG2Route",
               "Update-AG2RouteResponse",
               "Update-AG2Stage",
               "Update-AG2VpcLink")
}

_awsArgumentCompleterRegistration $AG2_SelectCompleters $AG2_SelectMap
# Argument completions for service AWS AppConfig


$APPC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppConfig.GrowthType
        {
            ($_ -eq "New-APPCDeploymentStrategy/GrowthType") -Or
            ($_ -eq "Update-APPCDeploymentStrategy/GrowthType")
        }
        {
            $v = "EXPONENTIAL","LINEAR"
            break
        }

        # Amazon.AppConfig.ReplicateTo
        "New-APPCDeploymentStrategy/ReplicateTo"
        {
            $v = "NONE","SSM_DOCUMENT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APPC_map = @{
    "GrowthType"=@("New-APPCDeploymentStrategy","Update-APPCDeploymentStrategy")
    "ReplicateTo"=@("New-APPCDeploymentStrategy")
}

_awsArgumentCompleterRegistration $APPC_Completers $APPC_map

$APPC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.APPC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APPC_SelectMap = @{
    "Select"=@("New-APPCApplication",
               "New-APPCConfigurationProfile",
               "New-APPCDeploymentStrategy",
               "New-APPCEnvironment",
               "New-APPCExtension",
               "New-APPCExtensionAssociation",
               "New-APPCHostedConfigurationVersion",
               "Remove-APPCApplication",
               "Remove-APPCConfigurationProfile",
               "Remove-APPCDeploymentStrategy",
               "Remove-APPCEnvironment",
               "Remove-APPCExtension",
               "Remove-APPCExtensionAssociation",
               "Remove-APPCHostedConfigurationVersion",
               "Get-APPCApplication",
               "Get-APPCConfiguration",
               "Get-APPCConfigurationProfile",
               "Get-APPCDeployment",
               "Get-APPCDeploymentStrategy",
               "Get-APPCEnvironment",
               "Get-APPCExtension",
               "Get-APPCExtensionAssociation",
               "Get-APPCHostedConfigurationVersion",
               "Get-APPCApplicationList",
               "Get-APPCConfigurationProfileList",
               "Get-APPCDeploymentList",
               "Get-APPCDeploymentStrategyList",
               "Get-APPCEnvironmentList",
               "Get-APPCExtensionAssociationList",
               "Get-APPCExtensionList",
               "Get-APPCHostedConfigurationVersionList",
               "Get-APPCResourceTag",
               "Start-APPCDeployment",
               "Stop-APPCDeployment",
               "Add-APPCResourceTag",
               "Remove-APPCResourceTag",
               "Update-APPCApplication",
               "Update-APPCConfigurationProfile",
               "Update-APPCDeploymentStrategy",
               "Update-APPCEnvironment",
               "Update-APPCExtension",
               "Update-APPCExtensionAssociation",
               "Test-APPCConfigurationValidity")
}

_awsArgumentCompleterRegistration $APPC_SelectCompleters $APPC_SelectMap
# Argument completions for service AWS AppConfig Data


$ACD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACD_SelectMap = @{
    "Select"=@("Get-ACDLatestConfiguration",
               "Start-ACDConfigurationSession")
}

_awsArgumentCompleterRegistration $ACD_SelectCompleters $ACD_SelectMap
# Argument completions for service Amazon Appflow


$AF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Appflow.ConnectionMode
        {
            ($_ -eq "New-AFConnectorProfile/ConnectionMode") -Or
            ($_ -eq "Update-AFConnectorProfile/ConnectionMode")
        }
        {
            $v = "Private","Public"
            break
        }

        # Amazon.Appflow.ConnectorProvisioningType
        "Register-AFConnector/ConnectorProvisioningType"
        {
            $v = "LAMBDA"
            break
        }

        # Amazon.Appflow.ConnectorType
        {
            ($_ -eq "Get-AFConnector/ConnectorType") -Or
            ($_ -eq "Get-AFConnectorEntity/ConnectorType") -Or
            ($_ -eq "Get-AFConnectorEntityList/ConnectorType") -Or
            ($_ -eq "Get-AFConnectorProfile/ConnectorType") -Or
            ($_ -eq "New-AFConnectorProfile/ConnectorType") -Or
            ($_ -eq "New-AFFlow/SourceFlowConfig_ConnectorType") -Or
            ($_ -eq "Update-AFFlow/SourceFlowConfig_ConnectorType")
        }
        {
            $v = "Amplitude","CustomConnector","CustomerProfiles","Datadog","Dynatrace","EventBridge","Googleanalytics","Honeycode","Infornexus","LookoutMetrics","Marketo","Redshift","S3","Salesforce","SAPOData","Servicenow","Singular","Slack","Snowflake","Trendmicro","Upsolver","Veeva","Zendesk"
            break
        }

        # Amazon.Appflow.DataPullMode
        {
            ($_ -eq "New-AFFlow/TriggerConfig_TriggerProperties_Scheduled_DataPullMode") -Or
            ($_ -eq "Update-AFFlow/TriggerConfig_TriggerProperties_Scheduled_DataPullMode")
        }
        {
            $v = "Complete","Incremental"
            break
        }

        # Amazon.Appflow.S3InputFileType
        {
            ($_ -eq "New-AFFlow/SourceFlowConfig_SourceConnectorProperties_S3_S3InputFormatConfig_S3InputFileType") -Or
            ($_ -eq "Update-AFFlow/SourceFlowConfig_SourceConnectorProperties_S3_S3InputFormatConfig_S3InputFileType")
        }
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.Appflow.SalesforceDataTransferApi
        {
            ($_ -eq "New-AFFlow/SourceFlowConfig_SourceConnectorProperties_Salesforce_DataTransferApi") -Or
            ($_ -eq "Update-AFFlow/SourceFlowConfig_SourceConnectorProperties_Salesforce_DataTransferApi")
        }
        {
            $v = "AUTOMATIC","BULKV2","REST_SYNC"
            break
        }

        # Amazon.Appflow.TriggerType
        {
            ($_ -eq "New-AFFlow/TriggerConfig_TriggerType") -Or
            ($_ -eq "Update-AFFlow/TriggerConfig_TriggerType")
        }
        {
            $v = "Event","OnDemand","Scheduled"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AF_map = @{
    "ConnectionMode"=@("New-AFConnectorProfile","Update-AFConnectorProfile")
    "ConnectorProvisioningType"=@("Register-AFConnector")
    "ConnectorType"=@("Get-AFConnector","Get-AFConnectorEntity","Get-AFConnectorEntityList","Get-AFConnectorProfile","New-AFConnectorProfile")
    "SourceFlowConfig_ConnectorType"=@("New-AFFlow","Update-AFFlow")
    "SourceFlowConfig_SourceConnectorProperties_S3_S3InputFormatConfig_S3InputFileType"=@("New-AFFlow","Update-AFFlow")
    "SourceFlowConfig_SourceConnectorProperties_Salesforce_DataTransferApi"=@("New-AFFlow","Update-AFFlow")
    "TriggerConfig_TriggerProperties_Scheduled_DataPullMode"=@("New-AFFlow","Update-AFFlow")
    "TriggerConfig_TriggerType"=@("New-AFFlow","Update-AFFlow")
}

_awsArgumentCompleterRegistration $AF_Completers $AF_map

$AF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AF_SelectMap = @{
    "Select"=@("New-AFConnectorProfile",
               "New-AFFlow",
               "Remove-AFConnectorProfile",
               "Remove-AFFlow",
               "Get-AFConnector",
               "Get-AFConnectorEntity",
               "Get-AFConnectorProfile",
               "Get-AFConnectorConfigurationList",
               "Get-AFFlow",
               "Get-AFFlowExecutionRecord",
               "Get-AFConnectorEntityList",
               "Get-AFConnectorList",
               "Get-AFFlowList",
               "Get-AFResourceTag",
               "Register-AFConnector",
               "Start-AFFlow",
               "Stop-AFFlow",
               "Add-AFResourceTag",
               "Unregister-AFConnector",
               "Remove-AFResourceTag",
               "Update-AFConnectorProfile",
               "Update-AFFlow")
}

_awsArgumentCompleterRegistration $AF_SelectCompleters $AF_SelectMap
# Argument completions for service Amazon AppIntegrations Service


$AIS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AIS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AIS_SelectMap = @{
    "Select"=@("New-AISDataIntegration",
               "New-AISEventIntegration",
               "Remove-AISDataIntegration",
               "Remove-AISEventIntegration",
               "Get-AISDataIntegration",
               "Get-AISEventIntegration",
               "Get-AISDataIntegrationAssociationList",
               "Get-AISDataIntegrationList",
               "Get-AISEventIntegrationAssociationList",
               "Get-AISEventIntegrationList",
               "Get-AISResourceTag",
               "Add-AISResourceTag",
               "Remove-AISResourceTag",
               "Update-AISDataIntegration",
               "Update-AISEventIntegration")
}

_awsArgumentCompleterRegistration $AIS_SelectCompleters $AIS_SelectMap
# Argument completions for service Application Auto Scaling


$AAS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationAutoScaling.AdjustmentType
        "Set-AASScalingPolicy/StepScalingPolicyConfiguration_AdjustmentType"
        {
            $v = "ChangeInCapacity","ExactCapacity","PercentChangeInCapacity"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricAggregationType
        "Set-AASScalingPolicy/StepScalingPolicyConfiguration_MetricAggregationType"
        {
            $v = "Average","Maximum","Minimum"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricStatistic
        "Set-AASScalingPolicy/TargetTrackingScalingPolicyConfiguration_CustomizedMetricSpecification_Statistic"
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricType
        "Set-AASScalingPolicy/TargetTrackingScalingPolicyConfiguration_PredefinedMetricSpecification_PredefinedMetricType"
        {
            $v = "ALBRequestCountPerTarget","AppStreamAverageCapacityUtilization","CassandraReadCapacityUtilization","CassandraWriteCapacityUtilization","ComprehendInferenceUtilization","DynamoDBReadCapacityUtilization","DynamoDBWriteCapacityUtilization","EC2SpotFleetRequestAverageCPUUtilization","EC2SpotFleetRequestAverageNetworkIn","EC2SpotFleetRequestAverageNetworkOut","ECSServiceAverageCPUUtilization","ECSServiceAverageMemoryUtilization","ElastiCacheDatabaseMemoryUsageCountedForEvictPercentage","ElastiCachePrimaryEngineCPUUtilization","ElastiCacheReplicaEngineCPUUtilization","KafkaBrokerStorageUtilization","LambdaProvisionedConcurrencyUtilization","NeptuneReaderAverageCPUUtilization","RDSReaderAverageCPUUtilization","RDSReaderAverageDatabaseConnections","SageMakerVariantInvocationsPerInstance"
            break
        }

        # Amazon.ApplicationAutoScaling.PolicyType
        "Set-AASScalingPolicy/PolicyType"
        {
            $v = "StepScaling","TargetTrackingScaling"
            break
        }

        # Amazon.ApplicationAutoScaling.ScalableDimension
        {
            ($_ -eq "Add-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Get-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Get-AASScalingActivity/ScalableDimension") -Or
            ($_ -eq "Get-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Get-AASScheduledAction/ScalableDimension") -Or
            ($_ -eq "Remove-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Remove-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Remove-AASScheduledAction/ScalableDimension") -Or
            ($_ -eq "Set-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Set-AASScheduledAction/ScalableDimension")
        }
        {
            $v = "appstream:fleet:DesiredCapacity","cassandra:table:ReadCapacityUnits","cassandra:table:WriteCapacityUnits","comprehend:document-classifier-endpoint:DesiredInferenceUnits","comprehend:entity-recognizer-endpoint:DesiredInferenceUnits","custom-resource:ResourceType:Property","dynamodb:index:ReadCapacityUnits","dynamodb:index:WriteCapacityUnits","dynamodb:table:ReadCapacityUnits","dynamodb:table:WriteCapacityUnits","ec2:spot-fleet-request:TargetCapacity","ecs:service:DesiredCount","elasticache:replication-group:NodeGroups","elasticache:replication-group:Replicas","elasticmapreduce:instancegroup:InstanceCount","kafka:broker-storage:VolumeSize","lambda:function:ProvisionedConcurrency","neptune:cluster:ReadReplicaCount","rds:cluster:ReadReplicaCount","sagemaker:variant:DesiredInstanceCount"
            break
        }

        # Amazon.ApplicationAutoScaling.ServiceNamespace
        {
            ($_ -eq "Add-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalingActivity/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Get-AASScheduledAction/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScheduledAction/ServiceNamespace") -Or
            ($_ -eq "Set-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Set-AASScheduledAction/ServiceNamespace")
        }
        {
            $v = "appstream","cassandra","comprehend","custom-resource","dynamodb","ec2","ecs","elasticache","elasticmapreduce","kafka","lambda","neptune","rds","sagemaker"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAS_map = @{
    "PolicyType"=@("Set-AASScalingPolicy")
    "ScalableDimension"=@("Add-AASScalableTarget","Get-AASScalableTarget","Get-AASScalingActivity","Get-AASScalingPolicy","Get-AASScheduledAction","Remove-AASScalableTarget","Remove-AASScalingPolicy","Remove-AASScheduledAction","Set-AASScalingPolicy","Set-AASScheduledAction")
    "ServiceNamespace"=@("Add-AASScalableTarget","Get-AASScalableTarget","Get-AASScalingActivity","Get-AASScalingPolicy","Get-AASScheduledAction","Remove-AASScalableTarget","Remove-AASScalingPolicy","Remove-AASScheduledAction","Set-AASScalingPolicy","Set-AASScheduledAction")
    "StepScalingPolicyConfiguration_AdjustmentType"=@("Set-AASScalingPolicy")
    "StepScalingPolicyConfiguration_MetricAggregationType"=@("Set-AASScalingPolicy")
    "TargetTrackingScalingPolicyConfiguration_CustomizedMetricSpecification_Statistic"=@("Set-AASScalingPolicy")
    "TargetTrackingScalingPolicyConfiguration_PredefinedMetricSpecification_PredefinedMetricType"=@("Set-AASScalingPolicy")
}

_awsArgumentCompleterRegistration $AAS_Completers $AAS_map

$AAS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AAS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAS_SelectMap = @{
    "Select"=@("Remove-AASScalingPolicy",
               "Remove-AASScheduledAction",
               "Remove-AASScalableTarget",
               "Get-AASScalableTarget",
               "Get-AASScalingActivity",
               "Get-AASScalingPolicy",
               "Get-AASScheduledAction",
               "Set-AASScalingPolicy",
               "Set-AASScheduledAction",
               "Add-AASScalableTarget")
}

_awsArgumentCompleterRegistration $AAS_SelectCompleters $AAS_SelectMap
# Argument completions for service Amazon ApplicationCostProfiler


$ACP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationCostProfiler.Format
        {
            ($_ -eq "Update-ACPReportDefinition/Format") -Or
            ($_ -eq "Write-ACPReportDefinition/Format")
        }
        {
            $v = "CSV","PARQUET"
            break
        }

        # Amazon.ApplicationCostProfiler.ReportFrequency
        {
            ($_ -eq "Update-ACPReportDefinition/ReportFrequency") -Or
            ($_ -eq "Write-ACPReportDefinition/ReportFrequency")
        }
        {
            $v = "ALL","DAILY","MONTHLY"
            break
        }

        # Amazon.ApplicationCostProfiler.S3BucketRegion
        "Import-ACPApplicationUsage/SourceS3Location_Region"
        {
            $v = "af-south-1","ap-east-1","eu-south-1","me-south-1"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACP_map = @{
    "Format"=@("Update-ACPReportDefinition","Write-ACPReportDefinition")
    "ReportFrequency"=@("Update-ACPReportDefinition","Write-ACPReportDefinition")
    "SourceS3Location_Region"=@("Import-ACPApplicationUsage")
}

_awsArgumentCompleterRegistration $ACP_Completers $ACP_map

$ACP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACP_SelectMap = @{
    "Select"=@("Remove-ACPReportDefinition",
               "Get-ACPReportDefinition",
               "Import-ACPApplicationUsage",
               "Get-ACPReportDefinitionList",
               "Write-ACPReportDefinition",
               "Update-ACPReportDefinition")
}

_awsArgumentCompleterRegistration $ACP_SelectCompleters $ACP_SelectMap
# Argument completions for service Amazon CloudWatch Application Insights


$CWAI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationInsights.ConfigurationEventStatus
        "Get-CWAIConfigurationHistoryList/EventStatus"
        {
            $v = "ERROR","INFO","WARN"
            break
        }

        # Amazon.ApplicationInsights.GroupingType
        "New-CWAIApplication/GroupingType"
        {
            $v = "ACCOUNT_BASED"
            break
        }

        # Amazon.ApplicationInsights.Tier
        {
            ($_ -eq "Get-CWAIComponentConfigurationRecommendation/Tier") -Or
            ($_ -eq "Update-CWAIComponentConfiguration/Tier")
        }
        {
            $v = "ACTIVE_DIRECTORY","CUSTOM","DEFAULT","DOT_NET_CORE","DOT_NET_WEB","DOT_NET_WEB_TIER","DOT_NET_WORKER","JAVA_JMX","MYSQL","ORACLE","POSTGRESQL","SAP_HANA_HIGH_AVAILABILITY","SAP_HANA_MULTI_NODE","SAP_HANA_SINGLE_NODE","SHAREPOINT","SQL_SERVER","SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP","SQL_SERVER_FAILOVER_CLUSTER_INSTANCE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWAI_map = @{
    "EventStatus"=@("Get-CWAIConfigurationHistoryList")
    "GroupingType"=@("New-CWAIApplication")
    "Tier"=@("Get-CWAIComponentConfigurationRecommendation","Update-CWAIComponentConfiguration")
}

_awsArgumentCompleterRegistration $CWAI_Completers $CWAI_map

$CWAI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWAI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWAI_SelectMap = @{
    "Select"=@("New-CWAIApplication",
               "New-CWAIComponent",
               "New-CWAILogPattern",
               "Remove-CWAIApplication",
               "Remove-CWAIComponent",
               "Remove-CWAILogPattern",
               "Get-CWAIApplication",
               "Get-CWAIComponent",
               "Get-CWAIComponentConfiguration",
               "Get-CWAIComponentConfigurationRecommendation",
               "Get-CWAILogPattern",
               "Get-CWAIObservation",
               "Get-CWAIProblem",
               "Get-CWAIProblemObservation",
               "Get-CWAIApplicationList",
               "Get-CWAIComponentList",
               "Get-CWAIConfigurationHistoryList",
               "Get-CWAILogPatternList",
               "Get-CWAILogPatternSetList",
               "Get-CWAIProblemList",
               "Get-CWAIResourceTag",
               "Add-CWAIResourceTag",
               "Remove-CWAIResourceTag",
               "Update-CWAIApplication",
               "Update-CWAIComponent",
               "Update-CWAIComponentConfiguration",
               "Update-CWAILogPattern")
}

_awsArgumentCompleterRegistration $CWAI_SelectCompleters $CWAI_SelectMap
# Argument completions for service AWS App Mesh


$AMSH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppMesh.DefaultGatewayRouteRewrite
        {
            ($_ -eq "New-AMSHGatewayRoute/Spec_GrpcRoute_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_GrpcRoute_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "New-AMSHGatewayRoute/Spec_Http2Route_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_Http2Route_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "New-AMSHGatewayRoute/Spec_Http2Route_Action_Rewrite_Prefix_DefaultPrefix") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_Http2Route_Action_Rewrite_Prefix_DefaultPrefix") -Or
            ($_ -eq "New-AMSHGatewayRoute/Spec_HttpRoute_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_HttpRoute_Action_Rewrite_Hostname_DefaultTargetHostname") -Or
            ($_ -eq "New-AMSHGatewayRoute/Spec_HttpRoute_Action_Rewrite_Prefix_DefaultPrefix") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_HttpRoute_Action_Rewrite_Prefix_DefaultPrefix")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.AppMesh.DnsResponseType
        {
            ($_ -eq "New-AMSHVirtualNode/Spec_ServiceDiscovery_Dns_ResponseType") -Or
            ($_ -eq "Update-AMSHVirtualNode/Spec_ServiceDiscovery_Dns_ResponseType")
        }
        {
            $v = "ENDPOINTS","LOADBALANCER"
            break
        }

        # Amazon.AppMesh.DurationUnit
        {
            ($_ -eq "New-AMSHRoute/Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_GrpcRoute_Timeout_Idle_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_GrpcRoute_Timeout_Idle_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_GrpcRoute_Timeout_PerRequest_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_GrpcRoute_Timeout_PerRequest_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Timeout_Idle_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Timeout_Idle_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Timeout_PerRequest_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Timeout_PerRequest_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Timeout_Idle_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Timeout_Idle_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Timeout_PerRequest_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Timeout_PerRequest_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_TcpRoute_Timeout_Idle_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_TcpRoute_Timeout_Idle_Unit")
        }
        {
            $v = "ms","s"
            break
        }

        # Amazon.AppMesh.EgressFilterType
        {
            ($_ -eq "New-AMSHMesh/Spec_EgressFilter_Type") -Or
            ($_ -eq "Update-AMSHMesh/Spec_EgressFilter_Type")
        }
        {
            $v = "ALLOW_ALL","DROP_ALL"
            break
        }

        # Amazon.AppMesh.HttpMethod
        {
            ($_ -eq "New-AMSHGatewayRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "New-AMSHGatewayRoute/Spec_HttpRoute_Match_Method") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Match_Method") -Or
            ($_ -eq "Update-AMSHGatewayRoute/Spec_HttpRoute_Match_Method") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Match_Method")
        }
        {
            $v = "CONNECT","DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT","TRACE"
            break
        }

        # Amazon.AppMesh.HttpScheme
        {
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Match_Scheme") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Match_Scheme") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Match_Scheme") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Match_Scheme")
        }
        {
            $v = "http","https"
            break
        }

        # Amazon.AppMesh.IpPreference
        {
            ($_ -eq "New-AMSHVirtualNode/Spec_ServiceDiscovery_AwsCloudMap_IpPreference") -Or
            ($_ -eq "Update-AMSHVirtualNode/Spec_ServiceDiscovery_AwsCloudMap_IpPreference") -Or
            ($_ -eq "New-AMSHVirtualNode/Spec_ServiceDiscovery_Dns_IpPreference") -Or
            ($_ -eq "Update-AMSHVirtualNode/Spec_ServiceDiscovery_Dns_IpPreference") -Or
            ($_ -eq "New-AMSHMesh/Spec_ServiceDiscovery_IpPreference") -Or
            ($_ -eq "Update-AMSHMesh/Spec_ServiceDiscovery_IpPreference")
        }
        {
            $v = "IPv4_ONLY","IPv4_PREFERRED","IPv6_ONLY","IPv6_PREFERRED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMSH_map = @{
    "Spec_EgressFilter_Type"=@("New-AMSHMesh","Update-AMSHMesh")
    "Spec_GrpcRoute_Action_Rewrite_Hostname_DefaultTargetHostname"=@("New-AMSHGatewayRoute","Update-AMSHGatewayRoute")
    "Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_GrpcRoute_Timeout_Idle_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_GrpcRoute_Timeout_PerRequest_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_Action_Rewrite_Hostname_DefaultTargetHostname"=@("New-AMSHGatewayRoute","Update-AMSHGatewayRoute")
    "Spec_Http2Route_Action_Rewrite_Prefix_DefaultPrefix"=@("New-AMSHGatewayRoute","Update-AMSHGatewayRoute")
    "Spec_Http2Route_Match_Method"=@("New-AMSHGatewayRoute","New-AMSHRoute","Update-AMSHGatewayRoute","Update-AMSHRoute")
    "Spec_Http2Route_Match_Scheme"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_Timeout_Idle_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_Timeout_PerRequest_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Action_Rewrite_Hostname_DefaultTargetHostname"=@("New-AMSHGatewayRoute","Update-AMSHGatewayRoute")
    "Spec_HttpRoute_Action_Rewrite_Prefix_DefaultPrefix"=@("New-AMSHGatewayRoute","Update-AMSHGatewayRoute")
    "Spec_HttpRoute_Match_Method"=@("New-AMSHGatewayRoute","New-AMSHRoute","Update-AMSHGatewayRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Match_Scheme"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Timeout_Idle_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Timeout_PerRequest_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_ServiceDiscovery_AwsCloudMap_IpPreference"=@("New-AMSHVirtualNode","Update-AMSHVirtualNode")
    "Spec_ServiceDiscovery_Dns_IpPreference"=@("New-AMSHVirtualNode","Update-AMSHVirtualNode")
    "Spec_ServiceDiscovery_Dns_ResponseType"=@("New-AMSHVirtualNode","Update-AMSHVirtualNode")
    "Spec_ServiceDiscovery_IpPreference"=@("New-AMSHMesh","Update-AMSHMesh")
    "Spec_TcpRoute_Timeout_Idle_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
}

_awsArgumentCompleterRegistration $AMSH_Completers $AMSH_map

$AMSH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMSH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMSH_SelectMap = @{
    "Select"=@("New-AMSHGatewayRoute",
               "New-AMSHMesh",
               "New-AMSHRoute",
               "New-AMSHVirtualGateway",
               "New-AMSHVirtualNode",
               "New-AMSHVirtualRouter",
               "New-AMSHVirtualService",
               "Remove-AMSHGatewayRoute",
               "Remove-AMSHMesh",
               "Remove-AMSHRoute",
               "Remove-AMSHVirtualGateway",
               "Remove-AMSHVirtualNode",
               "Remove-AMSHVirtualRouter",
               "Remove-AMSHVirtualService",
               "Get-AMSHGatewayRoute",
               "Get-AMSHMesh",
               "Get-AMSHRoute",
               "Get-AMSHVirtualGateway",
               "Get-AMSHVirtualNode",
               "Get-AMSHVirtualRouter",
               "Get-AMSHVirtualService",
               "Get-AMSHGatewayRouteList",
               "Get-AMSHMeshList",
               "Get-AMSHRouteList",
               "Get-AMSHResourceTag",
               "Get-AMSHVirtualGatewayList",
               "Get-AMSHVirtualNodeList",
               "Get-AMSHVirtualRouterList",
               "Get-AMSHVirtualServiceList",
               "Add-AMSHResourceTag",
               "Remove-AMSHResourceTag",
               "Update-AMSHGatewayRoute",
               "Update-AMSHMesh",
               "Update-AMSHRoute",
               "Update-AMSHVirtualGateway",
               "Update-AMSHVirtualNode",
               "Update-AMSHVirtualRouter",
               "Update-AMSHVirtualService")
}

_awsArgumentCompleterRegistration $AMSH_SelectCompleters $AMSH_SelectMap
# Argument completions for service AWS App Runner


$AAR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppRunner.ConfigurationSource
        {
            ($_ -eq "New-AARService/SourceConfiguration_CodeRepository_CodeConfiguration_ConfigurationSource") -Or
            ($_ -eq "Update-AARService/SourceConfiguration_CodeRepository_CodeConfiguration_ConfigurationSource")
        }
        {
            $v = "API","REPOSITORY"
            break
        }

        # Amazon.AppRunner.EgressType
        {
            ($_ -eq "New-AARService/NetworkConfiguration_EgressConfiguration_EgressType") -Or
            ($_ -eq "Update-AARService/NetworkConfiguration_EgressConfiguration_EgressType")
        }
        {
            $v = "DEFAULT","VPC"
            break
        }

        # Amazon.AppRunner.HealthCheckProtocol
        {
            ($_ -eq "New-AARService/HealthCheckConfiguration_Protocol") -Or
            ($_ -eq "Update-AARService/HealthCheckConfiguration_Protocol")
        }
        {
            $v = "HTTP","TCP"
            break
        }

        # Amazon.AppRunner.ImageRepositoryType
        {
            ($_ -eq "New-AARService/SourceConfiguration_ImageRepository_ImageRepositoryType") -Or
            ($_ -eq "Update-AARService/SourceConfiguration_ImageRepository_ImageRepositoryType")
        }
        {
            $v = "ECR","ECR_PUBLIC"
            break
        }

        # Amazon.AppRunner.ProviderType
        "New-AARConnection/ProviderType"
        {
            $v = "GITHUB"
            break
        }

        # Amazon.AppRunner.Runtime
        {
            ($_ -eq "New-AARService/SourceConfiguration_CodeRepository_CodeConfiguration_CodeConfigurationValues_Runtime") -Or
            ($_ -eq "Update-AARService/SourceConfiguration_CodeRepository_CodeConfiguration_CodeConfigurationValues_Runtime")
        }
        {
            $v = "CORRETTO_11","CORRETTO_8","DOTNET_6","GO_1","NODEJS_12","NODEJS_14","NODEJS_16","PHP_81","PYTHON_3","RUBY_31"
            break
        }

        # Amazon.AppRunner.SourceCodeVersionType
        {
            ($_ -eq "New-AARService/SourceConfiguration_CodeRepository_SourceCodeVersion_Type") -Or
            ($_ -eq "Update-AARService/SourceConfiguration_CodeRepository_SourceCodeVersion_Type")
        }
        {
            $v = "BRANCH"
            break
        }

        # Amazon.AppRunner.TracingVendor
        "New-AARObservabilityConfiguration/TraceConfiguration_Vendor"
        {
            $v = "AWSXRAY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAR_map = @{
    "HealthCheckConfiguration_Protocol"=@("New-AARService","Update-AARService")
    "NetworkConfiguration_EgressConfiguration_EgressType"=@("New-AARService","Update-AARService")
    "ProviderType"=@("New-AARConnection")
    "SourceConfiguration_CodeRepository_CodeConfiguration_CodeConfigurationValues_Runtime"=@("New-AARService","Update-AARService")
    "SourceConfiguration_CodeRepository_CodeConfiguration_ConfigurationSource"=@("New-AARService","Update-AARService")
    "SourceConfiguration_CodeRepository_SourceCodeVersion_Type"=@("New-AARService","Update-AARService")
    "SourceConfiguration_ImageRepository_ImageRepositoryType"=@("New-AARService","Update-AARService")
    "TraceConfiguration_Vendor"=@("New-AARObservabilityConfiguration")
}

_awsArgumentCompleterRegistration $AAR_Completers $AAR_map

$AAR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AAR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAR_SelectMap = @{
    "Select"=@("Add-AARCustomDomain",
               "New-AARAutoScalingConfiguration",
               "New-AARConnection",
               "New-AARObservabilityConfiguration",
               "New-AARService",
               "New-AARVpcConnector",
               "New-AARVpcIngressConnection",
               "Remove-AARAutoScalingConfiguration",
               "Remove-AARConnection",
               "Remove-AARObservabilityConfiguration",
               "Remove-AARService",
               "Remove-AARVpcConnector",
               "Remove-AARVpcIngressConnection",
               "Get-AARAutoScalingConfiguration",
               "Get-AARCustomDomain",
               "Get-AARObservabilityConfiguration",
               "Get-AARService",
               "Get-AARVpcConnector",
               "Get-AARVpcIngressConnection",
               "Remove-AARCustomDomain",
               "Get-AARAutoScalingConfigurationList",
               "Get-AARConnectionList",
               "Get-AARObservabilityConfigurationList",
               "Get-AAROperationList",
               "Get-AARServiceList",
               "Get-AARResourceTag",
               "Get-AARVpcConnectorList",
               "Get-AARVpcIngressConnectionList",
               "Suspend-AARService",
               "Resume-AARService",
               "Start-AARDeployment",
               "Add-AARResourceTag",
               "Remove-AARResourceTag",
               "Update-AARService",
               "Update-AARVpcIngressConnection")
}

_awsArgumentCompleterRegistration $AAR_SelectCompleters $AAR_SelectMap
# Argument completions for service Amazon AppStream


$APS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppStream.AppVisibility
        {
            ($_ -eq "New-APSEntitlement/AppVisibility") -Or
            ($_ -eq "Update-APSEntitlement/AppVisibility")
        }
        {
            $v = "ALL","ASSOCIATED"
            break
        }

        # Amazon.AppStream.AuthenticationType
        {
            ($_ -eq "Disable-APSUser/AuthenticationType") -Or
            ($_ -eq "Enable-APSUser/AuthenticationType") -Or
            ($_ -eq "Get-APSSessionList/AuthenticationType") -Or
            ($_ -eq "Get-APSUser/AuthenticationType") -Or
            ($_ -eq "Get-APSUserStackAssociation/AuthenticationType") -Or
            ($_ -eq "New-APSUser/AuthenticationType") -Or
            ($_ -eq "Remove-APSUser/AuthenticationType")
        }
        {
            $v = "API","AWS_AD","SAML","USERPOOL"
            break
        }

        # Amazon.AppStream.CertificateBasedAuthStatus
        {
            ($_ -eq "New-APSDirectoryConfig/CertificateBasedAuthProperties_Status") -Or
            ($_ -eq "Update-APSDirectoryConfig/CertificateBasedAuthProperties_Status")
        }
        {
            $v = "DISABLED","ENABLED","ENABLED_NO_DIRECTORY_LOGIN_FALLBACK"
            break
        }

        # Amazon.AppStream.FleetType
        "New-APSFleet/FleetType"
        {
            $v = "ALWAYS_ON","ELASTIC","ON_DEMAND"
            break
        }

        # Amazon.AppStream.MessageAction
        "New-APSUser/MessageAction"
        {
            $v = "RESEND","SUPPRESS"
            break
        }

        # Amazon.AppStream.PlatformType
        {
            ($_ -eq "New-APSFleet/Platform") -Or
            ($_ -eq "Update-APSFleet/Platform")
        }
        {
            $v = "AMAZON_LINUX2","WINDOWS","WINDOWS_SERVER_2016","WINDOWS_SERVER_2019"
            break
        }

        # Amazon.AppStream.PreferredProtocol
        {
            ($_ -eq "New-APSStack/StreamingExperienceSettings_PreferredProtocol") -Or
            ($_ -eq "Update-APSStack/StreamingExperienceSettings_PreferredProtocol")
        }
        {
            $v = "TCP","UDP"
            break
        }

        # Amazon.AppStream.StreamView
        {
            ($_ -eq "New-APSFleet/StreamView") -Or
            ($_ -eq "Update-APSFleet/StreamView")
        }
        {
            $v = "APP","DESKTOP"
            break
        }

        # Amazon.AppStream.VisibilityType
        "Get-APSImageList/Type"
        {
            $v = "PRIVATE","PUBLIC","SHARED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APS_map = @{
    "AppVisibility"=@("New-APSEntitlement","Update-APSEntitlement")
    "AuthenticationType"=@("Disable-APSUser","Enable-APSUser","Get-APSSessionList","Get-APSUser","Get-APSUserStackAssociation","New-APSUser","Remove-APSUser")
    "CertificateBasedAuthProperties_Status"=@("New-APSDirectoryConfig","Update-APSDirectoryConfig")
    "FleetType"=@("New-APSFleet")
    "MessageAction"=@("New-APSUser")
    "Platform"=@("New-APSFleet","Update-APSFleet")
    "StreamingExperienceSettings_PreferredProtocol"=@("New-APSStack","Update-APSStack")
    "StreamView"=@("New-APSFleet","Update-APSFleet")
    "Type"=@("Get-APSImageList")
}

_awsArgumentCompleterRegistration $APS_Completers $APS_map

$APS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.APS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APS_SelectMap = @{
    "Select"=@("Register-APSApplicationFleet",
               "Add-APSApplicationToEntitlement",
               "Register-APSFleet",
               "Register-APSUserStackBatch",
               "Unregister-APSUserStackBatch",
               "Copy-APSImage",
               "New-APSAppBlock",
               "New-APSApplication",
               "New-APSDirectoryConfig",
               "New-APSEntitlement",
               "New-APSFleet",
               "New-APSImageBuilder",
               "New-APSImageBuilderStreamingURL",
               "New-APSStack",
               "New-APSStreamingURL",
               "New-APSUpdatedImage",
               "New-APSUsageReportSubscription",
               "New-APSUser",
               "Remove-APSAppBlock",
               "Remove-APSApplication",
               "Remove-APSDirectoryConfig",
               "Remove-APSEntitlement",
               "Remove-APSFleet",
               "Remove-APSImage",
               "Remove-APSImageBuilder",
               "Remove-APSImagePermission",
               "Remove-APSStack",
               "Remove-APSUsageReportSubscription",
               "Remove-APSUser",
               "Get-APSAppBlock",
               "Get-APSApplicationFleetAssociation",
               "Get-APSApplication",
               "Get-APSDirectoryConfigList",
               "Get-APSEntitlement",
               "Get-APSFleetList",
               "Get-APSImageBuilderList",
               "Get-APSImagePermission",
               "Get-APSImageList",
               "Get-APSSessionList",
               "Get-APSStackList",
               "Get-APSUsageReportSubscription",
               "Get-APSUser",
               "Get-APSUserStackAssociation",
               "Disable-APSUser",
               "Unregister-APSApplicationFleet",
               "Remove-APSApplicationFromEntitlement",
               "Unregister-APSFleet",
               "Enable-APSUser",
               "Revoke-APSSession",
               "Get-APSAssociatedFleetList",
               "Get-APSAssociatedStackList",
               "Get-APSEntitledApplicationList",
               "Get-APSTagsForResourceList",
               "Start-APSFleet",
               "Start-APSImageBuilder",
               "Stop-APSFleet",
               "Stop-APSImageBuilder",
               "Add-APSResourceTag",
               "Remove-APSResourceTag",
               "Update-APSApplication",
               "Update-APSDirectoryConfig",
               "Update-APSEntitlement",
               "Update-APSFleet",
               "Update-APSImagePermission",
               "Update-APSStack")
}

_awsArgumentCompleterRegistration $APS_SelectCompleters $APS_SelectMap
# Argument completions for service AWS AppSync


$ASYN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppSync.ApiCacheType
        {
            ($_ -eq "New-ASYNApiCache/Type") -Or
            ($_ -eq "Update-ASYNApiCache/Type")
        }
        {
            $v = "LARGE","LARGE_12X","LARGE_2X","LARGE_4X","LARGE_8X","MEDIUM","R4_2XLARGE","R4_4XLARGE","R4_8XLARGE","R4_LARGE","R4_XLARGE","SMALL","T2_MEDIUM","T2_SMALL","XLARGE"
            break
        }

        # Amazon.AppSync.ApiCachingBehavior
        {
            ($_ -eq "New-ASYNApiCache/ApiCachingBehavior") -Or
            ($_ -eq "Update-ASYNApiCache/ApiCachingBehavior")
        }
        {
            $v = "FULL_REQUEST_CACHING","PER_RESOLVER_CACHING"
            break
        }

        # Amazon.AppSync.AuthenticationType
        {
            ($_ -eq "New-ASYNGraphqlApi/AuthenticationType") -Or
            ($_ -eq "Update-ASYNGraphqlApi/AuthenticationType")
        }
        {
            $v = "AMAZON_COGNITO_USER_POOLS","API_KEY","AWS_IAM","AWS_LAMBDA","OPENID_CONNECT"
            break
        }

        # Amazon.AppSync.ConflictDetectionType
        {
            ($_ -eq "New-ASYNFunction/SyncConfig_ConflictDetection") -Or
            ($_ -eq "New-ASYNResolver/SyncConfig_ConflictDetection") -Or
            ($_ -eq "Update-ASYNFunction/SyncConfig_ConflictDetection") -Or
            ($_ -eq "Update-ASYNResolver/SyncConfig_ConflictDetection")
        }
        {
            $v = "NONE","VERSION"
            break
        }

        # Amazon.AppSync.ConflictHandlerType
        {
            ($_ -eq "New-ASYNFunction/SyncConfig_ConflictHandler") -Or
            ($_ -eq "New-ASYNResolver/SyncConfig_ConflictHandler") -Or
            ($_ -eq "Update-ASYNFunction/SyncConfig_ConflictHandler") -Or
            ($_ -eq "Update-ASYNResolver/SyncConfig_ConflictHandler")
        }
        {
            $v = "AUTOMERGE","LAMBDA","NONE","OPTIMISTIC_CONCURRENCY"
            break
        }

        # Amazon.AppSync.DataSourceType
        {
            ($_ -eq "New-ASYNDataSource/Type") -Or
            ($_ -eq "Update-ASYNDataSource/Type")
        }
        {
            $v = "AMAZON_DYNAMODB","AMAZON_ELASTICSEARCH","AMAZON_OPENSEARCH_SERVICE","AWS_LAMBDA","HTTP","NONE","RELATIONAL_DATABASE"
            break
        }

        # Amazon.AppSync.FieldLogLevel
        {
            ($_ -eq "New-ASYNGraphqlApi/LogConfig_FieldLogLevel") -Or
            ($_ -eq "Update-ASYNGraphqlApi/LogConfig_FieldLogLevel")
        }
        {
            $v = "ALL","ERROR","NONE"
            break
        }

        # Amazon.AppSync.OutputType
        "Get-ASYNIntrospectionSchema/Format"
        {
            $v = "JSON","SDL"
            break
        }

        # Amazon.AppSync.RelationalDatabaseSourceType
        {
            ($_ -eq "New-ASYNDataSource/RelationalDatabaseConfig_RelationalDatabaseSourceType") -Or
            ($_ -eq "Update-ASYNDataSource/RelationalDatabaseConfig_RelationalDatabaseSourceType")
        }
        {
            $v = "RDS_HTTP_ENDPOINT"
            break
        }

        # Amazon.AppSync.ResolverKind
        {
            ($_ -eq "New-ASYNResolver/Kind") -Or
            ($_ -eq "Update-ASYNResolver/Kind")
        }
        {
            $v = "PIPELINE","UNIT"
            break
        }

        # Amazon.AppSync.TypeDefinitionFormat
        {
            ($_ -eq "Get-ASYNType/Format") -Or
            ($_ -eq "Get-ASYNTypeList/Format") -Or
            ($_ -eq "New-ASYNType/Format") -Or
            ($_ -eq "Update-ASYNType/Format")
        }
        {
            $v = "JSON","SDL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASYN_map = @{
    "ApiCachingBehavior"=@("New-ASYNApiCache","Update-ASYNApiCache")
    "AuthenticationType"=@("New-ASYNGraphqlApi","Update-ASYNGraphqlApi")
    "Format"=@("Get-ASYNIntrospectionSchema","Get-ASYNType","Get-ASYNTypeList","New-ASYNType","Update-ASYNType")
    "Kind"=@("New-ASYNResolver","Update-ASYNResolver")
    "LogConfig_FieldLogLevel"=@("New-ASYNGraphqlApi","Update-ASYNGraphqlApi")
    "RelationalDatabaseConfig_RelationalDatabaseSourceType"=@("New-ASYNDataSource","Update-ASYNDataSource")
    "SyncConfig_ConflictDetection"=@("New-ASYNFunction","New-ASYNResolver","Update-ASYNFunction","Update-ASYNResolver")
    "SyncConfig_ConflictHandler"=@("New-ASYNFunction","New-ASYNResolver","Update-ASYNFunction","Update-ASYNResolver")
    "Type"=@("New-ASYNApiCache","New-ASYNDataSource","Update-ASYNApiCache","Update-ASYNDataSource")
}

_awsArgumentCompleterRegistration $ASYN_Completers $ASYN_map

$ASYN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASYN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASYN_SelectMap = @{
    "Select"=@("Start-ASYNApiAssociation",
               "New-ASYNApiCache",
               "New-ASYNApiKey",
               "New-ASYNDataSource",
               "New-ASYNDomainName",
               "New-ASYNFunction",
               "New-ASYNGraphqlApi",
               "New-ASYNResolver",
               "New-ASYNType",
               "Remove-ASYNApiCache",
               "Remove-ASYNApiKey",
               "Remove-ASYNDataSource",
               "Remove-ASYNDomainName",
               "Remove-ASYNFunction",
               "Remove-ASYNGraphqlApi",
               "Remove-ASYNResolver",
               "Remove-ASYNType",
               "Stop-ASYNApiAssociation",
               "Test-ASYNMappingTemplate",
               "Clear-ASYNApiCache",
               "Get-ASYNApiAssociation",
               "Get-ASYNApiCache",
               "Get-ASYNDataSource",
               "Get-ASYNDomainName",
               "Get-ASYNFunction",
               "Get-ASYNGraphqlApi",
               "Get-ASYNIntrospectionSchema",
               "Get-ASYNResolver",
               "Get-ASYNSchemaCreationStatus",
               "Get-ASYNType",
               "Get-ASYNApiKeyList",
               "Get-ASYNDataSourceList",
               "Get-ASYNDomainNameList",
               "Get-ASYNFunctionList",
               "Get-ASYNGraphqlApiList",
               "Get-ASYNResolverList",
               "Get-ASYNResolverListByFunction",
               "Get-ASYNResourceTag",
               "Get-ASYNTypeList",
               "Start-ASYNSchemaCreation",
               "Add-ASYNResourceTag",
               "Remove-ASYNResourceTag",
               "Update-ASYNApiCache",
               "Update-ASYNApiKey",
               "Update-ASYNDataSource",
               "Update-ASYNDomainName",
               "Update-ASYNFunction",
               "Update-ASYNGraphqlApi",
               "Update-ASYNResolver",
               "Update-ASYNType")
}

_awsArgumentCompleterRegistration $ASYN_SelectCompleters $ASYN_SelectMap
# Argument completions for service Amazon Prometheus Service


$PROM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PROM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PROM_SelectMap = @{
    "Select"=@("New-PROMAlertManagerDefinition",
               "New-PROMLoggingConfiguration",
               "New-PROMRuleGroupsNamespace",
               "New-PROMWorkspace",
               "Remove-PROMAlertManagerDefinition",
               "Remove-PROMLoggingConfiguration",
               "Remove-PROMRuleGroupsNamespace",
               "Remove-PROMWorkspace",
               "Get-PROMAlertManagerDefinition",
               "Get-PROMLoggingConfiguration",
               "Get-PROMRuleGroupsNamespace",
               "Get-PROMWorkspace",
               "Get-PROMRuleGroupsNamespaceList",
               "Get-PROMResourceTag",
               "Get-PROMWorkspaceList",
               "Write-PROMAlertManagerDefinition",
               "Write-PROMRuleGroupsNamespace",
               "Add-PROMResourceTag",
               "Remove-PROMResourceTag",
               "Update-PROMLoggingConfiguration",
               "Update-PROMWorkspaceAlias")
}

_awsArgumentCompleterRegistration $PROM_SelectCompleters $PROM_SelectMap
# Argument completions for service Amazon Athena


$ATH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Athena.DataCatalogType
        {
            ($_ -eq "New-ATHDataCatalog/Type") -Or
            ($_ -eq "Update-ATHDataCatalog/Type")
        }
        {
            $v = "GLUE","HIVE","LAMBDA"
            break
        }

        # Amazon.Athena.EncryptionOption
        {
            ($_ -eq "New-ATHWorkGroup/Configuration_ResultConfiguration_EncryptionConfiguration_EncryptionOption") -Or
            ($_ -eq "Update-ATHWorkGroup/ConfigurationUpdates_ResultConfigurationUpdates_EncryptionConfiguration_EncryptionOption") -Or
            ($_ -eq "Start-ATHQueryExecution/ResultConfiguration_EncryptionConfiguration_EncryptionOption")
        }
        {
            $v = "CSE_KMS","SSE_KMS","SSE_S3"
            break
        }

        # Amazon.Athena.S3AclOption
        {
            ($_ -eq "New-ATHWorkGroup/Configuration_ResultConfiguration_AclConfiguration_S3AclOption") -Or
            ($_ -eq "Update-ATHWorkGroup/ConfigurationUpdates_ResultConfigurationUpdates_AclConfiguration_S3AclOption") -Or
            ($_ -eq "Start-ATHQueryExecution/ResultConfiguration_AclConfiguration_S3AclOption")
        }
        {
            $v = "BUCKET_OWNER_FULL_CONTROL"
            break
        }

        # Amazon.Athena.WorkGroupState
        "Update-ATHWorkGroup/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ATH_map = @{
    "Configuration_ResultConfiguration_AclConfiguration_S3AclOption"=@("New-ATHWorkGroup")
    "Configuration_ResultConfiguration_EncryptionConfiguration_EncryptionOption"=@("New-ATHWorkGroup")
    "ConfigurationUpdates_ResultConfigurationUpdates_AclConfiguration_S3AclOption"=@("Update-ATHWorkGroup")
    "ConfigurationUpdates_ResultConfigurationUpdates_EncryptionConfiguration_EncryptionOption"=@("Update-ATHWorkGroup")
    "ResultConfiguration_AclConfiguration_S3AclOption"=@("Start-ATHQueryExecution")
    "ResultConfiguration_EncryptionConfiguration_EncryptionOption"=@("Start-ATHQueryExecution")
    "State"=@("Update-ATHWorkGroup")
    "Type"=@("New-ATHDataCatalog","Update-ATHDataCatalog")
}

_awsArgumentCompleterRegistration $ATH_Completers $ATH_map

$ATH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ATH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ATH_SelectMap = @{
    "Select"=@("Get-ATHNamedQueryBatch",
               "Get-ATHBatchPreparedStatement",
               "Get-ATHQueryExecutionBatch",
               "New-ATHDataCatalog",
               "New-ATHNamedQuery",
               "New-ATHPreparedStatement",
               "New-ATHWorkGroup",
               "Remove-ATHDataCatalog",
               "Remove-ATHNamedQuery",
               "Remove-ATHPreparedStatement",
               "Remove-ATHWorkGroup",
               "Get-ATHDatabase",
               "Get-ATHDataCatalog",
               "Get-ATHNamedQuery",
               "Get-ATHPreparedStatement",
               "Get-ATHQueryExecution",
               "Get-ATHQueryResult",
               "Get-ATHQueryRuntimeStatistic",
               "Get-ATHTableMetadata",
               "Get-ATHWorkGroup",
               "Get-ATHDatabasisList",
               "Get-ATHDataCatalogList",
               "Get-ATHEngineVersionList",
               "Get-ATHNamedQueryList",
               "Get-ATHPreparedStatementList",
               "Get-ATHQueryExecutionList",
               "Get-ATHTableMetadataList",
               "Get-ATHResourceTag",
               "Get-ATHWorkGroupList",
               "Start-ATHQueryExecution",
               "Stop-ATHQueryExecution",
               "Add-ATHResourceTag",
               "Remove-ATHResourceTag",
               "Update-ATHDataCatalog",
               "Update-ATHNamedQuery",
               "Update-ATHPreparedStatement",
               "Update-ATHWorkGroup")
}

_awsArgumentCompleterRegistration $ATH_SelectCompleters $ATH_SelectMap
# Argument completions for service AWS Audit Manager


$AUDM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AuditManager.AssessmentReportDestinationType
        {
            ($_ -eq "Edit-AUDMAssessment/AssessmentReportsDestination_DestinationType") -Or
            ($_ -eq "New-AUDMAssessment/AssessmentReportsDestination_DestinationType") -Or
            ($_ -eq "Edit-AUDMSetting/DefaultAssessmentReportsDestination_DestinationType")
        }
        {
            $v = "S3"
            break
        }

        # Amazon.AuditManager.AssessmentStatus
        {
            ($_ -eq "Edit-AUDMAssessmentStatus/Status") -Or
            ($_ -eq "Get-AUDMAssessmentList/Status")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.AuditManager.ControlSetStatus
        "Edit-AUDMAssessmentControlSetStatus/Status"
        {
            $v = "ACTIVE","REVIEWED","UNDER_REVIEW"
            break
        }

        # Amazon.AuditManager.ControlStatus
        "Edit-AUDMAssessmentControl/ControlStatus"
        {
            $v = "INACTIVE","REVIEWED","UNDER_REVIEW"
            break
        }

        # Amazon.AuditManager.ControlType
        "Get-AUDMControlList/ControlType"
        {
            $v = "Custom","Standard"
            break
        }

        # Amazon.AuditManager.FrameworkType
        "Get-AUDMAssessmentFrameworkList/FrameworkType"
        {
            $v = "Custom","Standard"
            break
        }

        # Amazon.AuditManager.SettingAttribute
        "Get-AUDMSetting/Attribute"
        {
            $v = "ALL","DEFAULT_ASSESSMENT_REPORTS_DESTINATION","DEFAULT_PROCESS_OWNERS","IS_AWS_ORG_ENABLED","SNS_TOPIC"
            break
        }

        # Amazon.AuditManager.ShareRequestAction
        "Update-AUDMAssessmentFrameworkShare/Action"
        {
            $v = "ACCEPT","DECLINE","REVOKE"
            break
        }

        # Amazon.AuditManager.ShareRequestType
        {
            ($_ -eq "Get-AUDMAssessmentFrameworkShareRequestList/RequestType") -Or
            ($_ -eq "Remove-AUDMAssessmentFrameworkShare/RequestType") -Or
            ($_ -eq "Update-AUDMAssessmentFrameworkShare/RequestType")
        }
        {
            $v = "RECEIVED","SENT"
            break
        }

        # Amazon.AuditManager.SourceType
        "Get-AUDMKeywordForDataSourceList/Source"
        {
            $v = "AWS_API_Call","AWS_Cloudtrail","AWS_Config","AWS_Security_Hub","MANUAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AUDM_map = @{
    "Action"=@("Update-AUDMAssessmentFrameworkShare")
    "AssessmentReportsDestination_DestinationType"=@("Edit-AUDMAssessment","New-AUDMAssessment")
    "Attribute"=@("Get-AUDMSetting")
    "ControlStatus"=@("Edit-AUDMAssessmentControl")
    "ControlType"=@("Get-AUDMControlList")
    "DefaultAssessmentReportsDestination_DestinationType"=@("Edit-AUDMSetting")
    "FrameworkType"=@("Get-AUDMAssessmentFrameworkList")
    "RequestType"=@("Get-AUDMAssessmentFrameworkShareRequestList","Remove-AUDMAssessmentFrameworkShare","Update-AUDMAssessmentFrameworkShare")
    "Source"=@("Get-AUDMKeywordForDataSourceList")
    "Status"=@("Edit-AUDMAssessmentControlSetStatus","Edit-AUDMAssessmentStatus","Get-AUDMAssessmentList")
}

_awsArgumentCompleterRegistration $AUDM_Completers $AUDM_map

$AUDM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AUDM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AUDM_SelectMap = @{
    "Select"=@("Add-AUDMAssessmentReportEvidenceFolder",
               "Add-AUDMAssessmentReportEvidence",
               "New-AUDMCreateDelegationByAssessment",
               "Remove-AUDMDelegationByAssessment",
               "Remove-AUDMAssessmentReportEvidence",
               "Add-AUDMEvidenceToAssessmentControl",
               "New-AUDMAssessment",
               "New-AUDMAssessmentFramework",
               "New-AUDMAssessmentReport",
               "New-AUDMControl",
               "Remove-AUDMAssessment",
               "Remove-AUDMAssessmentFramework",
               "Remove-AUDMAssessmentFrameworkShare",
               "Remove-AUDMAssessmentReport",
               "Remove-AUDMControl",
               "Unregister-AUDMAccount",
               "Unregister-AUDMOrganizationAdminAccount",
               "Remove-AUDMAssessmentReportEvidenceFolder",
               "Get-AUDMAccountStatus",
               "Get-AUDMAssessment",
               "Get-AUDMAssessmentFramework",
               "Get-AUDMAssessmentReportUrl",
               "Get-AUDMChangeLog",
               "Get-AUDMControl",
               "Get-AUDMDelegation",
               "Get-AUDMEvidence",
               "Get-AUDMEvidenceByEvidenceFolder",
               "Get-AUDMEvidenceFolder",
               "Get-AUDMEvidenceFolderByAssessment",
               "Get-AUDMEvidenceFolderByAssessmentControl",
               "Get-AUDMInsight",
               "Get-AUDMInsightsByAssessment",
               "Get-AUDMOrganizationAdminAccount",
               "Get-AUDMServiceInScope",
               "Get-AUDMSetting",
               "Get-AUDMAssessmentControlInsightsByControlDomainList",
               "Get-AUDMAssessmentFrameworkList",
               "Get-AUDMAssessmentFrameworkShareRequestList",
               "Get-AUDMAssessmentReportList",
               "Get-AUDMAssessmentList",
               "Get-AUDMControlDomainInsightList",
               "Get-AUDMControlDomainInsightsByAssessmentList",
               "Get-AUDMControlInsightsByControlDomainList",
               "Get-AUDMControlList",
               "Get-AUDMKeywordForDataSourceList",
               "Get-AUDMNotificationList",
               "Get-AUDMResourceTagList",
               "Register-AUDMAccount",
               "Register-AUDMOrganizationAdminAccount",
               "Start-AUDMAssessmentFrameworkShare",
               "Add-AUDMResourceTag",
               "Remove-AUDMResourceTag",
               "Edit-AUDMAssessment",
               "Edit-AUDMAssessmentControl",
               "Edit-AUDMAssessmentControlSetStatus",
               "Edit-AUDMAssessmentFramework",
               "Update-AUDMAssessmentFrameworkShare",
               "Edit-AUDMAssessmentStatus",
               "Edit-AUDMControl",
               "Edit-AUDMSetting",
               "Confirm-AUDMAssessmentReportIntegrity")
}

_awsArgumentCompleterRegistration $AUDM_SelectCompleters $AUDM_SelectMap
# Argument completions for service AWS Auto Scaling


$AS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AutoScaling.InstanceMetadataEndpointState
        "New-ASLaunchConfiguration/MetadataOptions_HttpEndpoint"
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.AutoScaling.InstanceMetadataHttpTokensState
        "New-ASLaunchConfiguration/MetadataOptions_HttpTokens"
        {
            $v = "optional","required"
            break
        }

        # Amazon.AutoScaling.MetricStatistic
        "Write-ASScalingPolicy/TargetTrackingConfiguration_CustomizedMetricSpecification_Statistic"
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }

        # Amazon.AutoScaling.MetricType
        "Write-ASScalingPolicy/TargetTrackingConfiguration_PredefinedMetricSpecification_PredefinedMetricType"
        {
            $v = "ALBRequestCountPerTarget","ASGAverageCPUUtilization","ASGAverageNetworkIn","ASGAverageNetworkOut"
            break
        }

        # Amazon.AutoScaling.PredictiveScalingMaxCapacityBreachBehavior
        "Write-ASScalingPolicy/PredictiveScalingConfiguration_MaxCapacityBreachBehavior"
        {
            $v = "HonorMaxCapacity","IncreaseMaxCapacity"
            break
        }

        # Amazon.AutoScaling.PredictiveScalingMode
        "Write-ASScalingPolicy/PredictiveScalingConfiguration_Mode"
        {
            $v = "ForecastAndScale","ForecastOnly"
            break
        }

        # Amazon.AutoScaling.RefreshStrategy
        "Start-ASInstanceRefresh/Strategy"
        {
            $v = "Rolling"
            break
        }

        # Amazon.AutoScaling.WarmPoolState
        "Write-ASWarmPool/PoolState"
        {
            $v = "Hibernated","Running","Stopped"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AS_map = @{
    "MetadataOptions_HttpEndpoint"=@("New-ASLaunchConfiguration")
    "MetadataOptions_HttpTokens"=@("New-ASLaunchConfiguration")
    "PoolState"=@("Write-ASWarmPool")
    "PredictiveScalingConfiguration_MaxCapacityBreachBehavior"=@("Write-ASScalingPolicy")
    "PredictiveScalingConfiguration_Mode"=@("Write-ASScalingPolicy")
    "Strategy"=@("Start-ASInstanceRefresh")
    "TargetTrackingConfiguration_CustomizedMetricSpecification_Statistic"=@("Write-ASScalingPolicy")
    "TargetTrackingConfiguration_PredefinedMetricSpecification_PredefinedMetricType"=@("Write-ASScalingPolicy")
}

_awsArgumentCompleterRegistration $AS_Completers $AS_map

$AS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AS_SelectMap = @{
    "Select"=@("Mount-ASInstance",
               "Add-ASLoadBalancer",
               "Add-ASLoadBalancerTargetGroup",
               "Remove-ASScheduledActionBatch",
               "Set-ASScheduledUpdateGroupActionBatch",
               "Stop-ASInstanceRefresh",
               "Complete-ASLifecycleAction",
               "New-ASAutoScalingGroup",
               "New-ASLaunchConfiguration",
               "Set-ASTag",
               "Remove-ASAutoScalingGroup",
               "Remove-ASLaunchConfiguration",
               "Remove-ASLifecycleHook",
               "Remove-ASNotificationConfiguration",
               "Remove-ASPolicy",
               "Remove-ASScheduledAction",
               "Remove-ASTag",
               "Remove-ASWarmPool",
               "Get-ASAccountLimit",
               "Get-ASAdjustmentType",
               "Get-ASAutoScalingGroup",
               "Get-ASAutoScalingInstance",
               "Get-ASAutoScalingNotificationType",
               "Get-ASInstanceRefresh",
               "Get-ASLaunchConfiguration",
               "Get-ASLifecycleHook",
               "Get-ASLifecycleHookType",
               "Get-ASLoadBalancer",
               "Get-ASLoadBalancerTargetGroup",
               "Get-ASMetricCollectionType",
               "Get-ASNotificationConfiguration",
               "Get-ASPolicy",
               "Get-ASScalingActivity",
               "Get-ASScalingProcessType",
               "Get-ASScheduledAction",
               "Get-ASTag",
               "Get-ASTerminationPolicyType",
               "Get-ASWarmPool",
               "Dismount-ASInstance",
               "Dismount-ASLoadBalancer",
               "Dismount-ASLoadBalancerTargetGroup",
               "Disable-ASMetricsCollection",
               "Enable-ASMetricsCollection",
               "Enter-ASStandby",
               "Start-ASPolicy",
               "Exit-ASStandby",
               "Get-ASPredictiveScalingForecast",
               "Write-ASLifecycleHook",
               "Write-ASNotificationConfiguration",
               "Write-ASScalingPolicy",
               "Write-ASScheduledUpdateGroupAction",
               "Write-ASWarmPool",
               "Write-ASLifecycleActionHeartbeat",
               "Resume-ASProcess",
               "Set-ASDesiredCapacity",
               "Set-ASInstanceHealth",
               "Set-ASInstanceProtection",
               "Start-ASInstanceRefresh",
               "Suspend-ASProcess",
               "Stop-ASInstanceInAutoScalingGroup",
               "Update-ASAutoScalingGroup")
}

_awsArgumentCompleterRegistration $AS_SelectCompleters $AS_SelectMap
# Argument completions for service AWS Auto Scaling Plans


$ASP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AutoScalingPlans.ForecastDataType
        "Get-ASPScalingPlanResourceForecastData/ForecastDataType"
        {
            $v = "CapacityForecast","LoadForecast","ScheduledActionMaxCapacity","ScheduledActionMinCapacity"
            break
        }

        # Amazon.AutoScalingPlans.ScalableDimension
        "Get-ASPScalingPlanResourceForecastData/ScalableDimension"
        {
            $v = "autoscaling:autoScalingGroup:DesiredCapacity","dynamodb:index:ReadCapacityUnits","dynamodb:index:WriteCapacityUnits","dynamodb:table:ReadCapacityUnits","dynamodb:table:WriteCapacityUnits","ec2:spot-fleet-request:TargetCapacity","ecs:service:DesiredCount","rds:cluster:ReadReplicaCount"
            break
        }

        # Amazon.AutoScalingPlans.ServiceNamespace
        "Get-ASPScalingPlanResourceForecastData/ServiceNamespace"
        {
            $v = "autoscaling","dynamodb","ec2","ecs","rds"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASP_map = @{
    "ForecastDataType"=@("Get-ASPScalingPlanResourceForecastData")
    "ScalableDimension"=@("Get-ASPScalingPlanResourceForecastData")
    "ServiceNamespace"=@("Get-ASPScalingPlanResourceForecastData")
}

_awsArgumentCompleterRegistration $ASP_Completers $ASP_map

$ASP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASP_SelectMap = @{
    "Select"=@("New-ASPScalingPlan",
               "Remove-ASPScalingPlan",
               "Get-ASPScalingPlanResource",
               "Get-ASPScalingPlan",
               "Get-ASPScalingPlanResourceForecastData",
               "Update-ASPScalingPlan")
}

_awsArgumentCompleterRegistration $ASP_SelectCompleters $ASP_SelectMap
# Argument completions for service AWS Migration Hub


$MH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHub.ApplicationStatus
        "Send-MHApplicationStateNotification/Status"
        {
            $v = "COMPLETED","IN_PROGRESS","NOT_STARTED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MH_map = @{
    "Status"=@("Send-MHApplicationStateNotification")
}

_awsArgumentCompleterRegistration $MH_Completers $MH_map

$MH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MH_SelectMap = @{
    "Select"=@("Add-MHCreatedArtifact",
               "Add-MHDiscoveredResource",
               "New-MHProgressUpdateStream",
               "Remove-MHProgressUpdateStream",
               "Get-MHApplicationState",
               "Get-MHMigrationTask",
               "Remove-MHCreatedArtifact",
               "Remove-MHDiscoveredResource",
               "Import-MHMigrationTask",
               "Get-MHApplicationStateList",
               "Get-MHCreatedArtifactList",
               "Get-MHDiscoveredResourceList",
               "Get-MHMigrationTaskList",
               "Get-MHProgressUpdateStream",
               "Send-MHApplicationStateNotification",
               "Send-MHMigrationTaskStateNotification",
               "Set-MHResourceAttribute")
}

_awsArgumentCompleterRegistration $MH_SelectCompleters $MH_SelectMap
# Argument completions for service AWS Backup


$BAK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Backup.BackupJobState
        "Get-BAKBackupJobList/ByState"
        {
            $v = "ABORTED","ABORTING","COMPLETED","CREATED","EXPIRED","FAILED","PENDING","RUNNING"
            break
        }

        # Amazon.Backup.CopyJobState
        "Get-BAKCopyJobList/ByState"
        {
            $v = "COMPLETED","CREATED","FAILED","RUNNING"
            break
        }

        # Amazon.Backup.RestoreJobStatus
        "Get-BAKRestoreJobList/ByStatus"
        {
            $v = "ABORTED","COMPLETED","FAILED","PENDING","RUNNING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAK_map = @{
    "ByState"=@("Get-BAKBackupJobList","Get-BAKCopyJobList")
    "ByStatus"=@("Get-BAKRestoreJobList")
}

_awsArgumentCompleterRegistration $BAK_Completers $BAK_map

$BAK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BAK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAK_SelectMap = @{
    "Select"=@("New-BAKBackupPlan",
               "New-BAKBackupSelection",
               "New-BAKBackupVault",
               "New-BAKFramework",
               "New-BAKReportPlan",
               "Remove-BAKBackupPlan",
               "Remove-BAKBackupSelection",
               "Remove-BAKBackupVault",
               "Remove-BAKBackupVaultAccessPolicy",
               "Remove-BAKBackupVaultLockConfiguration",
               "Remove-BAKBackupVaultNotification",
               "Remove-BAKFramework",
               "Remove-BAKRecoveryPoint",
               "Remove-BAKReportPlan",
               "Get-BAKBackupJob",
               "Get-BAKBackupVault",
               "Get-BAKCopyJob",
               "Get-BAKFramework",
               "Get-BAKGlobalSetting",
               "Get-BAKProtectedResource",
               "Get-BAKRecoveryPoint",
               "Get-BAKRegionSetting",
               "Get-BAKReportJob",
               "Get-BAKReportPlan",
               "Get-BAKRestoreJob",
               "Unlock-BAKRecoveryPoint",
               "Export-BAKBackupPlanTemplate",
               "Get-BAKBackupPlan",
               "Get-BAKBackupPlanFromJSON",
               "Get-BAKBackupPlanFromTemplate",
               "Get-BAKBackupSelection",
               "Get-BAKBackupVaultAccessPolicy",
               "Get-BAKBackupVaultNotification",
               "Get-BAKRecoveryPointRestoreMetadata",
               "Get-BAKSupportedResourceType",
               "Get-BAKBackupJobList",
               "Get-BAKBackupPlanList",
               "Get-BAKBackupPlanTemplateList",
               "Get-BAKBackupPlanVersionList",
               "Get-BAKBackupSelectionList",
               "Get-BAKBackupVaultList",
               "Get-BAKCopyJobList",
               "Get-BAKFrameworkList",
               "Get-BAKProtectedResourceList",
               "Get-BAKRecoveryPointsByBackupVaultList",
               "Get-BAKRecoveryPointsByResourceList",
               "Get-BAKReportJobList",
               "Get-BAKReportPlanList",
               "Get-BAKRestoreJobList",
               "Get-BAKResourceTag",
               "Write-BAKBackupVaultAccessPolicy",
               "Write-BAKBackupVaultLockConfiguration",
               "Write-BAKBackupVaultNotification",
               "Start-BAKBackupJob",
               "Start-BAKCopyJob",
               "Start-BAKReportJob",
               "Start-BAKRestoreJob",
               "Stop-BAKBackupJob",
               "Add-BAKResourceTag",
               "Remove-BAKResourceTag",
               "Update-BAKBackupPlan",
               "Update-BAKFramework",
               "Update-BAKGlobalSetting",
               "Update-BAKRecoveryPointLifecycle",
               "Update-BAKRegionSetting",
               "Update-BAKReportPlan")
}

_awsArgumentCompleterRegistration $BAK_SelectCompleters $BAK_SelectMap
# Argument completions for service AWS Backup Gateway


$BUGW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.BackupGateway.GatewayType
        "New-BUGWGateway/GatewayType"
        {
            $v = "BACKUP_VM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BUGW_map = @{
    "GatewayType"=@("New-BUGWGateway")
}

_awsArgumentCompleterRegistration $BUGW_Completers $BUGW_map

$BUGW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BUGW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BUGW_SelectMap = @{
    "Select"=@("Add-BUGWGatewayToServer",
               "New-BUGWGateway",
               "Remove-BUGWGateway",
               "Remove-BUGWHypervisor",
               "Remove-BUGWGatewayFromServer",
               "Get-BUGWGateway",
               "Get-BUGWVirtualMachine",
               "Import-BUGWHypervisorConfiguration",
               "Get-BUGWGatewayList",
               "Get-BUGWHypervisorList",
               "Get-BUGWResourceTag",
               "Get-BUGWVirtualMachineList",
               "Write-BUGWMaintenanceStartTime",
               "Add-BUGWResourceTag",
               "Test-BUGWHypervisorConfiguration",
               "Remove-BUGWResourceTag",
               "Update-BUGWGatewayInformation",
               "Update-BUGWGatewaySoftwareNow",
               "Update-BUGWHypervisor")
}

_awsArgumentCompleterRegistration $BUGW_SelectCompleters $BUGW_SelectMap
# Argument completions for service AWS Backup Storage


$BAKS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.BackupStorage.DataChecksumAlgorithm
        {
            ($_ -eq "Write-BAKSChunk/ChecksumAlgorithm") -Or
            ($_ -eq "Submit-BAKSObjectComplete/MetadataBlobChecksumAlgorithm")
        }
        {
            $v = "SHA256"
            break
        }

        # Amazon.BackupStorage.SummaryChecksumAlgorithm
        {
            ($_ -eq "Submit-BAKSObjectComplete/ObjectChecksumAlgorithm") -Or
            ($_ -eq "Write-BAKSObject/ObjectChecksumAlgorithm")
        }
        {
            $v = "SUMMARY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAKS_map = @{
    "ChecksumAlgorithm"=@("Write-BAKSChunk")
    "MetadataBlobChecksumAlgorithm"=@("Submit-BAKSObjectComplete")
    "ObjectChecksumAlgorithm"=@("Submit-BAKSObjectComplete","Write-BAKSObject")
}

_awsArgumentCompleterRegistration $BAKS_Completers $BAKS_map

$BAKS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BAKS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAKS_SelectMap = @{
    "Select"=@("Remove-BAKSObject",
               "Get-BAKSChunk",
               "Get-BAKSObjectMetadata",
               "Get-BAKSChunkList",
               "Get-BAKSObjectList",
               "Submit-BAKSObjectComplete",
               "Write-BAKSChunk",
               "Write-BAKSObject",
               "Start-BAKSObject")
}

_awsArgumentCompleterRegistration $BAKS_SelectCompleters $BAKS_SelectMap
# Argument completions for service AWS Batch


$BAT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Batch.AssignPublicIp
        "Register-BATJobDefinition/ContainerProperties_NetworkConfiguration_AssignPublicIp"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Batch.CEState
        {
            ($_ -eq "New-BATComputeEnvironment/State") -Or
            ($_ -eq "Update-BATComputeEnvironment/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Batch.CEType
        "New-BATComputeEnvironment/Type"
        {
            $v = "MANAGED","UNMANAGED"
            break
        }

        # Amazon.Batch.CRAllocationStrategy
        "New-BATComputeEnvironment/ComputeResources_AllocationStrategy"
        {
            $v = "BEST_FIT","BEST_FIT_PROGRESSIVE","SPOT_CAPACITY_OPTIMIZED"
            break
        }

        # Amazon.Batch.CRType
        {
            ($_ -eq "New-BATComputeEnvironment/ComputeResources_Type") -Or
            ($_ -eq "Update-BATComputeEnvironment/ComputeResources_Type")
        }
        {
            $v = "EC2","FARGATE","FARGATE_SPOT","SPOT"
            break
        }

        # Amazon.Batch.CRUpdateAllocationStrategy
        "Update-BATComputeEnvironment/ComputeResources_AllocationStrategy"
        {
            $v = "BEST_FIT_PROGRESSIVE","SPOT_CAPACITY_OPTIMIZED"
            break
        }

        # Amazon.Batch.JobDefinitionType
        "Register-BATJobDefinition/Type"
        {
            $v = "container","multinode"
            break
        }

        # Amazon.Batch.JobStatus
        "Get-BATJobList/JobStatus"
        {
            $v = "FAILED","PENDING","RUNNABLE","RUNNING","STARTING","SUBMITTED","SUCCEEDED"
            break
        }

        # Amazon.Batch.JQState
        {
            ($_ -eq "New-BATJobQueue/State") -Or
            ($_ -eq "Update-BATJobQueue/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Batch.LogDriver
        "Register-BATJobDefinition/ContainerProperties_LogConfiguration_LogDriver"
        {
            $v = "awslogs","fluentd","gelf","journald","json-file","splunk","syslog"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAT_map = @{
    "ComputeResources_AllocationStrategy"=@("New-BATComputeEnvironment","Update-BATComputeEnvironment")
    "ComputeResources_Type"=@("New-BATComputeEnvironment","Update-BATComputeEnvironment")
    "ContainerProperties_LogConfiguration_LogDriver"=@("Register-BATJobDefinition")
    "ContainerProperties_NetworkConfiguration_AssignPublicIp"=@("Register-BATJobDefinition")
    "JobStatus"=@("Get-BATJobList")
    "State"=@("New-BATComputeEnvironment","New-BATJobQueue","Update-BATComputeEnvironment","Update-BATJobQueue")
    "Type"=@("New-BATComputeEnvironment","Register-BATJobDefinition")
}

_awsArgumentCompleterRegistration $BAT_Completers $BAT_map

$BAT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BAT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAT_SelectMap = @{
    "Select"=@("Stop-BATJob",
               "New-BATComputeEnvironment",
               "New-BATJobQueue",
               "New-BATSchedulingPolicy",
               "Remove-BATComputeEnvironment",
               "Remove-BATJobQueue",
               "Remove-BATSchedulingPolicy",
               "Unregister-BATJobDefinition",
               "Get-BATComputeEnvironment",
               "Get-BATJobDefinition",
               "Get-BATJobQueue",
               "Get-BATJobDetail",
               "Get-BATSchedulingPolicy",
               "Get-BATJobList",
               "Get-BATSchedulingPolicyList",
               "Get-BATResourceTag",
               "Register-BATJobDefinition",
               "Submit-BATJob",
               "Add-BATResourceTag",
               "Remove-BATJob",
               "Remove-BATResourceTag",
               "Update-BATComputeEnvironment",
               "Update-BATJobQueue",
               "Update-BATSchedulingPolicy")
}

_awsArgumentCompleterRegistration $BAT_SelectCompleters $BAT_SelectMap
# Argument completions for service AWSBillingConductor


$ABC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.BillingConductor.BillingGroupStatus
        "Update-ABCBillingGroup/Status"
        {
            $v = "ACTIVE","PRIMARY_ACCOUNT_MISSING"
            break
        }

        # Amazon.BillingConductor.CustomLineItemRelationship
        "Get-ABCResourcesAssociatedToCustomLineItemList/Filters_Relationship"
        {
            $v = "CHILD","PARENT"
            break
        }

        # Amazon.BillingConductor.CustomLineItemType
        "New-ABCCustomLineItem/ChargeDetails_Type"
        {
            $v = "CREDIT","FEE"
            break
        }

        # Amazon.BillingConductor.PricingRuleScope
        "New-ABCPricingRule/Scope"
        {
            $v = "BILLING_ENTITY","GLOBAL","SERVICE"
            break
        }

        # Amazon.BillingConductor.PricingRuleType
        {
            ($_ -eq "New-ABCPricingRule/Type") -Or
            ($_ -eq "Update-ABCPricingRule/Type")
        }
        {
            $v = "DISCOUNT","MARKUP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ABC_map = @{
    "ChargeDetails_Type"=@("New-ABCCustomLineItem")
    "Filters_Relationship"=@("Get-ABCResourcesAssociatedToCustomLineItemList")
    "Scope"=@("New-ABCPricingRule")
    "Status"=@("Update-ABCBillingGroup")
    "Type"=@("New-ABCPricingRule","Update-ABCPricingRule")
}

_awsArgumentCompleterRegistration $ABC_Completers $ABC_map

$ABC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ABC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ABC_SelectMap = @{
    "Select"=@("Register-ABCAccount",
               "Register-ABCPricingRule",
               "Register-ABCResourceBatchToCustomLineItem",
               "Unregister-ABCResourceBatchFromCustomLineItem",
               "New-ABCBillingGroup",
               "New-ABCCustomLineItem",
               "New-ABCPricingPlan",
               "New-ABCPricingRule",
               "Remove-ABCBillingGroup",
               "Remove-ABCCustomLineItem",
               "Remove-ABCPricingPlan",
               "Remove-ABCPricingRule",
               "Unregister-ABCAccount",
               "Unregister-ABCPricingRule",
               "Get-ABCAccountAssociationList",
               "Get-ABCBillingGroupCostReportList",
               "Get-ABCBillingGroupList",
               "Get-ABCCustomLineItemList",
               "Get-ABCCustomLineItemVersionList",
               "Get-ABCPricingPlanList",
               "Get-ABCPricingPlansAssociatedWithPricingRuleList",
               "Get-ABCPricingRuleList",
               "Get-ABCPricingRulesAssociatedToPricingPlanList",
               "Get-ABCResourcesAssociatedToCustomLineItemList",
               "Get-ABCResourceTag",
               "Add-ABCResourceTag",
               "Remove-ABCResourceTag",
               "Update-ABCBillingGroup",
               "Update-ABCCustomLineItem",
               "Update-ABCPricingPlan",
               "Update-ABCPricingRule")
}

_awsArgumentCompleterRegistration $ABC_SelectCompleters $ABC_SelectMap
# Argument completions for service Amazon Braket


$BRKT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Braket.CompressionType
        "New-BRKTJob/AlgorithmSpecification_ScriptModeConfig_CompressionType"
        {
            $v = "GZIP","NONE"
            break
        }

        # Amazon.Braket.InstanceType
        "New-BRKTJob/InstanceConfig_InstanceType"
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.c5n.18xlarge","ml.c5n.2xlarge","ml.c5n.4xlarge","ml.c5n.9xlarge","ml.c5n.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.p3dn.24xlarge","ml.p4d.24xlarge"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BRKT_map = @{
    "AlgorithmSpecification_ScriptModeConfig_CompressionType"=@("New-BRKTJob")
    "InstanceConfig_InstanceType"=@("New-BRKTJob")
}

_awsArgumentCompleterRegistration $BRKT_Completers $BRKT_map

$BRKT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BRKT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BRKT_SelectMap = @{
    "Select"=@("Stop-BRKTJob",
               "Stop-BRKTQuantumTask",
               "New-BRKTJob",
               "New-BRKTQuantumTask",
               "Get-BRKTDevice",
               "Get-BRKTJob",
               "Get-BRKTQuantumTask",
               "Get-BRKTResourceTag",
               "Search-BRKTDevice",
               "Search-BRKTJob",
               "Search-BRKTQuantumTask",
               "Add-BRKTResourceTag",
               "Remove-BRKTResourceTag")
}

_awsArgumentCompleterRegistration $BRKT_SelectCompleters $BRKT_SelectMap
# Argument completions for service AWS Budgets


$BGT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Budgets.ActionSubType
        {
            ($_ -eq "New-BGTBudgetAction/Definition_SsmActionDefinition_ActionSubType") -Or
            ($_ -eq "Update-BGTBudgetAction/Definition_SsmActionDefinition_ActionSubType")
        }
        {
            $v = "STOP_EC2_INSTANCES","STOP_RDS_INSTANCES"
            break
        }

        # Amazon.Budgets.ActionType
        "New-BGTBudgetAction/ActionType"
        {
            $v = "APPLY_IAM_POLICY","APPLY_SCP_POLICY","RUN_SSM_DOCUMENTS"
            break
        }

        # Amazon.Budgets.ApprovalModel
        {
            ($_ -eq "New-BGTBudgetAction/ApprovalModel") -Or
            ($_ -eq "Update-BGTBudgetAction/ApprovalModel")
        }
        {
            $v = "AUTOMATIC","MANUAL"
            break
        }

        # Amazon.Budgets.AutoAdjustType
        {
            ($_ -eq "New-BGTBudget/Budget_AutoAdjustData_AutoAdjustType") -Or
            ($_ -eq "Update-BGTBudget/NewBudget_AutoAdjustData_AutoAdjustType")
        }
        {
            $v = "FORECAST","HISTORICAL"
            break
        }

        # Amazon.Budgets.BudgetType
        {
            ($_ -eq "New-BGTBudget/Budget_BudgetType") -Or
            ($_ -eq "Update-BGTBudget/NewBudget_BudgetType")
        }
        {
            $v = "COST","RI_COVERAGE","RI_UTILIZATION","SAVINGS_PLANS_COVERAGE","SAVINGS_PLANS_UTILIZATION","USAGE"
            break
        }

        # Amazon.Budgets.ComparisonOperator
        {
            ($_ -eq "Update-BGTNotification/NewNotification_ComparisonOperator") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "New-BGTNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "New-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Remove-BGTNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_ComparisonOperator")
        }
        {
            $v = "EQUAL_TO","GREATER_THAN","LESS_THAN"
            break
        }

        # Amazon.Budgets.ExecutionType
        "Invoke-BGTBudgetAction/ExecutionType"
        {
            $v = "APPROVE_BUDGET_ACTION","RESET_BUDGET_ACTION","RETRY_BUDGET_ACTION","REVERSE_BUDGET_ACTION"
            break
        }

        # Amazon.Budgets.NotificationState
        {
            ($_ -eq "Update-BGTNotification/NewNotification_NotificationState") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_NotificationState") -Or
            ($_ -eq "New-BGTNotification/Notification_NotificationState") -Or
            ($_ -eq "New-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Remove-BGTNotification/Notification_NotificationState") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_NotificationState")
        }
        {
            $v = "ALARM","OK"
            break
        }

        # Amazon.Budgets.NotificationType
        {
            ($_ -eq "Update-BGTNotification/NewNotification_NotificationType") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_NotificationType") -Or
            ($_ -eq "New-BGTNotification/Notification_NotificationType") -Or
            ($_ -eq "New-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "Remove-BGTNotification/Notification_NotificationType") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "New-BGTBudgetAction/NotificationType") -Or
            ($_ -eq "Update-BGTBudgetAction/NotificationType") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_NotificationType")
        }
        {
            $v = "ACTUAL","FORECASTED"
            break
        }

        # Amazon.Budgets.SubscriptionType
        {
            ($_ -eq "Update-BGTSubscriber/NewSubscriber_SubscriptionType") -Or
            ($_ -eq "Update-BGTSubscriber/OldSubscriber_SubscriptionType") -Or
            ($_ -eq "New-BGTSubscriber/Subscriber_SubscriptionType") -Or
            ($_ -eq "Remove-BGTSubscriber/Subscriber_SubscriptionType")
        }
        {
            $v = "EMAIL","SNS"
            break
        }

        # Amazon.Budgets.ThresholdType
        {
            ($_ -eq "New-BGTBudgetAction/ActionThreshold_ActionThresholdType") -Or
            ($_ -eq "Update-BGTBudgetAction/ActionThreshold_ActionThresholdType") -Or
            ($_ -eq "Update-BGTNotification/NewNotification_ThresholdType") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_ThresholdType") -Or
            ($_ -eq "New-BGTNotification/Notification_ThresholdType") -Or
            ($_ -eq "New-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Remove-BGTNotification/Notification_ThresholdType") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_ThresholdType")
        }
        {
            $v = "ABSOLUTE_VALUE","PERCENTAGE"
            break
        }

        # Amazon.Budgets.TimeUnit
        {
            ($_ -eq "New-BGTBudget/Budget_TimeUnit") -Or
            ($_ -eq "Update-BGTBudget/NewBudget_TimeUnit")
        }
        {
            $v = "ANNUALLY","DAILY","MONTHLY","QUARTERLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BGT_map = @{
    "ActionThreshold_ActionThresholdType"=@("New-BGTBudgetAction","Update-BGTBudgetAction")
    "ActionType"=@("New-BGTBudgetAction")
    "ApprovalModel"=@("New-BGTBudgetAction","Update-BGTBudgetAction")
    "Budget_AutoAdjustData_AutoAdjustType"=@("New-BGTBudget")
    "Budget_BudgetType"=@("New-BGTBudget")
    "Budget_TimeUnit"=@("New-BGTBudget")
    "Definition_SsmActionDefinition_ActionSubType"=@("New-BGTBudgetAction","Update-BGTBudgetAction")
    "ExecutionType"=@("Invoke-BGTBudgetAction")
    "NewBudget_AutoAdjustData_AutoAdjustType"=@("Update-BGTBudget")
    "NewBudget_BudgetType"=@("Update-BGTBudget")
    "NewBudget_TimeUnit"=@("Update-BGTBudget")
    "NewNotification_ComparisonOperator"=@("Update-BGTNotification")
    "NewNotification_NotificationState"=@("Update-BGTNotification")
    "NewNotification_NotificationType"=@("Update-BGTNotification")
    "NewNotification_ThresholdType"=@("Update-BGTNotification")
    "NewSubscriber_SubscriptionType"=@("Update-BGTSubscriber")
    "Notification_ComparisonOperator"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_NotificationState"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_NotificationType"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_ThresholdType"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "NotificationType"=@("New-BGTBudgetAction","Update-BGTBudgetAction")
    "OldNotification_ComparisonOperator"=@("Update-BGTNotification")
    "OldNotification_NotificationState"=@("Update-BGTNotification")
    "OldNotification_NotificationType"=@("Update-BGTNotification")
    "OldNotification_ThresholdType"=@("Update-BGTNotification")
    "OldSubscriber_SubscriptionType"=@("Update-BGTSubscriber")
    "Subscriber_SubscriptionType"=@("New-BGTSubscriber","Remove-BGTSubscriber")
}

_awsArgumentCompleterRegistration $BGT_Completers $BGT_map

$BGT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BGT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BGT_SelectMap = @{
    "Select"=@("New-BGTBudget",
               "New-BGTBudgetAction",
               "New-BGTNotification",
               "New-BGTSubscriber",
               "Remove-BGTBudget",
               "Remove-BGTBudgetAction",
               "Remove-BGTNotification",
               "Remove-BGTSubscriber",
               "Get-BGTBudget",
               "Get-BGTBudgetAction",
               "Get-BGTBudgetActionHistory",
               "Get-BGTBudgetActionsForAccount",
               "Get-BGTBudgetActionsForBudget",
               "Get-BGTBudgetNotificationsForAccount",
               "Get-BGTBudgetPerformanceHistory",
               "Get-BGTBudgetList",
               "Get-BGTNotificationsForBudget",
               "Get-BGTSubscribersForNotification",
               "Invoke-BGTBudgetAction",
               "Update-BGTBudget",
               "Update-BGTBudgetAction",
               "Update-BGTNotification",
               "Update-BGTSubscriber")
}

_awsArgumentCompleterRegistration $BGT_SelectCompleters $BGT_SelectMap
# Argument completions for service AWS Cost Explorer


$CE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CostExplorer.AccountScope
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/AccountScope") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/AccountScope")
        }
        {
            $v = "LINKED","PAYER"
            break
        }

        # Amazon.CostExplorer.AnomalyFeedbackType
        {
            ($_ -eq "Get-CEAnomaly/Feedback") -Or
            ($_ -eq "Set-CEAnomalyFeedback/Feedback")
        }
        {
            $v = "NO","PLANNED_ACTIVITY","YES"
            break
        }

        # Amazon.CostExplorer.AnomalySubscriptionFrequency
        {
            ($_ -eq "New-CEAnomalySubscription/AnomalySubscription_Frequency") -Or
            ($_ -eq "Update-CEAnomalySubscription/Frequency")
        }
        {
            $v = "DAILY","IMMEDIATE","WEEKLY"
            break
        }

        # Amazon.CostExplorer.Context
        "Get-CEDimensionValue/Context"
        {
            $v = "COST_AND_USAGE","RESERVATIONS","SAVINGS_PLANS"
            break
        }

        # Amazon.CostExplorer.CostAllocationTagStatus
        "Get-CECostAllocationTagList/Status"
        {
            $v = "Active","Inactive"
            break
        }

        # Amazon.CostExplorer.CostAllocationTagType
        "Get-CECostAllocationTagList/Type"
        {
            $v = "AWSGenerated","UserDefined"
            break
        }

        # Amazon.CostExplorer.CostCategoryRuleVersion
        {
            ($_ -eq "New-CECostCategoryDefinition/RuleVersion") -Or
            ($_ -eq "Update-CECostCategoryDefinition/RuleVersion")
        }
        {
            $v = "CostCategoryExpression.v1"
            break
        }

        # Amazon.CostExplorer.Dimension
        "Get-CEDimensionValue/Dimension"
        {
            $v = "AGREEMENT_END_DATE_TIME_AFTER","AGREEMENT_END_DATE_TIME_BEFORE","AZ","BILLING_ENTITY","CACHE_ENGINE","DATABASE_ENGINE","DEPLOYMENT_OPTION","INSTANCE_TYPE","INSTANCE_TYPE_FAMILY","INVOICING_ENTITY","LEGAL_ENTITY_NAME","LINKED_ACCOUNT","LINKED_ACCOUNT_NAME","OPERATING_SYSTEM","OPERATION","PAYMENT_OPTION","PLATFORM","PURCHASE_TYPE","RECORD_TYPE","REGION","RESERVATION_ID","RESOURCE_ID","RIGHTSIZING_TYPE","SAVINGS_PLANS_TYPE","SAVINGS_PLAN_ARN","SCOPE","SERVICE","SERVICE_CODE","SUBSCRIPTION_ID","TENANCY","USAGE_TYPE","USAGE_TYPE_GROUP"
            break
        }

        # Amazon.CostExplorer.Granularity
        {
            ($_ -eq "Get-CECostAndUsage/Granularity") -Or
            ($_ -eq "Get-CECostAndUsageWithResource/Granularity") -Or
            ($_ -eq "Get-CECostForecast/Granularity") -Or
            ($_ -eq "Get-CEReservationCoverage/Granularity") -Or
            ($_ -eq "Get-CEReservationUtilization/Granularity") -Or
            ($_ -eq "Get-CESavingsPlansCoverage/Granularity") -Or
            ($_ -eq "Get-CESavingsPlansUtilization/Granularity") -Or
            ($_ -eq "Get-CEUsageForecast/Granularity")
        }
        {
            $v = "DAILY","HOURLY","MONTHLY"
            break
        }

        # Amazon.CostExplorer.LookbackPeriodInDays
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/LookbackPeriodInDays") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/LookbackPeriodInDays")
        }
        {
            $v = "SEVEN_DAYS","SIXTY_DAYS","THIRTY_DAYS"
            break
        }

        # Amazon.CostExplorer.Metric
        {
            ($_ -eq "Get-CECostForecast/Metric") -Or
            ($_ -eq "Get-CEUsageForecast/Metric")
        }
        {
            $v = "AMORTIZED_COST","BLENDED_COST","NET_AMORTIZED_COST","NET_UNBLENDED_COST","NORMALIZED_USAGE_AMOUNT","UNBLENDED_COST","USAGE_QUANTITY"
            break
        }

        # Amazon.CostExplorer.MonitorDimension
        "New-CEAnomalyMonitor/AnomalyMonitor_MonitorDimension"
        {
            $v = "SERVICE"
            break
        }

        # Amazon.CostExplorer.MonitorType
        "New-CEAnomalyMonitor/AnomalyMonitor_MonitorType"
        {
            $v = "CUSTOM","DIMENSIONAL"
            break
        }

        # Amazon.CostExplorer.NumericOperator
        "Get-CEAnomaly/TotalImpact_NumericOperator"
        {
            $v = "BETWEEN","EQUAL","GREATER_THAN","GREATER_THAN_OR_EQUAL","LESS_THAN","LESS_THAN_OR_EQUAL"
            break
        }

        # Amazon.CostExplorer.OfferingClass
        "Get-CEReservationPurchaseRecommendation/ServiceSpecification_EC2Specification_OfferingClass"
        {
            $v = "CONVERTIBLE","STANDARD"
            break
        }

        # Amazon.CostExplorer.PaymentOption
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/PaymentOption") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/PaymentOption")
        }
        {
            $v = "ALL_UPFRONT","HEAVY_UTILIZATION","LIGHT_UTILIZATION","MEDIUM_UTILIZATION","NO_UPFRONT","PARTIAL_UPFRONT"
            break
        }

        # Amazon.CostExplorer.RecommendationTarget
        "Get-CERightsizingRecommendation/Configuration_RecommendationTarget"
        {
            $v = "CROSS_INSTANCE_FAMILY","SAME_INSTANCE_FAMILY"
            break
        }

        # Amazon.CostExplorer.SortOrder
        {
            ($_ -eq "Get-CEReservationCoverage/SortBy_SortOrder") -Or
            ($_ -eq "Get-CEReservationUtilization/SortBy_SortOrder") -Or
            ($_ -eq "Get-CESavingsPlansCoverage/SortBy_SortOrder") -Or
            ($_ -eq "Get-CESavingsPlansUtilization/SortBy_SortOrder") -Or
            ($_ -eq "Get-CESavingsPlansUtilizationDetail/SortBy_SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.CostExplorer.SupportedSavingsPlansType
        "Get-CESavingsPlansPurchaseRecommendation/SavingsPlansType"
        {
            $v = "COMPUTE_SP","EC2_INSTANCE_SP","SAGEMAKER_SP"
            break
        }

        # Amazon.CostExplorer.TermInYears
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/TermInYears") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/TermInYears")
        }
        {
            $v = "ONE_YEAR","THREE_YEARS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CE_map = @{
    "AccountScope"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "AnomalyMonitor_MonitorDimension"=@("New-CEAnomalyMonitor")
    "AnomalyMonitor_MonitorType"=@("New-CEAnomalyMonitor")
    "AnomalySubscription_Frequency"=@("New-CEAnomalySubscription")
    "Configuration_RecommendationTarget"=@("Get-CERightsizingRecommendation")
    "Context"=@("Get-CEDimensionValue")
    "Dimension"=@("Get-CEDimensionValue")
    "Feedback"=@("Get-CEAnomaly","Set-CEAnomalyFeedback")
    "Frequency"=@("Update-CEAnomalySubscription")
    "Granularity"=@("Get-CECostAndUsage","Get-CECostAndUsageWithResource","Get-CECostForecast","Get-CEReservationCoverage","Get-CEReservationUtilization","Get-CESavingsPlansCoverage","Get-CESavingsPlansUtilization","Get-CEUsageForecast")
    "LookbackPeriodInDays"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "Metric"=@("Get-CECostForecast","Get-CEUsageForecast")
    "PaymentOption"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "RuleVersion"=@("New-CECostCategoryDefinition","Update-CECostCategoryDefinition")
    "SavingsPlansType"=@("Get-CESavingsPlansPurchaseRecommendation")
    "ServiceSpecification_EC2Specification_OfferingClass"=@("Get-CEReservationPurchaseRecommendation")
    "SortBy_SortOrder"=@("Get-CEReservationCoverage","Get-CEReservationUtilization","Get-CESavingsPlansCoverage","Get-CESavingsPlansUtilization","Get-CESavingsPlansUtilizationDetail")
    "Status"=@("Get-CECostAllocationTagList")
    "TermInYears"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "TotalImpact_NumericOperator"=@("Get-CEAnomaly")
    "Type"=@("Get-CECostAllocationTagList")
}

_awsArgumentCompleterRegistration $CE_Completers $CE_map

$CE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CE_SelectMap = @{
    "Select"=@("New-CEAnomalyMonitor",
               "New-CEAnomalySubscription",
               "New-CECostCategoryDefinition",
               "Remove-CEAnomalyMonitor",
               "Remove-CEAnomalySubscription",
               "Remove-CECostCategoryDefinition",
               "Get-CECostCategoryDefinition",
               "Get-CEAnomaly",
               "Get-CEAnomalyMonitor",
               "Get-CEAnomalySubscription",
               "Get-CECostAndUsage",
               "Get-CECostAndUsageWithResource",
               "Get-CECostCategory",
               "Get-CECostForecast",
               "Get-CEDimensionValue",
               "Get-CEReservationCoverage",
               "Get-CEReservationPurchaseRecommendation",
               "Get-CEReservationUtilization",
               "Get-CERightsizingRecommendation",
               "Get-CESavingsPlansCoverage",
               "Get-CESavingsPlansPurchaseRecommendation",
               "Get-CESavingsPlansUtilization",
               "Get-CESavingsPlansUtilizationDetail",
               "Get-CETag",
               "Get-CEUsageForecast",
               "Get-CECostAllocationTagList",
               "Get-CECostCategoryDefinitionList",
               "Get-CEResourceTag",
               "Set-CEAnomalyFeedback",
               "Add-CEResourceTag",
               "Remove-CEResourceTag",
               "Update-CEAnomalyMonitor",
               "Update-CEAnomalySubscription",
               "Update-CECostAllocationTagsStatus",
               "Update-CECostCategoryDefinition")
}

_awsArgumentCompleterRegistration $CE_SelectCompleters $CE_SelectMap
# Argument completions for service Amazon Chime


$CHM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Chime.ArtifactsState
        {
            ($_ -eq "New-CHMMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_State") -Or
            ($_ -eq "New-CHMMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_State")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.Chime.AudioMuxType
        "New-CHMMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Audio_MuxType"
        {
            $v = "AudioOnly","AudioWithActiveSpeakerVideo"
            break
        }

        # Amazon.Chime.ChannelMembershipType
        {
            ($_ -eq "Get-CHMChannelMembershipList/Type") -Or
            ($_ -eq "New-CHMChannelMembership/Type") -Or
            ($_ -eq "New-CHMCreateChannelMembership/Type")
        }
        {
            $v = "DEFAULT","HIDDEN"
            break
        }

        # Amazon.Chime.ChannelMessagePersistenceType
        "Send-CHMChannelMessage/Persistence"
        {
            $v = "NON_PERSISTENT","PERSISTENT"
            break
        }

        # Amazon.Chime.ChannelMessageType
        "Send-CHMChannelMessage/Type"
        {
            $v = "CONTROL","STANDARD"
            break
        }

        # Amazon.Chime.ChannelMode
        {
            ($_ -eq "New-CHMChannel/Mode") -Or
            ($_ -eq "Update-CHMChannel/Mode")
        }
        {
            $v = "RESTRICTED","UNRESTRICTED"
            break
        }

        # Amazon.Chime.ChannelPrivacy
        {
            ($_ -eq "Get-CHMChannelList/Privacy") -Or
            ($_ -eq "New-CHMChannel/Privacy")
        }
        {
            $v = "PRIVATE","PUBLIC"
            break
        }

        # Amazon.Chime.ContentMuxType
        "New-CHMMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_MuxType"
        {
            $v = "ContentOnly"
            break
        }

        # Amazon.Chime.GeoMatchLevel
        "New-CHMProxySession/GeoMatchLevel"
        {
            $v = "AreaCode","Country"
            break
        }

        # Amazon.Chime.License
        {
            ($_ -eq "Update-CHMAccount/DefaultLicense") -Or
            ($_ -eq "Update-CHMUser/LicenseType")
        }
        {
            $v = "Basic","Plus","Pro","ProTrial"
            break
        }

        # Amazon.Chime.MediaPipelineSinkType
        "New-CHMMediaCapturePipeline/SinkType"
        {
            $v = "S3Bucket"
            break
        }

        # Amazon.Chime.MediaPipelineSourceType
        "New-CHMMediaCapturePipeline/SourceType"
        {
            $v = "ChimeSdkMeeting"
            break
        }

        # Amazon.Chime.NumberSelectionBehavior
        "New-CHMProxySession/NumberSelectionBehavior"
        {
            $v = "AvoidSticky","PreferSticky"
            break
        }

        # Amazon.Chime.PhoneNumberAssociationName
        "Get-CHMPhoneNumberList/FilterName"
        {
            $v = "AccountId","SipRuleId","UserId","VoiceConnectorGroupId","VoiceConnectorId"
            break
        }

        # Amazon.Chime.PhoneNumberProductType
        {
            ($_ -eq "Get-CHMPhoneNumberList/ProductType") -Or
            ($_ -eq "Get-CHMSupportedPhoneNumberCountryList/ProductType") -Or
            ($_ -eq "New-CHMPhoneNumberOrder/ProductType") -Or
            ($_ -eq "Update-CHMPhoneNumber/ProductType")
        }
        {
            $v = "BusinessCalling","SipMediaApplicationDialIn","VoiceConnector"
            break
        }

        # Amazon.Chime.PhoneNumberStatus
        "Get-CHMPhoneNumberList/Status"
        {
            $v = "AcquireFailed","AcquireInProgress","Assigned","DeleteFailed","DeleteInProgress","ReleaseFailed","ReleaseInProgress","Unassigned"
            break
        }

        # Amazon.Chime.PhoneNumberType
        "Search-CHMAvailablePhoneNumber/PhoneNumberType"
        {
            $v = "Local","TollFree"
            break
        }

        # Amazon.Chime.ProxySessionStatus
        "Get-CHMProxySessionList/Status"
        {
            $v = "Closed","InProgress","Open"
            break
        }

        # Amazon.Chime.RoomMembershipRole
        {
            ($_ -eq "New-CHMRoomMembership/Role") -Or
            ($_ -eq "Update-CHMRoomMembership/Role")
        }
        {
            $v = "Administrator","Member"
            break
        }

        # Amazon.Chime.SipRuleTriggerType
        "New-CHMSipRule/TriggerType"
        {
            $v = "RequestUriHostname","ToPhoneNumber"
            break
        }

        # Amazon.Chime.SortOrder
        "Get-CHMChannelMessageList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Chime.TranscribeContentIdentificationType
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_ContentIdentificationType"
        {
            $v = "PII"
            break
        }

        # Amazon.Chime.TranscribeContentRedactionType
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_ContentRedactionType"
        {
            $v = "PII"
            break
        }

        # Amazon.Chime.TranscribeLanguageCode
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_LanguageCode"
        {
            $v = "de-DE","en-AU","en-GB","en-US","es-US","fr-CA","fr-FR","it-IT","ja-JP","ko-KR","pt-BR","zh-CN"
            break
        }

        # Amazon.Chime.TranscribeMedicalContentIdentificationType
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_ContentIdentificationType"
        {
            $v = "PHI"
            break
        }

        # Amazon.Chime.TranscribeMedicalLanguageCode
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_LanguageCode"
        {
            $v = "en-US"
            break
        }

        # Amazon.Chime.TranscribeMedicalRegion
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Region"
        {
            $v = "ap-southeast-2","auto","ca-central-1","eu-west-1","us-east-1","us-east-2","us-west-2"
            break
        }

        # Amazon.Chime.TranscribeMedicalSpecialty
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Specialty"
        {
            $v = "CARDIOLOGY","NEUROLOGY","ONCOLOGY","PRIMARYCARE","RADIOLOGY","UROLOGY"
            break
        }

        # Amazon.Chime.TranscribeMedicalType
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Type"
        {
            $v = "CONVERSATION","DICTATION"
            break
        }

        # Amazon.Chime.TranscribePartialResultsStability
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_PartialResultsStability"
        {
            $v = "high","low","medium"
            break
        }

        # Amazon.Chime.TranscribeRegion
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_Region"
        {
            $v = "ap-northeast-1","ap-northeast-2","ap-southeast-2","auto","ca-central-1","eu-central-1","eu-west-1","eu-west-2","sa-east-1","us-east-1","us-east-2","us-west-2"
            break
        }

        # Amazon.Chime.TranscribeVocabularyFilterMethod
        "Start-CHMMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_VocabularyFilterMethod"
        {
            $v = "mask","remove","tag"
            break
        }

        # Amazon.Chime.UserType
        {
            ($_ -eq "Get-CHMUserList/UserType") -Or
            ($_ -eq "New-CHMUser/UserType") -Or
            ($_ -eq "Send-CHMUserInvitation/UserType") -Or
            ($_ -eq "Update-CHMUser/UserType")
        }
        {
            $v = "PrivateUser","SharedDevice"
            break
        }

        # Amazon.Chime.VideoMuxType
        "New-CHMMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_MuxType"
        {
            $v = "VideoOnly"
            break
        }

        # Amazon.Chime.VoiceConnectorAwsRegion
        "New-CHMVoiceConnector/AwsRegion"
        {
            $v = "us-east-1","us-west-2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHM_map = @{
    "AwsRegion"=@("New-CHMVoiceConnector")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Audio_MuxType"=@("New-CHMMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_MuxType"=@("New-CHMMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_State"=@("New-CHMMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_MuxType"=@("New-CHMMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_State"=@("New-CHMMediaCapturePipeline")
    "DefaultLicense"=@("Update-CHMAccount")
    "FilterName"=@("Get-CHMPhoneNumberList")
    "GeoMatchLevel"=@("New-CHMProxySession")
    "LicenseType"=@("Update-CHMUser")
    "Mode"=@("New-CHMChannel","Update-CHMChannel")
    "NumberSelectionBehavior"=@("New-CHMProxySession")
    "Persistence"=@("Send-CHMChannelMessage")
    "PhoneNumberType"=@("Search-CHMAvailablePhoneNumber")
    "Privacy"=@("Get-CHMChannelList","New-CHMChannel")
    "ProductType"=@("Get-CHMPhoneNumberList","Get-CHMSupportedPhoneNumberCountryList","New-CHMPhoneNumberOrder","Update-CHMPhoneNumber")
    "Role"=@("New-CHMRoomMembership","Update-CHMRoomMembership")
    "SinkType"=@("New-CHMMediaCapturePipeline")
    "SortOrder"=@("Get-CHMChannelMessageList")
    "SourceType"=@("New-CHMMediaCapturePipeline")
    "Status"=@("Get-CHMPhoneNumberList","Get-CHMProxySessionList")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_ContentIdentificationType"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_LanguageCode"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Region"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Specialty"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Type"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_ContentIdentificationType"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_ContentRedactionType"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_LanguageCode"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_PartialResultsStability"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_Region"=@("Start-CHMMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_VocabularyFilterMethod"=@("Start-CHMMeetingTranscription")
    "TriggerType"=@("New-CHMSipRule")
    "Type"=@("Get-CHMChannelMembershipList","New-CHMChannelMembership","New-CHMCreateChannelMembership","Send-CHMChannelMessage")
    "UserType"=@("Get-CHMUserList","New-CHMUser","Send-CHMUserInvitation","Update-CHMUser")
}

_awsArgumentCompleterRegistration $CHM_Completers $CHM_map

$CHM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHM_SelectMap = @{
    "Select"=@("Add-CHMPhoneNumbersToVoiceConnector",
               "Add-CHMPhoneNumbersToVoiceConnectorGroup",
               "Add-CHMPhoneNumberToUser",
               "Add-CHMSigninDelegateGroupsToAccount",
               "New-CHMAttendeeBatch",
               "New-CHMCreateChannelMembership",
               "New-CHMRoomMembershipBatch",
               "Remove-CHMPhoneNumberBatch",
               "Enable-CHMUserSuspensionBatch",
               "Disable-CHMUserSuspensionBatch",
               "Update-CHMPhoneNumberBatch",
               "Update-CHMUserBatch",
               "New-CHMAccount",
               "New-CHMAppInstance",
               "New-CHMAppInstanceAdmin",
               "New-CHMAppInstanceUser",
               "New-CHMAttendee",
               "New-CHMBot",
               "New-CHMChannel",
               "New-CHMChannelBan",
               "New-CHMChannelMembership",
               "New-CHMChannelModerator",
               "New-CHMMediaCapturePipeline",
               "New-CHMMeeting",
               "New-CHMMeetingDialOut",
               "New-CHMMeetingWithAttendee",
               "New-CHMPhoneNumberOrder",
               "New-CHMProxySession",
               "New-CHMRoom",
               "New-CHMRoomMembership",
               "New-CHMSipMediaApplication",
               "New-CHMSipMediaApplicationCall",
               "New-CHMSipRule",
               "New-CHMUser",
               "New-CHMVoiceConnector",
               "New-CHMVoiceConnectorGroup",
               "Remove-CHMAccount",
               "Remove-CHMAppInstance",
               "Remove-CHMAppInstanceAdmin",
               "Remove-CHMAppInstanceStreamingConfiguration",
               "Remove-CHMAppInstanceUser",
               "Remove-CHMAttendee",
               "Remove-CHMChannel",
               "Remove-CHMChannelBan",
               "Remove-CHMChannelMembership",
               "Remove-CHMChannelMessage",
               "Remove-CHMChannelModerator",
               "Remove-CHMEventsConfiguration",
               "Remove-CHMMediaCapturePipeline",
               "Remove-CHMMeeting",
               "Remove-CHMPhoneNumber",
               "Remove-CHMProxySession",
               "Remove-CHMRoom",
               "Remove-CHMRoomMembership",
               "Remove-CHMSipMediaApplication",
               "Remove-CHMSipRule",
               "Remove-CHMVoiceConnector",
               "Remove-CHMVoiceConnectorEmergencyCallingConfiguration",
               "Remove-CHMVoiceConnectorGroup",
               "Remove-CHMVoiceConnectorOrigination",
               "Remove-CHMVoiceConnectorProxy",
               "Remove-CHMVoiceConnectorStreamingConfiguration",
               "Remove-CHMVoiceConnectorTermination",
               "Remove-CHMVoiceConnectorTerminationCredential",
               "Get-CHMAppInstance",
               "Get-CHMAppInstanceAdmin",
               "Get-CHMAppInstanceUser",
               "Get-CHMChannel",
               "Get-CHMChannelBan",
               "Get-CHMChannelMembership",
               "Get-CHMChannelMembershipForAppInstanceUser",
               "Get-CHMChannelModeratedByAppInstanceUser",
               "Get-CHMChannelModerator",
               "Remove-CHMPhoneNumberFromUser",
               "Remove-CHMPhoneNumbersFromVoiceConnector",
               "Remove-CHMPhoneNumbersFromVoiceConnectorGroup",
               "Remove-CHMSigninDelegateGroupsFromAccount",
               "Get-CHMAccount",
               "Get-CHMAccountSetting",
               "Get-CHMAppInstanceRetentionSetting",
               "Get-CHMAppInstanceStreamingConfiguration",
               "Get-CHMAttendee",
               "Get-CHMBot",
               "Get-CHMChannelMessage",
               "Get-CHMEventsConfiguration",
               "Get-CHMGlobalSetting",
               "Get-CHMMediaCapturePipeline",
               "Get-CHMMeeting",
               "Get-CHMMessagingSessionEndpoint",
               "Get-CHMPhoneNumber",
               "Get-CHMPhoneNumberOrder",
               "Get-CHMPhoneNumberSetting",
               "Get-CHMProxySession",
               "Get-CHMRetentionSetting",
               "Get-CHMRoom",
               "Get-CHMSipMediaApplication",
               "Get-CHMSipMediaApplicationLoggingConfiguration",
               "Get-CHMSipRule",
               "Get-CHMUser",
               "Get-CHMUserSetting",
               "Get-CHMVoiceConnector",
               "Get-CHMVoiceConnectorEmergencyCallingConfiguration",
               "Get-CHMVoiceConnectorGroup",
               "Get-CHMVoiceConnectorLoggingConfiguration",
               "Get-CHMVoiceConnectorOrigination",
               "Get-CHMVoiceConnectorProxy",
               "Get-CHMVoiceConnectorStreamingConfiguration",
               "Get-CHMVoiceConnectorTermination",
               "Get-CHMVoiceConnectorTerminationHealth",
               "Send-CHMUserInvitation",
               "Get-CHMAccountList",
               "Get-CHMAppInstanceAdminList",
               "Get-CHMAppInstanceList",
               "Get-CHMAppInstanceUserList",
               "Get-CHMAttendeeList",
               "Get-CHMAttendeeTagList",
               "Get-CHMBotList",
               "Get-CHMChannelBanList",
               "Get-CHMChannelMembershipList",
               "Get-CHMChannelMembershipsForAppInstanceUserList",
               "Get-CHMChannelMessageList",
               "Get-CHMChannelModeratorList",
               "Get-CHMChannelList",
               "Get-CHMChannelsModeratedByAppInstanceUserList",
               "Get-CHMMediaCapturePipelineList",
               "Get-CHMMeetingList",
               "Get-CHMMeetingTagList",
               "Get-CHMPhoneNumberOrderList",
               "Get-CHMPhoneNumberList",
               "Get-CHMProxySessionList",
               "Get-CHMRoomMembershipList",
               "Get-CHMRoomList",
               "Get-CHMSipMediaApplicationList",
               "Get-CHMSipRuleList",
               "Get-CHMSupportedPhoneNumberCountryList",
               "Get-CHMResourceTag",
               "Get-CHMUserList",
               "Get-CHMVoiceConnectorGroupList",
               "Get-CHMVoiceConnectorList",
               "Get-CHMVoiceConnectorTerminationCredentialList",
               "Invoke-CHMUserLogout",
               "Write-CHMAppInstanceRetentionSetting",
               "Write-CHMAppInstanceStreamingConfiguration",
               "Write-CHMEventsConfiguration",
               "Write-CHMRetentionSetting",
               "Write-CHMSipMediaApplicationLoggingConfiguration",
               "Write-CHMVoiceConnectorEmergencyCallingConfiguration",
               "Write-CHMVoiceConnectorLoggingConfiguration",
               "Write-CHMVoiceConnectorOrigination",
               "Write-CHMVoiceConnectorProxy",
               "Write-CHMVoiceConnectorStreamingConfiguration",
               "Write-CHMVoiceConnectorTermination",
               "Write-CHMVoiceConnectorTerminationCredential",
               "Hide-CHMChannelMessage",
               "Hide-CHMConversationMessage",
               "Hide-CHMRoomMessage",
               "Update-CHMSecurityToken",
               "Reset-CHMPersonalPIN",
               "Restore-CHMPhoneNumber",
               "Search-CHMAvailablePhoneNumber",
               "Send-CHMChannelMessage",
               "Start-CHMMeetingTranscription",
               "Stop-CHMMeetingTranscription",
               "Add-CHMAttendee",
               "Add-CHMMeeting",
               "Add-CHMResourceTag",
               "Remove-CHMAttendeeTag",
               "Remove-CHMMeetingTag",
               "Remove-CHMResourceTag",
               "Update-CHMAccount",
               "Update-CHMAccountSetting",
               "Update-CHMAppInstance",
               "Update-CHMAppInstanceUser",
               "Update-CHMBot",
               "Update-CHMChannel",
               "Update-CHMChannelMessage",
               "Update-CHMChannelReadMarker",
               "Update-CHMGlobalSetting",
               "Update-CHMPhoneNumber",
               "Update-CHMPhoneNumberSetting",
               "Update-CHMProxySession",
               "Update-CHMRoom",
               "Update-CHMRoomMembership",
               "Update-CHMSipMediaApplication",
               "Update-CHMSipMediaApplicationCall",
               "Update-CHMSipRule",
               "Update-CHMUser",
               "Update-CHMUserSetting",
               "Update-CHMVoiceConnector",
               "Update-CHMVoiceConnectorGroup",
               "Confirm-CHME911Address")
}

_awsArgumentCompleterRegistration $CHM_SelectCompleters $CHM_SelectMap
# Argument completions for service Amazon Chime SDK Identity


$CHMID_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ChimeSDKIdentity.AllowMessages
        {
            ($_ -eq "Register-CHMIDAppInstanceUserEndpoint/AllowMessages") -Or
            ($_ -eq "Update-CHMIDAppInstanceUserEndpoint/AllowMessages")
        }
        {
            $v = "ALL","NONE"
            break
        }

        # Amazon.ChimeSDKIdentity.AppInstanceUserEndpointType
        "Register-CHMIDAppInstanceUserEndpoint/Type"
        {
            $v = "APNS","APNS_SANDBOX","GCM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMID_map = @{
    "AllowMessages"=@("Register-CHMIDAppInstanceUserEndpoint","Update-CHMIDAppInstanceUserEndpoint")
    "Type"=@("Register-CHMIDAppInstanceUserEndpoint")
}

_awsArgumentCompleterRegistration $CHMID_Completers $CHMID_map

$CHMID_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHMID.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMID_SelectMap = @{
    "Select"=@("New-CHMIDAppInstance",
               "New-CHMIDAppInstanceAdmin",
               "New-CHMIDAppInstanceUser",
               "Remove-CHMIDAppInstance",
               "Remove-CHMIDAppInstanceAdmin",
               "Remove-CHMIDAppInstanceUser",
               "Unregister-CHMIDAppInstanceUserEndpoint",
               "Get-CHMIDAppInstance",
               "Get-CHMIDAppInstanceAdmin",
               "Get-CHMIDAppInstanceUser",
               "Get-CHMIDAppInstanceUserEndpoint",
               "Get-CHMIDAppInstanceRetentionSetting",
               "Get-CHMIDAppInstanceAdminList",
               "Get-CHMIDAppInstanceList",
               "Get-CHMIDAppInstanceUserEndpointList",
               "Get-CHMIDAppInstanceUserList",
               "Get-CHMIDResourceTag",
               "Write-CHMIDAppInstanceRetentionSetting",
               "Register-CHMIDAppInstanceUserEndpoint",
               "Add-CHMIDResourceTag",
               "Remove-CHMIDResourceTag",
               "Update-CHMIDAppInstance",
               "Update-CHMIDAppInstanceUser",
               "Update-CHMIDAppInstanceUserEndpoint")
}

_awsArgumentCompleterRegistration $CHMID_SelectCompleters $CHMID_SelectMap
# Argument completions for service Amazon Chime SDK Media Pipelines


$CHMMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ChimeSDKMediaPipelines.ArtifactsState
        {
            ($_ -eq "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_State") -Or
            ($_ -eq "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_State")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.AudioMuxType
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Audio_MuxType"
        {
            $v = "AudioOnly","AudioWithActiveSpeakerVideo","AudioWithCompositedVideo"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.ContentMuxType
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_MuxType"
        {
            $v = "ContentOnly"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.ContentShareLayoutOption
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_GridViewConfiguration_ContentShareLayout"
        {
            $v = "Horizontal","PresenterOnly","Vertical"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.LayoutOption
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_Layout"
        {
            $v = "GridView"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.MediaPipelineSinkType
        "New-CHMMPMediaCapturePipeline/SinkType"
        {
            $v = "S3Bucket"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.MediaPipelineSourceType
        "New-CHMMPMediaCapturePipeline/SourceType"
        {
            $v = "ChimeSdkMeeting"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.PresenterPosition
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_GridViewConfiguration_PresenterOnlyConfiguration_PresenterPosition"
        {
            $v = "BottomLeft","BottomRight","TopLeft","TopRight"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.ResolutionOption
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_Resolution"
        {
            $v = "FHD","HD"
            break
        }

        # Amazon.ChimeSDKMediaPipelines.VideoMuxType
        "New-CHMMPMediaCapturePipeline/ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_MuxType"
        {
            $v = "VideoOnly"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMMP_map = @{
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Audio_MuxType"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_GridViewConfiguration_ContentShareLayout"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_GridViewConfiguration_PresenterOnlyConfiguration_PresenterPosition"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_Layout"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_CompositedVideo_Resolution"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_MuxType"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Content_State"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_MuxType"=@("New-CHMMPMediaCapturePipeline")
    "ChimeSdkMeetingConfiguration_ArtifactsConfiguration_Video_State"=@("New-CHMMPMediaCapturePipeline")
    "SinkType"=@("New-CHMMPMediaCapturePipeline")
    "SourceType"=@("New-CHMMPMediaCapturePipeline")
}

_awsArgumentCompleterRegistration $CHMMP_Completers $CHMMP_map

$CHMMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHMMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMMP_SelectMap = @{
    "Select"=@("New-CHMMPMediaCapturePipeline",
               "New-CHMMPMediaConcatenationPipeline",
               "New-CHMMPMediaLiveConnectorPipeline",
               "Remove-CHMMPMediaCapturePipeline",
               "Remove-CHMMPMediaPipeline",
               "Get-CHMMPMediaCapturePipeline",
               "Get-CHMMPMediaPipeline",
               "Get-CHMMPMediaCapturePipelineList",
               "Get-CHMMPMediaPipelineList",
               "Get-CHMMPResourceTag",
               "Add-CHMMPResourceTag",
               "Remove-CHMMPResourceTag")
}

_awsArgumentCompleterRegistration $CHMMP_SelectCompleters $CHMMP_SelectMap
# Argument completions for service Amazon Chime SDK Meetings


$CHMTG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ChimeSDKMeetings.MediaCapabilities
        {
            ($_ -eq "New-CHMTGAttendee/Capabilities_Audio") -Or
            ($_ -eq "Update-CHMTGAttendeeCapability/Capabilities_Audio") -Or
            ($_ -eq "Update-CHMTGUpdateAttendeeCapabilitiesExcept/Capabilities_Audio") -Or
            ($_ -eq "New-CHMTGAttendee/Capabilities_Content") -Or
            ($_ -eq "Update-CHMTGAttendeeCapability/Capabilities_Content") -Or
            ($_ -eq "Update-CHMTGUpdateAttendeeCapabilitiesExcept/Capabilities_Content") -Or
            ($_ -eq "New-CHMTGAttendee/Capabilities_Video") -Or
            ($_ -eq "Update-CHMTGAttendeeCapability/Capabilities_Video") -Or
            ($_ -eq "Update-CHMTGUpdateAttendeeCapabilitiesExcept/Capabilities_Video")
        }
        {
            $v = "None","Receive","Send","SendReceive"
            break
        }

        # Amazon.ChimeSDKMeetings.MeetingFeatureStatus
        {
            ($_ -eq "New-CHMTGMeeting/MeetingFeatures_Audio_EchoReduction") -Or
            ($_ -eq "New-CHMTGMeetingWithAttendee/MeetingFeatures_Audio_EchoReduction")
        }
        {
            $v = "AVAILABLE","UNAVAILABLE"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeContentIdentificationType
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_ContentIdentificationType"
        {
            $v = "PII"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeContentRedactionType
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_ContentRedactionType"
        {
            $v = "PII"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeLanguageCode
        {
            ($_ -eq "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_LanguageCode") -Or
            ($_ -eq "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_PreferredLanguage")
        }
        {
            $v = "de-DE","en-AU","en-GB","en-US","es-US","fr-CA","fr-FR","it-IT","ja-JP","ko-KR","pt-BR","zh-CN"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeMedicalContentIdentificationType
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_ContentIdentificationType"
        {
            $v = "PHI"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeMedicalLanguageCode
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_LanguageCode"
        {
            $v = "en-US"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeMedicalRegion
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Region"
        {
            $v = "ap-southeast-2","auto","ca-central-1","eu-west-1","us-east-1","us-east-2","us-west-2"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeMedicalSpecialty
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Specialty"
        {
            $v = "CARDIOLOGY","NEUROLOGY","ONCOLOGY","PRIMARYCARE","RADIOLOGY","UROLOGY"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeMedicalType
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeMedicalSettings_Type"
        {
            $v = "CONVERSATION","DICTATION"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribePartialResultsStability
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_PartialResultsStability"
        {
            $v = "high","low","medium"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeRegion
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_Region"
        {
            $v = "ap-northeast-1","ap-northeast-2","ap-southeast-2","auto","ca-central-1","eu-central-1","eu-west-1","eu-west-2","sa-east-1","us-east-1","us-east-2","us-gov-west-1","us-west-2"
            break
        }

        # Amazon.ChimeSDKMeetings.TranscribeVocabularyFilterMethod
        "Start-CHMTGMeetingTranscription/TranscriptionConfiguration_EngineTranscribeSettings_VocabularyFilterMethod"
        {
            $v = "mask","remove","tag"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMTG_map = @{
    "Capabilities_Audio"=@("New-CHMTGAttendee","Update-CHMTGAttendeeCapability","Update-CHMTGUpdateAttendeeCapabilitiesExcept")
    "Capabilities_Content"=@("New-CHMTGAttendee","Update-CHMTGAttendeeCapability","Update-CHMTGUpdateAttendeeCapabilitiesExcept")
    "Capabilities_Video"=@("New-CHMTGAttendee","Update-CHMTGAttendeeCapability","Update-CHMTGUpdateAttendeeCapabilitiesExcept")
    "MeetingFeatures_Audio_EchoReduction"=@("New-CHMTGMeeting","New-CHMTGMeetingWithAttendee")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_ContentIdentificationType"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_LanguageCode"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Region"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Specialty"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeMedicalSettings_Type"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_ContentIdentificationType"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_ContentRedactionType"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_LanguageCode"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_PartialResultsStability"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_PreferredLanguage"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_Region"=@("Start-CHMTGMeetingTranscription")
    "TranscriptionConfiguration_EngineTranscribeSettings_VocabularyFilterMethod"=@("Start-CHMTGMeetingTranscription")
}

_awsArgumentCompleterRegistration $CHMTG_Completers $CHMTG_map

$CHMTG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHMTG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMTG_SelectMap = @{
    "Select"=@("New-CHMTGAttendeeBatch",
               "Update-CHMTGUpdateAttendeeCapabilitiesExcept",
               "New-CHMTGAttendee",
               "New-CHMTGMeeting",
               "New-CHMTGMeetingWithAttendee",
               "Remove-CHMTGAttendee",
               "Remove-CHMTGMeeting",
               "Get-CHMTGAttendee",
               "Get-CHMTGMeeting",
               "Get-CHMTGAttendeeList",
               "Get-CHMTGResourceTag",
               "Start-CHMTGMeetingTranscription",
               "Stop-CHMTGMeetingTranscription",
               "Add-CHMTGResourceTag",
               "Remove-CHMTGResourceTag",
               "Update-CHMTGAttendeeCapability")
}

_awsArgumentCompleterRegistration $CHMTG_SelectCompleters $CHMTG_SelectMap
# Argument completions for service Amazon Chime SDK Messaging


$CHMMG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ChimeSDKMessaging.AllowNotifications
        "Write-CHMMGChannelMembershipPreference/Preferences_PushNotifications_AllowNotifications"
        {
            $v = "ALL","FILTERED","NONE"
            break
        }

        # Amazon.ChimeSDKMessaging.ChannelMembershipType
        {
            ($_ -eq "Get-CHMMGChannelMembershipList/Type") -Or
            ($_ -eq "New-CHMMGChannelMembership/Type") -Or
            ($_ -eq "New-CHMMGCreateChannelMembership/Type")
        }
        {
            $v = "DEFAULT","HIDDEN"
            break
        }

        # Amazon.ChimeSDKMessaging.ChannelMessagePersistenceType
        "Send-CHMMGChannelMessage/Persistence"
        {
            $v = "NON_PERSISTENT","PERSISTENT"
            break
        }

        # Amazon.ChimeSDKMessaging.ChannelMessageType
        "Send-CHMMGChannelMessage/Type"
        {
            $v = "CONTROL","STANDARD"
            break
        }

        # Amazon.ChimeSDKMessaging.ChannelMode
        {
            ($_ -eq "New-CHMMGChannel/Mode") -Or
            ($_ -eq "Update-CHMMGChannel/Mode")
        }
        {
            $v = "RESTRICTED","UNRESTRICTED"
            break
        }

        # Amazon.ChimeSDKMessaging.ChannelPrivacy
        {
            ($_ -eq "Get-CHMMGChannelList/Privacy") -Or
            ($_ -eq "New-CHMMGChannel/Privacy")
        }
        {
            $v = "PRIVATE","PUBLIC"
            break
        }

        # Amazon.ChimeSDKMessaging.PushNotificationType
        {
            ($_ -eq "Send-CHMMGChannelFlowCallback/ChannelMessage_PushNotification_Type") -Or
            ($_ -eq "Send-CHMMGChannelMessage/PushNotification_Type")
        }
        {
            $v = "DEFAULT","VOIP"
            break
        }

        # Amazon.ChimeSDKMessaging.SortOrder
        "Get-CHMMGChannelMessageList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMMG_map = @{
    "ChannelMessage_PushNotification_Type"=@("Send-CHMMGChannelFlowCallback")
    "Mode"=@("New-CHMMGChannel","Update-CHMMGChannel")
    "Persistence"=@("Send-CHMMGChannelMessage")
    "Preferences_PushNotifications_AllowNotifications"=@("Write-CHMMGChannelMembershipPreference")
    "Privacy"=@("Get-CHMMGChannelList","New-CHMMGChannel")
    "PushNotification_Type"=@("Send-CHMMGChannelMessage")
    "SortOrder"=@("Get-CHMMGChannelMessageList")
    "Type"=@("Get-CHMMGChannelMembershipList","New-CHMMGChannelMembership","New-CHMMGCreateChannelMembership","Send-CHMMGChannelMessage")
}

_awsArgumentCompleterRegistration $CHMMG_Completers $CHMMG_map

$CHMMG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHMMG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHMMG_SelectMap = @{
    "Select"=@("Register-CHMMGChannelFlow",
               "New-CHMMGCreateChannelMembership",
               "Send-CHMMGChannelFlowCallback",
               "New-CHMMGChannel",
               "New-CHMMGChannelBan",
               "New-CHMMGChannelFlow",
               "New-CHMMGChannelMembership",
               "New-CHMMGChannelModerator",
               "Remove-CHMMGChannel",
               "Remove-CHMMGChannelBan",
               "Remove-CHMMGChannelFlow",
               "Remove-CHMMGChannelMembership",
               "Remove-CHMMGChannelMessage",
               "Remove-CHMMGChannelModerator",
               "Get-CHMMGChannel",
               "Get-CHMMGChannelBan",
               "Get-CHMMGChannelFlow",
               "Get-CHMMGChannelMembership",
               "Get-CHMMGChannelMembershipForAppInstanceUser",
               "Get-CHMMGChannelModeratedByAppInstanceUser",
               "Get-CHMMGChannelModerator",
               "Unregister-CHMMGChannelFlow",
               "Get-CHMMGChannelMembershipPreference",
               "Get-CHMMGChannelMessage",
               "Get-CHMMGChannelMessageStatus",
               "Get-CHMMGMessagingSessionEndpoint",
               "Get-CHMMGChannelBanList",
               "Get-CHMMGChannelFlowList",
               "Get-CHMMGChannelMembershipList",
               "Get-CHMMGChannelMembershipsForAppInstanceUserList",
               "Get-CHMMGChannelMessageList",
               "Get-CHMMGChannelModeratorList",
               "Get-CHMMGChannelList",
               "Get-CHMMGChannelsAssociatedWithChannelFlowList",
               "Get-CHMMGChannelsModeratedByAppInstanceUserList",
               "Get-CHMMGSubChannelList",
               "Get-CHMMGResourceTag",
               "Write-CHMMGChannelMembershipPreference",
               "Hide-CHMMGChannelMessage",
               "Search-CHMMGChannel",
               "Send-CHMMGChannelMessage",
               "Add-CHMMGResourceTag",
               "Remove-CHMMGResourceTag",
               "Update-CHMMGChannel",
               "Update-CHMMGChannelFlow",
               "Update-CHMMGChannelMessage",
               "Update-CHMMGChannelReadMarker")
}

_awsArgumentCompleterRegistration $CHMMG_SelectCompleters $CHMMG_SelectMap
# Argument completions for service AWS Cloud9


$C9_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Cloud9.ConnectionType
        "New-C9EnvironmentEC2/ConnectionType"
        {
            $v = "CONNECT_SSH","CONNECT_SSM"
            break
        }

        # Amazon.Cloud9.ManagedCredentialsAction
        "Update-C9Environment/ManagedCredentialsAction"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.Cloud9.MemberPermissions
        {
            ($_ -eq "New-C9EnvironmentMembership/Permissions") -Or
            ($_ -eq "Update-C9EnvironmentMembership/Permissions")
        }
        {
            $v = "read-only","read-write"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$C9_map = @{
    "ConnectionType"=@("New-C9EnvironmentEC2")
    "ManagedCredentialsAction"=@("Update-C9Environment")
    "Permissions"=@("New-C9EnvironmentMembership","Update-C9EnvironmentMembership")
}

_awsArgumentCompleterRegistration $C9_Completers $C9_map

$C9_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.C9.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$C9_SelectMap = @{
    "Select"=@("New-C9EnvironmentEC2",
               "New-C9EnvironmentMembership",
               "Remove-C9Environment",
               "Remove-C9EnvironmentMembership",
               "Get-C9EnvironmentMembershipList",
               "Get-C9EnvironmentData",
               "Get-C9EnvironmentStatus",
               "Get-C9EnvironmentList",
               "Get-C9ResourceTag",
               "Add-C9ResourceTag",
               "Remove-C9ResourceTag",
               "Update-C9Environment",
               "Update-C9EnvironmentMembership")
}

_awsArgumentCompleterRegistration $C9_SelectCompleters $C9_SelectMap
# Argument completions for service AWS Cloud Control API


$CCA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CCA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCA_SelectMap = @{
    "Select"=@("Stop-CCAResourceRequest",
               "New-CCAResource",
               "Remove-CCAResource",
               "Get-CCAResource",
               "Get-CCAResourceRequestStatus",
               "Get-CCAResourceRequestList",
               "Get-CCAResourceList",
               "Update-CCAResource")
}

_awsArgumentCompleterRegistration $CCA_SelectCompleters $CCA_SelectMap
# Argument completions for service Amazon Cloud Directory


$CDIR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudDirectory.ConsistencyLevel
        {
            ($_ -eq "Get-CDIRIncomingTypedLink/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRIndex/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRLinkAttribute/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectAttribute/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectAttributeList/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectChild/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectIndex/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectInformation/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectParent/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectPolicy/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIROutgoingTypedLink/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRPolicyAttachment/ConsistencyLevel") -Or
            ($_ -eq "Read-CDIRDirectoryBatch/ConsistencyLevel")
        }
        {
            $v = "EVENTUAL","SERIALIZABLE"
            break
        }

        # Amazon.CloudDirectory.DirectoryState
        "Get-CDIRDirectory/State"
        {
            $v = "DELETED","DISABLED","ENABLED"
            break
        }

        # Amazon.CloudDirectory.FacetStyle
        "New-CDIRFacet/FacetStyle"
        {
            $v = "DYNAMIC","STATIC"
            break
        }

        # Amazon.CloudDirectory.ObjectType
        {
            ($_ -eq "New-CDIRFacet/ObjectType") -Or
            ($_ -eq "Update-CDIRFacet/ObjectType")
        }
        {
            $v = "INDEX","LEAF_NODE","NODE","POLICY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CDIR_map = @{
    "ConsistencyLevel"=@("Get-CDIRIncomingTypedLink","Get-CDIRIndex","Get-CDIRLinkAttribute","Get-CDIRObjectAttribute","Get-CDIRObjectAttributeList","Get-CDIRObjectChild","Get-CDIRObjectIndex","Get-CDIRObjectInformation","Get-CDIRObjectParent","Get-CDIRObjectPolicy","Get-CDIROutgoingTypedLink","Get-CDIRPolicyAttachment","Read-CDIRDirectoryBatch")
    "FacetStyle"=@("New-CDIRFacet")
    "ObjectType"=@("New-CDIRFacet","Update-CDIRFacet")
    "State"=@("Get-CDIRDirectory")
}

_awsArgumentCompleterRegistration $CDIR_Completers $CDIR_map

$CDIR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CDIR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CDIR_SelectMap = @{
    "Select"=@("Add-CDIRFacetToObject",
               "Add-CDIRSchema",
               "Connect-CDIRObject",
               "Mount-CDIRPolicy",
               "Mount-CDIRObjectToIndex",
               "Mount-CDIRTypedLink",
               "Read-CDIRDirectoryBatch",
               "Write-CDIRDirectoryBatch",
               "New-CDIRDirectory",
               "New-CDIRFacet",
               "New-CDIRIndex",
               "New-CDIRDirectoryObject",
               "New-CDIRSchema",
               "New-CDIRTypedLinkFacet",
               "Remove-CDIRDirectory",
               "Remove-CDIRFacet",
               "Remove-CDIRDirectoryObject",
               "Remove-CDIRSchema",
               "Remove-CDIRTypedLinkFacet",
               "Dismount-CDIRObjectFromIndex",
               "Disconnect-CDIRObject",
               "Dismount-CDIRPolicyFromObject",
               "Dismount-CDIRTypedLink",
               "Disable-CDIRDirectory",
               "Enable-CDIRDirectory",
               "Get-CDIRAppliedSchemaVersion",
               "Get-CDIRDirectoryMetadata",
               "Get-CDIRFacet",
               "Get-CDIRLinkAttribute",
               "Get-CDIRObjectAttribute",
               "Get-CDIRObjectInformation",
               "Get-CDIRSchemaAsJson",
               "Get-CDIRTypedLinkFacetInformation",
               "Get-CDIRAppliedSchemaArn",
               "Get-CDIRObjectIndex",
               "Get-CDIRDevelopmentSchemaArn",
               "Get-CDIRDirectory",
               "Get-CDIRFacetAttribute",
               "Get-CDIRFacetName",
               "Get-CDIRIncomingTypedLink",
               "Get-CDIRIndex",
               "Get-CDIRManagedSchemaArn",
               "Get-CDIRObjectAttributeList",
               "Get-CDIRObjectChild",
               "Get-CDIRObjectParentPath",
               "Get-CDIRObjectParent",
               "Get-CDIRObjectPolicy",
               "Get-CDIROutgoingTypedLink",
               "Get-CDIRPolicyAttachment",
               "Get-CDIRPublishedSchemaArn",
               "Get-CDIRResourceTag",
               "Get-CDIRTypedLinkFacetAttribute",
               "Get-CDIRTypedLinkFacetName",
               "Get-CDIRDirectoryPolicy",
               "Publish-CDIRSchema",
               "Write-CDIRSchemaFromJson",
               "Remove-CDIRFacetFromObject",
               "Add-CDIRResourceTag",
               "Remove-CDIRResourceTag",
               "Update-CDIRFacet",
               "Update-CDIRLinkAttribute",
               "Update-CDIRObjectAttribute",
               "Update-CDIRSchema",
               "Update-CDIRTypedLinkFacet",
               "Update-CDIRAppliedSchema",
               "Update-CDIRPublishedSchema")
}

_awsArgumentCompleterRegistration $CDIR_SelectCompleters $CDIR_SelectMap
# Argument completions for service AWS CloudFormation


$CFN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudFormation.AccountFilterType
        {
            ($_ -eq "New-CFNStackInstance/DeploymentTargets_AccountFilterType") -Or
            ($_ -eq "Remove-CFNStackInstance/DeploymentTargets_AccountFilterType") -Or
            ($_ -eq "Update-CFNStackInstance/DeploymentTargets_AccountFilterType") -Or
            ($_ -eq "Update-CFNStackSet/DeploymentTargets_AccountFilterType")
        }
        {
            $v = "DIFFERENCE","INTERSECTION","NONE","UNION"
            break
        }

        # Amazon.CloudFormation.CallAs
        {
            ($_ -eq "Get-CFNStackInstance/CallAs") -Or
            ($_ -eq "Get-CFNStackInstanceList/CallAs") -Or
            ($_ -eq "Get-CFNStackSet/CallAs") -Or
            ($_ -eq "Get-CFNStackSetList/CallAs") -Or
            ($_ -eq "Get-CFNStackSetOperation/CallAs") -Or
            ($_ -eq "Get-CFNStackSetOperationList/CallAs") -Or
            ($_ -eq "Get-CFNStackSetOperationResultList/CallAs") -Or
            ($_ -eq "Get-CFNTemplateSummary/CallAs") -Or
            ($_ -eq "Import-CFNStacksToStackSet/CallAs") -Or
            ($_ -eq "New-CFNStackInstance/CallAs") -Or
            ($_ -eq "New-CFNStackSet/CallAs") -Or
            ($_ -eq "Remove-CFNStackInstance/CallAs") -Or
            ($_ -eq "Remove-CFNStackSet/CallAs") -Or
            ($_ -eq "Start-CFNStackSetDriftDetection/CallAs") -Or
            ($_ -eq "Stop-CFNStackSetOperation/CallAs") -Or
            ($_ -eq "Update-CFNStackInstance/CallAs") -Or
            ($_ -eq "Update-CFNStackSet/CallAs")
        }
        {
            $v = "DELEGATED_ADMIN","SELF"
            break
        }

        # Amazon.CloudFormation.Category
        "Get-CFNTypeList/Filters_Category"
        {
            $v = "ACTIVATED","AWS_TYPES","REGISTERED","THIRD_PARTY"
            break
        }

        # Amazon.CloudFormation.ChangeSetType
        "New-CFNChangeSet/ChangeSetType"
        {
            $v = "CREATE","IMPORT","UPDATE"
            break
        }

        # Amazon.CloudFormation.DeprecatedStatus
        {
            ($_ -eq "Get-CFNTypeList/DeprecatedStatus") -Or
            ($_ -eq "Get-CFNTypeVersion/DeprecatedStatus")
        }
        {
            $v = "DEPRECATED","LIVE"
            break
        }

        # Amazon.CloudFormation.HandlerErrorCode
        "Write-CFNHandlerProgress/ErrorCode"
        {
            $v = "AccessDenied","AlreadyExists","GeneralServiceException","HandlerInternalFailure","InternalFailure","InvalidCredentials","InvalidRequest","InvalidTypeConfiguration","NetworkFailure","NonCompliant","NotFound","NotStabilized","NotUpdatable","ResourceConflict","ServiceInternalError","ServiceLimitExceeded","Throttling","Unknown","UnsupportedTarget"
            break
        }

        # Amazon.CloudFormation.OnFailure
        "New-CFNStack/OnFailure"
        {
            $v = "DELETE","DO_NOTHING","ROLLBACK"
            break
        }

        # Amazon.CloudFormation.OperationStatus
        {
            ($_ -eq "Write-CFNHandlerProgress/CurrentOperationStatus") -Or
            ($_ -eq "Write-CFNHandlerProgress/OperationStatus")
        }
        {
            $v = "FAILED","IN_PROGRESS","PENDING","SUCCESS"
            break
        }

        # Amazon.CloudFormation.PermissionModels
        {
            ($_ -eq "New-CFNStackSet/PermissionModel") -Or
            ($_ -eq "Update-CFNStackSet/PermissionModel")
        }
        {
            $v = "SELF_MANAGED","SERVICE_MANAGED"
            break
        }

        # Amazon.CloudFormation.ProvisioningType
        "Get-CFNTypeList/ProvisioningType"
        {
            $v = "FULLY_MUTABLE","IMMUTABLE","NON_PROVISIONABLE"
            break
        }

        # Amazon.CloudFormation.RegistrationStatus
        "Get-CFNTypeRegistrationList/RegistrationStatusFilter"
        {
            $v = "COMPLETE","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.CloudFormation.RegistryType
        {
            ($_ -eq "Get-CFNType/Type") -Or
            ($_ -eq "Get-CFNTypeList/Type") -Or
            ($_ -eq "Get-CFNTypeRegistrationList/Type") -Or
            ($_ -eq "Get-CFNTypeVersion/Type") -Or
            ($_ -eq "Register-CFNType/Type") -Or
            ($_ -eq "Set-CFNTypeDefaultVersion/Type") -Or
            ($_ -eq "Unregister-CFNType/Type")
        }
        {
            $v = "HOOK","MODULE","RESOURCE"
            break
        }

        # Amazon.CloudFormation.ResourceSignalStatus
        "Send-CFNResourceSignal/Status"
        {
            $v = "FAILURE","SUCCESS"
            break
        }

        # Amazon.CloudFormation.StackSetStatus
        "Get-CFNStackSetList/Status"
        {
            $v = "ACTIVE","DELETED"
            break
        }

        # Amazon.CloudFormation.StackStatus
        {
            ($_ -eq "Test-CFNStack/Status") -Or
            ($_ -eq "Wait-CFNStack/Status")
        }
        {
            $v = "CREATE_COMPLETE","CREATE_FAILED","CREATE_IN_PROGRESS","DELETE_COMPLETE","DELETE_FAILED","DELETE_IN_PROGRESS","IMPORT_COMPLETE","IMPORT_IN_PROGRESS","IMPORT_ROLLBACK_COMPLETE","IMPORT_ROLLBACK_FAILED","IMPORT_ROLLBACK_IN_PROGRESS","REVIEW_IN_PROGRESS","ROLLBACK_COMPLETE","ROLLBACK_FAILED","ROLLBACK_IN_PROGRESS","UPDATE_COMPLETE","UPDATE_COMPLETE_CLEANUP_IN_PROGRESS","UPDATE_FAILED","UPDATE_IN_PROGRESS","UPDATE_ROLLBACK_COMPLETE","UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS","UPDATE_ROLLBACK_FAILED","UPDATE_ROLLBACK_IN_PROGRESS"
            break
        }

        # Amazon.CloudFormation.TemplateStage
        "Get-CFNTemplate/TemplateStage"
        {
            $v = "Original","Processed"
            break
        }

        # Amazon.CloudFormation.ThirdPartyType
        {
            ($_ -eq "Disable-CFNType/Type") -Or
            ($_ -eq "Enable-CFNType/Type") -Or
            ($_ -eq "Publish-CFNType/Type") -Or
            ($_ -eq "Set-CFNTypeConfiguration/Type") -Or
            ($_ -eq "Test-CFNType/Type")
        }
        {
            $v = "HOOK","MODULE","RESOURCE"
            break
        }

        # Amazon.CloudFormation.VersionBump
        "Enable-CFNType/VersionBump"
        {
            $v = "MAJOR","MINOR"
            break
        }

        # Amazon.CloudFormation.Visibility
        "Get-CFNTypeList/Visibility"
        {
            $v = "PRIVATE","PUBLIC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFN_map = @{
    "CallAs"=@("Get-CFNStackInstance","Get-CFNStackInstanceList","Get-CFNStackSet","Get-CFNStackSetList","Get-CFNStackSetOperation","Get-CFNStackSetOperationList","Get-CFNStackSetOperationResultList","Get-CFNTemplateSummary","Import-CFNStacksToStackSet","New-CFNStackInstance","New-CFNStackSet","Remove-CFNStackInstance","Remove-CFNStackSet","Start-CFNStackSetDriftDetection","Stop-CFNStackSetOperation","Update-CFNStackInstance","Update-CFNStackSet")
    "ChangeSetType"=@("New-CFNChangeSet")
    "CurrentOperationStatus"=@("Write-CFNHandlerProgress")
    "DeploymentTargets_AccountFilterType"=@("New-CFNStackInstance","Remove-CFNStackInstance","Update-CFNStackInstance","Update-CFNStackSet")
    "DeprecatedStatus"=@("Get-CFNTypeList","Get-CFNTypeVersion")
    "ErrorCode"=@("Write-CFNHandlerProgress")
    "Filters_Category"=@("Get-CFNTypeList")
    "OnFailure"=@("New-CFNStack")
    "OperationStatus"=@("Write-CFNHandlerProgress")
    "PermissionModel"=@("New-CFNStackSet","Update-CFNStackSet")
    "ProvisioningType"=@("Get-CFNTypeList")
    "RegistrationStatusFilter"=@("Get-CFNTypeRegistrationList")
    "Status"=@("Get-CFNStackSetList","Send-CFNResourceSignal","Test-CFNStack","Wait-CFNStack")
    "TemplateStage"=@("Get-CFNTemplate")
    "Type"=@("Disable-CFNType","Enable-CFNType","Get-CFNType","Get-CFNTypeList","Get-CFNTypeRegistrationList","Get-CFNTypeVersion","Publish-CFNType","Register-CFNType","Set-CFNTypeConfiguration","Set-CFNTypeDefaultVersion","Test-CFNType","Unregister-CFNType")
    "VersionBump"=@("Enable-CFNType")
    "Visibility"=@("Get-CFNTypeList")
}

_awsArgumentCompleterRegistration $CFN_Completers $CFN_map

$CFN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CFN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFN_SelectMap = @{
    "Select"=@("Enable-CFNType",
               "Get-CFNDescribeTypeConfiguration",
               "Stop-CFNUpdateStack",
               "Resume-CFNUpdateRollback",
               "New-CFNChangeSet",
               "New-CFNStack",
               "New-CFNStackInstance",
               "New-CFNStackSet",
               "Disable-CFNType",
               "Remove-CFNChangeSet",
               "Remove-CFNStack",
               "Remove-CFNStackInstance",
               "Remove-CFNStackSet",
               "Unregister-CFNType",
               "Get-CFNAccountLimit",
               "Get-CFNChangeSet",
               "Get-CFNChangeSetHook",
               "Get-CFNPublisher",
               "Get-CFNStackDriftDetectionStatus",
               "Get-CFNStackEvent",
               "Get-CFNStackInstance",
               "Get-CFNStackResource",
               "Get-CFNDetectedStackResourceDrift",
               "Get-CFNStackResourceList",
               "Get-CFNStack",
               "Get-CFNStackSet",
               "Get-CFNStackSetOperation",
               "Get-CFNType",
               "Get-CFNTypeRegistration",
               "Start-CFNStackDriftDetection",
               "Get-CFNStackResourceDrift",
               "Start-CFNStackSetDriftDetection",
               "Measure-CFNTemplateCost",
               "Start-CFNChangeSet",
               "Get-CFNStackPolicy",
               "Get-CFNTemplate",
               "Get-CFNTemplateSummary",
               "Import-CFNStacksToStackSet",
               "Get-CFNChangeSetList",
               "Get-CFNExport",
               "Get-CFNImportList",
               "Get-CFNStackInstanceList",
               "Get-CFNStackResourceSummary",
               "Get-CFNStackSummary",
               "Get-CFNStackSetOperationResultList",
               "Get-CFNStackSetOperationList",
               "Get-CFNStackSetList",
               "Get-CFNTypeRegistrationList",
               "Get-CFNTypeList",
               "Get-CFNTypeVersion",
               "Publish-CFNType",
               "Write-CFNHandlerProgress",
               "Register-CFNPublisher",
               "Register-CFNType",
               "Undo-CFNStack",
               "Set-CFNStackPolicy",
               "Set-CFNTypeConfiguration",
               "Set-CFNTypeDefaultVersion",
               "Send-CFNResourceSignal",
               "Stop-CFNStackSetOperation",
               "Test-CFNType",
               "Update-CFNStack",
               "Update-CFNStackInstance",
               "Update-CFNStackSet",
               "Update-CFNTerminationProtection",
               "Test-CFNTemplate",
               "Test-CFNStack",
               "Wait-CFNStack")
}

_awsArgumentCompleterRegistration $CFN_SelectCompleters $CFN_SelectMap
# Argument completions for service Amazon CloudFront


$CF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudFront.CachePolicyCookieBehavior
        {
            ($_ -eq "New-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_CookiesConfig_CookieBehavior") -Or
            ($_ -eq "Update-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_CookiesConfig_CookieBehavior")
        }
        {
            $v = "all","allExcept","none","whitelist"
            break
        }

        # Amazon.CloudFront.CachePolicyHeaderBehavior
        {
            ($_ -eq "New-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_HeadersConfig_HeaderBehavior") -Or
            ($_ -eq "Update-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_HeadersConfig_HeaderBehavior")
        }
        {
            $v = "none","whitelist"
            break
        }

        # Amazon.CloudFront.CachePolicyQueryStringBehavior
        {
            ($_ -eq "New-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_QueryStringsConfig_QueryStringBehavior") -Or
            ($_ -eq "Update-CFCachePolicy/CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_QueryStringsConfig_QueryStringBehavior")
        }
        {
            $v = "all","allExcept","none","whitelist"
            break
        }

        # Amazon.CloudFront.CachePolicyType
        "Get-CFCachePolicyList/Type"
        {
            $v = "custom","managed"
            break
        }

        # Amazon.CloudFront.CertificateSource
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_CertificateSource") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_CertificateSource") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_CertificateSource")
        }
        {
            $v = "acm","cloudfront","iam"
            break
        }

        # Amazon.CloudFront.FrameOptionsList
        {
            ($_ -eq "New-CFResponseHeadersPolicy/ResponseHeadersPolicyConfig_SecurityHeadersConfig_FrameOptions_FrameOption") -Or
            ($_ -eq "Update-CFResponseHeadersPolicy/ResponseHeadersPolicyConfig_SecurityHeadersConfig_FrameOptions_FrameOption")
        }
        {
            $v = "DENY","SAMEORIGIN"
            break
        }

        # Amazon.CloudFront.FunctionRuntime
        {
            ($_ -eq "New-CFFunction/FunctionConfig_Runtime") -Or
            ($_ -eq "Update-CFFunction/FunctionConfig_Runtime")
        }
        {
            $v = "cloudfront-js-1.0"
            break
        }

        # Amazon.CloudFront.FunctionStage
        {
            ($_ -eq "Get-CFFunction/Stage") -Or
            ($_ -eq "Get-CFFunctionList/Stage") -Or
            ($_ -eq "Get-CFFunctionSummary/Stage") -Or
            ($_ -eq "Test-CFFunction/Stage")
        }
        {
            $v = "DEVELOPMENT","LIVE"
            break
        }

        # Amazon.CloudFront.GeoRestrictionType
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_Restrictions_GeoRestriction_RestrictionType") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_Restrictions_GeoRestriction_RestrictionType") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_Restrictions_GeoRestriction_RestrictionType")
        }
        {
            $v = "blacklist","none","whitelist"
            break
        }

        # Amazon.CloudFront.HttpVersion
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_HttpVersion") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_HttpVersion") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_HttpVersion")
        }
        {
            $v = "http1.1","http2","http2and3","http3"
            break
        }

        # Amazon.CloudFront.ItemSelection
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward")
        }
        {
            $v = "all","none","whitelist"
            break
        }

        # Amazon.CloudFront.MinimumProtocolVersion
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_MinimumProtocolVersion") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_MinimumProtocolVersion") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_MinimumProtocolVersion")
        }
        {
            $v = "SSLv3","TLSv1","TLSv1.1_2016","TLSv1.2_2018","TLSv1.2_2019","TLSv1.2_2021","TLSv1_2016"
            break
        }

        # Amazon.CloudFront.OriginAccessControlOriginTypes
        {
            ($_ -eq "New-CFOriginAccessControl/OriginAccessControlConfig_OriginAccessControlOriginType") -Or
            ($_ -eq "Update-CFOriginAccessControl/OriginAccessControlConfig_OriginAccessControlOriginType")
        }
        {
            $v = "s3"
            break
        }

        # Amazon.CloudFront.OriginAccessControlSigningBehaviors
        {
            ($_ -eq "New-CFOriginAccessControl/OriginAccessControlConfig_SigningBehavior") -Or
            ($_ -eq "Update-CFOriginAccessControl/OriginAccessControlConfig_SigningBehavior")
        }
        {
            $v = "always","never","no-override"
            break
        }

        # Amazon.CloudFront.OriginAccessControlSigningProtocols
        {
            ($_ -eq "New-CFOriginAccessControl/OriginAccessControlConfig_SigningProtocol") -Or
            ($_ -eq "Update-CFOriginAccessControl/OriginAccessControlConfig_SigningProtocol")
        }
        {
            $v = "sigv4"
            break
        }

        # Amazon.CloudFront.OriginRequestPolicyCookieBehavior
        {
            ($_ -eq "New-CFOriginRequestPolicy/OriginRequestPolicyConfig_CookiesConfig_CookieBehavior") -Or
            ($_ -eq "Update-CFOriginRequestPolicy/OriginRequestPolicyConfig_CookiesConfig_CookieBehavior")
        }
        {
            $v = "all","none","whitelist"
            break
        }

        # Amazon.CloudFront.OriginRequestPolicyHeaderBehavior
        {
            ($_ -eq "New-CFOriginRequestPolicy/OriginRequestPolicyConfig_HeadersConfig_HeaderBehavior") -Or
            ($_ -eq "Update-CFOriginRequestPolicy/OriginRequestPolicyConfig_HeadersConfig_HeaderBehavior")
        }
        {
            $v = "allViewer","allViewerAndWhitelistCloudFront","none","whitelist"
            break
        }

        # Amazon.CloudFront.OriginRequestPolicyQueryStringBehavior
        {
            ($_ -eq "New-CFOriginRequestPolicy/OriginRequestPolicyConfig_QueryStringsConfig_QueryStringBehavior") -Or
            ($_ -eq "Update-CFOriginRequestPolicy/OriginRequestPolicyConfig_QueryStringsConfig_QueryStringBehavior")
        }
        {
            $v = "all","none","whitelist"
            break
        }

        # Amazon.CloudFront.OriginRequestPolicyType
        "Get-CFOriginRequestPolicyList/Type"
        {
            $v = "custom","managed"
            break
        }

        # Amazon.CloudFront.PriceClass
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_PriceClass") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFStreamingDistribution/StreamingDistributionConfig_PriceClass") -Or
            ($_ -eq "Update-CFStreamingDistribution/StreamingDistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFStreamingDistributionWithTag/StreamingDistributionConfigWithTags_StreamingDistributionConfig_PriceClass")
        }
        {
            $v = "PriceClass_100","PriceClass_200","PriceClass_All"
            break
        }

        # Amazon.CloudFront.RealtimeMetricsSubscriptionStatus
        "New-CFMonitoringSubscription/MonitoringSubscription_RealtimeMetricsSubscriptionConfig_RealtimeMetricsSubscriptionStatus"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.CloudFront.ReferrerPolicyList
        {
            ($_ -eq "New-CFResponseHeadersPolicy/ResponseHeadersPolicyConfig_SecurityHeadersConfig_ReferrerPolicy_ReferrerPolicy") -Or
            ($_ -eq "Update-CFResponseHeadersPolicy/ResponseHeadersPolicyConfig_SecurityHeadersConfig_ReferrerPolicy_ReferrerPolicy")
        }
        {
            $v = "no-referrer","no-referrer-when-downgrade","origin","origin-when-cross-origin","same-origin","strict-origin","strict-origin-when-cross-origin","unsafe-url"
            break
        }

        # Amazon.CloudFront.ResponseHeadersPolicyType
        "Get-CFResponseHeadersPolicyList/Type"
        {
            $v = "custom","managed"
            break
        }

        # Amazon.CloudFront.SSLSupportMethod
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_SSLSupportMethod") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_SSLSupportMethod") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_SSLSupportMethod")
        }
        {
            $v = "sni-only","static-ip","vip"
            break
        }

        # Amazon.CloudFront.ViewerProtocolPolicy
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy")
        }
        {
            $v = "allow-all","https-only","redirect-to-https"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CF_map = @{
    "CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_CookiesConfig_CookieBehavior"=@("New-CFCachePolicy","Update-CFCachePolicy")
    "CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_HeadersConfig_HeaderBehavior"=@("New-CFCachePolicy","Update-CFCachePolicy")
    "CachePolicyConfig_ParametersInCacheKeyAndForwardedToOrigin_QueryStringsConfig_QueryStringBehavior"=@("New-CFCachePolicy","Update-CFCachePolicy")
    "DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_HttpVersion"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_PriceClass"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_Restrictions_GeoRestriction_RestrictionType"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_CertificateSource"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_MinimumProtocolVersion"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_SSLSupportMethod"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_HttpVersion"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_PriceClass"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_Restrictions_GeoRestriction_RestrictionType"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_CertificateSource"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_MinimumProtocolVersion"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_SSLSupportMethod"=@("New-CFDistributionWithTag")
    "FunctionConfig_Runtime"=@("New-CFFunction","Update-CFFunction")
    "MonitoringSubscription_RealtimeMetricsSubscriptionConfig_RealtimeMetricsSubscriptionStatus"=@("New-CFMonitoringSubscription")
    "OriginAccessControlConfig_OriginAccessControlOriginType"=@("New-CFOriginAccessControl","Update-CFOriginAccessControl")
    "OriginAccessControlConfig_SigningBehavior"=@("New-CFOriginAccessControl","Update-CFOriginAccessControl")
    "OriginAccessControlConfig_SigningProtocol"=@("New-CFOriginAccessControl","Update-CFOriginAccessControl")
    "OriginRequestPolicyConfig_CookiesConfig_CookieBehavior"=@("New-CFOriginRequestPolicy","Update-CFOriginRequestPolicy")
    "OriginRequestPolicyConfig_HeadersConfig_HeaderBehavior"=@("New-CFOriginRequestPolicy","Update-CFOriginRequestPolicy")
    "OriginRequestPolicyConfig_QueryStringsConfig_QueryStringBehavior"=@("New-CFOriginRequestPolicy","Update-CFOriginRequestPolicy")
    "ResponseHeadersPolicyConfig_SecurityHeadersConfig_FrameOptions_FrameOption"=@("New-CFResponseHeadersPolicy","Update-CFResponseHeadersPolicy")
    "ResponseHeadersPolicyConfig_SecurityHeadersConfig_ReferrerPolicy_ReferrerPolicy"=@("New-CFResponseHeadersPolicy","Update-CFResponseHeadersPolicy")
    "Stage"=@("Get-CFFunction","Get-CFFunctionList","Get-CFFunctionSummary","Test-CFFunction")
    "StreamingDistributionConfig_PriceClass"=@("New-CFStreamingDistribution","Update-CFStreamingDistribution")
    "StreamingDistributionConfigWithTags_StreamingDistributionConfig_PriceClass"=@("New-CFStreamingDistributionWithTag")
    "Type"=@("Get-CFCachePolicyList","Get-CFOriginRequestPolicyList","Get-CFResponseHeadersPolicyList")
}

_awsArgumentCompleterRegistration $CF_Completers $CF_map

$CF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CF_SelectMap = @{
    "Select"=@("Move-CFAlias",
               "New-CFCachePolicy",
               "New-CFCloudFrontOriginAccessIdentity",
               "New-CFDistribution",
               "New-CFDistributionWithTag",
               "New-CFFieldLevelEncryptionConfig",
               "New-CFFieldLevelEncryptionProfile",
               "New-CFFunction",
               "New-CFInvalidation",
               "New-CFKeyGroup",
               "New-CFMonitoringSubscription",
               "New-CFOriginAccessControl",
               "New-CFOriginRequestPolicy",
               "New-CFPublicKey",
               "New-CFRealtimeLogConfig",
               "New-CFResponseHeadersPolicy",
               "New-CFStreamingDistribution",
               "New-CFStreamingDistributionWithTag",
               "Remove-CFCachePolicy",
               "Remove-CFCloudFrontOriginAccessIdentity",
               "Remove-CFDistribution",
               "Remove-CFFieldLevelEncryptionConfig",
               "Remove-CFFieldLevelEncryptionProfile",
               "Remove-CFFunction",
               "Remove-CFKeyGroup",
               "Remove-CFMonitoringSubscription",
               "Remove-CFOriginAccessControl",
               "Remove-CFOriginRequestPolicy",
               "Remove-CFPublicKey",
               "Remove-CFRealtimeLogConfig",
               "Remove-CFResponseHeadersPolicy",
               "Remove-CFStreamingDistribution",
               "Get-CFFunctionSummary",
               "Get-CFCachePolicy",
               "Get-CFCachePolicyConfig",
               "Get-CFCloudFrontOriginAccessIdentity",
               "Get-CFCloudFrontOriginAccessIdentityConfig",
               "Get-CFDistribution",
               "Get-CFDistributionConfig",
               "Get-CFFieldLevelEncryption",
               "Get-CFFieldLevelEncryptionConfig",
               "Get-CFFieldLevelEncryptionProfile",
               "Get-CFFieldLevelEncryptionProfileConfig",
               "Get-CFFunction",
               "Get-CFInvalidation",
               "Get-CFKeyGroup",
               "Get-CFKeyGroupConfig",
               "Get-CFMonitoringSubscription",
               "Get-CFOriginAccessControl",
               "Get-CFOriginAccessControlConfig",
               "Get-CFOriginRequestPolicy",
               "Get-CFOriginRequestPolicyConfig",
               "Get-CFPublicKey",
               "Get-CFPublicKeyConfig",
               "Get-CFRealtimeLogConfig",
               "Get-CFResponseHeadersPolicy",
               "Get-CFResponseHeadersPolicyConfig",
               "Get-CFStreamingDistribution",
               "Get-CFStreamingDistributionConfig",
               "Get-CFCachePolicyList",
               "Get-CFCloudFrontOriginAccessIdentityList",
               "Get-CFConflictingAlias",
               "Get-CFDistributionList",
               "Get-CFDistributionsByCachePolicyId",
               "Get-CFDistributionsByKeyGroup",
               "Get-CFDistributionsByOriginRequestPolicyId",
               "Get-CFDistributionsByRealtimeLogConfig",
               "Get-CFDistributionsByResponseHeadersPolicyId",
               "Get-CFDistributionListByWebACLId",
               "Get-CFFieldLevelEncryptionConfigList",
               "Get-CFFieldLevelEncryptionProfileList",
               "Get-CFFunctionList",
               "Get-CFInvalidationList",
               "Get-CFKeyGroupList",
               "Get-CFOriginAccessControlList",
               "Get-CFOriginRequestPolicyList",
               "Get-CFPublicKeyList",
               "Get-CFRealtimeLogConfigList",
               "Get-CFResponseHeadersPolicyList",
               "Get-CFStreamingDistributionList",
               "Get-CFResourceTag",
               "Publish-CFFunction",
               "Add-CFResourceTag",
               "Test-CFFunction",
               "Remove-CFResourceTag",
               "Update-CFCachePolicy",
               "Update-CFCloudFrontOriginAccessIdentity",
               "Update-CFDistribution",
               "Update-CFFieldLevelEncryptionConfig",
               "Update-CFFieldLevelEncryptionProfile",
               "Update-CFFunction",
               "Update-CFKeyGroup",
               "Update-CFOriginAccessControl",
               "Update-CFOriginRequestPolicy",
               "Update-CFPublicKey",
               "Update-CFRealtimeLogConfig",
               "Update-CFResponseHeadersPolicy",
               "Update-CFStreamingDistribution",
               "New-CFSignedCookie",
               "New-CFSignedUrl")
}

_awsArgumentCompleterRegistration $CF_SelectCompleters $CF_SelectMap
# Argument completions for service AWS CloudHSM


$HSM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudHSM.ClientVersion
        "Get-HSMConfig/ClientVersion"
        {
            $v = "5.1","5.3"
            break
        }

        # Amazon.CloudHSM.SubscriptionType
        "New-HSMItem/SubscriptionType"
        {
            $v = "PRODUCTION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM_map = @{
    "ClientVersion"=@("Get-HSMConfig")
    "SubscriptionType"=@("New-HSMItem")
}

_awsArgumentCompleterRegistration $HSM_Completers $HSM_map

$HSM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HSM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM_SelectMap = @{
    "Select"=@("Set-HSMResourceTag",
               "New-HSMPartitionGroup",
               "New-HSMItem",
               "New-HSMLunaClient",
               "Remove-HSMPartitionGroup",
               "Remove-HSMItem",
               "Remove-HSMLunaClient",
               "Get-HSMPartitionGroup",
               "Get-HSMItem",
               "Get-HSMLunaClient",
               "Get-HSMConfig",
               "Get-HSMAvailableZone",
               "Get-HSMPartitionGroupList",
               "Get-HSMItemList",
               "Get-HSMLunaClientList",
               "Get-HSMResourceTag",
               "Edit-HSMPartitionGroup",
               "Edit-HSMItem",
               "Edit-HSMLunaClient",
               "Remove-HSMResourceTag")
}

_awsArgumentCompleterRegistration $HSM_SelectCompleters $HSM_SelectMap
# Argument completions for service AWS CloudHSM V2


$HSM2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudHSMV2.BackupRetentionType
        {
            ($_ -eq "Edit-HSM2Cluster/BackupRetentionPolicy_Type") -Or
            ($_ -eq "New-HSM2Cluster/BackupRetentionPolicy_Type")
        }
        {
            $v = "DAYS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM2_map = @{
    "BackupRetentionPolicy_Type"=@("Edit-HSM2Cluster","New-HSM2Cluster")
}

_awsArgumentCompleterRegistration $HSM2_Completers $HSM2_map

$HSM2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HSM2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM2_SelectMap = @{
    "Select"=@("Copy-HSM2BackupToRegion",
               "New-HSM2Cluster",
               "New-HSM2Hsm",
               "Remove-HSM2Backup",
               "Remove-HSM2Cluster",
               "Remove-HSM2Hsm",
               "Get-HSM2Backup",
               "Get-HSM2Cluster",
               "Initialize-HSM2Cluster",
               "Get-HSM2ResourceTag",
               "Edit-HSM2BackupAttribute",
               "Edit-HSM2Cluster",
               "Restore-HSM2Backup",
               "Add-HSM2ResourceTag",
               "Remove-HSM2ResourceTag")
}

_awsArgumentCompleterRegistration $HSM2_SelectCompleters $HSM2_SelectMap
# Argument completions for service Amazon CloudSearch


$CS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudSearch.AlgorithmicStemming
        "Set-CSAnalysisScheme/AnalysisScheme_AnalysisOptions_AlgorithmicStemming"
        {
            $v = "full","light","minimal","none"
            break
        }

        # Amazon.CloudSearch.AnalysisSchemeLanguage
        "Set-CSAnalysisScheme/AnalysisScheme_AnalysisSchemeLanguage"
        {
            $v = "ar","bg","ca","cs","da","de","el","en","es","eu","fa","fi","fr","ga","gl","he","hi","hu","hy","id","it","ja","ko","lv","mul","nl","no","pt","ro","ru","sv","th","tr","zh-Hans","zh-Hant"
            break
        }

        # Amazon.CloudSearch.IndexFieldType
        "Set-CSIndexField/IndexField_IndexFieldType"
        {
            $v = "date","date-array","double","double-array","int","int-array","latlon","literal","literal-array","text","text-array"
            break
        }

        # Amazon.CloudSearch.PartitionInstanceType
        "Update-CSScalingParameter/ScalingParameters_DesiredInstanceType"
        {
            $v = "search.2xlarge","search.large","search.m1.large","search.m1.small","search.m2.2xlarge","search.m2.xlarge","search.m3.2xlarge","search.m3.large","search.m3.medium","search.m3.xlarge","search.medium","search.previousgeneration.2xlarge","search.previousgeneration.large","search.previousgeneration.small","search.previousgeneration.xlarge","search.small","search.xlarge"
            break
        }

        # Amazon.CloudSearch.SuggesterFuzzyMatching
        "Set-CSSuggester/Suggester_DocumentSuggesterOptions_FuzzyMatching"
        {
            $v = "high","low","none"
            break
        }

        # Amazon.CloudSearch.TLSSecurityPolicy
        "Update-CSDomainEndpointOption/DomainEndpointOptions_TLSSecurityPolicy"
        {
            $v = "Policy-Min-TLS-1-0-2019-07","Policy-Min-TLS-1-2-2019-07"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CS_map = @{
    "AnalysisScheme_AnalysisOptions_AlgorithmicStemming"=@("Set-CSAnalysisScheme")
    "AnalysisScheme_AnalysisSchemeLanguage"=@("Set-CSAnalysisScheme")
    "DomainEndpointOptions_TLSSecurityPolicy"=@("Update-CSDomainEndpointOption")
    "IndexField_IndexFieldType"=@("Set-CSIndexField")
    "ScalingParameters_DesiredInstanceType"=@("Update-CSScalingParameter")
    "Suggester_DocumentSuggesterOptions_FuzzyMatching"=@("Set-CSSuggester")
}

_awsArgumentCompleterRegistration $CS_Completers $CS_map

$CS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CS_SelectMap = @{
    "Select"=@("Start-CSSuggestersBuild",
               "New-CSDomain",
               "Set-CSAnalysisScheme",
               "Set-CSExpression",
               "Set-CSIndexField",
               "Set-CSSuggester",
               "Remove-CSAnalysisScheme",
               "Remove-CSDomain",
               "Remove-CSExpression",
               "Remove-CSIndexField",
               "Remove-CSSuggester",
               "Get-CSAnalysisScheme",
               "Get-CSAvailabilityOption",
               "Get-CSDomainEndpointOption",
               "Get-CSDomain",
               "Get-CSExpression",
               "Get-CSIndexField",
               "Get-CSScalingParameter",
               "Get-CSServiceAccessPolicy",
               "Get-CSSuggester",
               "Start-CSIndex",
               "Get-CSDomainNameList",
               "Update-CSAvailabilityOption",
               "Update-CSDomainEndpointOption",
               "Update-CSScalingParameter",
               "Update-CSServiceAccessPolicy")
}

_awsArgumentCompleterRegistration $CS_SelectCompleters $CS_SelectMap
# Argument completions for service Amazon CloudSearch Domain


$CSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudSearchDomain.ContentType
        "Write-CSDDocument/ContentType"
        {
            $v = "application/json","application/xml"
            break
        }

        # Amazon.CloudSearchDomain.QueryParser
        "Search-CSDDocument/QueryParser"
        {
            $v = "dismax","lucene","simple","structured"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSD_map = @{
    "ContentType"=@("Write-CSDDocument")
    "QueryParser"=@("Search-CSDDocument")
}

_awsArgumentCompleterRegistration $CSD_Completers $CSD_map

$CSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSD_SelectMap = @{
    "Select"=@("Get-CSDSuggestion",
               "Search-CSDDocument",
               "Write-CSDDocument")
}

_awsArgumentCompleterRegistration $CSD_SelectCompleters $CSD_SelectMap
# Argument completions for service AWS CloudTrail


$CT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudTrail.EventCategory
        "Find-CTEvent/EventCategory"
        {
            $v = "insight"
            break
        }

        # Amazon.CloudTrail.ImportStatus
        "Get-CTImportList/ImportStatus"
        {
            $v = "COMPLETED","FAILED","INITIALIZING","IN_PROGRESS","STOPPED"
            break
        }

        # Amazon.CloudTrail.QueryStatus
        "Get-CTQuerySummary/QueryStatus"
        {
            $v = "CANCELLED","FAILED","FINISHED","QUEUED","RUNNING","TIMED_OUT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CT_map = @{
    "EventCategory"=@("Find-CTEvent")
    "ImportStatus"=@("Get-CTImportList")
    "QueryStatus"=@("Get-CTQuerySummary")
}

_awsArgumentCompleterRegistration $CT_Completers $CT_map

$CT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CT_SelectMap = @{
    "Select"=@("Add-CTResourceTag",
               "Stop-CTQuery",
               "New-CTEventDataStore",
               "New-CTTrail",
               "Remove-CTEventDataStore",
               "Remove-CTTrail",
               "Unregister-CTOrganizationDelegatedAdmin",
               "Get-CTQuery",
               "Get-CTTrail",
               "Get-CTChannel",
               "Get-CTEventDataStore",
               "Get-CTEventSelector",
               "Get-CTImport",
               "Get-CTInsightSelector",
               "Get-CTQueryResult",
               "Get-CTTrailByName",
               "Get-CTTrailStatus",
               "Get-CTChannelSummary",
               "Get-CTEventDataStoreSummary",
               "Get-CTImportFailure",
               "Get-CTImportList",
               "Get-CTPublicKey",
               "Get-CTQuerySummary",
               "Get-CTResourceTag",
               "Get-CTTrailSummary",
               "Find-CTEvent",
               "Write-CTEventSelector",
               "Write-CTInsightSelector",
               "Register-CTOrganizationDelegatedAdmin",
               "Remove-CTResourceTag",
               "Restore-CTEventDataStore",
               "Start-CTImport",
               "Start-CTLogging",
               "Start-CTQuery",
               "Stop-CTImport",
               "Stop-CTLogging",
               "Update-CTEventDataStore",
               "Update-CTTrail")
}

_awsArgumentCompleterRegistration $CT_SelectCompleters $CT_SelectMap
# Argument completions for service AWS CodeArtifact


$CA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeArtifact.AllowPublish
        {
            ($_ -eq "Get-CAPackageList/Publish") -Or
            ($_ -eq "Write-CAPackageOriginConfiguration/Restrictions_Publish")
        }
        {
            $v = "ALLOW","BLOCK"
            break
        }

        # Amazon.CodeArtifact.AllowUpstream
        {
            ($_ -eq "Write-CAPackageOriginConfiguration/Restrictions_Upstream") -Or
            ($_ -eq "Get-CAPackageList/Upstream")
        }
        {
            $v = "ALLOW","BLOCK"
            break
        }

        # Amazon.CodeArtifact.PackageFormat
        {
            ($_ -eq "Copy-CAPackageVersion/Format") -Or
            ($_ -eq "Get-CAPackage/Format") -Or
            ($_ -eq "Get-CAPackageList/Format") -Or
            ($_ -eq "Get-CAPackageVersion/Format") -Or
            ($_ -eq "Get-CAPackageVersionAsset/Format") -Or
            ($_ -eq "Get-CAPackageVersionAssetList/Format") -Or
            ($_ -eq "Get-CAPackageVersionDependencyList/Format") -Or
            ($_ -eq "Get-CAPackageVersionList/Format") -Or
            ($_ -eq "Get-CAPackageVersionReadme/Format") -Or
            ($_ -eq "Get-CARepositoryEndpoint/Format") -Or
            ($_ -eq "Remove-CAPackageVersion/Format") -Or
            ($_ -eq "Unpublish-CAPackageVersion/Format") -Or
            ($_ -eq "Update-CAPackageVersionsStatus/Format") -Or
            ($_ -eq "Write-CAPackageOriginConfiguration/Format")
        }
        {
            $v = "maven","npm","nuget","pypi"
            break
        }

        # Amazon.CodeArtifact.PackageVersionOriginType
        "Get-CAPackageVersionList/OriginType"
        {
            $v = "EXTERNAL","INTERNAL","UNKNOWN"
            break
        }

        # Amazon.CodeArtifact.PackageVersionSortType
        "Get-CAPackageVersionList/SortBy"
        {
            $v = "PUBLISHED_TIME"
            break
        }

        # Amazon.CodeArtifact.PackageVersionStatus
        {
            ($_ -eq "Remove-CAPackageVersion/ExpectedStatus") -Or
            ($_ -eq "Unpublish-CAPackageVersion/ExpectedStatus") -Or
            ($_ -eq "Update-CAPackageVersionsStatus/ExpectedStatus") -Or
            ($_ -eq "Get-CAPackageVersionList/Status") -Or
            ($_ -eq "Update-CAPackageVersionsStatus/TargetStatus")
        }
        {
            $v = "Archived","Deleted","Disposed","Published","Unfinished","Unlisted"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CA_map = @{
    "ExpectedStatus"=@("Remove-CAPackageVersion","Unpublish-CAPackageVersion","Update-CAPackageVersionsStatus")
    "Format"=@("Copy-CAPackageVersion","Get-CAPackage","Get-CAPackageList","Get-CAPackageVersion","Get-CAPackageVersionAsset","Get-CAPackageVersionAssetList","Get-CAPackageVersionDependencyList","Get-CAPackageVersionList","Get-CAPackageVersionReadme","Get-CARepositoryEndpoint","Remove-CAPackageVersion","Unpublish-CAPackageVersion","Update-CAPackageVersionsStatus","Write-CAPackageOriginConfiguration")
    "OriginType"=@("Get-CAPackageVersionList")
    "Publish"=@("Get-CAPackageList")
    "Restrictions_Publish"=@("Write-CAPackageOriginConfiguration")
    "Restrictions_Upstream"=@("Write-CAPackageOriginConfiguration")
    "SortBy"=@("Get-CAPackageVersionList")
    "Status"=@("Get-CAPackageVersionList")
    "TargetStatus"=@("Update-CAPackageVersionsStatus")
    "Upstream"=@("Get-CAPackageList")
}

_awsArgumentCompleterRegistration $CA_Completers $CA_map

$CA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CA_SelectMap = @{
    "Select"=@("Connect-CAExternalConnection",
               "Copy-CAPackageVersion",
               "New-CADomain",
               "New-CARepository",
               "Remove-CADomain",
               "Remove-CADomainPermissionsPolicy",
               "Remove-CAPackageVersion",
               "Remove-CARepository",
               "Remove-CARepositoryPermissionsPolicy",
               "Get-CADomain",
               "Get-CAPackage",
               "Get-CAPackageVersion",
               "Get-CARepository",
               "Disconnect-CAExternalConnection",
               "Unpublish-CAPackageVersion",
               "Get-CAAuthorizationToken",
               "Get-CADomainPermissionsPolicy",
               "Get-CAPackageVersionAsset",
               "Get-CAPackageVersionReadme",
               "Get-CARepositoryEndpoint",
               "Get-CARepositoryPermissionsPolicy",
               "Get-CADomainList",
               "Get-CAPackageList",
               "Get-CAPackageVersionAssetList",
               "Get-CAPackageVersionDependencyList",
               "Get-CAPackageVersionList",
               "Get-CARepositoryList",
               "Get-CARepositoriesInDomainList",
               "Get-CAResourceTag",
               "Write-CADomainPermissionsPolicy",
               "Write-CAPackageOriginConfiguration",
               "Write-CARepositoryPermissionsPolicy",
               "Add-CAResourceTag",
               "Remove-CAResourceTag",
               "Update-CAPackageVersionsStatus",
               "Update-CARepository")
}

_awsArgumentCompleterRegistration $CA_SelectCompleters $CA_SelectMap
# Argument completions for service AWS CodeBuild


$CB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeBuild.ArtifactNamespace
        {
            ($_ -eq "New-CBProject/Artifacts_NamespaceType") -Or
            ($_ -eq "Update-CBProject/Artifacts_NamespaceType") -Or
            ($_ -eq "Start-CBBatch/ArtifactsOverride_NamespaceType") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_NamespaceType")
        }
        {
            $v = "BUILD_ID","NONE"
            break
        }

        # Amazon.CodeBuild.ArtifactPackaging
        {
            ($_ -eq "New-CBProject/Artifacts_Packaging") -Or
            ($_ -eq "Update-CBProject/Artifacts_Packaging") -Or
            ($_ -eq "Start-CBBatch/ArtifactsOverride_Packaging") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_Packaging")
        }
        {
            $v = "NONE","ZIP"
            break
        }

        # Amazon.CodeBuild.ArtifactsType
        {
            ($_ -eq "New-CBProject/Artifacts_Type") -Or
            ($_ -eq "Update-CBProject/Artifacts_Type") -Or
            ($_ -eq "Start-CBBatch/ArtifactsOverride_Type") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_Type")
        }
        {
            $v = "CODEPIPELINE","NO_ARTIFACTS","S3"
            break
        }

        # Amazon.CodeBuild.AuthType
        "Import-CBSourceCredential/AuthType"
        {
            $v = "BASIC_AUTH","OAUTH","PERSONAL_ACCESS_TOKEN"
            break
        }

        # Amazon.CodeBuild.BatchReportModeType
        {
            ($_ -eq "New-CBProject/BuildBatchConfig_BatchReportMode") -Or
            ($_ -eq "Update-CBProject/BuildBatchConfig_BatchReportMode") -Or
            ($_ -eq "Start-CBBatch/BuildBatchConfigOverride_BatchReportMode")
        }
        {
            $v = "REPORT_AGGREGATED_BATCH","REPORT_INDIVIDUAL_BUILDS"
            break
        }

        # Amazon.CodeBuild.BucketOwnerAccess
        {
            ($_ -eq "New-CBProject/Artifacts_BucketOwnerAccess") -Or
            ($_ -eq "Update-CBProject/Artifacts_BucketOwnerAccess") -Or
            ($_ -eq "Start-CBBatch/ArtifactsOverride_BucketOwnerAccess") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_BucketOwnerAccess") -Or
            ($_ -eq "New-CBProject/LogsConfig_S3Logs_BucketOwnerAccess") -Or
            ($_ -eq "Update-CBProject/LogsConfig_S3Logs_BucketOwnerAccess") -Or
            ($_ -eq "Start-CBBatch/LogsConfigOverride_S3Logs_BucketOwnerAccess") -Or
            ($_ -eq "Start-CBBuild/LogsConfigOverride_S3Logs_BucketOwnerAccess")
        }
        {
            $v = "FULL","NONE","READ_ONLY"
            break
        }

        # Amazon.CodeBuild.CacheType
        {
            ($_ -eq "New-CBProject/Cache_Type") -Or
            ($_ -eq "Update-CBProject/Cache_Type") -Or
            ($_ -eq "Start-CBBatch/CacheOverride_Type") -Or
            ($_ -eq "Start-CBBuild/CacheOverride_Type")
        }
        {
            $v = "LOCAL","NO_CACHE","S3"
            break
        }

        # Amazon.CodeBuild.ComputeType
        {
            ($_ -eq "Start-CBBatch/ComputeTypeOverride") -Or
            ($_ -eq "Start-CBBuild/ComputeTypeOverride") -Or
            ($_ -eq "New-CBProject/Environment_ComputeType") -Or
            ($_ -eq "Update-CBProject/Environment_ComputeType")
        }
        {
            $v = "BUILD_GENERAL1_2XLARGE","BUILD_GENERAL1_LARGE","BUILD_GENERAL1_MEDIUM","BUILD_GENERAL1_SMALL"
            break
        }

        # Amazon.CodeBuild.CredentialProviderType
        {
            ($_ -eq "New-CBProject/Environment_RegistryCredential_CredentialProvider") -Or
            ($_ -eq "Update-CBProject/Environment_RegistryCredential_CredentialProvider") -Or
            ($_ -eq "Start-CBBatch/RegistryCredentialOverride_CredentialProvider") -Or
            ($_ -eq "Start-CBBuild/RegistryCredentialOverride_CredentialProvider")
        }
        {
            $v = "SECRETS_MANAGER"
            break
        }

        # Amazon.CodeBuild.EnvironmentType
        {
            ($_ -eq "New-CBProject/Environment_Type") -Or
            ($_ -eq "Update-CBProject/Environment_Type") -Or
            ($_ -eq "Start-CBBatch/EnvironmentTypeOverride") -Or
            ($_ -eq "Start-CBBuild/EnvironmentTypeOverride")
        }
        {
            $v = "ARM_CONTAINER","LINUX_CONTAINER","LINUX_GPU_CONTAINER","WINDOWS_CONTAINER","WINDOWS_SERVER_2019_CONTAINER"
            break
        }

        # Amazon.CodeBuild.ImagePullCredentialsType
        {
            ($_ -eq "New-CBProject/Environment_ImagePullCredentialsType") -Or
            ($_ -eq "Update-CBProject/Environment_ImagePullCredentialsType") -Or
            ($_ -eq "Start-CBBatch/ImagePullCredentialsTypeOverride") -Or
            ($_ -eq "Start-CBBuild/ImagePullCredentialsTypeOverride")
        }
        {
            $v = "CODEBUILD","SERVICE_ROLE"
            break
        }

        # Amazon.CodeBuild.LogsConfigStatusType
        {
            ($_ -eq "New-CBProject/LogsConfig_CloudWatchLogs_Status") -Or
            ($_ -eq "Update-CBProject/LogsConfig_CloudWatchLogs_Status") -Or
            ($_ -eq "New-CBProject/LogsConfig_S3Logs_Status") -Or
            ($_ -eq "Update-CBProject/LogsConfig_S3Logs_Status") -Or
            ($_ -eq "Start-CBBatch/LogsConfigOverride_CloudWatchLogs_Status") -Or
            ($_ -eq "Start-CBBuild/LogsConfigOverride_CloudWatchLogs_Status") -Or
            ($_ -eq "Start-CBBatch/LogsConfigOverride_S3Logs_Status") -Or
            ($_ -eq "Start-CBBuild/LogsConfigOverride_S3Logs_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.CodeBuild.ProjectSortByType
        "Get-CBProjectList/SortBy"
        {
            $v = "CREATED_TIME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.CodeBuild.ProjectVisibilityType
        "Update-CBProjectVisibility/ProjectVisibility"
        {
            $v = "PRIVATE","PUBLIC_READ"
            break
        }

        # Amazon.CodeBuild.ReportCodeCoverageSortByType
        "Get-CBCodeCoverage/SortBy"
        {
            $v = "FILE_PATH","LINE_COVERAGE_PERCENTAGE"
            break
        }

        # Amazon.CodeBuild.ReportExportConfigType
        {
            ($_ -eq "New-CBReportGroup/ExportConfig_ExportConfigType") -Or
            ($_ -eq "Update-CBReportGroup/ExportConfig_ExportConfigType")
        }
        {
            $v = "NO_EXPORT","S3"
            break
        }

        # Amazon.CodeBuild.ReportGroupSortByType
        "Get-CBReportGroupList/SortBy"
        {
            $v = "CREATED_TIME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.CodeBuild.ReportGroupTrendFieldType
        "Get-CBReportGroupTrend/TrendField"
        {
            $v = "BRANCHES_COVERED","BRANCHES_MISSED","BRANCH_COVERAGE","DURATION","LINES_COVERED","LINES_MISSED","LINE_COVERAGE","PASS_RATE","TOTAL"
            break
        }

        # Amazon.CodeBuild.ReportPackagingType
        {
            ($_ -eq "New-CBReportGroup/ExportConfig_S3Destination_Packaging") -Or
            ($_ -eq "Update-CBReportGroup/ExportConfig_S3Destination_Packaging")
        }
        {
            $v = "NONE","ZIP"
            break
        }

        # Amazon.CodeBuild.ReportStatusType
        {
            ($_ -eq "Get-CBReportList/Filter_Status") -Or
            ($_ -eq "Get-CBReportsForReportGroupList/Filter_Status")
        }
        {
            $v = "DELETING","FAILED","GENERATING","INCOMPLETE","SUCCEEDED"
            break
        }

        # Amazon.CodeBuild.ReportType
        "New-CBReportGroup/Type"
        {
            $v = "CODE_COVERAGE","TEST"
            break
        }

        # Amazon.CodeBuild.RetryBuildBatchType
        "Redo-CBBatch/RetryType"
        {
            $v = "RETRY_ALL_BUILDS","RETRY_FAILED_BUILDS"
            break
        }

        # Amazon.CodeBuild.ServerType
        "Import-CBSourceCredential/ServerType"
        {
            $v = "BITBUCKET","GITHUB","GITHUB_ENTERPRISE"
            break
        }

        # Amazon.CodeBuild.SharedResourceSortByType
        {
            ($_ -eq "Get-CBSharedProjectList/SortBy") -Or
            ($_ -eq "Get-CBSharedReportGroupList/SortBy")
        }
        {
            $v = "ARN","MODIFIED_TIME"
            break
        }

        # Amazon.CodeBuild.SortOrderType
        {
            ($_ -eq "Get-CBBatchIdList/SortOrder") -Or
            ($_ -eq "Get-CBBatchIdListForProject/SortOrder") -Or
            ($_ -eq "Get-CBBuildIdList/SortOrder") -Or
            ($_ -eq "Get-CBBuildIdListForProject/SortOrder") -Or
            ($_ -eq "Get-CBCodeCoverage/SortOrder") -Or
            ($_ -eq "Get-CBProjectList/SortOrder") -Or
            ($_ -eq "Get-CBReportGroupList/SortOrder") -Or
            ($_ -eq "Get-CBReportList/SortOrder") -Or
            ($_ -eq "Get-CBReportsForReportGroupList/SortOrder") -Or
            ($_ -eq "Get-CBSharedProjectList/SortOrder") -Or
            ($_ -eq "Get-CBSharedReportGroupList/SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.CodeBuild.SourceAuthType
        {
            ($_ -eq "New-CBProject/Source_Auth_Type") -Or
            ($_ -eq "Update-CBProject/Source_Auth_Type") -Or
            ($_ -eq "Start-CBBatch/SourceAuthOverride_Type") -Or
            ($_ -eq "Start-CBBuild/SourceAuthOverride_Type")
        }
        {
            $v = "OAUTH"
            break
        }

        # Amazon.CodeBuild.SourceType
        {
            ($_ -eq "New-CBProject/Source_Type") -Or
            ($_ -eq "Update-CBProject/Source_Type") -Or
            ($_ -eq "Start-CBBatch/SourceTypeOverride") -Or
            ($_ -eq "Start-CBBuild/SourceTypeOverride")
        }
        {
            $v = "BITBUCKET","CODECOMMIT","CODEPIPELINE","GITHUB","GITHUB_ENTERPRISE","NO_SOURCE","S3"
            break
        }

        # Amazon.CodeBuild.StatusType
        {
            ($_ -eq "Get-CBBatchIdList/Filter_Status") -Or
            ($_ -eq "Get-CBBatchIdListForProject/Filter_Status")
        }
        {
            $v = "FAILED","FAULT","IN_PROGRESS","STOPPED","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.CodeBuild.WebhookBuildType
        {
            ($_ -eq "New-CBWebhook/BuildType") -Or
            ($_ -eq "Update-CBWebhook/BuildType")
        }
        {
            $v = "BUILD","BUILD_BATCH"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CB_map = @{
    "Artifacts_BucketOwnerAccess"=@("New-CBProject","Update-CBProject")
    "Artifacts_NamespaceType"=@("New-CBProject","Update-CBProject")
    "Artifacts_Packaging"=@("New-CBProject","Update-CBProject")
    "Artifacts_Type"=@("New-CBProject","Update-CBProject")
    "ArtifactsOverride_BucketOwnerAccess"=@("Start-CBBatch","Start-CBBuild")
    "ArtifactsOverride_NamespaceType"=@("Start-CBBatch","Start-CBBuild")
    "ArtifactsOverride_Packaging"=@("Start-CBBatch","Start-CBBuild")
    "ArtifactsOverride_Type"=@("Start-CBBatch","Start-CBBuild")
    "AuthType"=@("Import-CBSourceCredential")
    "BuildBatchConfig_BatchReportMode"=@("New-CBProject","Update-CBProject")
    "BuildBatchConfigOverride_BatchReportMode"=@("Start-CBBatch")
    "BuildType"=@("New-CBWebhook","Update-CBWebhook")
    "Cache_Type"=@("New-CBProject","Update-CBProject")
    "CacheOverride_Type"=@("Start-CBBatch","Start-CBBuild")
    "ComputeTypeOverride"=@("Start-CBBatch","Start-CBBuild")
    "Environment_ComputeType"=@("New-CBProject","Update-CBProject")
    "Environment_ImagePullCredentialsType"=@("New-CBProject","Update-CBProject")
    "Environment_RegistryCredential_CredentialProvider"=@("New-CBProject","Update-CBProject")
    "Environment_Type"=@("New-CBProject","Update-CBProject")
    "EnvironmentTypeOverride"=@("Start-CBBatch","Start-CBBuild")
    "ExportConfig_ExportConfigType"=@("New-CBReportGroup","Update-CBReportGroup")
    "ExportConfig_S3Destination_Packaging"=@("New-CBReportGroup","Update-CBReportGroup")
    "Filter_Status"=@("Get-CBBatchIdList","Get-CBBatchIdListForProject","Get-CBReportList","Get-CBReportsForReportGroupList")
    "ImagePullCredentialsTypeOverride"=@("Start-CBBatch","Start-CBBuild")
    "LogsConfig_CloudWatchLogs_Status"=@("New-CBProject","Update-CBProject")
    "LogsConfig_S3Logs_BucketOwnerAccess"=@("New-CBProject","Update-CBProject")
    "LogsConfig_S3Logs_Status"=@("New-CBProject","Update-CBProject")
    "LogsConfigOverride_CloudWatchLogs_Status"=@("Start-CBBatch","Start-CBBuild")
    "LogsConfigOverride_S3Logs_BucketOwnerAccess"=@("Start-CBBatch","Start-CBBuild")
    "LogsConfigOverride_S3Logs_Status"=@("Start-CBBatch","Start-CBBuild")
    "ProjectVisibility"=@("Update-CBProjectVisibility")
    "RegistryCredentialOverride_CredentialProvider"=@("Start-CBBatch","Start-CBBuild")
    "RetryType"=@("Redo-CBBatch")
    "ServerType"=@("Import-CBSourceCredential")
    "SortBy"=@("Get-CBCodeCoverage","Get-CBProjectList","Get-CBReportGroupList","Get-CBSharedProjectList","Get-CBSharedReportGroupList")
    "SortOrder"=@("Get-CBBatchIdList","Get-CBBatchIdListForProject","Get-CBBuildIdList","Get-CBBuildIdListForProject","Get-CBCodeCoverage","Get-CBProjectList","Get-CBReportGroupList","Get-CBReportList","Get-CBReportsForReportGroupList","Get-CBSharedProjectList","Get-CBSharedReportGroupList")
    "Source_Auth_Type"=@("New-CBProject","Update-CBProject")
    "Source_Type"=@("New-CBProject","Update-CBProject")
    "SourceAuthOverride_Type"=@("Start-CBBatch","Start-CBBuild")
    "SourceTypeOverride"=@("Start-CBBatch","Start-CBBuild")
    "TrendField"=@("Get-CBReportGroupTrend")
    "Type"=@("New-CBReportGroup")
}

_awsArgumentCompleterRegistration $CB_Completers $CB_map

$CB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CB_SelectMap = @{
    "Select"=@("Remove-CBBuildBatch",
               "Get-CBBatch",
               "Get-CBBuildBatch",
               "Get-CBProjectBatch",
               "Get-CBReportGroupBatch",
               "Get-CBReportBatch",
               "New-CBProject",
               "New-CBReportGroup",
               "New-CBWebhook",
               "Remove-CBBatch",
               "Remove-CBProject",
               "Remove-CBReport",
               "Remove-CBReportGroup",
               "Remove-CBResourcePolicy",
               "Remove-CBSourceCredential",
               "Remove-CBWebhook",
               "Get-CBCodeCoverage",
               "Get-CBTestCase",
               "Get-CBReportGroupTrend",
               "Get-CBResourcePolicy",
               "Import-CBSourceCredential",
               "Reset-CBProjectCache",
               "Get-CBBatchIdList",
               "Get-CBBatchIdListForProject",
               "Get-CBBuildIdList",
               "Get-CBBuildIdListForProject",
               "Get-CBCuratedEnvironmentImageList",
               "Get-CBProjectList",
               "Get-CBReportGroupList",
               "Get-CBReportList",
               "Get-CBReportsForReportGroupList",
               "Get-CBSharedProjectList",
               "Get-CBSharedReportGroupList",
               "Get-CBSourceCredentialList",
               "Write-CBResourcePolicy",
               "Redo-CBBuild",
               "Redo-CBBatch",
               "Start-CBBuild",
               "Start-CBBatch",
               "Stop-CBBuild",
               "Stop-CBBatch",
               "Update-CBProject",
               "Update-CBProjectVisibility",
               "Update-CBReportGroup",
               "Update-CBWebhook")
}

_awsArgumentCompleterRegistration $CB_SelectCompleters $CB_SelectMap
# Argument completions for service AWS CodeCommit


$CC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeCommit.ApprovalState
        "Update-CCPullRequestApprovalState/ApprovalState"
        {
            $v = "APPROVE","REVOKE"
            break
        }

        # Amazon.CodeCommit.ConflictDetailLevelTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeCommit/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeConflict/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeOption/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCBranchesBySquash/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCBranchesByThreeWay/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCPullRequestBySquash/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCPullRequestByThreeWay/ConflictDetailLevel") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/ConflictDetailLevel")
        }
        {
            $v = "FILE_LEVEL","LINE_LEVEL"
            break
        }

        # Amazon.CodeCommit.ConflictResolutionStrategyTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeCommit/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeConflict/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeOption/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCBranchesBySquash/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCBranchesByThreeWay/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCPullRequestBySquash/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCPullRequestByThreeWay/ConflictResolutionStrategy") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/ConflictResolutionStrategy")
        }
        {
            $v = "ACCEPT_DESTINATION","ACCEPT_SOURCE","AUTOMERGE","NONE"
            break
        }

        # Amazon.CodeCommit.FileModeTypeEnum
        "Write-CCFile/FileMode"
        {
            $v = "EXECUTABLE","NORMAL","SYMLINK"
            break
        }

        # Amazon.CodeCommit.MergeOptionTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/MergeOption") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/MergeOption") -Or
            ($_ -eq "Get-CCMergeConflict/MergeOption") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/MergeOption")
        }
        {
            $v = "FAST_FORWARD_MERGE","SQUASH_MERGE","THREE_WAY_MERGE"
            break
        }

        # Amazon.CodeCommit.OrderEnum
        "Get-CCRepositoryList/Order"
        {
            $v = "ascending","descending"
            break
        }

        # Amazon.CodeCommit.OverrideStatus
        "Skip-CCPullRequestApprovalRule/OverrideStatus"
        {
            $v = "OVERRIDE","REVOKE"
            break
        }

        # Amazon.CodeCommit.PullRequestEventType
        "Get-CCPullRequestEvent/PullRequestEventType"
        {
            $v = "PULL_REQUEST_APPROVAL_RULE_CREATED","PULL_REQUEST_APPROVAL_RULE_DELETED","PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN","PULL_REQUEST_APPROVAL_RULE_UPDATED","PULL_REQUEST_APPROVAL_STATE_CHANGED","PULL_REQUEST_CREATED","PULL_REQUEST_MERGE_STATE_CHANGED","PULL_REQUEST_SOURCE_REFERENCE_UPDATED","PULL_REQUEST_STATUS_CHANGED"
            break
        }

        # Amazon.CodeCommit.PullRequestStatusEnum
        {
            ($_ -eq "Get-CCPullRequestList/PullRequestStatus") -Or
            ($_ -eq "Update-CCPullRequestStatus/PullRequestStatus")
        }
        {
            $v = "CLOSED","OPEN"
            break
        }

        # Amazon.CodeCommit.RelativeFileVersionEnum
        {
            ($_ -eq "Send-CCCommentForComparedCommit/Location_RelativeFileVersion") -Or
            ($_ -eq "Send-CCCommentForPullRequest/Location_RelativeFileVersion")
        }
        {
            $v = "AFTER","BEFORE"
            break
        }

        # Amazon.CodeCommit.SortByEnum
        "Get-CCRepositoryList/SortBy"
        {
            $v = "lastModifiedDate","repositoryName"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CC_map = @{
    "ApprovalState"=@("Update-CCPullRequestApprovalState")
    "ConflictDetailLevel"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeCommit","Get-CCMergeConflict","Get-CCMergeOption","Merge-CCBranchesBySquash","Merge-CCBranchesByThreeWay","Merge-CCPullRequestBySquash","Merge-CCPullRequestByThreeWay","New-CCUnreferencedMergeCommit")
    "ConflictResolutionStrategy"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeCommit","Get-CCMergeConflict","Get-CCMergeOption","Merge-CCBranchesBySquash","Merge-CCBranchesByThreeWay","Merge-CCPullRequestBySquash","Merge-CCPullRequestByThreeWay","New-CCUnreferencedMergeCommit")
    "FileMode"=@("Write-CCFile")
    "Location_RelativeFileVersion"=@("Send-CCCommentForComparedCommit","Send-CCCommentForPullRequest")
    "MergeOption"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeConflict","New-CCUnreferencedMergeCommit")
    "Order"=@("Get-CCRepositoryList")
    "OverrideStatus"=@("Skip-CCPullRequestApprovalRule")
    "PullRequestEventType"=@("Get-CCPullRequestEvent")
    "PullRequestStatus"=@("Get-CCPullRequestList","Update-CCPullRequestStatus")
    "SortBy"=@("Get-CCRepositoryList")
}

_awsArgumentCompleterRegistration $CC_Completers $CC_map

$CC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CC_SelectMap = @{
    "Select"=@("Add-CCApprovalRuleTemplateToRepository",
               "Add-CCApprovalRuleTemplateToRepositoryBatch",
               "Get-CCFileMergeConflictBatch",
               "Remove-CCApprovalRuleTemplateFromRepositoryBatch",
               "Get-CCCommitBatch",
               "Get-CCRepositoryBatch",
               "New-CCApprovalRuleTemplate",
               "New-CCBranch",
               "New-CCCommit",
               "New-CCPullRequest",
               "New-CCPullRequestApprovalRule",
               "New-CCRepository",
               "New-CCUnreferencedMergeCommit",
               "Remove-CCApprovalRuleTemplate",
               "Remove-CCBranch",
               "Remove-CCCommentContent",
               "Remove-CCFile",
               "Remove-CCPullRequestApprovalRule",
               "Remove-CCRepository",
               "Get-CCFileMergeConflict",
               "Get-CCPullRequestEvent",
               "Remove-CCApprovalRuleTemplateFromRepository",
               "Invoke-CCPullRequestApprovalRule",
               "Get-CCApprovalRuleTemplate",
               "Get-CCBlob",
               "Get-CCBranch",
               "Get-CCComment",
               "Get-CCCommentReaction",
               "Get-CCCommentsForComparedCommit",
               "Get-CCCommentsForPullRequest",
               "Get-CCCommit",
               "Get-CCDifferenceList",
               "Get-CCFile",
               "Get-CCFolder",
               "Get-CCMergeCommit",
               "Get-CCMergeConflict",
               "Get-CCMergeOption",
               "Get-CCPullRequest",
               "Get-CCPullRequestApprovalState",
               "Get-CCPullRequestOverrideState",
               "Get-CCRepository",
               "Get-CCRepositoryTrigger",
               "Get-CCApprovalRuleTemplateList",
               "Get-CCAssociatedApprovalRuleTemplatesForRepositoryList",
               "Get-CCBranchList",
               "Get-CCPullRequestList",
               "Get-CCRepositoryList",
               "Get-CCRepositoriesForApprovalRuleTemplateList",
               "Get-CCResourceTag",
               "Merge-CCBranchesByFastForward",
               "Merge-CCBranchesBySquash",
               "Merge-CCBranchesByThreeWay",
               "Merge-CCPullRequestByFastForward",
               "Merge-CCPullRequestBySquash",
               "Merge-CCPullRequestByThreeWay",
               "Skip-CCPullRequestApprovalRule",
               "Send-CCCommentForComparedCommit",
               "Send-CCCommentForPullRequest",
               "Send-CCCommentReply",
               "Write-CCCommentReaction",
               "Write-CCFile",
               "Set-CCRepositoryTrigger",
               "Add-CCResourceTag",
               "Test-CCRepositoryTrigger",
               "Remove-CCResourceTag",
               "Update-CCApprovalRuleTemplateContent",
               "Update-CCApprovalRuleTemplateDescription",
               "Update-CCApprovalRuleTemplateName",
               "Update-CCComment",
               "Update-CCDefaultBranch",
               "Update-CCPullRequestApprovalRuleContent",
               "Update-CCPullRequestApprovalState",
               "Update-CCPullRequestDescription",
               "Update-CCPullRequestStatus",
               "Update-CCPullRequestTitle",
               "Update-CCRepositoryDescription",
               "Update-CCRepositoryName")
}

_awsArgumentCompleterRegistration $CC_SelectCompleters $CC_SelectMap
# Argument completions for service AWS CodeDeploy


$CD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeDeploy.ApplicationRevisionSortBy
        "Get-CDApplicationRevisionList/SortBy"
        {
            $v = "firstUsedTime","lastUsedTime","registerTime"
            break
        }

        # Amazon.CodeDeploy.BundleType
        {
            ($_ -eq "Get-CDApplicationRevision/Revision_S3Location_BundleType") -Or
            ($_ -eq "New-CDDeployment/Revision_S3Location_BundleType") -Or
            ($_ -eq "Register-CDApplicationRevision/Revision_S3Location_BundleType")
        }
        {
            $v = "JSON","tar","tgz","YAML","zip"
            break
        }

        # Amazon.CodeDeploy.ComputePlatform
        {
            ($_ -eq "New-CDApplication/ComputePlatform") -Or
            ($_ -eq "New-CDDeploymentConfig/ComputePlatform")
        }
        {
            $v = "ECS","Lambda","Server"
            break
        }

        # Amazon.CodeDeploy.DeploymentOption
        {
            ($_ -eq "New-CDDeploymentGroup/DeploymentStyle_DeploymentOption") -Or
            ($_ -eq "Update-CDDeploymentGroup/DeploymentStyle_DeploymentOption")
        }
        {
            $v = "WITHOUT_TRAFFIC_CONTROL","WITH_TRAFFIC_CONTROL"
            break
        }

        # Amazon.CodeDeploy.DeploymentReadyAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout")
        }
        {
            $v = "CONTINUE_DEPLOYMENT","STOP_DEPLOYMENT"
            break
        }

        # Amazon.CodeDeploy.DeploymentType
        {
            ($_ -eq "New-CDDeploymentGroup/DeploymentStyle_DeploymentType") -Or
            ($_ -eq "Update-CDDeploymentGroup/DeploymentStyle_DeploymentType")
        }
        {
            $v = "BLUE_GREEN","IN_PLACE"
            break
        }

        # Amazon.CodeDeploy.DeploymentWaitType
        "Resume-CDDeployment/DeploymentWaitType"
        {
            $v = "READY_WAIT","TERMINATION_WAIT"
            break
        }

        # Amazon.CodeDeploy.FileExistsBehavior
        "New-CDDeployment/FileExistsBehavior"
        {
            $v = "DISALLOW","OVERWRITE","RETAIN"
            break
        }

        # Amazon.CodeDeploy.GreenFleetProvisioningAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action")
        }
        {
            $v = "COPY_AUTO_SCALING_GROUP","DISCOVER_EXISTING"
            break
        }

        # Amazon.CodeDeploy.InstanceAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action")
        }
        {
            $v = "KEEP_ALIVE","TERMINATE"
            break
        }

        # Amazon.CodeDeploy.LifecycleEventStatus
        "Write-CDLifecycleEventHookExecutionStatus/Status"
        {
            $v = "Failed","InProgress","Pending","Skipped","Succeeded","Unknown"
            break
        }

        # Amazon.CodeDeploy.ListStateFilterAction
        "Get-CDApplicationRevisionList/Deployed"
        {
            $v = "exclude","ignore","include"
            break
        }

        # Amazon.CodeDeploy.MinimumHealthyHostsType
        "New-CDDeploymentConfig/MinimumHealthyHosts_Type"
        {
            $v = "FLEET_PERCENT","HOST_COUNT"
            break
        }

        # Amazon.CodeDeploy.OutdatedInstancesStrategy
        {
            ($_ -eq "New-CDDeploymentGroup/OutdatedInstancesStrategy") -Or
            ($_ -eq "Update-CDDeploymentGroup/OutdatedInstancesStrategy")
        }
        {
            $v = "IGNORE","UPDATE"
            break
        }

        # Amazon.CodeDeploy.RegistrationStatus
        "Get-CDOnPremiseInstanceList/RegistrationStatus"
        {
            $v = "Deregistered","Registered"
            break
        }

        # Amazon.CodeDeploy.RevisionLocationType
        {
            ($_ -eq "Get-CDApplicationRevision/Revision_RevisionType") -Or
            ($_ -eq "New-CDDeployment/Revision_RevisionType") -Or
            ($_ -eq "Register-CDApplicationRevision/Revision_RevisionType")
        }
        {
            $v = "AppSpecContent","GitHub","S3","String"
            break
        }

        # Amazon.CodeDeploy.SortOrder
        "Get-CDApplicationRevisionList/SortOrder"
        {
            $v = "ascending","descending"
            break
        }

        # Amazon.CodeDeploy.TrafficRoutingType
        "New-CDDeploymentConfig/TrafficRoutingConfig_Type"
        {
            $v = "AllAtOnce","TimeBasedCanary","TimeBasedLinear"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CD_map = @{
    "BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "ComputePlatform"=@("New-CDApplication","New-CDDeploymentConfig")
    "Deployed"=@("Get-CDApplicationRevisionList")
    "DeploymentStyle_DeploymentOption"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "DeploymentStyle_DeploymentType"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "DeploymentWaitType"=@("Resume-CDDeployment")
    "FileExistsBehavior"=@("New-CDDeployment")
    "MinimumHealthyHosts_Type"=@("New-CDDeploymentConfig")
    "OutdatedInstancesStrategy"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "RegistrationStatus"=@("Get-CDOnPremiseInstanceList")
    "Revision_RevisionType"=@("Get-CDApplicationRevision","New-CDDeployment","Register-CDApplicationRevision")
    "Revision_S3Location_BundleType"=@("Get-CDApplicationRevision","New-CDDeployment","Register-CDApplicationRevision")
    "SortBy"=@("Get-CDApplicationRevisionList")
    "SortOrder"=@("Get-CDApplicationRevisionList")
    "Status"=@("Write-CDLifecycleEventHookExecutionStatus")
    "TrafficRoutingConfig_Type"=@("New-CDDeploymentConfig")
}

_awsArgumentCompleterRegistration $CD_Completers $CD_map

$CD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CD_SelectMap = @{
    "Select"=@("Add-CDOnPremiseInstanceTag",
               "Get-CDApplicationRevisionBatch",
               "Get-CDApplicationBatch",
               "Get-CDDeploymentGroupBatch",
               "Get-CDDeploymentInstanceBatch",
               "Get-CDDeploymentBatch",
               "Get-CDDeploymentTargetBatch",
               "Get-CDOnPremiseInstanceBatch",
               "Resume-CDDeployment",
               "New-CDApplication",
               "New-CDDeployment",
               "New-CDDeploymentConfig",
               "New-CDDeploymentGroup",
               "Remove-CDApplication",
               "Remove-CDDeploymentConfig",
               "Remove-CDDeploymentGroup",
               "Remove-CDGitHubAccountToken",
               "Remove-CDResourcesByExternalId",
               "Unregister-CDOnPremiseInstance",
               "Get-CDApplication",
               "Get-CDApplicationRevision",
               "Get-CDDeployment",
               "Get-CDDeploymentConfig",
               "Get-CDDeploymentGroup",
               "Get-CDDeploymentInstance",
               "Get-CDDeploymentTarget",
               "Get-CDOnPremiseInstance",
               "Get-CDApplicationRevisionList",
               "Get-CDApplicationList",
               "Get-CDDeploymentConfigList",
               "Get-CDDeploymentGroupList",
               "Get-CDDeploymentInstanceList",
               "Get-CDDeploymentList",
               "Get-CDDeploymentTargetList",
               "Get-CDGitHubAccountTokenNameList",
               "Get-CDOnPremiseInstanceList",
               "Get-CDResourceTag",
               "Write-CDLifecycleEventHookExecutionStatus",
               "Register-CDApplicationRevision",
               "Register-CDOnPremiseInstance",
               "Remove-CDOnPremiseInstanceTag",
               "Skip-CDWaitTimeForInstanceTermination",
               "Stop-CDDeployment",
               "Add-CDResourceTag",
               "Remove-CDResourceTag",
               "Update-CDApplication",
               "Update-CDDeploymentGroup")
}

_awsArgumentCompleterRegistration $CD_SelectCompleters $CD_SelectMap
# Argument completions for service Amazon CodeGuru Profiler


$CGP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeGuruProfiler.ActionGroup
        {
            ($_ -eq "Remove-CGPPermission/ActionGroup") -Or
            ($_ -eq "Write-CGPPermission/ActionGroup")
        }
        {
            $v = "agentPermissions"
            break
        }

        # Amazon.CodeGuruProfiler.AggregationPeriod
        {
            ($_ -eq "Get-CGPProfileTimeList/Period") -Or
            ($_ -eq "Get-CGPGetFrameMetricData/TargetResolution")
        }
        {
            $v = "P1D","PT1H","PT5M"
            break
        }

        # Amazon.CodeGuruProfiler.ComputePlatform
        "New-CGPProfilingGroup/ComputePlatform"
        {
            $v = "AWSLambda","Default"
            break
        }

        # Amazon.CodeGuruProfiler.FeedbackType
        "Submit-CGPFeedback/Type"
        {
            $v = "Negative","Positive"
            break
        }

        # Amazon.CodeGuruProfiler.OrderBy
        "Get-CGPProfileTimeList/OrderBy"
        {
            $v = "TimestampAscending","TimestampDescending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGP_map = @{
    "ActionGroup"=@("Remove-CGPPermission","Write-CGPPermission")
    "ComputePlatform"=@("New-CGPProfilingGroup")
    "OrderBy"=@("Get-CGPProfileTimeList")
    "Period"=@("Get-CGPProfileTimeList")
    "TargetResolution"=@("Get-CGPGetFrameMetricData")
    "Type"=@("Submit-CGPFeedback")
}

_awsArgumentCompleterRegistration $CGP_Completers $CGP_map

$CGP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGP_SelectMap = @{
    "Select"=@("Add-CGPNotificationChannel",
               "Get-CGPGetFrameMetricData",
               "Set-CGPAgentConfiguration",
               "New-CGPProfilingGroup",
               "Remove-CGPProfilingGroup",
               "Get-CGPProfilingGroup",
               "Get-CGPFindingsReportAccountSummary",
               "Get-CGPNotificationConfiguration",
               "Get-CGPPolicy",
               "Get-CGPProfile",
               "Get-CGPRecommendation",
               "Get-CGPFindingsReportList",
               "Get-CGPProfileTimeList",
               "Get-CGPProfilingGroupList",
               "Get-CGPResourceTag",
               "Send-CGPAgentProfile",
               "Write-CGPPermission",
               "Remove-CGPNotificationChannel",
               "Remove-CGPPermission",
               "Submit-CGPFeedback",
               "Add-CGPResourceTag",
               "Remove-CGPResourceTag",
               "Update-CGPProfilingGroup")
}

_awsArgumentCompleterRegistration $CGP_SelectCompleters $CGP_SelectMap
# Argument completions for service Amazon CodeGuru Reviewer


$CGR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeGuruReviewer.EncryptionOption
        "Register-CGRRepository/KMSKeyDetails_EncryptionOption"
        {
            $v = "AWS_OWNED_CMK","CUSTOMER_MANAGED_CMK"
            break
        }

        # Amazon.CodeGuruReviewer.Type
        "Get-CGRCodeReviewList/Type"
        {
            $v = "PullRequest","RepositoryAnalysis"
            break
        }

        # Amazon.CodeGuruReviewer.VendorName
        "New-CGRCodeReview/Type_RepositoryAnalysis_SourceCodeType_RequestMetadata_VendorName"
        {
            $v = "GitHub","GitLab","NativeS3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGR_map = @{
    "KMSKeyDetails_EncryptionOption"=@("Register-CGRRepository")
    "Type"=@("Get-CGRCodeReviewList")
    "Type_RepositoryAnalysis_SourceCodeType_RequestMetadata_VendorName"=@("New-CGRCodeReview")
}

_awsArgumentCompleterRegistration $CGR_Completers $CGR_map

$CGR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGR_SelectMap = @{
    "Select"=@("Register-CGRRepository",
               "New-CGRCodeReview",
               "Get-CGRCodeReview",
               "Get-CGRRecommendationFeedback",
               "Get-CGRRepositoryAssociation",
               "Unregister-CGRRepository",
               "Get-CGRCodeReviewList",
               "Get-CGRRecommendationFeedbackList",
               "Get-CGRRecommendationList",
               "Get-CGRRepositoryAssociationList",
               "Get-CGRResourceTag",
               "Write-CGRRecommendationFeedback",
               "Add-CGRResourceTag",
               "Remove-CGRResourceTag")
}

_awsArgumentCompleterRegistration $CGR_SelectCompleters $CGR_SelectMap
# Argument completions for service AWS CodePipeline


$CP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodePipeline.ActionCategory
        {
            ($_ -eq "Update-CPActionType/ActionType_Id_Category") -Or
            ($_ -eq "Get-CPActionableJobList/ActionTypeId_Category") -Or
            ($_ -eq "Get-CPActionableThirdPartyJobList/ActionTypeId_Category") -Or
            ($_ -eq "Get-CPActionTypeDeclaration/Category") -Or
            ($_ -eq "New-CPCustomActionType/Category") -Or
            ($_ -eq "Remove-CPCustomActionType/Category")
        }
        {
            $v = "Approval","Build","Deploy","Invoke","Source","Test"
            break
        }

        # Amazon.CodePipeline.ActionOwner
        {
            ($_ -eq "Get-CPActionType/ActionOwnerFilter") -Or
            ($_ -eq "Get-CPActionableJobList/ActionTypeId_Owner") -Or
            ($_ -eq "Get-CPActionableThirdPartyJobList/ActionTypeId_Owner")
        }
        {
            $v = "AWS","Custom","ThirdParty"
            break
        }

        # Amazon.CodePipeline.ApprovalStatus
        "Write-CPApprovalResult/Result_Status"
        {
            $v = "Approved","Rejected"
            break
        }

        # Amazon.CodePipeline.ExecutorType
        "Update-CPActionType/ActionType_Executor_Type"
        {
            $v = "JobWorker","Lambda"
            break
        }

        # Amazon.CodePipeline.FailureType
        {
            ($_ -eq "Write-CPJobFailureResult/FailureDetails_Type") -Or
            ($_ -eq "Write-CPThirdPartyJobFailureResult/FailureDetails_Type")
        }
        {
            $v = "ConfigurationError","JobFailed","PermissionError","RevisionOutOfSync","RevisionUnavailable","SystemUnavailable"
            break
        }

        # Amazon.CodePipeline.StageRetryMode
        "Redo-CPStageExecution/RetryMode"
        {
            $v = "FAILED_ACTIONS"
            break
        }

        # Amazon.CodePipeline.StageTransitionType
        {
            ($_ -eq "Disable-CPStageTransition/TransitionType") -Or
            ($_ -eq "Enable-CPStageTransition/TransitionType")
        }
        {
            $v = "Inbound","Outbound"
            break
        }

        # Amazon.CodePipeline.WebhookAuthenticationType
        "Write-CPWebhook/Webhook_Authentication"
        {
            $v = "GITHUB_HMAC","IP","UNAUTHENTICATED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CP_map = @{
    "ActionOwnerFilter"=@("Get-CPActionType")
    "ActionType_Executor_Type"=@("Update-CPActionType")
    "ActionType_Id_Category"=@("Update-CPActionType")
    "ActionTypeId_Category"=@("Get-CPActionableJobList","Get-CPActionableThirdPartyJobList")
    "ActionTypeId_Owner"=@("Get-CPActionableJobList","Get-CPActionableThirdPartyJobList")
    "Category"=@("Get-CPActionTypeDeclaration","New-CPCustomActionType","Remove-CPCustomActionType")
    "FailureDetails_Type"=@("Write-CPJobFailureResult","Write-CPThirdPartyJobFailureResult")
    "Result_Status"=@("Write-CPApprovalResult")
    "RetryMode"=@("Redo-CPStageExecution")
    "TransitionType"=@("Disable-CPStageTransition","Enable-CPStageTransition")
    "Webhook_Authentication"=@("Write-CPWebhook")
}

_awsArgumentCompleterRegistration $CP_Completers $CP_map

$CP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CP_SelectMap = @{
    "Select"=@("Confirm-CPJob",
               "Confirm-CPThirdPartyJob",
               "New-CPCustomActionType",
               "New-CPPipeline",
               "Remove-CPCustomActionType",
               "Remove-CPPipeline",
               "Remove-CPWebhook",
               "Unregister-CPWebhookWithThirdParty",
               "Disable-CPStageTransition",
               "Enable-CPStageTransition",
               "Get-CPActionTypeDeclaration",
               "Get-CPJobDetail",
               "Get-CPPipeline",
               "Get-CPPipelineExecution",
               "Get-CPPipelineState",
               "Get-CPThirdPartyJobDetail",
               "Get-CPActionExecutionList",
               "Get-CPActionType",
               "Get-CPPipelineExecutionSummary",
               "Get-CPPipelineList",
               "Get-CPResourceTag",
               "Get-CPWebhookList",
               "Get-CPActionableJobList",
               "Get-CPActionableThirdPartyJobList",
               "Write-CPActionRevision",
               "Write-CPApprovalResult",
               "Write-CPJobFailureResult",
               "Write-CPJobSuccessResult",
               "Write-CPThirdPartyJobFailureResult",
               "Write-CPThirdPartyJobSuccessResult",
               "Write-CPWebhook",
               "Register-CPWebhookWithThirdParty",
               "Redo-CPStageExecution",
               "Start-CPPipelineExecution",
               "Stop-CPPipelineExecution",
               "Add-CPResourceTag",
               "Remove-CPResourceTag",
               "Update-CPActionType",
               "Update-CPPipeline")
}

_awsArgumentCompleterRegistration $CP_SelectCompleters $CP_SelectMap
# Argument completions for service AWS CodeStar


$CST_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CST.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CST_SelectMap = @{
    "Select"=@("Add-CSTTeamMember",
               "New-CSTProject",
               "New-CSTUserProfile",
               "Remove-CSTProject",
               "Remove-CSTUserProfile",
               "Get-CSTProject",
               "Get-CSTUserProfile",
               "Remove-CSTTeamMember",
               "Get-CSTProjectList",
               "Get-CSTResourceList",
               "Get-CSTTagsForProject",
               "Get-CSTTeamMemberList",
               "Get-CSTUserProfileList",
               "Add-CSTTagsForProject",
               "Remove-CSTTagsForProject",
               "Update-CSTProject",
               "Update-CSTTeamMember",
               "Update-CSTUserProfile")
}

_awsArgumentCompleterRegistration $CST_SelectCompleters $CST_SelectMap
# Argument completions for service AWS CodeStar Connections


$CSTC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeStarconnections.ProviderType
        {
            ($_ -eq "New-CSTCConnection/ProviderType") -Or
            ($_ -eq "New-CSTCHost/ProviderType") -Or
            ($_ -eq "Get-CSTCConnectionList/ProviderTypeFilter")
        }
        {
            $v = "Bitbucket","GitHub","GitHubEnterpriseServer"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTC_map = @{
    "ProviderType"=@("New-CSTCConnection","New-CSTCHost")
    "ProviderTypeFilter"=@("Get-CSTCConnectionList")
}

_awsArgumentCompleterRegistration $CSTC_Completers $CSTC_map

$CSTC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CSTC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTC_SelectMap = @{
    "Select"=@("New-CSTCConnection",
               "New-CSTCHost",
               "Remove-CSTCConnection",
               "Remove-CSTCHost",
               "Get-CSTCConnection",
               "Get-CSTCHost",
               "Get-CSTCConnectionList",
               "Get-CSTCHostList",
               "Get-CSTCResourceTagList",
               "Add-CSTCResourceTag",
               "Remove-CSTCResourceTag",
               "Update-CSTCHost")
}

_awsArgumentCompleterRegistration $CSTC_SelectCompleters $CSTC_SelectMap
# Argument completions for service AWS CodeStar Notifications


$CSTN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeStarNotifications.DetailType
        {
            ($_ -eq "New-CSTNNotificationRule/DetailType") -Or
            ($_ -eq "Update-CSTNNotificationRule/DetailType")
        }
        {
            $v = "BASIC","FULL"
            break
        }

        # Amazon.CodeStarNotifications.NotificationRuleStatus
        {
            ($_ -eq "New-CSTNNotificationRule/Status") -Or
            ($_ -eq "Update-CSTNNotificationRule/Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTN_map = @{
    "DetailType"=@("New-CSTNNotificationRule","Update-CSTNNotificationRule")
    "Status"=@("New-CSTNNotificationRule","Update-CSTNNotificationRule")
}

_awsArgumentCompleterRegistration $CSTN_Completers $CSTN_map

$CSTN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CSTN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTN_SelectMap = @{
    "Select"=@("New-CSTNNotificationRule",
               "Remove-CSTNNotificationRule",
               "Remove-CSTNTarget",
               "Get-CSTNNotificationRule",
               "Get-CSTNEventTypeList",
               "Get-CSTNNotificationRuleList",
               "Get-CSTNResourceTag",
               "Get-CSTNTargetList",
               "Add-CSTNSubscription",
               "Add-CSTNResourceTag",
               "Remove-CSTNSubscription",
               "Remove-CSTNResourceTag",
               "Update-CSTNNotificationRule")
}

_awsArgumentCompleterRegistration $CSTN_SelectCompleters $CSTN_SelectMap
# Argument completions for service Amazon Cognito Identity


$CGI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGI_SelectMap = @{
    "Select"=@("New-CGIIdentityPool",
               "Remove-CGIIdentityPool",
               "Get-CGIIdentityPool",
               "Get-CGIIdentityPoolRole",
               "Get-CGIPrincipalTagAttributeMap",
               "Get-CGIIdentityPoolList",
               "Get-CGIResourceTag",
               "Set-CGIIdentityPoolRole",
               "Set-CGIPrincipalTagAttributeMap",
               "Add-CGIResourceTag",
               "Remove-CGIResourceTag",
               "Update-CGIIdentityPool")
}

_awsArgumentCompleterRegistration $CGI_SelectCompleters $CGI_SelectMap
# Argument completions for service Amazon Cognito Identity Provider


$CGIP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CognitoIdentityProvider.AccountTakeoverEventActionType
        {
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_HighAction_EventAction") -Or
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_LowAction_EventAction") -Or
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_MediumAction_EventAction")
        }
        {
            $v = "BLOCK","MFA_IF_CONFIGURED","MFA_REQUIRED","NO_ACTION"
            break
        }

        # Amazon.CognitoIdentityProvider.AdvancedSecurityModeType
        {
            ($_ -eq "New-CGIPUserPool/UserPoolAddOns_AdvancedSecurityMode") -Or
            ($_ -eq "Update-CGIPUserPool/UserPoolAddOns_AdvancedSecurityMode")
        }
        {
            $v = "AUDIT","ENFORCED","OFF"
            break
        }

        # Amazon.CognitoIdentityProvider.AuthFlowType
        {
            ($_ -eq "Start-CGIPAuth/AuthFlow") -Or
            ($_ -eq "Start-CGIPAuthAdmin/AuthFlow")
        }
        {
            $v = "ADMIN_NO_SRP_AUTH","ADMIN_USER_PASSWORD_AUTH","CUSTOM_AUTH","REFRESH_TOKEN","REFRESH_TOKEN_AUTH","USER_PASSWORD_AUTH","USER_SRP_AUTH"
            break
        }

        # Amazon.CognitoIdentityProvider.ChallengeNameType
        {
            ($_ -eq "Send-CGIPAuthChallengeResponse/ChallengeName") -Or
            ($_ -eq "Send-CGIPAuthChallengeResponseAdmin/ChallengeName")
        }
        {
            $v = "ADMIN_NO_SRP_AUTH","CUSTOM_CHALLENGE","DEVICE_PASSWORD_VERIFIER","DEVICE_SRP_AUTH","MFA_SETUP","NEW_PASSWORD_REQUIRED","PASSWORD_VERIFIER","SELECT_MFA_TYPE","SMS_MFA","SOFTWARE_TOKEN_MFA"
            break
        }

        # Amazon.CognitoIdentityProvider.CompromisedCredentialsEventActionType
        "Set-CGIPRiskConfiguration/CompromisedCredentialsRiskConfiguration_Actions_EventAction"
        {
            $v = "BLOCK","NO_ACTION"
            break
        }

        # Amazon.CognitoIdentityProvider.CustomEmailSenderLambdaVersionType
        {
            ($_ -eq "New-CGIPUserPool/LambdaConfig_CustomEmailSender_LambdaVersion") -Or
            ($_ -eq "Update-CGIPUserPool/LambdaConfig_CustomEmailSender_LambdaVersion")
        }
        {
            $v = "V1_0"
            break
        }

        # Amazon.CognitoIdentityProvider.CustomSMSSenderLambdaVersionType
        {
            ($_ -eq "New-CGIPUserPool/LambdaConfig_CustomSMSSender_LambdaVersion") -Or
            ($_ -eq "Update-CGIPUserPool/LambdaConfig_CustomSMSSender_LambdaVersion")
        }
        {
            $v = "V1_0"
            break
        }

        # Amazon.CognitoIdentityProvider.DefaultEmailOptionType
        {
            ($_ -eq "New-CGIPUserPool/VerificationMessageTemplate_DefaultEmailOption") -Or
            ($_ -eq "Update-CGIPUserPool/VerificationMessageTemplate_DefaultEmailOption")
        }
        {
            $v = "CONFIRM_WITH_CODE","CONFIRM_WITH_LINK"
            break
        }

        # Amazon.CognitoIdentityProvider.DeletionProtectionType
        {
            ($_ -eq "New-CGIPUserPool/DeletionProtection") -Or
            ($_ -eq "Update-CGIPUserPool/DeletionProtection")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.CognitoIdentityProvider.DeviceRememberedStatusType
        {
            ($_ -eq "Edit-CGIPDeviceStatus/DeviceRememberedStatus") -Or
            ($_ -eq "Edit-CGIPDeviceStatusAdmin/DeviceRememberedStatus")
        }
        {
            $v = "not_remembered","remembered"
            break
        }

        # Amazon.CognitoIdentityProvider.EmailSendingAccountType
        {
            ($_ -eq "New-CGIPUserPool/EmailConfiguration_EmailSendingAccount") -Or
            ($_ -eq "Update-CGIPUserPool/EmailConfiguration_EmailSendingAccount")
        }
        {
            $v = "COGNITO_DEFAULT","DEVELOPER"
            break
        }

        # Amazon.CognitoIdentityProvider.FeedbackValueType
        {
            ($_ -eq "Update-CGIPAuthEventFeedback/FeedbackValue") -Or
            ($_ -eq "Update-CGIPAuthEventFeedbackAdmin/FeedbackValue")
        }
        {
            $v = "Invalid","Valid"
            break
        }

        # Amazon.CognitoIdentityProvider.IdentityProviderTypeType
        "New-CGIPIdentityProvider/ProviderType"
        {
            $v = "Facebook","Google","LoginWithAmazon","OIDC","SAML","SignInWithApple"
            break
        }

        # Amazon.CognitoIdentityProvider.MessageActionType
        "New-CGIPUserAdmin/MessageAction"
        {
            $v = "RESEND","SUPPRESS"
            break
        }

        # Amazon.CognitoIdentityProvider.PreventUserExistenceErrorTypes
        {
            ($_ -eq "New-CGIPUserPoolClient/PreventUserExistenceErrors") -Or
            ($_ -eq "Update-CGIPUserPoolClient/PreventUserExistenceErrors")
        }
        {
            $v = "ENABLED","LEGACY"
            break
        }

        # Amazon.CognitoIdentityProvider.TimeUnitsType
        {
            ($_ -eq "New-CGIPUserPoolClient/TokenValidityUnits_AccessToken") -Or
            ($_ -eq "Update-CGIPUserPoolClient/TokenValidityUnits_AccessToken") -Or
            ($_ -eq "New-CGIPUserPoolClient/TokenValidityUnits_IdToken") -Or
            ($_ -eq "Update-CGIPUserPoolClient/TokenValidityUnits_IdToken") -Or
            ($_ -eq "New-CGIPUserPoolClient/TokenValidityUnits_RefreshToken") -Or
            ($_ -eq "Update-CGIPUserPoolClient/TokenValidityUnits_RefreshToken")
        }
        {
            $v = "days","hours","minutes","seconds"
            break
        }

        # Amazon.CognitoIdentityProvider.UserPoolMfaType
        {
            ($_ -eq "New-CGIPUserPool/MfaConfiguration") -Or
            ($_ -eq "Set-CGIPUserPoolMfaConfig/MfaConfiguration") -Or
            ($_ -eq "Update-CGIPUserPool/MfaConfiguration")
        }
        {
            $v = "OFF","ON","OPTIONAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIP_map = @{
    "AccountTakeoverRiskConfiguration_Actions_HighAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AccountTakeoverRiskConfiguration_Actions_LowAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AccountTakeoverRiskConfiguration_Actions_MediumAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AuthFlow"=@("Start-CGIPAuth","Start-CGIPAuthAdmin")
    "ChallengeName"=@("Send-CGIPAuthChallengeResponse","Send-CGIPAuthChallengeResponseAdmin")
    "CompromisedCredentialsRiskConfiguration_Actions_EventAction"=@("Set-CGIPRiskConfiguration")
    "DeletionProtection"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "DeviceRememberedStatus"=@("Edit-CGIPDeviceStatus","Edit-CGIPDeviceStatusAdmin")
    "EmailConfiguration_EmailSendingAccount"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "FeedbackValue"=@("Update-CGIPAuthEventFeedback","Update-CGIPAuthEventFeedbackAdmin")
    "LambdaConfig_CustomEmailSender_LambdaVersion"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "LambdaConfig_CustomSMSSender_LambdaVersion"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "MessageAction"=@("New-CGIPUserAdmin")
    "MfaConfiguration"=@("New-CGIPUserPool","Set-CGIPUserPoolMfaConfig","Update-CGIPUserPool")
    "PreventUserExistenceErrors"=@("New-CGIPUserPoolClient","Update-CGIPUserPoolClient")
    "ProviderType"=@("New-CGIPIdentityProvider")
    "TokenValidityUnits_AccessToken"=@("New-CGIPUserPoolClient","Update-CGIPUserPoolClient")
    "TokenValidityUnits_IdToken"=@("New-CGIPUserPoolClient","Update-CGIPUserPoolClient")
    "TokenValidityUnits_RefreshToken"=@("New-CGIPUserPoolClient","Update-CGIPUserPoolClient")
    "UserPoolAddOns_AdvancedSecurityMode"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "VerificationMessageTemplate_DefaultEmailOption"=@("New-CGIPUserPool","Update-CGIPUserPool")
}

_awsArgumentCompleterRegistration $CGIP_Completers $CGIP_map

$CGIP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGIP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIP_SelectMap = @{
    "Select"=@("Add-CGIPCustomAttribute",
               "Add-CGIPUserToGroupAdmin",
               "Confirm-CGIPUserRegistrationAdmin",
               "New-CGIPUserAdmin",
               "Remove-CGIPUserAdmin",
               "Remove-CGIPUserAttributeAdmin",
               "Disable-CGIPProviderForUserAdmin",
               "Disable-CGIPUserAdmin",
               "Enable-CGIPUserAdmin",
               "Stop-CGIPDeviceTrackingAdmin",
               "Get-CGIPDeviceAdmin",
               "Get-CGIPUserAdmin",
               "Start-CGIPAuthAdmin",
               "Connect-CGIPProviderForUserAdmin",
               "Get-CGIPDeviceListAdmin",
               "Get-CGIPGroupsForUserAdmin",
               "Get-CGIPUserAuthEventListAdmin",
               "Remove-CGIPUserFromGroupAdmin",
               "Reset-CGIPUserPasswordAdmin",
               "Send-CGIPAuthChallengeResponseAdmin",
               "Set-CGIPUserMFAPreferenceAdmin",
               "Set-CGIPUserPasswordAdmin",
               "Set-CGIPUserSettingAdmin",
               "Update-CGIPAuthEventFeedbackAdmin",
               "Edit-CGIPDeviceStatusAdmin",
               "Update-CGIPUserAttributeAdmin",
               "Disconnect-CGIPUserGlobalAdmin",
               "Add-CGIPSoftwareToken",
               "Update-CGIPPassword",
               "Approve-CGIPDevice",
               "Confirm-CGIPForgotPassword",
               "Confirm-CGIPUserRegistration",
               "New-CGIPGroup",
               "New-CGIPIdentityProvider",
               "New-CGIPResourceServer",
               "New-CGIPUserImportJob",
               "New-CGIPUserPool",
               "New-CGIPUserPoolClient",
               "New-CGIPUserPoolDomain",
               "Remove-CGIPGroup",
               "Remove-CGIPIdentityProvider",
               "Remove-CGIPResourceServer",
               "Remove-CGIPUser",
               "Remove-CGIPUserAttribute",
               "Remove-CGIPUserPool",
               "Remove-CGIPUserPoolClient",
               "Remove-CGIPUserPoolDomain",
               "Get-CGIPIdentityProvider",
               "Get-CGIPResourceServer",
               "Get-CGIPRiskConfiguration",
               "Get-CGIPUserImportJob",
               "Get-CGIPUserPool",
               "Get-CGIPUserPoolClient",
               "Get-CGIPUserPoolDomain",
               "Stop-CGIPDeviceTracking",
               "Reset-CGIPForgottenPassword",
               "Get-CGIPCSVHeader",
               "Get-CGIPDevice",
               "Get-CGIPGroup",
               "Get-CGIPIdentityProviderByIdentifier",
               "Get-CGIPSigningCertificate",
               "Get-CGIPUICustomization",
               "Get-CGIPUser",
               "Get-CGIPUserAttributeVerificationCode",
               "Get-CGIPUserPoolMfaConfig",
               "Disconnect-CGIPDeviceGlobal",
               "Start-CGIPAuth",
               "Get-CGIPDeviceList",
               "Get-CGIPGroupList",
               "Get-CGIPIdentityProviderList",
               "Get-CGIPResourceServerList",
               "Get-CGIPResourceTag",
               "Get-CGIPUserImportJobList",
               "Get-CGIPUserPoolClientList",
               "Get-CGIPUserPoolList",
               "Get-CGIPUserList",
               "Get-CGIPUsersInGroup",
               "Send-CGIPConfirmationCode",
               "Send-CGIPAuthChallengeResponse",
               "Revoke-CGIPToken",
               "Set-CGIPRiskConfiguration",
               "Set-CGIPUICustomization",
               "Set-CGIPUserMFAPreference",
               "Set-CGIPUserPoolMfaConfig",
               "Set-CGIPUserSetting",
               "Register-CGIPUserInPool",
               "Start-CGIPUserImportJob",
               "Stop-CGIPUserImportJob",
               "Add-CGIPResourceTag",
               "Remove-CGIPResourceTag",
               "Update-CGIPAuthEventFeedback",
               "Edit-CGIPDeviceStatus",
               "Update-CGIPGroup",
               "Update-CGIPIdentityProvider",
               "Update-CGIPResourceServer",
               "Update-CGIPUserAttribute",
               "Update-CGIPUserPool",
               "Update-CGIPUserPoolClient",
               "Update-CGIPUserPoolDomain",
               "Test-CGIPSoftwareToken",
               "Test-CGIPUserAttribute")
}

_awsArgumentCompleterRegistration $CGIP_SelectCompleters $CGIP_SelectMap
# Argument completions for service Amazon Cognito Sync


$CGIS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CognitoSync.Platform
        "Register-CGISDevice/Platform"
        {
            $v = "ADM","APNS","APNS_SANDBOX","GCM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIS_map = @{
    "Platform"=@("Register-CGISDevice")
}

_awsArgumentCompleterRegistration $CGIS_Completers $CGIS_map

$CGIS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGIS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIS_SelectMap = @{
    "Select"=@("Publish-CGISBulkDataset",
               "Remove-CGISDataset",
               "Get-CGISDataset",
               "Get-CGISIdentityPoolUsage",
               "Get-CGISIdentityUsage",
               "Get-CGISBulkPublishDetail",
               "Get-CGISCognitoEvent",
               "Get-CGISIdentityPoolConfiguration",
               "Get-CGISDatasetList",
               "Get-CGISIdentityPoolUsageList",
               "Get-CGISRecordList",
               "Register-CGISDevice",
               "Set-CGISCognitoEventLambdaFunction",
               "Set-CGISIdentityPoolConfiguration",
               "Add-CGISDatasetSubscription",
               "Remove-CGISDatasetSubscription",
               "Update-CGISRecord")
}

_awsArgumentCompleterRegistration $CGIS_SelectCompleters $CGIS_SelectMap
# Argument completions for service Amazon Comprehend


$COMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Comprehend.DocumentClassifierDataFormat
        "New-COMPDocumentClassifier/InputDataConfig_DataFormat"
        {
            $v = "AUGMENTED_MANIFEST","COMPREHEND_CSV"
            break
        }

        # Amazon.Comprehend.DocumentClassifierMode
        "New-COMPDocumentClassifier/Mode"
        {
            $v = "MULTI_CLASS","MULTI_LABEL"
            break
        }

        # Amazon.Comprehend.EndpointStatus
        "Get-COMPEndpointList/Filter_Status"
        {
            $v = "CREATING","DELETING","FAILED","IN_SERVICE","UPDATING"
            break
        }

        # Amazon.Comprehend.EntityRecognizerDataFormat
        "New-COMPEntityRecognizer/InputDataConfig_DataFormat"
        {
            $v = "AUGMENTED_MANIFEST","COMPREHEND_CSV"
            break
        }

        # Amazon.Comprehend.InputFormat
        "New-COMPEntityRecognizer/InputDataConfig_Documents_InputFormat"
        {
            $v = "ONE_DOC_PER_FILE","ONE_DOC_PER_LINE"
            break
        }

        # Amazon.Comprehend.JobStatus
        {
            ($_ -eq "Get-COMPDocumentClassificationJobList/Filter_JobStatus") -Or
            ($_ -eq "Get-COMPEventsDetectionJobList/Filter_JobStatus") -Or
            ($_ -eq "Get-COMPTargetedSentimentDetectionJobList/Filter_JobStatus")
        }
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","STOPPED","STOP_REQUESTED","SUBMITTED"
            break
        }

        # Amazon.Comprehend.LanguageCode
        {
            ($_ -eq "Find-COMPEntity/LanguageCode") -Or
            ($_ -eq "Find-COMPEntityBatch/LanguageCode") -Or
            ($_ -eq "Find-COMPKeyPhrase/LanguageCode") -Or
            ($_ -eq "Find-COMPKeyPhrasesBatch/LanguageCode") -Or
            ($_ -eq "Find-COMPPiiEntity/LanguageCode") -Or
            ($_ -eq "Find-COMPPiiEntityType/LanguageCode") -Or
            ($_ -eq "Find-COMPSentiment/LanguageCode") -Or
            ($_ -eq "Find-COMPSentimentBatch/LanguageCode") -Or
            ($_ -eq "Find-COMPTargetedSentiment/LanguageCode") -Or
            ($_ -eq "Find-COMPTargetedSentimentBatch/LanguageCode") -Or
            ($_ -eq "New-COMPDocumentClassifier/LanguageCode") -Or
            ($_ -eq "New-COMPEntityRecognizer/LanguageCode") -Or
            ($_ -eq "Start-COMPEntitiesDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPEventsDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPKeyPhrasesDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPPiiEntitiesDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPSentimentDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPTargetedSentimentDetectionJob/LanguageCode")
        }
        {
            $v = "ar","de","en","es","fr","hi","it","ja","ko","pt","zh","zh-TW"
            break
        }

        # Amazon.Comprehend.ModelStatus
        {
            ($_ -eq "Get-COMPDocumentClassifierList/Filter_Status") -Or
            ($_ -eq "Get-COMPEntityRecognizerList/Filter_Status")
        }
        {
            $v = "DELETING","IN_ERROR","STOPPED","STOP_REQUESTED","SUBMITTED","TRAINED","TRAINING"
            break
        }

        # Amazon.Comprehend.PiiEntitiesDetectionMaskMode
        "Start-COMPPiiEntitiesDetectionJob/RedactionConfig_MaskMode"
        {
            $v = "MASK","REPLACE_WITH_PII_ENTITY_TYPE"
            break
        }

        # Amazon.Comprehend.PiiEntitiesDetectionMode
        "Start-COMPPiiEntitiesDetectionJob/Mode"
        {
            $v = "ONLY_OFFSETS","ONLY_REDACTION"
            break
        }

        # Amazon.Comprehend.SyntaxLanguageCode
        {
            ($_ -eq "Find-COMPSyntax/LanguageCode") -Or
            ($_ -eq "Find-COMPSyntaxBatch/LanguageCode")
        }
        {
            $v = "de","en","es","fr","it","pt"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$COMP_map = @{
    "Filter_JobStatus"=@("Get-COMPDocumentClassificationJobList","Get-COMPEventsDetectionJobList","Get-COMPTargetedSentimentDetectionJobList")
    "Filter_Status"=@("Get-COMPDocumentClassifierList","Get-COMPEndpointList","Get-COMPEntityRecognizerList")
    "InputDataConfig_DataFormat"=@("New-COMPDocumentClassifier","New-COMPEntityRecognizer")
    "InputDataConfig_Documents_InputFormat"=@("New-COMPEntityRecognizer")
    "LanguageCode"=@("Find-COMPEntity","Find-COMPEntityBatch","Find-COMPKeyPhrase","Find-COMPKeyPhrasesBatch","Find-COMPPiiEntity","Find-COMPPiiEntityType","Find-COMPSentiment","Find-COMPSentimentBatch","Find-COMPSyntax","Find-COMPSyntaxBatch","Find-COMPTargetedSentiment","Find-COMPTargetedSentimentBatch","New-COMPDocumentClassifier","New-COMPEntityRecognizer","Start-COMPEntitiesDetectionJob","Start-COMPEventsDetectionJob","Start-COMPKeyPhrasesDetectionJob","Start-COMPPiiEntitiesDetectionJob","Start-COMPSentimentDetectionJob","Start-COMPTargetedSentimentDetectionJob")
    "Mode"=@("New-COMPDocumentClassifier","Start-COMPPiiEntitiesDetectionJob")
    "RedactionConfig_MaskMode"=@("Start-COMPPiiEntitiesDetectionJob")
}

_awsArgumentCompleterRegistration $COMP_Completers $COMP_map

$COMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.COMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$COMP_SelectMap = @{
    "Select"=@("Find-COMPDominantLanguageBatch",
               "Find-COMPEntityBatch",
               "Find-COMPKeyPhrasesBatch",
               "Find-COMPSentimentBatch",
               "Find-COMPSyntaxBatch",
               "Find-COMPTargetedSentimentBatch",
               "Invoke-COMPDocumentClassification",
               "Find-COMPPiiEntityType",
               "New-COMPDocumentClassifier",
               "New-COMPEndpoint",
               "New-COMPEntityRecognizer",
               "Remove-COMPDocumentClassifier",
               "Remove-COMPEndpoint",
               "Remove-COMPEntityRecognizer",
               "Remove-COMPResourcePolicy",
               "Get-COMPDocumentClassificationJob",
               "Get-COMPDocumentClassifier",
               "Get-COMPDominantLanguageDetectionJob",
               "Get-COMPEndpoint",
               "Get-COMPEntitiesDetectionJob",
               "Get-COMPEntityRecognizer",
               "Get-COMPEventsDetectionJob",
               "Get-COMPKeyPhrasesDetectionJob",
               "Get-COMPPiiEntitiesDetectionJob",
               "Get-COMPResourcePolicy",
               "Get-COMPSentimentDetectionJob",
               "Get-COMPTargetedSentimentDetectionJob",
               "Get-COMPTopicsDetectionJob",
               "Find-COMPDominantLanguage",
               "Find-COMPEntity",
               "Find-COMPKeyPhrase",
               "Find-COMPPiiEntity",
               "Find-COMPSentiment",
               "Find-COMPSyntax",
               "Find-COMPTargetedSentiment",
               "Import-COMPModel",
               "Get-COMPDocumentClassificationJobList",
               "Get-COMPDocumentClassifierList",
               "Get-COMPDocumentClassifierSummaryList",
               "Get-COMPDominantLanguageDetectionJobList",
               "Get-COMPEndpointList",
               "Get-COMPEntitiesDetectionJobList",
               "Get-COMPEntityRecognizerList",
               "Get-COMPEntityRecognizerSummaryList",
               "Get-COMPEventsDetectionJobList",
               "Get-COMPKeyPhrasesDetectionJobList",
               "Get-COMPPiiEntitiesDetectionJobList",
               "Get-COMPSentimentDetectionJobList",
               "Get-COMPResourceTag",
               "Get-COMPTargetedSentimentDetectionJobList",
               "Get-COMPTopicsDetectionJobList",
               "Write-COMPResourcePolicy",
               "Start-COMPDocumentClassificationJob",
               "Start-COMPDominantLanguageDetectionJob",
               "Start-COMPEntitiesDetectionJob",
               "Start-COMPEventsDetectionJob",
               "Start-COMPKeyPhrasesDetectionJob",
               "Start-COMPPiiEntitiesDetectionJob",
               "Start-COMPSentimentDetectionJob",
               "Start-COMPTargetedSentimentDetectionJob",
               "Start-COMPTopicsDetectionJob",
               "Stop-COMPDominantLanguageDetectionJob",
               "Stop-COMPEntitiesDetectionJob",
               "Stop-COMPEventsDetectionJob",
               "Stop-COMPKeyPhrasesDetectionJob",
               "Stop-COMPPiiEntitiesDetectionJob",
               "Stop-COMPSentimentDetectionJob",
               "Stop-COMPTargetedSentimentDetectionJob",
               "Stop-COMPTrainingDocumentClassifier",
               "Stop-COMPTrainingEntityRecognizer",
               "Add-COMPResourceTag",
               "Remove-COMPResourceTag",
               "Update-COMPEndpoint")
}

_awsArgumentCompleterRegistration $COMP_SelectCompleters $COMP_SelectMap
# Argument completions for service AWS Comprehend Medical


$CMPM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ComprehendMedical.JobStatus
        {
            ($_ -eq "Get-CMPMEntitiesDetectionV2JobList/Filter_JobStatus") -Or
            ($_ -eq "Get-CMPMICD10CMInferenceJobList/Filter_JobStatus") -Or
            ($_ -eq "Get-CMPMPersonalHealthInformationDetectionJobList/Filter_JobStatus") -Or
            ($_ -eq "Get-CMPMRxNormInferenceJobList/Filter_JobStatus") -Or
            ($_ -eq "Get-CMPMSNOMEDCTInferenceJobList/Filter_JobStatus")
        }
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","PARTIAL_SUCCESS","STOPPED","STOP_REQUESTED","SUBMITTED"
            break
        }

        # Amazon.ComprehendMedical.LanguageCode
        {
            ($_ -eq "Start-CMPMEntitiesDetectionV2Job/LanguageCode") -Or
            ($_ -eq "Start-CMPMICD10CMInferenceJob/LanguageCode") -Or
            ($_ -eq "Start-CMPMPersonalHealthInformationDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-CMPMRxNormInferenceJob/LanguageCode") -Or
            ($_ -eq "Start-CMPMSNOMEDCTInferenceJob/LanguageCode")
        }
        {
            $v = "en"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CMPM_map = @{
    "Filter_JobStatus"=@("Get-CMPMEntitiesDetectionV2JobList","Get-CMPMICD10CMInferenceJobList","Get-CMPMPersonalHealthInformationDetectionJobList","Get-CMPMRxNormInferenceJobList","Get-CMPMSNOMEDCTInferenceJobList")
    "LanguageCode"=@("Start-CMPMEntitiesDetectionV2Job","Start-CMPMICD10CMInferenceJob","Start-CMPMPersonalHealthInformationDetectionJob","Start-CMPMRxNormInferenceJob","Start-CMPMSNOMEDCTInferenceJob")
}

_awsArgumentCompleterRegistration $CMPM_Completers $CMPM_map

$CMPM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CMPM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CMPM_SelectMap = @{
    "Select"=@("Get-CMPMEntitiesDetectionV2Job",
               "Get-CMPMICD10CMInferenceJob",
               "Get-CMPMPersonalHealthInformationDetectionJob",
               "Get-CMPMRxNormInferenceJob",
               "Get-CMPMSNOMEDCTInferenceJob",
               "Find-CMPMMedicalEntity",
               "Find-CMPMMedicalEntityV2",
               "Find-CMPMPersonalHealthInformation",
               "Find-CMPMICD10CM",
               "Find-CMPMRxNorm",
               "Find-CMPMSNOMEDCT",
               "Get-CMPMEntitiesDetectionV2JobList",
               "Get-CMPMICD10CMInferenceJobList",
               "Get-CMPMPersonalHealthInformationDetectionJobList",
               "Get-CMPMRxNormInferenceJobList",
               "Get-CMPMSNOMEDCTInferenceJobList",
               "Start-CMPMEntitiesDetectionV2Job",
               "Start-CMPMICD10CMInferenceJob",
               "Start-CMPMPersonalHealthInformationDetectionJob",
               "Start-CMPMRxNormInferenceJob",
               "Start-CMPMSNOMEDCTInferenceJob",
               "Stop-CMPMEntitiesDetectionV2Job",
               "Stop-CMPMICD10CMInferenceJob",
               "Stop-CMPMPersonalHealthInformationDetectionJob",
               "Stop-CMPMRxNormInferenceJob",
               "Stop-CMPMSNOMEDCTInferenceJob")
}

_awsArgumentCompleterRegistration $CMPM_SelectCompleters $CMPM_SelectMap
# Argument completions for service AWS Compute Optimizer


$CO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ComputeOptimizer.EnhancedInfrastructureMetrics
        "Write-CORecommendationPreference/EnhancedInfrastructureMetrics"
        {
            $v = "Active","Inactive"
            break
        }

        # Amazon.ComputeOptimizer.FileFormat
        {
            ($_ -eq "Export-COAutoScalingGroupRecommendation/FileFormat") -Or
            ($_ -eq "Export-COEBSVolumeRecommendation/FileFormat") -Or
            ($_ -eq "Export-COEC2InstanceRecommendation/FileFormat") -Or
            ($_ -eq "Export-COLambdaFunctionRecommendation/FileFormat")
        }
        {
            $v = "Csv"
            break
        }

        # Amazon.ComputeOptimizer.InferredWorkloadTypesPreference
        "Write-CORecommendationPreference/InferredWorkloadTypes"
        {
            $v = "Active","Inactive"
            break
        }

        # Amazon.ComputeOptimizer.MetricStatistic
        "Get-COEC2RecommendationProjectedMetric/Stat"
        {
            $v = "Average","Maximum"
            break
        }

        # Amazon.ComputeOptimizer.ResourceType
        {
            ($_ -eq "Get-CORecommendationPreference/ResourceType") -Or
            ($_ -eq "Remove-CORecommendationPreference/ResourceType") -Or
            ($_ -eq "Write-CORecommendationPreference/ResourceType")
        }
        {
            $v = "AutoScalingGroup","EbsVolume","Ec2Instance","LambdaFunction","NotApplicable"
            break
        }

        # Amazon.ComputeOptimizer.ScopeName
        {
            ($_ -eq "Get-CORecommendationPreference/Scope_Name") -Or
            ($_ -eq "Remove-CORecommendationPreference/Scope_Name") -Or
            ($_ -eq "Write-CORecommendationPreference/Scope_Name")
        }
        {
            $v = "AccountId","Organization","ResourceArn"
            break
        }

        # Amazon.ComputeOptimizer.Status
        "Update-COEnrollmentStatus/Status"
        {
            $v = "Active","Failed","Inactive","Pending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CO_map = @{
    "EnhancedInfrastructureMetrics"=@("Write-CORecommendationPreference")
    "FileFormat"=@("Export-COAutoScalingGroupRecommendation","Export-COEBSVolumeRecommendation","Export-COEC2InstanceRecommendation","Export-COLambdaFunctionRecommendation")
    "InferredWorkloadTypes"=@("Write-CORecommendationPreference")
    "ResourceType"=@("Get-CORecommendationPreference","Remove-CORecommendationPreference","Write-CORecommendationPreference")
    "Scope_Name"=@("Get-CORecommendationPreference","Remove-CORecommendationPreference","Write-CORecommendationPreference")
    "Stat"=@("Get-COEC2RecommendationProjectedMetric")
    "Status"=@("Update-COEnrollmentStatus")
}

_awsArgumentCompleterRegistration $CO_Completers $CO_map

$CO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CO_SelectMap = @{
    "Select"=@("Remove-CORecommendationPreference",
               "Get-CORecommendationExportJob",
               "Export-COAutoScalingGroupRecommendation",
               "Export-COEBSVolumeRecommendation",
               "Export-COEC2InstanceRecommendation",
               "Export-COLambdaFunctionRecommendation",
               "Get-COAutoScalingGroupRecommendation",
               "Get-COEBSVolumeRecommendation",
               "Get-COEC2InstanceRecommendation",
               "Get-COEC2RecommendationProjectedMetric",
               "Get-COEffectiveRecommendationPreference",
               "Get-COEnrollmentStatus",
               "Get-COEnrollmentStatusesForOrganization",
               "Get-COLambdaFunctionRecommendation",
               "Get-CORecommendationPreference",
               "Get-CORecommendationSummary",
               "Write-CORecommendationPreference",
               "Update-COEnrollmentStatus")
}

_awsArgumentCompleterRegistration $CO_SelectCompleters $CO_SelectMap
# Argument completions for service AWS Config


$CFG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConfigService.AggregateConformancePackComplianceSummaryGroupKey
        "Get-CFGAggregateConformancePackComplianceSummary/GroupByKey"
        {
            $v = "ACCOUNT_ID","AWS_REGION"
            break
        }

        # Amazon.ConfigService.ChronologicalOrder
        "Get-CFGResourceConfigHistory/ChronologicalOrder"
        {
            $v = "Forward","Reverse"
            break
        }

        # Amazon.ConfigService.ComplianceType
        {
            ($_ -eq "Get-CFGAggregateComplianceDetailsByConfigRule/ComplianceType") -Or
            ($_ -eq "Write-CFGExternalEvaluation/ExternalEvaluation_ComplianceType") -Or
            ($_ -eq "Get-CFGAggregateComplianceByConfigRuleList/Filters_ComplianceType")
        }
        {
            $v = "COMPLIANT","INSUFFICIENT_DATA","NON_COMPLIANT","NOT_APPLICABLE"
            break
        }

        # Amazon.ConfigService.ConfigRuleComplianceSummaryGroupKey
        "Get-CFGAggregateConfigRuleComplianceSummary/GroupByKey"
        {
            $v = "ACCOUNT_ID","AWS_REGION"
            break
        }

        # Amazon.ConfigService.ConfigRuleState
        "Write-CFGConfigRule/ConfigRule_ConfigRuleState"
        {
            $v = "ACTIVE","DELETING","DELETING_RESULTS","EVALUATING"
            break
        }

        # Amazon.ConfigService.ConformancePackComplianceType
        {
            ($_ -eq "Get-CFGAggregateComplianceByConformancePack/Filters_ComplianceType") -Or
            ($_ -eq "Get-CFGConformancePackCompliance/Filters_ComplianceType") -Or
            ($_ -eq "Get-CFGConformancePackComplianceDetail/Filters_ComplianceType")
        }
        {
            $v = "COMPLIANT","INSUFFICIENT_DATA","NON_COMPLIANT"
            break
        }

        # Amazon.ConfigService.MaximumExecutionFrequency
        {
            ($_ -eq "Write-CFGConfigRule/ConfigRule_MaximumExecutionFrequency") -Or
            ($_ -eq "Write-CFGDeliveryChannel/DeliveryChannel_ConfigSnapshotDeliveryProperties_DeliveryFrequency") -Or
            ($_ -eq "Write-CFGOrganizationConfigRule/OrganizationCustomPolicyRuleMetadata_MaximumExecutionFrequency") -Or
            ($_ -eq "Write-CFGOrganizationConfigRule/OrganizationCustomRuleMetadata_MaximumExecutionFrequency") -Or
            ($_ -eq "Write-CFGOrganizationConfigRule/OrganizationManagedRuleMetadata_MaximumExecutionFrequency")
        }
        {
            $v = "One_Hour","Six_Hours","Three_Hours","Twelve_Hours","TwentyFour_Hours"
            break
        }

        # Amazon.ConfigService.MemberAccountRuleStatus
        "Get-CFGOrganizationConfigRuleDetailedStatus/Filters_MemberAccountRuleStatus"
        {
            $v = "CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_SUCCESSFUL","DELETE_FAILED","DELETE_IN_PROGRESS","DELETE_SUCCESSFUL","UPDATE_FAILED","UPDATE_IN_PROGRESS","UPDATE_SUCCESSFUL"
            break
        }

        # Amazon.ConfigService.OrganizationResourceDetailedStatus
        "Get-CFGOrganizationConformancePackDetailedStatus/Filters_Status"
        {
            $v = "CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_SUCCESSFUL","DELETE_FAILED","DELETE_IN_PROGRESS","DELETE_SUCCESSFUL","UPDATE_FAILED","UPDATE_IN_PROGRESS","UPDATE_SUCCESSFUL"
            break
        }

        # Amazon.ConfigService.Owner
        "Write-CFGConfigRule/ConfigRule_Source_Owner"
        {
            $v = "AWS","CUSTOM_LAMBDA","CUSTOM_POLICY"
            break
        }

        # Amazon.ConfigService.ResourceCountGroupKey
        "Get-CFGAggregateDiscoveredResourceCount/GroupByKey"
        {
            $v = "ACCOUNT_ID","AWS_REGION","RESOURCE_TYPE"
            break
        }

        # Amazon.ConfigService.ResourceType
        {
            ($_ -eq "Get-CFGAggregateDiscoveredResourceCount/Filters_ResourceType") -Or
            ($_ -eq "Get-CFGAggregateResourceConfig/ResourceIdentifier_ResourceType") -Or
            ($_ -eq "Get-CFGAggregateDiscoveredResourceList/ResourceType") -Or
            ($_ -eq "Get-CFGDiscoveredResource/ResourceType") -Or
            ($_ -eq "Get-CFGResourceConfigHistory/ResourceType")
        }
        {
            $v = "AWS::AccessAnalyzer::Analyzer","AWS::ACM::Certificate","AWS::ApiGateway::RestApi","AWS::ApiGateway::Stage","AWS::ApiGatewayV2::Api","AWS::ApiGatewayV2::Stage","AWS::AppConfig::Application","AWS::AppSync::GraphQLApi","AWS::Athena::DataCatalog","AWS::Athena::WorkGroup","AWS::AutoScaling::AutoScalingGroup","AWS::AutoScaling::LaunchConfiguration","AWS::AutoScaling::ScalingPolicy","AWS::AutoScaling::ScheduledAction","AWS::Backup::BackupPlan","AWS::Backup::BackupSelection","AWS::Backup::BackupVault","AWS::Backup::RecoveryPoint","AWS::Batch::ComputeEnvironment","AWS::Batch::JobQueue","AWS::CloudFormation::Stack","AWS::CloudFront::Distribution","AWS::CloudFront::StreamingDistribution","AWS::CloudTrail::Trail","AWS::CloudWatch::Alarm","AWS::CodeBuild::Project","AWS::CodeDeploy::Application","AWS::CodeDeploy::DeploymentConfig","AWS::CodeDeploy::DeploymentGroup","AWS::CodePipeline::Pipeline","AWS::Config::ConformancePackCompliance","AWS::Config::ResourceCompliance","AWS::DataSync::LocationEFS","AWS::DataSync::LocationFSxLustre","AWS::DataSync::LocationNFS","AWS::DataSync::LocationS3","AWS::DataSync::LocationSMB","AWS::DataSync::Task","AWS::Detective::Graph","AWS::DMS::Certificate","AWS::DMS::EventSubscription","AWS::DMS::ReplicationSubnetGroup","AWS::DynamoDB::Table","AWS::EC2::CustomerGateway","AWS::EC2::EgressOnlyInternetGateway","AWS::EC2::EIP","AWS::EC2::FlowLog","AWS::EC2::Host","AWS::EC2::Instance","AWS::EC2::InternetGateway","AWS::EC2::LaunchTemplate","AWS::EC2::NatGateway","AWS::EC2::NetworkAcl","AWS::EC2::NetworkInsightsAccessScopeAnalysis","AWS::EC2::NetworkInterface","AWS::EC2::RegisteredHAInstance","AWS::EC2::RouteTable","AWS::EC2::SecurityGroup","AWS::EC2::Subnet","AWS::EC2::TransitGateway","AWS::EC2::TransitGatewayAttachment","AWS::EC2::TransitGatewayRouteTable","AWS::EC2::Volume","AWS::EC2::VPC","AWS::EC2::VPCEndpoint","AWS::EC2::VPCEndpointService","AWS::EC2::VPCPeeringConnection","AWS::EC2::VPNConnection","AWS::EC2::VPNGateway","AWS::ECR::PublicRepository","AWS::ECR::Repository","AWS::ECS::Cluster","AWS::ECS::Service","AWS::ECS::TaskDefinition","AWS::EFS::AccessPoint","AWS::EFS::FileSystem","AWS::EKS::Cluster","AWS::EKS::FargateProfile","AWS::ElasticBeanstalk::Application","AWS::ElasticBeanstalk::ApplicationVersion","AWS::ElasticBeanstalk::Environment","AWS::ElasticLoadBalancing::LoadBalancer","AWS::ElasticLoadBalancingV2::Listener","AWS::ElasticLoadBalancingV2::LoadBalancer","AWS::Elasticsearch::Domain","AWS::EMR::SecurityConfiguration","AWS::GlobalAccelerator::Accelerator","AWS::GlobalAccelerator::EndpointGroup","AWS::GlobalAccelerator::Listener","AWS::Glue::Job","AWS::GuardDuty::Detector","AWS::GuardDuty::IPSet","AWS::GuardDuty::ThreatIntelSet","AWS::IAM::Group","AWS::IAM::Policy","AWS::IAM::Role","AWS::IAM::User","AWS::Kinesis::Stream","AWS::Kinesis::StreamConsumer","AWS::KMS::Key","AWS::Lambda::Function","AWS::MSK::Cluster","AWS::NetworkFirewall::Firewall","AWS::NetworkFirewall::FirewallPolicy","AWS::NetworkFirewall::RuleGroup","AWS::OpenSearch::Domain","AWS::QLDB::Ledger","AWS::RDS::DBCluster","AWS::RDS::DBClusterSnapshot","AWS::RDS::DBInstance","AWS::RDS::DBSecurityGroup","AWS::RDS::DBSnapshot","AWS::RDS::DBSubnetGroup","AWS::RDS::EventSubscription","AWS::Redshift::Cluster","AWS::Redshift::ClusterParameterGroup","AWS::Redshift::ClusterSecurityGroup","AWS::Redshift::ClusterSnapshot","AWS::Redshift::ClusterSubnetGroup","AWS::Redshift::EventSubscription","AWS::Route53::HostedZone","AWS::Route53Resolver::ResolverEndpoint","AWS::Route53Resolver::ResolverRule","AWS::Route53Resolver::ResolverRuleAssociation","AWS::S3::AccountPublicAccessBlock","AWS::S3::Bucket","AWS::SageMaker::CodeRepository","AWS::SageMaker::Model","AWS::SageMaker::NotebookInstanceLifecycleConfig","AWS::SageMaker::Workteam","AWS::SecretsManager::Secret","AWS::ServiceCatalog::CloudFormationProduct","AWS::ServiceCatalog::CloudFormationProvisionedProduct","AWS::ServiceCatalog::Portfolio","AWS::ServiceDiscovery::PublicDnsNamespace","AWS::ServiceDiscovery::Service","AWS::SES::ConfigurationSet","AWS::SES::ContactList","AWS::Shield::Protection","AWS::ShieldRegional::Protection","AWS::SNS::Topic","AWS::SQS::Queue","AWS::SSM::AssociationCompliance","AWS::SSM::FileData","AWS::SSM::ManagedInstanceInventory","AWS::SSM::PatchCompliance","AWS::StepFunctions::Activity","AWS::StepFunctions::StateMachine","AWS::WAF::RateBasedRule","AWS::WAF::Rule","AWS::WAF::RuleGroup","AWS::WAF::WebACL","AWS::WAFRegional::RateBasedRule","AWS::WAFRegional::Rule","AWS::WAFRegional::RuleGroup","AWS::WAFRegional::WebACL","AWS::WAFv2::IPSet","AWS::WAFv2::ManagedRuleSet","AWS::WAFv2::RegexPatternSet","AWS::WAFv2::RuleGroup","AWS::WAFv2::WebACL","AWS::WorkSpaces::ConnectionAlias","AWS::WorkSpaces::Workspace","AWS::XRay::EncryptionConfig"
            break
        }

        # Amazon.ConfigService.SortBy
        "Get-CFGConformancePackComplianceScoreList/SortBy"
        {
            $v = "SCORE"
            break
        }

        # Amazon.ConfigService.SortOrder
        "Get-CFGConformancePackComplianceScoreList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFG_map = @{
    "ChronologicalOrder"=@("Get-CFGResourceConfigHistory")
    "ComplianceType"=@("Get-CFGAggregateComplianceDetailsByConfigRule")
    "ConfigRule_ConfigRuleState"=@("Write-CFGConfigRule")
    "ConfigRule_MaximumExecutionFrequency"=@("Write-CFGConfigRule")
    "ConfigRule_Source_Owner"=@("Write-CFGConfigRule")
    "DeliveryChannel_ConfigSnapshotDeliveryProperties_DeliveryFrequency"=@("Write-CFGDeliveryChannel")
    "ExternalEvaluation_ComplianceType"=@("Write-CFGExternalEvaluation")
    "Filters_ComplianceType"=@("Get-CFGAggregateComplianceByConfigRuleList","Get-CFGAggregateComplianceByConformancePack","Get-CFGConformancePackCompliance","Get-CFGConformancePackComplianceDetail")
    "Filters_MemberAccountRuleStatus"=@("Get-CFGOrganizationConfigRuleDetailedStatus")
    "Filters_ResourceType"=@("Get-CFGAggregateDiscoveredResourceCount")
    "Filters_Status"=@("Get-CFGOrganizationConformancePackDetailedStatus")
    "GroupByKey"=@("Get-CFGAggregateConfigRuleComplianceSummary","Get-CFGAggregateConformancePackComplianceSummary","Get-CFGAggregateDiscoveredResourceCount")
    "OrganizationCustomPolicyRuleMetadata_MaximumExecutionFrequency"=@("Write-CFGOrganizationConfigRule")
    "OrganizationCustomRuleMetadata_MaximumExecutionFrequency"=@("Write-CFGOrganizationConfigRule")
    "OrganizationManagedRuleMetadata_MaximumExecutionFrequency"=@("Write-CFGOrganizationConfigRule")
    "ResourceIdentifier_ResourceType"=@("Get-CFGAggregateResourceConfig")
    "ResourceType"=@("Get-CFGAggregateDiscoveredResourceList","Get-CFGDiscoveredResource","Get-CFGResourceConfigHistory")
    "SortBy"=@("Get-CFGConformancePackComplianceScoreList")
    "SortOrder"=@("Get-CFGConformancePackComplianceScoreList")
}

_awsArgumentCompleterRegistration $CFG_Completers $CFG_map

$CFG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CFG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFG_SelectMap = @{
    "Select"=@("Get-CFGAggregateResourceConfigBatch",
               "Get-CFGGetResourceConfigBatch",
               "Remove-CFGAggregationAuthorization",
               "Remove-CFGConfigRule",
               "Remove-CFGConfigurationAggregator",
               "Remove-CFGConfigurationRecorder",
               "Remove-CFGConformancePack",
               "Remove-CFGDeliveryChannel",
               "Remove-CFGEvaluationResult",
               "Remove-CFGOrganizationConfigRule",
               "Remove-CFGOrganizationConformancePack",
               "Remove-CFGPendingAggregationRequest",
               "Remove-CFGRemediationConfiguration",
               "Remove-CFGRemediationException",
               "Remove-CFGResourceConfig",
               "Remove-CFGRetentionConfiguration",
               "Remove-CFGStoredQuery",
               "Submit-CFGConfigSnapshotDelivery",
               "Get-CFGAggregateComplianceByConfigRuleList",
               "Get-CFGAggregateComplianceByConformancePack",
               "Get-CFGAggregationAuthorizationList",
               "Get-CFGComplianceByConfigRule",
               "Get-CFGComplianceByResource",
               "Get-CFGConfigRuleEvaluationStatus",
               "Get-CFGConfigRule",
               "Get-CFGConfigurationAggregatorList",
               "Get-CFGConfigurationAggregatorSourcesStatus",
               "Get-CFGConfigurationRecorder",
               "Get-CFGConfigurationRecorderStatus",
               "Get-CFGConformancePackCompliance",
               "Get-CFGConformancePack",
               "Get-CFGConformancePackStatus",
               "Get-CFGDeliveryChannel",
               "Get-CFGDeliveryChannelStatus",
               "Get-CFGOrganizationConfigRule",
               "Get-CFGOrganizationConfigRuleStatus",
               "Get-CFGOrganizationConformancePack",
               "Get-CFGOrganizationConformancePackStatus",
               "Get-CFGPendingAggregationRequestList",
               "Get-CFGRemediationConfiguration",
               "Get-CFGRemediationException",
               "Get-CFGRemediationExecutionStatus",
               "Get-CFGRetentionConfiguration",
               "Get-CFGAggregateComplianceDetailsByConfigRule",
               "Get-CFGAggregateConfigRuleComplianceSummary",
               "Get-CFGAggregateConformancePackComplianceSummary",
               "Get-CFGAggregateDiscoveredResourceCount",
               "Get-CFGAggregateResourceConfig",
               "Get-CFGComplianceDetailsByConfigRule",
               "Get-CFGComplianceDetailsByResource",
               "Get-CFGComplianceSummaryByConfigRule",
               "Get-CFGComplianceSummaryByResourceType",
               "Get-CFGConformancePackComplianceDetail",
               "Get-CFGConformancePackComplianceSummary",
               "Get-CFGCustomRulePolicy",
               "Get-CFGDiscoveredResourceCount",
               "Get-CFGOrganizationConfigRuleDetailedStatus",
               "Get-CFGOrganizationConformancePackDetailedStatus",
               "Get-CFGOrganizationCustomRulePolicy",
               "Get-CFGResourceConfigHistory",
               "Get-CFGStoredQuery",
               "Get-CFGAggregateDiscoveredResourceList",
               "Get-CFGConformancePackComplianceScoreList",
               "Get-CFGDiscoveredResource",
               "Get-CFGStoredQueryList",
               "Get-CFGResourceTag",
               "Write-CFGAggregationAuthorization",
               "Write-CFGConfigRule",
               "Write-CFGConfigurationAggregator",
               "Write-CFGConfigurationRecorder",
               "Write-CFGConformancePack",
               "Write-CFGDeliveryChannel",
               "Write-CFGEvaluation",
               "Write-CFGExternalEvaluation",
               "Write-CFGOrganizationConfigRule",
               "Write-CFGOrganizationConformancePack",
               "Write-CFGRemediationConfiguration",
               "Write-CFGRemediationException",
               "Write-CFGResourceConfig",
               "Write-CFGRetentionConfiguration",
               "Write-CFGStoredQuery",
               "Select-CFGAggregateResourceConfig",
               "Select-CFGResourceConfig",
               "Start-CFGConfigRulesEvaluation",
               "Start-CFGConfigurationRecorder",
               "Start-CFGRemediationExecution",
               "Stop-CFGConfigurationRecorder",
               "Add-CFGResourceTag",
               "Remove-CFGResourceTag")
}

_awsArgumentCompleterRegistration $CFG_SelectCompleters $CFG_SelectMap
# Argument completions for service Amazon Connect Service


$CONN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Connect.AgentStatusState
        {
            ($_ -eq "New-CONNAgentStatus/State") -Or
            ($_ -eq "Update-CONNAgentStatus/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Connect.ContactFlowModuleState
        {
            ($_ -eq "Get-CONNContactFlowModuleList/ContactFlowModuleState") -Or
            ($_ -eq "Update-CONNContactFlowModuleMetadata/State")
        }
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }

        # Amazon.Connect.ContactFlowState
        "Update-CONNContactFlowMetadata/ContactFlowState"
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }

        # Amazon.Connect.ContactFlowType
        "New-CONNContactFlow/Type"
        {
            $v = "AGENT_HOLD","AGENT_TRANSFER","AGENT_WHISPER","CONTACT_FLOW","CUSTOMER_HOLD","CUSTOMER_QUEUE","CUSTOMER_WHISPER","OUTBOUND_WHISPER","QUEUE_TRANSFER"
            break
        }

        # Amazon.Connect.DirectoryType
        "New-CONNInstance/IdentityManagementType"
        {
            $v = "CONNECT_MANAGED","EXISTING_DIRECTORY","SAML"
            break
        }

        # Amazon.Connect.EncryptionType
        {
            ($_ -eq "Add-CONNInstanceStorageConfig/StorageConfig_KinesisVideoStreamConfig_EncryptionConfig_EncryptionType") -Or
            ($_ -eq "Update-CONNInstanceStorageConfig/StorageConfig_KinesisVideoStreamConfig_EncryptionConfig_EncryptionType") -Or
            ($_ -eq "Add-CONNInstanceStorageConfig/StorageConfig_S3Config_EncryptionConfig_EncryptionType") -Or
            ($_ -eq "Update-CONNInstanceStorageConfig/StorageConfig_S3Config_EncryptionConfig_EncryptionType")
        }
        {
            $v = "KMS"
            break
        }

        # Amazon.Connect.HierarchyGroupMatchType
        "Search-CONNUser/SearchCriteria_HierarchyGroupCondition_HierarchyGroupMatchType"
        {
            $v = "EXACT","WITH_CHILD_GROUPS"
            break
        }

        # Amazon.Connect.InstanceAttributeType
        {
            ($_ -eq "Get-CONNInstanceAttribute/AttributeType") -Or
            ($_ -eq "Update-CONNInstanceAttribute/AttributeType")
        }
        {
            $v = "AUTO_RESOLVE_BEST_VOICES","CONTACTFLOW_LOGS","CONTACT_LENS","EARLY_MEDIA","ENHANCED_CONTACT_MONITORING","HIGH_VOLUME_OUTBOUND","INBOUND_CALLS","MULTI_PARTY_CONFERENCE","OUTBOUND_CALLS","USE_CUSTOM_TTS_VOICES"
            break
        }

        # Amazon.Connect.InstanceStorageResourceType
        {
            ($_ -eq "Add-CONNInstanceStorageConfig/ResourceType") -Or
            ($_ -eq "Get-CONNInstanceStorageConfig/ResourceType") -Or
            ($_ -eq "Get-CONNInstanceStorageConfigList/ResourceType") -Or
            ($_ -eq "Remove-CONNInstanceStorageConfig/ResourceType") -Or
            ($_ -eq "Update-CONNInstanceStorageConfig/ResourceType")
        }
        {
            $v = "AGENT_EVENTS","CALL_RECORDINGS","CHAT_TRANSCRIPTS","CONTACT_TRACE_RECORDS","MEDIA_STREAMS","REAL_TIME_CONTACT_ANALYSIS_SEGMENTS","SCHEDULED_REPORTS"
            break
        }

        # Amazon.Connect.IntegrationType
        {
            ($_ -eq "Get-CONNIntegrationAssociationList/IntegrationType") -Or
            ($_ -eq "New-CONNIntegrationAssociation/IntegrationType")
        }
        {
            $v = "CASES_DOMAIN","EVENT","PINPOINT_APP","VOICE_ID","WISDOM_ASSISTANT","WISDOM_KNOWLEDGE_BASE"
            break
        }

        # Amazon.Connect.LexVersion
        "Get-CONNBotList/LexVersion"
        {
            $v = "V1","V2"
            break
        }

        # Amazon.Connect.PhoneNumberCountryCode
        "Search-CONNAvailablePhoneNumber/PhoneNumberCountryCode"
        {
            $v = "AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AZ","BA","BB","BD","BE","BF","BG","BH","BI","BJ","BL","BM","BN","BO","BR","BS","BT","BW","BY","BZ","CA","CC","CD","CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CW","CX","CY","CZ","DE","DJ","DK","DM","DO","DZ","EC","EE","EG","EH","ER","ES","ET","FI","FJ","FK","FM","FO","FR","GA","GB","GD","GE","GG","GH","GI","GL","GM","GN","GQ","GR","GT","GU","GW","GY","HK","HN","HR","HT","HU","ID","IE","IL","IM","IN","IO","IQ","IR","IS","IT","JE","JM","JO","JP","KE","KG","KH","KI","KM","KN","KP","KR","KW","KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT","LU","LV","LY","MA","MC","MD","ME","MF","MG","MH","MK","ML","MM","MN","MO","MP","MR","MS","MT","MU","MV","MW","MX","MY","MZ","NA","NC","NE","NG","NI","NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF","PG","PH","PK","PL","PM","PN","PR","PT","PW","PY","QA","RE","RO","RS","RU","RW","SA","SB","SC","SD","SE","SG","SH","SI","SJ","SK","SL","SM","SN","SO","SR","ST","SV","SX","SY","SZ","TC","TD","TG","TH","TJ","TK","TL","TM","TN","TO","TR","TT","TV","TW","TZ","UA","UG","US","UY","UZ","VA","VC","VE","VG","VI","VN","VU","WF","WS","YE","YT","ZA","ZM","ZW"
            break
        }

        # Amazon.Connect.PhoneNumberType
        "Search-CONNAvailablePhoneNumber/PhoneNumberType"
        {
            $v = "DID","TOLL_FREE"
            break
        }

        # Amazon.Connect.QueueStatus
        "Update-CONNQueueStatus/Status"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Connect.QuickConnectType
        {
            ($_ -eq "New-CONNQuickConnect/QuickConnectConfig_QuickConnectType") -Or
            ($_ -eq "Update-CONNQuickConnectConfig/QuickConnectConfig_QuickConnectType")
        }
        {
            $v = "PHONE_NUMBER","QUEUE","USER"
            break
        }

        # Amazon.Connect.SearchableQueueType
        "Search-CONNQueue/SearchCriteria_QueueTypeCondition"
        {
            $v = "STANDARD"
            break
        }

        # Amazon.Connect.SourceType
        "New-CONNIntegrationAssociation/SourceType"
        {
            $v = "SALESFORCE","ZENDESK"
            break
        }

        # Amazon.Connect.StorageType
        {
            ($_ -eq "Add-CONNInstanceStorageConfig/StorageConfig_StorageType") -Or
            ($_ -eq "Update-CONNInstanceStorageConfig/StorageConfig_StorageType")
        }
        {
            $v = "KINESIS_FIREHOSE","KINESIS_STREAM","KINESIS_VIDEO_STREAM","S3"
            break
        }

        # Amazon.Connect.StringComparisonType
        {
            ($_ -eq "Search-CONNQueue/SearchCriteria_StringCondition_ComparisonType") -Or
            ($_ -eq "Search-CONNRoutingProfile/SearchCriteria_StringCondition_ComparisonType") -Or
            ($_ -eq "Search-CONNSecurityProfile/SearchCriteria_StringCondition_ComparisonType") -Or
            ($_ -eq "Search-CONNUser/SearchCriteria_StringCondition_ComparisonType")
        }
        {
            $v = "CONTAINS","EXACT","STARTS_WITH"
            break
        }

        # Amazon.Connect.TaskTemplateStatus
        {
            ($_ -eq "Get-CONNTaskTemplateList/Status") -Or
            ($_ -eq "New-CONNTaskTemplate/Status") -Or
            ($_ -eq "Update-CONNTaskTemplate/Status")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.Connect.TrafficType
        "Start-CONNOutboundVoiceContact/TrafficType"
        {
            $v = "CAMPAIGN","GENERAL"
            break
        }

        # Amazon.Connect.UseCaseType
        "New-CONNUseCase/UseCaseType"
        {
            $v = "CONNECT_CAMPAIGNS","RULES_EVALUATION"
            break
        }

        # Amazon.Connect.VocabularyLanguageCode
        {
            ($_ -eq "Add-CONNDefaultVocabulary/LanguageCode") -Or
            ($_ -eq "Get-CONNDefaultVocabularyList/LanguageCode") -Or
            ($_ -eq "New-CONNVocabulary/LanguageCode") -Or
            ($_ -eq "Search-CONNVocabulary/LanguageCode")
        }
        {
            $v = "ar-AE","de-CH","de-DE","en-AB","en-AU","en-GB","en-IE","en-IN","en-US","en-WL","es-ES","es-US","fr-CA","fr-FR","hi-IN","it-IT","ja-JP","ko-KR","pt-BR","pt-PT","zh-CN"
            break
        }

        # Amazon.Connect.VocabularyState
        "Search-CONNVocabulary/State"
        {
            $v = "ACTIVE","CREATION_FAILED","CREATION_IN_PROGRESS","DELETE_IN_PROGRESS"
            break
        }

        # Amazon.Connect.VoiceRecordingTrack
        "Start-CONNContactRecording/VoiceRecordingConfiguration_VoiceRecordingTrack"
        {
            $v = "ALL","FROM_AGENT","TO_AGENT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONN_map = @{
    "AttributeType"=@("Get-CONNInstanceAttribute","Update-CONNInstanceAttribute")
    "ContactFlowModuleState"=@("Get-CONNContactFlowModuleList")
    "ContactFlowState"=@("Update-CONNContactFlowMetadata")
    "IdentityManagementType"=@("New-CONNInstance")
    "IntegrationType"=@("Get-CONNIntegrationAssociationList","New-CONNIntegrationAssociation")
    "LanguageCode"=@("Add-CONNDefaultVocabulary","Get-CONNDefaultVocabularyList","New-CONNVocabulary","Search-CONNVocabulary")
    "LexVersion"=@("Get-CONNBotList")
    "PhoneNumberCountryCode"=@("Search-CONNAvailablePhoneNumber")
    "PhoneNumberType"=@("Search-CONNAvailablePhoneNumber")
    "QuickConnectConfig_QuickConnectType"=@("New-CONNQuickConnect","Update-CONNQuickConnectConfig")
    "ResourceType"=@("Add-CONNInstanceStorageConfig","Get-CONNInstanceStorageConfig","Get-CONNInstanceStorageConfigList","Remove-CONNInstanceStorageConfig","Update-CONNInstanceStorageConfig")
    "SearchCriteria_HierarchyGroupCondition_HierarchyGroupMatchType"=@("Search-CONNUser")
    "SearchCriteria_QueueTypeCondition"=@("Search-CONNQueue")
    "SearchCriteria_StringCondition_ComparisonType"=@("Search-CONNQueue","Search-CONNRoutingProfile","Search-CONNSecurityProfile","Search-CONNUser")
    "SourceType"=@("New-CONNIntegrationAssociation")
    "State"=@("New-CONNAgentStatus","Search-CONNVocabulary","Update-CONNAgentStatus","Update-CONNContactFlowModuleMetadata")
    "Status"=@("Get-CONNTaskTemplateList","New-CONNTaskTemplate","Update-CONNQueueStatus","Update-CONNTaskTemplate")
    "StorageConfig_KinesisVideoStreamConfig_EncryptionConfig_EncryptionType"=@("Add-CONNInstanceStorageConfig","Update-CONNInstanceStorageConfig")
    "StorageConfig_S3Config_EncryptionConfig_EncryptionType"=@("Add-CONNInstanceStorageConfig","Update-CONNInstanceStorageConfig")
    "StorageConfig_StorageType"=@("Add-CONNInstanceStorageConfig","Update-CONNInstanceStorageConfig")
    "TrafficType"=@("Start-CONNOutboundVoiceContact")
    "Type"=@("New-CONNContactFlow")
    "UseCaseType"=@("New-CONNUseCase")
    "VoiceRecordingConfiguration_VoiceRecordingTrack"=@("Start-CONNContactRecording")
}

_awsArgumentCompleterRegistration $CONN_Completers $CONN_map

$CONN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CONN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONN_SelectMap = @{
    "Select"=@("Add-CONNApprovedOrigin",
               "Add-CONNBot",
               "Add-CONNDefaultVocabulary",
               "Add-CONNInstanceStorageConfig",
               "Add-CONNLambdaFunction",
               "Add-CONNLexBot",
               "Add-CONNPhoneNumberContactFlow",
               "Add-CONNQueueQuickConnect",
               "Join-CONNRoutingProfileQueue",
               "Add-CONNSecurityKey",
               "Request-CONNPhoneNumber",
               "New-CONNAgentStatus",
               "New-CONNContactFlow",
               "New-CONNContactFlowModule",
               "New-CONNHoursOfOperation",
               "New-CONNInstance",
               "New-CONNIntegrationAssociation",
               "New-CONNQueue",
               "New-CONNQuickConnect",
               "New-CONNRoutingProfile",
               "New-CONNSecurityProfile",
               "New-CONNTaskTemplate",
               "New-CONNTrafficDistributionGroup",
               "New-CONNUseCase",
               "New-CONNUser",
               "New-CONNUserHierarchyGroup",
               "New-CONNVocabulary",
               "Remove-CONNContactFlow",
               "Remove-CONNContactFlowModule",
               "Remove-CONNHoursOfOperation",
               "Remove-CONNInstance",
               "Remove-CONNIntegrationAssociation",
               "Remove-CONNQuickConnect",
               "Remove-CONNSecurityProfile",
               "Remove-CONNTaskTemplate",
               "Remove-CONNTrafficDistributionGroup",
               "Remove-CONNUseCase",
               "Remove-CONNUser",
               "Remove-CONNUserHierarchyGroup",
               "Remove-CONNVocabulary",
               "Get-CONNAgentStatus",
               "Get-CONNContact",
               "Get-CONNContactFlow",
               "Get-CONNContactFlowModule",
               "Get-CONNHoursOfOperation",
               "Get-CONNInstance",
               "Get-CONNInstanceAttribute",
               "Get-CONNInstanceStorageConfig",
               "Get-CONNPhoneNumber",
               "Get-CONNQueue",
               "Get-CONNQuickConnect",
               "Get-CONNRoutingProfile",
               "Get-CONNSecurityProfile",
               "Get-CONNTrafficDistributionGroup",
               "Get-CONNUser",
               "Get-CONNUserHierarchyGroup",
               "Get-CONNUserHierarchyStructure",
               "Get-CONNVocabulary",
               "Remove-CONNApprovedOrigin",
               "Remove-CONNBot",
               "Remove-CONNInstanceStorageConfig",
               "Remove-CONNLambdaFunction",
               "Remove-CONNLexBot",
               "Remove-CONNPhoneNumberContactFlow",
               "Remove-CONNQueueQuickConnect",
               "Disconnect-CONNRoutingProfileQueue",
               "Remove-CONNSecurityKey",
               "Write-CONNUserContact",
               "Get-CONNContactAttribute",
               "Get-CONNCurrentMetricData",
               "Get-CONNCurrentUserData",
               "Get-CONNFederationToken",
               "Get-CONNMetricData",
               "Get-CONNTaskTemplate",
               "Get-CONNTrafficDistribution",
               "Get-CONNAgentStatusList",
               "Get-CONNApprovedOriginList",
               "Get-CONNBotList",
               "Get-CONNContactFlowModuleList",
               "Get-CONNContactFlowList",
               "Get-CONNContactReferenceList",
               "Get-CONNDefaultVocabularyList",
               "Get-CONNHoursOfOperationList",
               "Get-CONNInstanceAttributeList",
               "Get-CONNInstanceList",
               "Get-CONNInstanceStorageConfigList",
               "Get-CONNIntegrationAssociationList",
               "Get-CONNLambdaFunctionList",
               "Get-CONNLexBotList",
               "Get-CONNPhoneNumberList",
               "Get-CONNPhoneNumbersV2List",
               "Get-CONNPromptList",
               "Get-CONNQueueQuickConnectList",
               "Get-CONNQueueList",
               "Get-CONNQuickConnectList",
               "Get-CONNRoutingProfileQueueList",
               "Get-CONNRoutingProfileList",
               "Get-CONNSecurityKeyList",
               "Get-CONNSecurityProfilePermissionList",
               "Get-CONNSecurityProfileList",
               "Get-CONNResourceTag",
               "Get-CONNTaskTemplateList",
               "Get-CONNTrafficDistributionGroupList",
               "Get-CONNUseCaseList",
               "Get-CONNUserHierarchyGroupList",
               "Get-CONNUserList",
               "Start-CONNContactMonitoring",
               "Write-CONNUserStatus",
               "Remove-CONNPhoneNumber",
               "Copy-CONNInstance",
               "Resume-CONNContactRecording",
               "Search-CONNAvailablePhoneNumber",
               "Search-CONNQueue",
               "Search-CONNRoutingProfile",
               "Search-CONNSecurityProfile",
               "Search-CONNUser",
               "Search-CONNVocabulary",
               "Start-CONNChatContact",
               "Start-CONNContactRecording",
               "Start-CONNContactStreaming",
               "Start-CONNOutboundVoiceContact",
               "Start-CONNTaskContact",
               "Stop-CONNContact",
               "Stop-CONNContactRecording",
               "Stop-CONNContactStreaming",
               "Suspend-CONNContactRecording",
               "Add-CONNResourceTag",
               "Move-CONNContact",
               "Remove-CONNResourceTag",
               "Update-CONNAgentStatus",
               "Update-CONNContact",
               "Update-CONNContactAttribute",
               "Update-CONNContactFlowContent",
               "Update-CONNContactFlowMetadata",
               "Update-CONNContactFlowModuleContent",
               "Update-CONNContactFlowModuleMetadata",
               "Update-CONNContactFlowName",
               "Update-CONNContactSchedule",
               "Update-CONNHoursOfOperation",
               "Update-CONNInstanceAttribute",
               "Update-CONNInstanceStorageConfig",
               "Update-CONNPhoneNumber",
               "Update-CONNQueueHoursOfOperation",
               "Update-CONNQueueMaxContact",
               "Update-CONNQueueName",
               "Update-CONNQueueOutboundCallerConfig",
               "Update-CONNQueueStatus",
               "Update-CONNQuickConnectConfig",
               "Update-CONNQuickConnectName",
               "Update-CONNRoutingProfileConcurrency",
               "Update-CONNRoutingProfileDefaultOutboundQueue",
               "Update-CONNRoutingProfileName",
               "Update-CONNRoutingProfileQueue",
               "Update-CONNSecurityProfile",
               "Update-CONNTaskTemplate",
               "Update-CONNTrafficDistribution",
               "Update-CONNUserHierarchy",
               "Update-CONNUserHierarchyGroupName",
               "Update-CONNUserHierarchyStructure",
               "Update-CONNUserIdentityInfo",
               "Update-CONNUserPhoneConfig",
               "Update-CONNUserRoutingProfile",
               "Update-CONNUserSecurityProfile")
}

_awsArgumentCompleterRegistration $CONN_SelectCompleters $CONN_SelectMap
# Argument completions for service Amazon Connect Campaign Service


$CCS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConnectCampaignService.EncryptionType
        "Start-CCSInstanceOnboardingJob/EncryptionConfig_EncryptionType"
        {
            $v = "KMS"
            break
        }

        # Amazon.ConnectCampaignService.InstanceIdFilterOperator
        "Get-CCSCampaignList/Filters_InstanceIdFilter_Operator"
        {
            $v = "Eq"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCS_map = @{
    "EncryptionConfig_EncryptionType"=@("Start-CCSInstanceOnboardingJob")
    "Filters_InstanceIdFilter_Operator"=@("Get-CCSCampaignList")
}

_awsArgumentCompleterRegistration $CCS_Completers $CCS_map

$CCS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CCS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCS_SelectMap = @{
    "Select"=@("New-CCSCampaign",
               "Remove-CCSCampaign",
               "Remove-CCSConnectInstanceConfig",
               "Remove-CCSInstanceOnboardingJob",
               "Get-CCSCampaign",
               "Get-CCSCampaignState",
               "Get-CCSCampaignStateBatch",
               "Get-CCSConnectInstanceConfig",
               "Get-CCSInstanceOnboardingJobStatus",
               "Get-CCSCampaignList",
               "Get-CCSResourceTag",
               "Suspend-CCSCampaign",
               "Write-CCSDialRequestBatch",
               "Resume-CCSCampaign",
               "Start-CCSCampaign",
               "Start-CCSInstanceOnboardingJob",
               "Stop-CCSCampaign",
               "Add-CCSResourceTag",
               "Remove-CCSResourceTag",
               "Update-CCSCampaignDialerConfig",
               "Update-CCSCampaignName",
               "Update-CCSCampaignOutboundCallConfig")
}

_awsArgumentCompleterRegistration $CCS_SelectCompleters $CCS_SelectMap
# Argument completions for service Amazon Connect Cases


$CCAS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConnectCases.CommentBodyTextType
        "New-CCASRelatedItem/Content_Comment_ContentType"
        {
            $v = "Text/Plain"
            break
        }

        # Amazon.ConnectCases.FieldType
        "New-CCASField/Type"
        {
            $v = "Boolean","DateTime","Number","SingleSelect","Text"
            break
        }

        # Amazon.ConnectCases.RelatedItemType
        "New-CCASRelatedItem/Type"
        {
            $v = "Comment","Contact"
            break
        }

        # Amazon.ConnectCases.TemplateStatus
        {
            ($_ -eq "New-CCASTemplate/Status") -Or
            ($_ -eq "Update-CCASTemplate/Status")
        }
        {
            $v = "Active","Inactive"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCAS_map = @{
    "Content_Comment_ContentType"=@("New-CCASRelatedItem")
    "Status"=@("New-CCASTemplate","Update-CCASTemplate")
    "Type"=@("New-CCASField","New-CCASRelatedItem")
}

_awsArgumentCompleterRegistration $CCAS_Completers $CCAS_map

$CCAS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CCAS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCAS_SelectMap = @{
    "Select"=@("Group-CCASGetField",
               "Group-CCASPutFieldOption",
               "New-CCASCase",
               "New-CCASDomain",
               "New-CCASField",
               "New-CCASLayout",
               "New-CCASRelatedItem",
               "New-CCASTemplate",
               "Get-CCASCase",
               "Get-CCASCaseEventConfiguration",
               "Get-CCASDomain",
               "Get-CCASLayout",
               "Get-CCASTemplate",
               "Get-CCASCasesForContactList",
               "Get-CCASDomainList",
               "Get-CCASFieldOptionList",
               "Get-CCASFieldList",
               "Get-CCASLayoutList",
               "Get-CCASResourceTag",
               "Get-CCASTemplateList",
               "Write-CCASCaseEventConfiguration",
               "Search-CCASCase",
               "Search-CCASRelatedItem",
               "Add-CCASResourceTag",
               "Remove-CCASResourceTag",
               "Update-CCASCase",
               "Update-CCASField",
               "Update-CCASLayout",
               "Update-CCASTemplate")
}

_awsArgumentCompleterRegistration $CCAS_SelectCompleters $CCAS_SelectMap
# Argument completions for service Amazon Connect Contact Lens


$CCL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CCL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CCL_SelectMap = @{
    "Select"=@("Get-CCLRealtimeContactAnalysisSegmentList")
}

_awsArgumentCompleterRegistration $CCL_SelectCompleters $CCL_SelectMap
# Argument completions for service Amazon Connect Participant Service


$CONNP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConnectParticipant.ScanDirection
        "Get-CONNPTranscript/ScanDirection"
        {
            $v = "BACKWARD","FORWARD"
            break
        }

        # Amazon.ConnectParticipant.SortKey
        "Get-CONNPTranscript/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONNP_map = @{
    "ScanDirection"=@("Get-CONNPTranscript")
    "SortOrder"=@("Get-CONNPTranscript")
}

_awsArgumentCompleterRegistration $CONNP_Completers $CONNP_map

$CONNP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CONNP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONNP_SelectMap = @{
    "Select"=@("Complete-CONNPAttachmentUpload",
               "New-CONNPParticipantConnection",
               "Disconnect-CONNPParticipant",
               "Get-CONNPAttachment",
               "Get-CONNPTranscript",
               "Send-CONNPEvent",
               "Send-CONNPMessage",
               "Start-CONNPAttachmentUpload")
}

_awsArgumentCompleterRegistration $CONNP_SelectCompleters $CONNP_SelectMap
# Argument completions for service AWS Control Tower


$ACT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACT_SelectMap = @{
    "Select"=@("Disable-ACTControl",
               "Enable-ACTControl",
               "Get-ACTControlOperation",
               "Get-ACTEnabledControlList")
}

_awsArgumentCompleterRegistration $ACT_SelectCompleters $ACT_SelectMap
# Argument completions for service AWS Cost and Usage Report


$CUR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CostAndUsageReport.AWSRegion
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_S3Region") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_S3Region")
        }
        {
            $v = "af-south-1","ap-east-1","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ap-southeast-3","ca-central-1","cn-north-1","cn-northwest-1","eu-central-1","eu-north-1","eu-south-1","eu-south-2","eu-west-1","eu-west-2","eu-west-3","me-central-1","me-south-1","sa-east-1","us-east-1","us-east-2","us-west-1","us-west-2"
            break
        }

        # Amazon.CostAndUsageReport.CompressionFormat
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_Compression") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_Compression")
        }
        {
            $v = "GZIP","Parquet","ZIP"
            break
        }

        # Amazon.CostAndUsageReport.ReportFormat
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_Format") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_Format")
        }
        {
            $v = "Parquet","textORcsv"
            break
        }

        # Amazon.CostAndUsageReport.ReportVersioning
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_ReportVersioning") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_ReportVersioning")
        }
        {
            $v = "CREATE_NEW_REPORT","OVERWRITE_REPORT"
            break
        }

        # Amazon.CostAndUsageReport.TimeUnit
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_TimeUnit") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_TimeUnit")
        }
        {
            $v = "DAILY","HOURLY","MONTHLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CUR_map = @{
    "ReportDefinition_Compression"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_Format"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_ReportVersioning"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_S3Region"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_TimeUnit"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
}

_awsArgumentCompleterRegistration $CUR_Completers $CUR_map

$CUR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CUR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CUR_SelectMap = @{
    "Select"=@("Remove-CURReportDefinition",
               "Get-CURReportDefinition",
               "Edit-CURReportDefinition",
               "Write-CURReportDefinition")
}

_awsArgumentCompleterRegistration $CUR_SelectCompleters $CUR_SelectMap
# Argument completions for service Amazon Connect Customer Profiles


$CPF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CustomerProfiles.ConflictResolvingModel
        {
            ($_ -eq "Get-CPFAutoMergingPreview/ConflictResolution_ConflictResolvingModel") -Or
            ($_ -eq "New-CPFDomain/Matching_AutoMerging_ConflictResolution_ConflictResolvingModel") -Or
            ($_ -eq "Update-CPFDomain/Matching_AutoMerging_ConflictResolution_ConflictResolvingModel")
        }
        {
            $v = "RECENCY","SOURCE"
            break
        }

        # Amazon.CustomerProfiles.DataPullMode
        {
            ($_ -eq "Write-CPFIntegration/FlowDefinition_TriggerConfig_TriggerProperties_Scheduled_DataPullMode") -Or
            ($_ -eq "New-CPFIntegrationWorkflow/IntegrationConfig_AppflowIntegration_FlowDefinition_TriggerConfig_TriggerProperties_Scheduled_DataPullMode")
        }
        {
            $v = "Complete","Incremental"
            break
        }

        # Amazon.CustomerProfiles.Gender
        {
            ($_ -eq "New-CPFProfile/Gender") -Or
            ($_ -eq "Update-CPFProfile/Gender")
        }
        {
            $v = "FEMALE","MALE","UNSPECIFIED"
            break
        }

        # Amazon.CustomerProfiles.JobScheduleDayOfTheWeek
        {
            ($_ -eq "New-CPFDomain/Matching_JobSchedule_DayOfTheWeek") -Or
            ($_ -eq "Update-CPFDomain/Matching_JobSchedule_DayOfTheWeek")
        }
        {
            $v = "FRIDAY","MONDAY","SATURDAY","SUNDAY","THURSDAY","TUESDAY","WEDNESDAY"
            break
        }

        # Amazon.CustomerProfiles.LogicalOperator
        "Search-CPFProfile/LogicalOperator"
        {
            $v = "AND","OR"
            break
        }

        # Amazon.CustomerProfiles.PartyType
        {
            ($_ -eq "New-CPFProfile/PartyType") -Or
            ($_ -eq "Update-CPFProfile/PartyType")
        }
        {
            $v = "BUSINESS","INDIVIDUAL","OTHER"
            break
        }

        # Amazon.CustomerProfiles.SourceConnectorType
        {
            ($_ -eq "Write-CPFIntegration/FlowDefinition_SourceFlowConfig_ConnectorType") -Or
            ($_ -eq "New-CPFIntegrationWorkflow/IntegrationConfig_AppflowIntegration_FlowDefinition_SourceFlowConfig_ConnectorType")
        }
        {
            $v = "Marketo","S3","Salesforce","Servicenow","Zendesk"
            break
        }

        # Amazon.CustomerProfiles.Status
        "Get-CPFWorkflowList/Status"
        {
            $v = "CANCELLED","COMPLETE","FAILED","IN_PROGRESS","NOT_STARTED","RETRY","SPLIT"
            break
        }

        # Amazon.CustomerProfiles.TriggerType
        {
            ($_ -eq "Write-CPFIntegration/FlowDefinition_TriggerConfig_TriggerType") -Or
            ($_ -eq "New-CPFIntegrationWorkflow/IntegrationConfig_AppflowIntegration_FlowDefinition_TriggerConfig_TriggerType")
        }
        {
            $v = "Event","OnDemand","Scheduled"
            break
        }

        # Amazon.CustomerProfiles.WorkflowType
        {
            ($_ -eq "Get-CPFWorkflowList/WorkflowType") -Or
            ($_ -eq "New-CPFIntegrationWorkflow/WorkflowType")
        }
        {
            $v = "APPFLOW_INTEGRATION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CPF_map = @{
    "ConflictResolution_ConflictResolvingModel"=@("Get-CPFAutoMergingPreview")
    "FlowDefinition_SourceFlowConfig_ConnectorType"=@("Write-CPFIntegration")
    "FlowDefinition_TriggerConfig_TriggerProperties_Scheduled_DataPullMode"=@("Write-CPFIntegration")
    "FlowDefinition_TriggerConfig_TriggerType"=@("Write-CPFIntegration")
    "Gender"=@("New-CPFProfile","Update-CPFProfile")
    "IntegrationConfig_AppflowIntegration_FlowDefinition_SourceFlowConfig_ConnectorType"=@("New-CPFIntegrationWorkflow")
    "IntegrationConfig_AppflowIntegration_FlowDefinition_TriggerConfig_TriggerProperties_Scheduled_DataPullMode"=@("New-CPFIntegrationWorkflow")
    "IntegrationConfig_AppflowIntegration_FlowDefinition_TriggerConfig_TriggerType"=@("New-CPFIntegrationWorkflow")
    "LogicalOperator"=@("Search-CPFProfile")
    "Matching_AutoMerging_ConflictResolution_ConflictResolvingModel"=@("New-CPFDomain","Update-CPFDomain")
    "Matching_JobSchedule_DayOfTheWeek"=@("New-CPFDomain","Update-CPFDomain")
    "PartyType"=@("New-CPFProfile","Update-CPFProfile")
    "Status"=@("Get-CPFWorkflowList")
    "WorkflowType"=@("Get-CPFWorkflowList","New-CPFIntegrationWorkflow")
}

_awsArgumentCompleterRegistration $CPF_Completers $CPF_map

$CPF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CPF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CPF_SelectMap = @{
    "Select"=@("Add-CPFProfileKey",
               "New-CPFDomain",
               "New-CPFIntegrationWorkflow",
               "New-CPFProfile",
               "Remove-CPFDomain",
               "Remove-CPFIntegration",
               "Remove-CPFProfile",
               "Remove-CPFProfileKey",
               "Remove-CPFProfileObject",
               "Remove-CPFProfileObjectType",
               "Remove-CPFWorkflow",
               "Get-CPFAutoMergingPreview",
               "Get-CPFDomain",
               "Get-CPFIdentityResolutionJob",
               "Get-CPFIntegration",
               "Get-CPFMatch",
               "Get-CPFProfileObjectType",
               "Get-CPFProfileObjectTypeTemplate",
               "Get-CPFWorkflow",
               "Get-CPFWorkflowStep",
               "Get-CPFAccountIntegrationList",
               "Get-CPFDomainList",
               "Get-CPFIdentityResolutionJobList",
               "Get-CPFIntegrationList",
               "Get-CPFProfileObjectList",
               "Get-CPFProfileObjectTypeList",
               "Get-CPFProfileObjectTypeTemplateList",
               "Get-CPFResourceTag",
               "Get-CPFWorkflowList",
               "Merge-CPFProfile",
               "Write-CPFIntegration",
               "Write-CPFProfileObject",
               "Write-CPFProfileObjectType",
               "Search-CPFProfile",
               "Add-CPFResourceTag",
               "Remove-CPFResourceTag",
               "Update-CPFDomain",
               "Update-CPFProfile")
}

_awsArgumentCompleterRegistration $CPF_SelectCompleters $CPF_SelectMap
# Argument completions for service AWS Glue DataBrew


$GDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GlueDataBrew.AnalyticsMode
        "Send-GDBProjectSessionAction/ViewFrame_Analytics"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.GlueDataBrew.EncryptionMode
        {
            ($_ -eq "New-GDBProfileJob/EncryptionMode") -Or
            ($_ -eq "New-GDBRecipeJob/EncryptionMode") -Or
            ($_ -eq "Update-GDBProfileJob/EncryptionMode") -Or
            ($_ -eq "Update-GDBRecipeJob/EncryptionMode")
        }
        {
            $v = "SSE-KMS","SSE-S3"
            break
        }

        # Amazon.GlueDataBrew.InputFormat
        {
            ($_ -eq "New-GDBDataset/Format") -Or
            ($_ -eq "Update-GDBDataset/Format")
        }
        {
            $v = "CSV","EXCEL","JSON","ORC","PARQUET"
            break
        }

        # Amazon.GlueDataBrew.LogSubscription
        {
            ($_ -eq "New-GDBProfileJob/LogSubscription") -Or
            ($_ -eq "New-GDBRecipeJob/LogSubscription") -Or
            ($_ -eq "Update-GDBProfileJob/LogSubscription") -Or
            ($_ -eq "Update-GDBRecipeJob/LogSubscription")
        }
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.GlueDataBrew.Order
        {
            ($_ -eq "New-GDBDataset/PathOptions_FilesLimit_Order") -Or
            ($_ -eq "Update-GDBDataset/PathOptions_FilesLimit_Order")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.GlueDataBrew.OrderedBy
        {
            ($_ -eq "New-GDBDataset/PathOptions_FilesLimit_OrderedBy") -Or
            ($_ -eq "Update-GDBDataset/PathOptions_FilesLimit_OrderedBy")
        }
        {
            $v = "LAST_MODIFIED_DATE"
            break
        }

        # Amazon.GlueDataBrew.SampleMode
        {
            ($_ -eq "New-GDBProfileJob/JobSample_Mode") -Or
            ($_ -eq "Update-GDBProfileJob/JobSample_Mode")
        }
        {
            $v = "CUSTOM_ROWS","FULL_DATASET"
            break
        }

        # Amazon.GlueDataBrew.SampleType
        {
            ($_ -eq "New-GDBProject/Sample_Type") -Or
            ($_ -eq "Update-GDBProject/Sample_Type")
        }
        {
            $v = "FIRST_N","LAST_N","RANDOM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GDB_map = @{
    "EncryptionMode"=@("New-GDBProfileJob","New-GDBRecipeJob","Update-GDBProfileJob","Update-GDBRecipeJob")
    "Format"=@("New-GDBDataset","Update-GDBDataset")
    "JobSample_Mode"=@("New-GDBProfileJob","Update-GDBProfileJob")
    "LogSubscription"=@("New-GDBProfileJob","New-GDBRecipeJob","Update-GDBProfileJob","Update-GDBRecipeJob")
    "PathOptions_FilesLimit_Order"=@("New-GDBDataset","Update-GDBDataset")
    "PathOptions_FilesLimit_OrderedBy"=@("New-GDBDataset","Update-GDBDataset")
    "Sample_Type"=@("New-GDBProject","Update-GDBProject")
    "ViewFrame_Analytics"=@("Send-GDBProjectSessionAction")
}

_awsArgumentCompleterRegistration $GDB_Completers $GDB_map

$GDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GDB_SelectMap = @{
    "Select"=@("Remove-GDBRecipeVersionBatch",
               "New-GDBDataset",
               "New-GDBProfileJob",
               "New-GDBProject",
               "New-GDBRecipe",
               "New-GDBRecipeJob",
               "New-GDBRuleset",
               "New-GDBSchedule",
               "Remove-GDBDataset",
               "Remove-GDBJob",
               "Remove-GDBProject",
               "Remove-GDBRecipeVersion",
               "Remove-GDBRuleset",
               "Remove-GDBSchedule",
               "Get-GDBDataset",
               "Get-GDBJob",
               "Get-GDBJobRun",
               "Get-GDBProject",
               "Get-GDBRecipe",
               "Get-GDBRuleset",
               "Get-GDBSchedule",
               "Get-GDBDatasetList",
               "Get-GDBJobRunList",
               "Get-GDBJobList",
               "Get-GDBProjectList",
               "Get-GDBRecipeList",
               "Get-GDBRecipeVersionList",
               "Get-GDBRulesetList",
               "Get-GDBScheduleList",
               "Get-GDBResourceTag",
               "Publish-GDBRecipe",
               "Send-GDBProjectSessionAction",
               "Start-GDBJobRun",
               "Start-GDBProjectSession",
               "Stop-GDBJobRun",
               "Add-GDBResourceTag",
               "Remove-GDBResourceTag",
               "Update-GDBDataset",
               "Update-GDBProfileJob",
               "Update-GDBProject",
               "Update-GDBRecipe",
               "Update-GDBRecipeJob",
               "Update-GDBRuleset",
               "Update-GDBSchedule")
}

_awsArgumentCompleterRegistration $GDB_SelectCompleters $GDB_SelectMap
# Argument completions for service AWS Data Exchange


$DTEX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataExchange.AssetType
        "New-DTEXDataSet/AssetType"
        {
            $v = "API_GATEWAY_API","REDSHIFT_DATA_SHARE","S3_SNAPSHOT"
            break
        }

        # Amazon.DataExchange.ProtocolType
        "New-DTEXJob/Details_ImportAssetFromApiGatewayApi_ProtocolType"
        {
            $v = "REST"
            break
        }

        # Amazon.DataExchange.ServerSideEncryptionTypes
        {
            ($_ -eq "New-DTEXEventAction/Action_ExportRevisionToS3_Encryption_Type") -Or
            ($_ -eq "Update-DTEXEventAction/Action_ExportRevisionToS3_Encryption_Type") -Or
            ($_ -eq "New-DTEXJob/Details_ExportAssetsToS3_Encryption_Type") -Or
            ($_ -eq "New-DTEXJob/Details_ExportRevisionsToS3_Encryption_Type")
        }
        {
            $v = "AES256","aws:kms"
            break
        }

        # Amazon.DataExchange.Type
        "New-DTEXJob/Type"
        {
            $v = "EXPORT_ASSETS_TO_S3","EXPORT_ASSET_TO_SIGNED_URL","EXPORT_REVISIONS_TO_S3","IMPORT_ASSETS_FROM_REDSHIFT_DATA_SHARES","IMPORT_ASSETS_FROM_S3","IMPORT_ASSET_FROM_API_GATEWAY_API","IMPORT_ASSET_FROM_SIGNED_URL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DTEX_map = @{
    "Action_ExportRevisionToS3_Encryption_Type"=@("New-DTEXEventAction","Update-DTEXEventAction")
    "AssetType"=@("New-DTEXDataSet")
    "Details_ExportAssetsToS3_Encryption_Type"=@("New-DTEXJob")
    "Details_ExportRevisionsToS3_Encryption_Type"=@("New-DTEXJob")
    "Details_ImportAssetFromApiGatewayApi_ProtocolType"=@("New-DTEXJob")
    "Type"=@("New-DTEXJob")
}

_awsArgumentCompleterRegistration $DTEX_Completers $DTEX_map

$DTEX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DTEX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DTEX_SelectMap = @{
    "Select"=@("Stop-DTEXJob",
               "New-DTEXDataSet",
               "New-DTEXEventAction",
               "New-DTEXJob",
               "New-DTEXRevision",
               "Remove-DTEXAsset",
               "Remove-DTEXDataSet",
               "Remove-DTEXEventAction",
               "Remove-DTEXRevision",
               "Get-DTEXAsset",
               "Get-DTEXDataSet",
               "Get-DTEXEventAction",
               "Get-DTEXJob",
               "Get-DTEXRevision",
               "Get-DTEXDataSetRevisionList",
               "Get-DTEXDataSetList",
               "Get-DTEXEventActionList",
               "Get-DTEXJobList",
               "Get-DTEXRevisionAssetList",
               "Get-DTEXResourceTag",
               "Revoke-DTEXRevision",
               "Send-DTEXApiAsset",
               "Start-DTEXJob",
               "Add-DTEXResourceTag",
               "Remove-DTEXResourceTag",
               "Update-DTEXAsset",
               "Update-DTEXDataSet",
               "Update-DTEXEventAction",
               "Update-DTEXRevision")
}

_awsArgumentCompleterRegistration $DTEX_SelectCompleters $DTEX_SelectMap
# Argument completions for service AWS Data Pipeline


$DP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataPipeline.TaskStatus
        "Set-DPTaskStatus/TaskStatus"
        {
            $v = "FAILED","FALSE","FINISHED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DP_map = @{
    "TaskStatus"=@("Set-DPTaskStatus")
}

_awsArgumentCompleterRegistration $DP_Completers $DP_map

$DP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DP_SelectMap = @{
    "Select"=@("Enable-DPPipeline",
               "Add-DPResourceTag",
               "New-DPPipeline",
               "Disable-DPPipeline",
               "Remove-DPPipeline",
               "Get-DPObject",
               "Get-DPPipelineDescription",
               "Invoke-DPExpression",
               "Get-DPPipelineDefinition",
               "Get-DPPipeline",
               "Get-DPTask",
               "Write-DPPipelineDefinition",
               "Find-DPObject",
               "Remove-DPResourceTag",
               "Update-DPTaskProgress",
               "Update-DPTaskRunnerHeartbeat",
               "Set-DPStatus",
               "Set-DPTaskStatus",
               "Test-DPPipelineDefinition")
}

_awsArgumentCompleterRegistration $DP_SelectCompleters $DP_SelectMap
# Argument completions for service AWS DataSync


$DSYN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataSync.EfsInTransitEncryption
        "New-DSYNLocationEfs/InTransitEncryption"
        {
            $v = "NONE","TLS1_2"
            break
        }

        # Amazon.DataSync.HdfsAuthenticationType
        {
            ($_ -eq "New-DSYNLocationHdf/AuthenticationType") -Or
            ($_ -eq "Update-DSYNLocationHdf/AuthenticationType")
        }
        {
            $v = "KERBEROS","SIMPLE"
            break
        }

        # Amazon.DataSync.HdfsDataTransferProtection
        {
            ($_ -eq "New-DSYNLocationHdf/QopConfiguration_DataTransferProtection") -Or
            ($_ -eq "Update-DSYNLocationHdf/QopConfiguration_DataTransferProtection")
        }
        {
            $v = "AUTHENTICATION","DISABLED","INTEGRITY","PRIVACY"
            break
        }

        # Amazon.DataSync.HdfsRpcProtection
        {
            ($_ -eq "New-DSYNLocationHdf/QopConfiguration_RpcProtection") -Or
            ($_ -eq "Update-DSYNLocationHdf/QopConfiguration_RpcProtection")
        }
        {
            $v = "AUTHENTICATION","DISABLED","INTEGRITY","PRIVACY"
            break
        }

        # Amazon.DataSync.NfsVersion
        {
            ($_ -eq "New-DSYNLocationNfs/MountOptions_Version") -Or
            ($_ -eq "Update-DSYNLocationNfs/MountOptions_Version") -Or
            ($_ -eq "New-DSYNLocationFsxOntap/Protocol_NFS_MountOptions_Version") -Or
            ($_ -eq "New-DSYNLocationFsxOpenZf/Protocol_NFS_MountOptions_Version")
        }
        {
            $v = "AUTOMATIC","NFS3","NFS4_0","NFS4_1"
            break
        }

        # Amazon.DataSync.ObjectStorageServerProtocol
        {
            ($_ -eq "New-DSYNLocationObjectStorage/ServerProtocol") -Or
            ($_ -eq "Update-DSYNLocationObjectStorage/ServerProtocol")
        }
        {
            $v = "HTTP","HTTPS"
            break
        }

        # Amazon.DataSync.S3StorageClass
        "New-DSYNLocationS3/S3StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER","INTELLIGENT_TIERING","ONEZONE_IA","OUTPOSTS","STANDARD","STANDARD_IA"
            break
        }

        # Amazon.DataSync.SmbVersion
        {
            ($_ -eq "New-DSYNLocationSmb/MountOptions_Version") -Or
            ($_ -eq "Update-DSYNLocationSmb/MountOptions_Version") -Or
            ($_ -eq "New-DSYNLocationFsxOntap/Protocol_SMB_MountOptions_Version") -Or
            ($_ -eq "New-DSYNLocationFsxOpenZf/Protocol_SMB_MountOptions_Version")
        }
        {
            $v = "AUTOMATIC","SMB2","SMB3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DSYN_map = @{
    "AuthenticationType"=@("New-DSYNLocationHdf","Update-DSYNLocationHdf")
    "InTransitEncryption"=@("New-DSYNLocationEfs")
    "MountOptions_Version"=@("New-DSYNLocationNfs","New-DSYNLocationSmb","Update-DSYNLocationNfs","Update-DSYNLocationSmb")
    "Protocol_NFS_MountOptions_Version"=@("New-DSYNLocationFsxOntap","New-DSYNLocationFsxOpenZf")
    "Protocol_SMB_MountOptions_Version"=@("New-DSYNLocationFsxOntap","New-DSYNLocationFsxOpenZf")
    "QopConfiguration_DataTransferProtection"=@("New-DSYNLocationHdf","Update-DSYNLocationHdf")
    "QopConfiguration_RpcProtection"=@("New-DSYNLocationHdf","Update-DSYNLocationHdf")
    "S3StorageClass"=@("New-DSYNLocationS3")
    "ServerProtocol"=@("New-DSYNLocationObjectStorage","Update-DSYNLocationObjectStorage")
}

_awsArgumentCompleterRegistration $DSYN_Completers $DSYN_map

$DSYN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DSYN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DSYN_SelectMap = @{
    "Select"=@("Stop-DSYNTaskExecution",
               "New-DSYNAgent",
               "New-DSYNLocationEfs",
               "New-DSYNLocationFsxLustre",
               "New-DSYNLocationFsxOntap",
               "New-DSYNLocationFsxOpenZf",
               "New-DSYNLocationFsxWindow",
               "New-DSYNLocationHdf",
               "New-DSYNLocationNfs",
               "New-DSYNLocationObjectStorage",
               "New-DSYNLocationS3",
               "New-DSYNLocationSmb",
               "New-DSYNTask",
               "Remove-DSYNAgent",
               "Remove-DSYNLocation",
               "Remove-DSYNTask",
               "Get-DSYNAgent",
               "Get-DSYNLocationEfs",
               "Get-DSYNLocationFsxLustre",
               "Get-DSYNLocationFsxOntap",
               "Get-DSYNLocationFsxOpenZf",
               "Get-DSYNLocationFsxWindow",
               "Get-DSYNLocationHdf",
               "Get-DSYNLocationNfs",
               "Get-DSYNLocationObjectStorage",
               "Get-DSYNLocationS3",
               "Get-DSYNLocationSmb",
               "Get-DSYNTask",
               "Get-DSYNTaskExecution",
               "Get-DSYNAgentList",
               "Get-DSYNLocationList",
               "Get-DSYNResourceTagList",
               "Get-DSYNTaskExecutionList",
               "Get-DSYNTaskList",
               "Start-DSYNTaskExecution",
               "Add-DSYNResourceTag",
               "Remove-DSYNResourceTag",
               "Update-DSYNAgent",
               "Update-DSYNLocationHdf",
               "Update-DSYNLocationNfs",
               "Update-DSYNLocationObjectStorage",
               "Update-DSYNLocationSmb",
               "Update-DSYNTask",
               "Update-DSYNTaskExecution")
}

_awsArgumentCompleterRegistration $DSYN_SelectCompleters $DSYN_SelectMap
# Argument completions for service Amazon DynamoDB Accelerator (DAX)


$DAX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DAX.ClusterEndpointEncryptionType
        "New-DAXCluster/ClusterEndpointEncryptionType"
        {
            $v = "NONE","TLS"
            break
        }

        # Amazon.DAX.SourceType
        "Get-DAXEvent/SourceType"
        {
            $v = "CLUSTER","PARAMETER_GROUP","SUBNET_GROUP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DAX_map = @{
    "ClusterEndpointEncryptionType"=@("New-DAXCluster")
    "SourceType"=@("Get-DAXEvent")
}

_awsArgumentCompleterRegistration $DAX_Completers $DAX_map

$DAX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DAX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DAX_SelectMap = @{
    "Select"=@("New-DAXCluster",
               "New-DAXParameterGroup",
               "New-DAXSubnetGroup",
               "Set-DAXReplicationFactorDecrease",
               "Remove-DAXCluster",
               "Remove-DAXParameterGroup",
               "Remove-DAXSubnetGroup",
               "Get-DAXCluster",
               "Get-DAXDefaultParameter",
               "Get-DAXEvent",
               "Get-DAXParameterGroup",
               "Get-DAXParameter",
               "Get-DAXSubnetGroup",
               "Set-DAXReplicationFactorIncrease",
               "Get-DAXResourceTag",
               "Restart-DAXNode",
               "Add-DAXResourceTag",
               "Remove-DAXResourceTag",
               "Update-DAXCluster",
               "Update-DAXParameterGroup",
               "Update-DAXSubnetGroup")
}

_awsArgumentCompleterRegistration $DAX_SelectCompleters $DAX_SelectMap
# Argument completions for service Amazon Detective


$DTCT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DTCT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DTCT_SelectMap = @{
    "Select"=@("Approve-DTCTInvitation",
               "Get-DTCTGraphMemberDatasource",
               "Get-DTCTMembershipDatasource",
               "New-DTCTGraph",
               "New-DTCTMember",
               "Remove-DTCTGraph",
               "Remove-DTCTMember",
               "Get-DTCTOrganizationConfiguration",
               "Disable-DTCTOrganizationAdminAccount",
               "Remove-DTCTMembership",
               "Enable-DTCTOrganizationAdminAccount",
               "Get-DTCTMember",
               "Get-DTCTDatasourcePackageList",
               "Get-DTCTGraphList",
               "Get-DTCTInvitationList",
               "Get-DTCTMemberList",
               "Get-DTCTOrganizationAdminAccountList",
               "Get-DTCTResourceTag",
               "Deny-DTCTInvitation",
               "Start-DTCTMonitoringMember",
               "Add-DTCTResourceTag",
               "Remove-DTCTResourceTag",
               "Update-DTCTDatasourcePackage",
               "Update-DTCTOrganizationConfiguration")
}

_awsArgumentCompleterRegistration $DTCT_SelectCompleters $DTCT_SelectMap
# Argument completions for service AWS Device Farm


$DF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DeviceFarm.ArtifactCategory
        "Get-DFArtifactList/Type"
        {
            $v = "FILE","LOG","SCREENSHOT"
            break
        }

        # Amazon.DeviceFarm.BillingMethod
        {
            ($_ -eq "Get-DFDevicePoolCompatibility/Configuration_BillingMethod") -Or
            ($_ -eq "New-DFRemoteAccessSession/Configuration_BillingMethod") -Or
            ($_ -eq "Submit-DFTestRun/Configuration_BillingMethod")
        }
        {
            $v = "METERED","UNMETERED"
            break
        }

        # Amazon.DeviceFarm.DevicePoolType
        "Get-DFDevicePoolList/Type"
        {
            $v = "CURATED","PRIVATE"
            break
        }

        # Amazon.DeviceFarm.InteractionMode
        "New-DFRemoteAccessSession/InteractionMode"
        {
            $v = "INTERACTIVE","NO_VIDEO","VIDEO_ONLY"
            break
        }

        # Amazon.DeviceFarm.NetworkProfileType
        {
            ($_ -eq "Get-DFNetworkProfileList/Type") -Or
            ($_ -eq "New-DFNetworkProfile/Type") -Or
            ($_ -eq "Update-DFNetworkProfile/Type")
        }
        {
            $v = "CURATED","PRIVATE"
            break
        }

        # Amazon.DeviceFarm.TestGridSessionArtifactCategory
        "Get-DFTestGridSessionArtifactList/Type"
        {
            $v = "LOG","VIDEO"
            break
        }

        # Amazon.DeviceFarm.TestGridSessionStatus
        "Get-DFTestGridSessionList/Status"
        {
            $v = "ACTIVE","CLOSED","ERRORED"
            break
        }

        # Amazon.DeviceFarm.TestType
        {
            ($_ -eq "Get-DFDevicePoolCompatibility/Test_Type") -Or
            ($_ -eq "Submit-DFTestRun/Test_Type") -Or
            ($_ -eq "Get-DFDevicePoolCompatibility/TestType")
        }
        {
            $v = "APPIUM_JAVA_JUNIT","APPIUM_JAVA_TESTNG","APPIUM_NODE","APPIUM_PYTHON","APPIUM_RUBY","APPIUM_WEB_JAVA_JUNIT","APPIUM_WEB_JAVA_TESTNG","APPIUM_WEB_NODE","APPIUM_WEB_PYTHON","APPIUM_WEB_RUBY","BUILTIN_EXPLORER","BUILTIN_FUZZ","CALABASH","INSTRUMENTATION","REMOTE_ACCESS_RECORD","REMOTE_ACCESS_REPLAY","UIAUTOMATION","UIAUTOMATOR","WEB_PERFORMANCE_PROFILE","XCTEST","XCTEST_UI"
            break
        }

        # Amazon.DeviceFarm.UploadType
        {
            ($_ -eq "Get-DFUploadList/Type") -Or
            ($_ -eq "New-DFUpload/Type")
        }
        {
            $v = "ANDROID_APP","APPIUM_JAVA_JUNIT_TEST_PACKAGE","APPIUM_JAVA_JUNIT_TEST_SPEC","APPIUM_JAVA_TESTNG_TEST_PACKAGE","APPIUM_JAVA_TESTNG_TEST_SPEC","APPIUM_NODE_TEST_PACKAGE","APPIUM_NODE_TEST_SPEC","APPIUM_PYTHON_TEST_PACKAGE","APPIUM_PYTHON_TEST_SPEC","APPIUM_RUBY_TEST_PACKAGE","APPIUM_RUBY_TEST_SPEC","APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE","APPIUM_WEB_JAVA_JUNIT_TEST_SPEC","APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE","APPIUM_WEB_JAVA_TESTNG_TEST_SPEC","APPIUM_WEB_NODE_TEST_PACKAGE","APPIUM_WEB_NODE_TEST_SPEC","APPIUM_WEB_PYTHON_TEST_PACKAGE","APPIUM_WEB_PYTHON_TEST_SPEC","APPIUM_WEB_RUBY_TEST_PACKAGE","APPIUM_WEB_RUBY_TEST_SPEC","CALABASH_TEST_PACKAGE","EXTERNAL_DATA","INSTRUMENTATION_TEST_PACKAGE","INSTRUMENTATION_TEST_SPEC","IOS_APP","UIAUTOMATION_TEST_PACKAGE","UIAUTOMATOR_TEST_PACKAGE","WEB_APP","XCTEST_TEST_PACKAGE","XCTEST_UI_TEST_PACKAGE","XCTEST_UI_TEST_SPEC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DF_map = @{
    "Configuration_BillingMethod"=@("Get-DFDevicePoolCompatibility","New-DFRemoteAccessSession","Submit-DFTestRun")
    "InteractionMode"=@("New-DFRemoteAccessSession")
    "Status"=@("Get-DFTestGridSessionList")
    "Test_Type"=@("Get-DFDevicePoolCompatibility","Submit-DFTestRun")
    "TestType"=@("Get-DFDevicePoolCompatibility")
    "Type"=@("Get-DFArtifactList","Get-DFDevicePoolList","Get-DFNetworkProfileList","Get-DFTestGridSessionArtifactList","Get-DFUploadList","New-DFNetworkProfile","New-DFUpload","Update-DFNetworkProfile")
}

_awsArgumentCompleterRegistration $DF_Completers $DF_map

$DF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DF_SelectMap = @{
    "Select"=@("New-DFDevicePool",
               "New-DFInstanceProfile",
               "New-DFNetworkProfile",
               "New-DFProject",
               "New-DFRemoteAccessSession",
               "New-DFTestGridProject",
               "New-DFTestGridUrl",
               "New-DFUpload",
               "New-DFVPCEConfiguration",
               "Remove-DFDevicePool",
               "Remove-DFInstanceProfile",
               "Remove-DFNetworkProfile",
               "Remove-DFProject",
               "Remove-DFRemoteAccessSession",
               "Remove-DFRun",
               "Remove-DFTestGridProject",
               "Remove-DFUpload",
               "Remove-DFVPCEConfiguration",
               "Get-DFAccountSettingList",
               "Get-DFDevice",
               "Get-DFDeviceInstance",
               "Get-DFDevicePool",
               "Get-DFDevicePoolCompatibility",
               "Get-DFInstanceProfile",
               "Get-DFJob",
               "Get-DFNetworkProfile",
               "Get-DFOfferingStatus",
               "Get-DFProject",
               "Get-DFRemoteAccessSession",
               "Get-DFRun",
               "Get-DFSuite",
               "Get-DFTest",
               "Get-DFTestGridProject",
               "Get-DFTestGridSession",
               "Get-DFUpload",
               "Get-DFVPCEConfiguration",
               "Install-DFToRemoteAccessSession",
               "Get-DFArtifactList",
               "Get-DFDeviceInstanceList",
               "Get-DFDevicePoolList",
               "Get-DFDeviceList",
               "Get-DFInstanceProfileList",
               "Get-DFJobList",
               "Get-DFNetworkProfileList",
               "Get-DFOfferingPromotion",
               "Get-DFOffering",
               "Get-DFOfferingTransaction",
               "Get-DFProjectList",
               "Get-DFRemoteAccessSessionList",
               "Get-DFRunList",
               "Get-DFSampleList",
               "Get-DFSuiteList",
               "Get-DFResourceTag",
               "Get-DFTestGridProjectList",
               "Get-DFTestGridSessionActionList",
               "Get-DFTestGridSessionArtifactList",
               "Get-DFTestGridSessionList",
               "Get-DFTestList",
               "Get-DFUniqueProblemList",
               "Get-DFUploadList",
               "Get-DFVPCEConfigurationList",
               "New-DFOfferingPurchase",
               "New-DFOfferingRenewal",
               "Submit-DFTestRun",
               "Stop-DFJob",
               "Stop-DFRemoteAccessSession",
               "Stop-DFRun",
               "Add-DFResourceTag",
               "Remove-DFResourceTag",
               "Update-DFDeviceInstance",
               "Update-DFDevicePool",
               "Update-DFInstanceProfile",
               "Update-DFNetworkProfile",
               "Update-DFProject",
               "Update-DFTestGridProject",
               "Update-DFUpload",
               "Update-DFVPCEConfiguration")
}

_awsArgumentCompleterRegistration $DF_SelectCompleters $DF_SelectMap
# Argument completions for service Amazon DevOps Guru


$DGURU_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DevOpsGuru.EventClass
        "Get-DGURUEventList/Filters_EventClass"
        {
            $v = "CONFIG_CHANGE","DEPLOYMENT","INFRASTRUCTURE","SCHEMA_CHANGE","SECURITY_CHANGE"
            break
        }

        # Amazon.DevOpsGuru.EventDataSource
        "Get-DGURUEventList/Filters_DataSource"
        {
            $v = "AWS_CLOUD_TRAIL","AWS_CODE_DEPLOY"
            break
        }

        # Amazon.DevOpsGuru.EventSourceOptInStatus
        "Update-DGURUEventSourcesConfig/EventSources_AmazonCodeGuruProfiler_Status"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.DevOpsGuru.InsightType
        {
            ($_ -eq "Get-DGURUOrganizationInsightList/StatusFilter_Any_Type") -Or
            ($_ -eq "Get-DGURUOrganizationInsightList/StatusFilter_Closed_Type") -Or
            ($_ -eq "Get-DGURUOrganizationInsightList/StatusFilter_Ongoing_Type") -Or
            ($_ -eq "Search-DGURUInsight/Type") -Or
            ($_ -eq "Search-DGURUOrganizationInsight/Type")
        }
        {
            $v = "PROACTIVE","REACTIVE"
            break
        }

        # Amazon.DevOpsGuru.Locale
        "Get-DGURURecommendationList/Locale"
        {
            $v = "DE_DE","EN_GB","EN_US","ES_ES","FR_FR","IT_IT","JA_JP","KO_KR","PT_BR","ZH_CN","ZH_TW"
            break
        }

        # Amazon.DevOpsGuru.OptInStatus
        "Update-DGURUServiceIntegration/ServiceIntegration_LogsAnomalyDetection_OptInStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.DevOpsGuru.OrganizationResourceCollectionType
        "Get-DGURUOrganizationResourceCollectionHealth/OrganizationResourceCollectionType"
        {
            $v = "AWS_ACCOUNT","AWS_CLOUD_FORMATION","AWS_SERVICE","AWS_TAGS"
            break
        }

        # Amazon.DevOpsGuru.ResourceCollectionType
        {
            ($_ -eq "Get-DGURUResourceCollection/ResourceCollectionType") -Or
            ($_ -eq "Get-DGURUResourceCollectionHealth/ResourceCollectionType")
        }
        {
            $v = "AWS_CLOUD_FORMATION","AWS_SERVICE","AWS_TAGS"
            break
        }

        # Amazon.DevOpsGuru.ResourcePermission
        "Get-DGURUMonitoredResourceList/Filters_ResourcePermission"
        {
            $v = "FULL_PERMISSION","MISSING_PERMISSION"
            break
        }

        # Amazon.DevOpsGuru.UpdateResourceCollectionAction
        "Update-DGURUResourceCollection/Action"
        {
            $v = "ADD","REMOVE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DGURU_map = @{
    "Action"=@("Update-DGURUResourceCollection")
    "EventSources_AmazonCodeGuruProfiler_Status"=@("Update-DGURUEventSourcesConfig")
    "Filters_DataSource"=@("Get-DGURUEventList")
    "Filters_EventClass"=@("Get-DGURUEventList")
    "Filters_ResourcePermission"=@("Get-DGURUMonitoredResourceList")
    "Locale"=@("Get-DGURURecommendationList")
    "OrganizationResourceCollectionType"=@("Get-DGURUOrganizationResourceCollectionHealth")
    "ResourceCollectionType"=@("Get-DGURUResourceCollection","Get-DGURUResourceCollectionHealth")
    "ServiceIntegration_LogsAnomalyDetection_OptInStatus"=@("Update-DGURUServiceIntegration")
    "StatusFilter_Any_Type"=@("Get-DGURUOrganizationInsightList")
    "StatusFilter_Closed_Type"=@("Get-DGURUOrganizationInsightList")
    "StatusFilter_Ongoing_Type"=@("Get-DGURUOrganizationInsightList")
    "Type"=@("Search-DGURUInsight","Search-DGURUOrganizationInsight")
}

_awsArgumentCompleterRegistration $DGURU_Completers $DGURU_map

$DGURU_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DGURU.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DGURU_SelectMap = @{
    "Select"=@("Add-DGURUNotificationChannel",
               "Remove-DGURUInsight",
               "Get-DGURUAccountHealth",
               "Get-DGURUAccountOverview",
               "Get-DGURUAnomaly",
               "Get-DGURUEventSourcesConfig",
               "Get-DGURUFeedback",
               "Get-DGURUInsight",
               "Get-DGURUOrganizationHealth",
               "Get-DGURUOrganizationOverview",
               "Get-DGURUOrganizationResourceCollectionHealth",
               "Get-DGURUResourceCollectionHealth",
               "Get-DGURUServiceIntegration",
               "Get-DGURUCostEstimation",
               "Get-DGURUResourceCollection",
               "Get-DGURUAnomaliesForInsightList",
               "Get-DGURUAnomalousLogGroupList",
               "Get-DGURUEventList",
               "Get-DGURUInsightList",
               "Get-DGURUMonitoredResourceList",
               "Get-DGURUNotificationChannelList",
               "Get-DGURUOrganizationInsightList",
               "Get-DGURURecommendationList",
               "Write-DGURUFeedback",
               "Remove-DGURUNotificationChannel",
               "Search-DGURUInsight",
               "Search-DGURUOrganizationInsight",
               "Start-DGURUCostEstimation",
               "Update-DGURUEventSourcesConfig",
               "Update-DGURUResourceCollection",
               "Update-DGURUServiceIntegration")
}

_awsArgumentCompleterRegistration $DGURU_SelectCompleters $DGURU_SelectMap
# Argument completions for service AWS Direct Connect


$DC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DirectConnect.AddressFamily
        {
            ($_ -eq "New-DCBGPPeer/NewBGPPeer_AddressFamily") -Or
            ($_ -eq "New-DCPrivateVirtualInterface/NewPrivateVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCPrivateVirtualInterface/NewPrivateVirtualInterfaceAllocation_AddressFamily") -Or
            ($_ -eq "New-DCPublicVirtualInterface/NewPublicVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCPublicVirtualInterface/NewPublicVirtualInterfaceAllocation_AddressFamily") -Or
            ($_ -eq "New-DCTransitVirtualInterface/NewTransitVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCTransitVirtualInterface/NewTransitVirtualInterfaceAllocation_AddressFamily")
        }
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.DirectConnect.LoaContentType
        {
            ($_ -eq "Get-DCConnectionLoa/LoaContentType") -Or
            ($_ -eq "Get-DCInterconnectLoa/LoaContentType") -Or
            ($_ -eq "Get-DCLoa/LoaContentType")
        }
        {
            $v = "application/pdf"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DC_map = @{
    "LoaContentType"=@("Get-DCConnectionLoa","Get-DCInterconnectLoa","Get-DCLoa")
    "NewBGPPeer_AddressFamily"=@("New-DCBGPPeer")
    "NewPrivateVirtualInterface_AddressFamily"=@("New-DCPrivateVirtualInterface")
    "NewPrivateVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCPrivateVirtualInterface")
    "NewPublicVirtualInterface_AddressFamily"=@("New-DCPublicVirtualInterface")
    "NewPublicVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCPublicVirtualInterface")
    "NewTransitVirtualInterface_AddressFamily"=@("New-DCTransitVirtualInterface")
    "NewTransitVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCTransitVirtualInterface")
}

_awsArgumentCompleterRegistration $DC_Completers $DC_map

$DC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DC_SelectMap = @{
    "Select"=@("Confirm-DCDirectConnectGatewayAssociationProposal",
               "Enable-DCConnectionOnInterconnect",
               "New-DCHostedConnection",
               "Enable-DCPrivateVirtualInterface",
               "Enable-DCPublicVirtualInterface",
               "Enable-DCTransitVirtualInterface",
               "Register-DCConnectionWithLag",
               "Register-DCHostedConnection",
               "Add-DCMacSecKey",
               "Register-DCVirtualInterface",
               "Confirm-DCConnection",
               "Confirm-DCCustomerAgreement",
               "Confirm-DCPrivateVirtualInterface",
               "Confirm-DCPublicVirtualInterface",
               "Confirm-DCTransitVirtualInterface",
               "New-DCBGPPeer",
               "New-DCConnection",
               "New-DCGateway",
               "New-DCGatewayAssociation",
               "New-DCDirectConnectGatewayAssociationProposal",
               "New-DCInterconnect",
               "New-DCLag",
               "New-DCPrivateVirtualInterface",
               "New-DCPublicVirtualInterface",
               "New-DCTransitVirtualInterface",
               "Remove-DCBGPPeer",
               "Remove-DCConnection",
               "Remove-DCGateway",
               "Remove-DCGatewayAssociation",
               "Remove-DCDirectConnectGatewayAssociationProposal",
               "Remove-DCInterconnect",
               "Remove-DCLag",
               "Remove-DCVirtualInterface",
               "Get-DCConnectionLoa",
               "Get-DCConnection",
               "Get-DCConnectionsOnInterconnect",
               "Get-DCCustomerMetadata",
               "Get-DCDirectConnectGatewayAssociationProposal",
               "Get-DCGatewayAssociation",
               "Get-DCGatewayAttachment",
               "Get-DCGateway",
               "Get-DCHostedConnection",
               "Get-DCInterconnectLoa",
               "Get-DCInterconnect",
               "Get-DCLag",
               "Get-DCLoa",
               "Get-DCLocation",
               "Get-DCRouterConfiguration",
               "Get-DCResourceTag",
               "Get-DCVirtualGateway",
               "Get-DCVirtualInterface",
               "Unregister-DCConnectionFromLag",
               "Remove-DCMacSecKey",
               "Get-DCVirtualInterfaceTestHistoryList",
               "Start-DCBgpFailoverTest",
               "Stop-DCBgpFailoverTest",
               "Add-DCResourceTag",
               "Remove-DCResourceTag",
               "Update-DCConnection",
               "Update-DCDirectConnectGateway",
               "Update-DCDirectConnectGatewayAssociation",
               "Update-DCLag",
               "Update-DCVirtualInterfaceAttribute")
}

_awsArgumentCompleterRegistration $DC_SelectCompleters $DC_SelectMap
# Argument completions for service AWS Application Discovery Service


$ADS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationDiscoveryService.ConfigurationItemType
        "Get-ADSConfigurationList/ConfigurationType"
        {
            $v = "APPLICATION","CONNECTION","PROCESS","SERVER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ADS_map = @{
    "ConfigurationType"=@("Get-ADSConfigurationList")
}

_awsArgumentCompleterRegistration $ADS_Completers $ADS_map

$ADS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ADS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ADS_SelectMap = @{
    "Select"=@("Add-ADSConfigurationItemsToApplication",
               "Remove-ADSImportDataBatch",
               "New-ADSApplication",
               "New-ADSTag",
               "Remove-ADSApplication",
               "Remove-ADSTag",
               "Get-ADSAgent",
               "Get-ADSConfiguration",
               "Get-ADSContinuousExport",
               "Get-ADSExportConfiguration",
               "Get-ADSExportTask",
               "Get-ADSImportTask",
               "Get-ADSTag",
               "Remove-ADSConfigurationItemsFromApplication",
               "Get-ADSExportConfigurationsId",
               "Get-ADSDiscoverySummary",
               "Get-ADSConfigurationList",
               "Get-ADSServerNeighborList",
               "Start-ADSContinuousExport",
               "Start-ADSDataCollectionByAgentId",
               "Start-ADSExportTask",
               "Start-ADSImportTask",
               "Stop-ADSContinuousExport",
               "Stop-ADSDataCollectionByAgentId",
               "Update-ADSApplication")
}

_awsArgumentCompleterRegistration $ADS_SelectCompleters $ADS_SelectMap
# Argument completions for service Amazon Data Lifecycle Manager


$DLM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DLM.EventSourceValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/PolicyDetails_EventSource_Type") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/PolicyDetails_EventSource_Type")
        }
        {
            $v = "MANAGED_CWE"
            break
        }

        # Amazon.DLM.EventTypeValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/PolicyDetails_EventSource_Parameters_EventType") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/PolicyDetails_EventSource_Parameters_EventType")
        }
        {
            $v = "shareSnapshot"
            break
        }

        # Amazon.DLM.GettablePolicyStateValues
        "Get-DLMLifecyclePolicySummary/State"
        {
            $v = "DISABLED","ENABLED","ERROR"
            break
        }

        # Amazon.DLM.PolicyTypeValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/PolicyDetails_PolicyType") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/PolicyDetails_PolicyType")
        }
        {
            $v = "EBS_SNAPSHOT_MANAGEMENT","EVENT_BASED_POLICY","IMAGE_MANAGEMENT"
            break
        }

        # Amazon.DLM.SettablePolicyStateValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/State") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DLM_map = @{
    "PolicyDetails_EventSource_Parameters_EventType"=@("New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
    "PolicyDetails_EventSource_Type"=@("New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
    "PolicyDetails_PolicyType"=@("New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
    "State"=@("Get-DLMLifecyclePolicySummary","New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
}

_awsArgumentCompleterRegistration $DLM_Completers $DLM_map

$DLM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DLM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DLM_SelectMap = @{
    "Select"=@("New-DLMLifecyclePolicy",
               "Remove-DLMLifecyclePolicy",
               "Get-DLMLifecyclePolicySummary",
               "Get-DLMLifecyclePolicy",
               "Get-DLMResourceTag",
               "Add-DLMResourceTag",
               "Remove-DLMResourceTag",
               "Update-DLMLifecyclePolicy")
}

_awsArgumentCompleterRegistration $DLM_SelectCompleters $DLM_SelectMap
# Argument completions for service AWS Database Migration Service


$DMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DatabaseMigrationService.AuthMechanismValue
        {
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_AuthMechanism") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_AuthMechanism")
        }
        {
            $v = "default","mongodb_cr","scram_sha_1"
            break
        }

        # Amazon.DatabaseMigrationService.AuthTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_AuthType") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_AuthType")
        }
        {
            $v = "no","password"
            break
        }

        # Amazon.DatabaseMigrationService.CannedAclForObjectsValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_CannedAclForObjects") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_CannedAclForObjects")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","none","private","public-read","public-read-write"
            break
        }

        # Amazon.DatabaseMigrationService.CharLengthSemantics
        {
            ($_ -eq "Edit-DMSEndpoint/OracleSettings_CharLengthSemantics") -Or
            ($_ -eq "New-DMSEndpoint/OracleSettings_CharLengthSemantics")
        }
        {
            $v = "byte","char","default"
            break
        }

        # Amazon.DatabaseMigrationService.CompressionTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_CompressionType") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_CompressionType")
        }
        {
            $v = "gzip","none"
            break
        }

        # Amazon.DatabaseMigrationService.DataFormatValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_DataFormat") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_DataFormat")
        }
        {
            $v = "csv","parquet"
            break
        }

        # Amazon.DatabaseMigrationService.DatePartitionDelimiterValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_DatePartitionDelimiter") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_DatePartitionDelimiter")
        }
        {
            $v = "DASH","NONE","SLASH","UNDERSCORE"
            break
        }

        # Amazon.DatabaseMigrationService.DatePartitionSequenceValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_DatePartitionSequence") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_DatePartitionSequence")
        }
        {
            $v = "DDMMYYYY","MMYYYYDD","YYYYMM","YYYYMMDD","YYYYMMDDHH"
            break
        }

        # Amazon.DatabaseMigrationService.DmsSslModeValue
        {
            ($_ -eq "Edit-DMSEndpoint/SslMode") -Or
            ($_ -eq "New-DMSEndpoint/SslMode")
        }
        {
            $v = "none","require","verify-ca","verify-full"
            break
        }

        # Amazon.DatabaseMigrationService.EncodingTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_EncodingType") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_EncodingType")
        }
        {
            $v = "plain","plain-dictionary","rle-dictionary"
            break
        }

        # Amazon.DatabaseMigrationService.EncryptionModeValue
        {
            ($_ -eq "Edit-DMSEndpoint/RedshiftSettings_EncryptionMode") -Or
            ($_ -eq "New-DMSEndpoint/RedshiftSettings_EncryptionMode") -Or
            ($_ -eq "Edit-DMSEndpoint/S3Settings_EncryptionMode") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_EncryptionMode")
        }
        {
            $v = "sse-kms","sse-s3"
            break
        }

        # Amazon.DatabaseMigrationService.KafkaSecurityProtocol
        {
            ($_ -eq "Edit-DMSEndpoint/KafkaSettings_SecurityProtocol") -Or
            ($_ -eq "New-DMSEndpoint/KafkaSettings_SecurityProtocol")
        }
        {
            $v = "plaintext","sasl-ssl","ssl-authentication","ssl-encryption"
            break
        }

        # Amazon.DatabaseMigrationService.MessageFormatValue
        {
            ($_ -eq "Edit-DMSEndpoint/KafkaSettings_MessageFormat") -Or
            ($_ -eq "New-DMSEndpoint/KafkaSettings_MessageFormat") -Or
            ($_ -eq "Edit-DMSEndpoint/KinesisSettings_MessageFormat") -Or
            ($_ -eq "New-DMSEndpoint/KinesisSettings_MessageFormat")
        }
        {
            $v = "json","json-unformatted"
            break
        }

        # Amazon.DatabaseMigrationService.MigrationTypeValue
        {
            ($_ -eq "Edit-DMSReplicationTask/MigrationType") -Or
            ($_ -eq "Get-DMSApplicableIndividualAssessment/MigrationType") -Or
            ($_ -eq "New-DMSReplicationTask/MigrationType")
        }
        {
            $v = "cdc","full-load","full-load-and-cdc"
            break
        }

        # Amazon.DatabaseMigrationService.NestingLevelValue
        {
            ($_ -eq "Edit-DMSEndpoint/DocDbSettings_NestingLevel") -Or
            ($_ -eq "New-DMSEndpoint/DocDbSettings_NestingLevel") -Or
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_NestingLevel") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_NestingLevel")
        }
        {
            $v = "none","one"
            break
        }

        # Amazon.DatabaseMigrationService.ParquetVersionValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_ParquetVersion") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_ParquetVersion")
        }
        {
            $v = "parquet-1-0","parquet-2-0"
            break
        }

        # Amazon.DatabaseMigrationService.PluginNameValue
        {
            ($_ -eq "Edit-DMSEndpoint/PostgreSQLSettings_PluginName") -Or
            ($_ -eq "New-DMSEndpoint/PostgreSQLSettings_PluginName")
        }
        {
            $v = "no-preference","pglogical","test-decoding"
            break
        }

        # Amazon.DatabaseMigrationService.RedisAuthTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/RedisSettings_AuthType") -Or
            ($_ -eq "New-DMSEndpoint/RedisSettings_AuthType")
        }
        {
            $v = "auth-role","auth-token","none"
            break
        }

        # Amazon.DatabaseMigrationService.ReloadOptionValue
        "Restore-DMSTable/ReloadOption"
        {
            $v = "data-reload","validate-only"
            break
        }

        # Amazon.DatabaseMigrationService.ReplicationEndpointTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/EndpointType") -Or
            ($_ -eq "New-DMSEndpoint/EndpointType")
        }
        {
            $v = "source","target"
            break
        }

        # Amazon.DatabaseMigrationService.SafeguardPolicy
        {
            ($_ -eq "Edit-DMSEndpoint/MicrosoftSQLServerSettings_SafeguardPolicy") -Or
            ($_ -eq "New-DMSEndpoint/MicrosoftSQLServerSettings_SafeguardPolicy")
        }
        {
            $v = "exclusive-automatic-truncation","rely-on-sql-server-replication-agent","shared-automatic-truncation"
            break
        }

        # Amazon.DatabaseMigrationService.SourceType
        "Get-DMSEvent/SourceType"
        {
            $v = "replication-instance"
            break
        }

        # Amazon.DatabaseMigrationService.SslSecurityProtocolValue
        {
            ($_ -eq "Edit-DMSEndpoint/RedisSettings_SslSecurityProtocol") -Or
            ($_ -eq "New-DMSEndpoint/RedisSettings_SslSecurityProtocol")
        }
        {
            $v = "plaintext","ssl-encryption"
            break
        }

        # Amazon.DatabaseMigrationService.StartReplicationTaskTypeValue
        "Start-DMSReplicationTask/StartReplicationTaskType"
        {
            $v = "reload-target","resume-processing","start-replication"
            break
        }

        # Amazon.DatabaseMigrationService.TargetDbType
        {
            ($_ -eq "Edit-DMSEndpoint/GcpMySQLSettings_TargetDbType") -Or
            ($_ -eq "New-DMSEndpoint/GcpMySQLSettings_TargetDbType") -Or
            ($_ -eq "Edit-DMSEndpoint/MySQLSettings_TargetDbType") -Or
            ($_ -eq "New-DMSEndpoint/MySQLSettings_TargetDbType")
        }
        {
            $v = "multiple-databases","specific-database"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DMS_map = @{
    "DocDbSettings_NestingLevel"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "EndpointType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "GcpMySQLSettings_TargetDbType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "KafkaSettings_MessageFormat"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "KafkaSettings_SecurityProtocol"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "KinesisSettings_MessageFormat"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MicrosoftSQLServerSettings_SafeguardPolicy"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MigrationType"=@("Edit-DMSReplicationTask","Get-DMSApplicableIndividualAssessment","New-DMSReplicationTask")
    "MongoDbSettings_AuthMechanism"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MongoDbSettings_AuthType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MongoDbSettings_NestingLevel"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MySQLSettings_TargetDbType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "OracleSettings_CharLengthSemantics"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "PostgreSQLSettings_PluginName"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "RedisSettings_AuthType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "RedisSettings_SslSecurityProtocol"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "RedshiftSettings_EncryptionMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "ReloadOption"=@("Restore-DMSTable")
    "S3Settings_CannedAclForObjects"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_CompressionType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_DataFormat"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_DatePartitionDelimiter"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_DatePartitionSequence"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_EncodingType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_EncryptionMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_ParquetVersion"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "SourceType"=@("Get-DMSEvent")
    "SslMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "StartReplicationTaskType"=@("Start-DMSReplicationTask")
}

_awsArgumentCompleterRegistration $DMS_Completers $DMS_map

$DMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DMS_SelectMap = @{
    "Select"=@("Set-DMSResourceTag",
               "Complete-DMSPendingMaintenanceAction",
               "Stop-DMSReplicationTaskAssessmentRun",
               "New-DMSEndpoint",
               "New-DMSEventSubscription",
               "New-DMSFleetAdvisorCollector",
               "New-DMSReplicationInstance",
               "New-DMSReplicationSubnetGroup",
               "New-DMSReplicationTask",
               "Remove-DMSCertificate",
               "Remove-DMSConnection",
               "Remove-DMSEndpoint",
               "Remove-DMSEventSubscription",
               "Remove-DMSFleetAdvisorCollector",
               "Remove-DMSFleetAdvisorDatabaseId",
               "Remove-DMSReplicationInstance",
               "Remove-DMSReplicationSubnetGroup",
               "Remove-DMSReplicationTask",
               "Remove-DMSReplicationTaskAssessmentRun",
               "Get-DMSAccountAttribute",
               "Get-DMSApplicableIndividualAssessment",
               "Get-DMSCertificate",
               "Get-DMSConnection",
               "Get-DMSEndpoint",
               "Get-DMSEndpointSetting",
               "Get-DMSEndpointType",
               "Get-DMSEventCategory",
               "Get-DMSEvent",
               "Get-DMSEventSubscription",
               "Get-DMSFleetAdvisorCollector",
               "Get-DMSFleetAdvisorDatabase",
               "Get-DMSFleetAdvisorLsaAnalysis",
               "Get-DMSFleetAdvisorSchemaObjectSummary",
               "Get-DMSFleetAdvisorSchema",
               "Get-DMSOrderableReplicationInstance",
               "Get-DMSPendingMaintenanceAction",
               "Get-DMSRefreshSchemasStatus",
               "Get-DMSReplicationInstance",
               "Get-DMSReplicationInstanceTaskLog",
               "Get-DMSReplicationSubnetGroup",
               "Get-DMSReplicationTaskAssessmentResult",
               "Get-DMSReplicationTaskAssessmentRun",
               "Get-DMSReplicationTaskIndividualAssessment",
               "Get-DMSReplicationTask",
               "Get-DMSSchema",
               "Get-DMSTableStatistic",
               "Import-DMSCertificate",
               "Get-DMSResourceTag",
               "Edit-DMSEndpoint",
               "Edit-DMSEventSubscription",
               "Edit-DMSReplicationInstance",
               "Edit-DMSReplicationSubnetGroup",
               "Edit-DMSReplicationTask",
               "Move-DMSReplicationTask",
               "Restart-DMSReplicationInstance",
               "Invoke-DMSSchemaRefresh",
               "Restore-DMSTable",
               "Remove-DMSResourceTag",
               "Start-DMSFleetAdvisorLsaAnalysis",
               "Start-DMSReplicationTask",
               "Start-DMSReplicationTaskAssessment",
               "Start-DMSReplicationTaskAssessmentRun",
               "Stop-DMSReplicationTask",
               "Test-DMSConnection",
               "Update-DMSSubscriptionsToEventBridge")
}

_awsArgumentCompleterRegistration $DMS_SelectCompleters $DMS_SelectMap
# Argument completions for service Amazon DocumentDB (with MongoDB compatibility)


$DOC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DocDB.SourceType
        "Get-DOCEvent/SourceType"
        {
            $v = "db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DOC_map = @{
    "SourceType"=@("Get-DOCEvent")
}

_awsArgumentCompleterRegistration $DOC_Completers $DOC_map

$DOC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DOC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DOC_SelectMap = @{
    "Select"=@("Add-DOCSourceIdentifierToSubscription",
               "Add-DOCResourceTag",
               "Complete-DOCPendingMaintenanceAction",
               "Copy-DOCDBClusterParameterGroup",
               "Copy-DOCDBClusterSnapshot",
               "New-DOCDBCluster",
               "New-DOCDBClusterParameterGroup",
               "New-DOCDBClusterSnapshot",
               "New-DOCDBInstance",
               "New-DOCDBSubnetGroup",
               "New-DOCEventSubscription",
               "New-DOCGlobalCluster",
               "Remove-DOCDBCluster",
               "Remove-DOCDBClusterParameterGroup",
               "Remove-DOCDBClusterSnapshot",
               "Remove-DOCDBInstance",
               "Remove-DOCDBSubnetGroup",
               "Remove-DOCEventSubscription",
               "Remove-DOCGlobalCluster",
               "Get-DOCCertificate",
               "Get-DOCDBClusterParameterGroup",
               "Get-DOCDBClusterParameter",
               "Get-DOCDBCluster",
               "Get-DOCDBClusterSnapshotAttribute",
               "Get-DOCDBClusterSnapshot",
               "Get-DOCDBEngineVersion",
               "Get-DOCDBInstance",
               "Get-DOCDBSubnetGroup",
               "Get-DOCEngineDefaultClusterParameter",
               "Get-DOCEventCategory",
               "Get-DOCEvent",
               "Get-DOCEventSubscription",
               "Get-DOCGlobalCluster",
               "Get-DOCOrderableDBInstanceOption",
               "Get-DOCPendingMaintenanceAction",
               "Start-DOCDBClusterFailover",
               "Get-DOCResourceTag",
               "Edit-DOCDBCluster",
               "Edit-DOCDBClusterParameterGroup",
               "Edit-DOCDBClusterSnapshotAttribute",
               "Edit-DOCDBInstance",
               "Edit-DOCDBSubnetGroup",
               "Edit-DOCEventSubscription",
               "Edit-DOCGlobalCluster",
               "Restart-DOCDBInstance",
               "Remove-DOCFromGlobalCluster",
               "Remove-DOCSourceIdentifierFromSubscription",
               "Remove-DOCResourceTag",
               "Reset-DOCDBClusterParameterGroup",
               "Restore-DOCDBClusterFromSnapshot",
               "Restore-DOCDBClusterToPointInTime",
               "Start-DOCDBCluster",
               "Stop-DOCDBCluster")
}

_awsArgumentCompleterRegistration $DOC_SelectCompleters $DOC_SelectMap
# Argument completions for service Elastic Disaster Recovery Service


$EDRS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Drs.LaunchDisposition
        "Update-EDRSLaunchConfiguration/LaunchDisposition"
        {
            $v = "STARTED","STOPPED"
            break
        }

        # Amazon.Drs.RecoverySnapshotsOrder
        "Get-EDRSRecoverySnapshot/Order"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.Drs.ReplicationConfigurationDataPlaneRouting
        {
            ($_ -eq "New-EDRSReplicationConfigurationTemplate/DataPlaneRouting") -Or
            ($_ -eq "Update-EDRSReplicationConfiguration/DataPlaneRouting") -Or
            ($_ -eq "Update-EDRSReplicationConfigurationTemplate/DataPlaneRouting")
        }
        {
            $v = "PRIVATE_IP","PUBLIC_IP"
            break
        }

        # Amazon.Drs.ReplicationConfigurationDefaultLargeStagingDiskType
        {
            ($_ -eq "New-EDRSReplicationConfigurationTemplate/DefaultLargeStagingDiskType") -Or
            ($_ -eq "Update-EDRSReplicationConfiguration/DefaultLargeStagingDiskType") -Or
            ($_ -eq "Update-EDRSReplicationConfigurationTemplate/DefaultLargeStagingDiskType")
        }
        {
            $v = "AUTO","GP2","GP3","ST1"
            break
        }

        # Amazon.Drs.ReplicationConfigurationEbsEncryption
        {
            ($_ -eq "New-EDRSReplicationConfigurationTemplate/EbsEncryption") -Or
            ($_ -eq "Update-EDRSReplicationConfiguration/EbsEncryption") -Or
            ($_ -eq "Update-EDRSReplicationConfigurationTemplate/EbsEncryption")
        }
        {
            $v = "CUSTOM","DEFAULT"
            break
        }

        # Amazon.Drs.TargetInstanceTypeRightSizingMethod
        "Update-EDRSLaunchConfiguration/TargetInstanceTypeRightSizingMethod"
        {
            $v = "BASIC","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EDRS_map = @{
    "DataPlaneRouting"=@("New-EDRSReplicationConfigurationTemplate","Update-EDRSReplicationConfiguration","Update-EDRSReplicationConfigurationTemplate")
    "DefaultLargeStagingDiskType"=@("New-EDRSReplicationConfigurationTemplate","Update-EDRSReplicationConfiguration","Update-EDRSReplicationConfigurationTemplate")
    "EbsEncryption"=@("New-EDRSReplicationConfigurationTemplate","Update-EDRSReplicationConfiguration","Update-EDRSReplicationConfigurationTemplate")
    "LaunchDisposition"=@("Update-EDRSLaunchConfiguration")
    "Order"=@("Get-EDRSRecoverySnapshot")
    "TargetInstanceTypeRightSizingMethod"=@("Update-EDRSLaunchConfiguration")
}

_awsArgumentCompleterRegistration $EDRS_Completers $EDRS_map

$EDRS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EDRS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EDRS_SelectMap = @{
    "Select"=@("New-EDRSExtendedSourceServer",
               "New-EDRSReplicationConfigurationTemplate",
               "Remove-EDRSJob",
               "Remove-EDRSRecoveryInstance",
               "Remove-EDRSReplicationConfigurationTemplate",
               "Remove-EDRSSourceServer",
               "Get-EDRSJobLogItem",
               "Get-EDRSJob",
               "Get-EDRSRecoveryInstance",
               "Get-EDRSRecoverySnapshot",
               "Get-EDRSReplicationConfigurationTemplate",
               "Get-EDRSSourceServer",
               "Disconnect-EDRSRecoveryInstance",
               "Disconnect-EDRSSourceServer",
               "Get-EDRSFailbackReplicationConfiguration",
               "Get-EDRSLaunchConfiguration",
               "Get-EDRSReplicationConfiguration",
               "Initialize-EDRSService",
               "Get-EDRSExtensibleSourceServerList",
               "Get-EDRSStagingAccountList",
               "Get-EDRSResourceTag",
               "Restart-EDRSDataReplication",
               "Start-EDRSFailbackLaunch",
               "Start-EDRSRecovery",
               "Stop-EDRSFailback",
               "Add-EDRSResourceTag",
               "Stop-EDRSRecoveryInstance",
               "Remove-EDRSResourceTag",
               "Update-EDRSFailbackReplicationConfiguration",
               "Update-EDRSLaunchConfiguration",
               "Update-EDRSReplicationConfiguration",
               "Update-EDRSReplicationConfigurationTemplate")
}

_awsArgumentCompleterRegistration $EDRS_SelectCompleters $EDRS_SelectMap
# Argument completions for service AWS Directory Service


$DS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DirectoryService.CertificateType
        "Register-DSCertificate/Type"
        {
            $v = "ClientCertAuth","ClientLDAPS"
            break
        }

        # Amazon.DirectoryService.ClientAuthenticationType
        {
            ($_ -eq "Disable-DSClientAuthentication/Type") -Or
            ($_ -eq "Enable-DSClientAuthentication/Type") -Or
            ($_ -eq "Get-DSClientAuthenticationSetting/Type")
        }
        {
            $v = "SmartCard","SmartCardOrPassword"
            break
        }

        # Amazon.DirectoryService.DirectoryConfigurationStatus
        "Get-DSSetting/Status"
        {
            $v = "Default","Failed","Requested","Updated","Updating"
            break
        }

        # Amazon.DirectoryService.DirectoryEdition
        "New-DSMicrosoftAD/Edition"
        {
            $v = "Enterprise","Standard"
            break
        }

        # Amazon.DirectoryService.DirectorySize
        {
            ($_ -eq "Connect-DSDirectory/Size") -Or
            ($_ -eq "New-DSDirectory/Size")
        }
        {
            $v = "Large","Small"
            break
        }

        # Amazon.DirectoryService.LDAPSType
        {
            ($_ -eq "Disable-DSLDAPS/Type") -Or
            ($_ -eq "Enable-DSLDAPS/Type") -Or
            ($_ -eq "Get-DSLDAPSSetting/Type")
        }
        {
            $v = "Client"
            break
        }

        # Amazon.DirectoryService.OSVersion
        "Update-DSDirectorySetup/OSUpdateSettings_OSVersion"
        {
            $v = "SERVER_2012","SERVER_2019"
            break
        }

        # Amazon.DirectoryService.RadiusAuthenticationProtocol
        {
            ($_ -eq "Enable-DSRadius/RadiusSettings_AuthenticationProtocol") -Or
            ($_ -eq "Update-DSRadius/RadiusSettings_AuthenticationProtocol")
        }
        {
            $v = "CHAP","MS-CHAPv1","MS-CHAPv2","PAP"
            break
        }

        # Amazon.DirectoryService.SelectiveAuth
        {
            ($_ -eq "New-DSTrust/SelectiveAuth") -Or
            ($_ -eq "Update-DSTrust/SelectiveAuth")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.DirectoryService.ShareMethod
        "Enable-DSDirectoryShare/ShareMethod"
        {
            $v = "HANDSHAKE","ORGANIZATIONS"
            break
        }

        # Amazon.DirectoryService.TargetType
        {
            ($_ -eq "Enable-DSDirectoryShare/ShareTarget_Type") -Or
            ($_ -eq "Disable-DSDirectoryShare/UnshareTarget_Type")
        }
        {
            $v = "ACCOUNT"
            break
        }

        # Amazon.DirectoryService.TrustDirection
        "New-DSTrust/TrustDirection"
        {
            $v = "One-Way: Incoming","One-Way: Outgoing","Two-Way"
            break
        }

        # Amazon.DirectoryService.TrustType
        "New-DSTrust/TrustType"
        {
            $v = "External","Forest"
            break
        }

        # Amazon.DirectoryService.UpdateType
        {
            ($_ -eq "Get-DSUpdateDirectory/UpdateType") -Or
            ($_ -eq "Update-DSDirectorySetup/UpdateType")
        }
        {
            $v = "OS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DS_map = @{
    "Edition"=@("New-DSMicrosoftAD")
    "OSUpdateSettings_OSVersion"=@("Update-DSDirectorySetup")
    "RadiusSettings_AuthenticationProtocol"=@("Enable-DSRadius","Update-DSRadius")
    "SelectiveAuth"=@("New-DSTrust","Update-DSTrust")
    "ShareMethod"=@("Enable-DSDirectoryShare")
    "ShareTarget_Type"=@("Enable-DSDirectoryShare")
    "Size"=@("Connect-DSDirectory","New-DSDirectory")
    "Status"=@("Get-DSSetting")
    "TrustDirection"=@("New-DSTrust")
    "TrustType"=@("New-DSTrust")
    "Type"=@("Disable-DSClientAuthentication","Disable-DSLDAPS","Enable-DSClientAuthentication","Enable-DSLDAPS","Get-DSClientAuthenticationSetting","Get-DSLDAPSSetting","Register-DSCertificate")
    "UnshareTarget_Type"=@("Disable-DSDirectoryShare")
    "UpdateType"=@("Get-DSUpdateDirectory","Update-DSDirectorySetup")
}

_awsArgumentCompleterRegistration $DS_Completers $DS_map

$DS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DS_SelectMap = @{
    "Select"=@("Confirm-DSSharedDirectory",
               "Add-DSIpRoute",
               "Add-DSRegion",
               "Add-DSResourceTag",
               "Stop-DSSchemaExtension",
               "Connect-DSDirectory",
               "New-DSAlias",
               "New-DSComputer",
               "New-DSConditionalForwarder",
               "New-DSDirectory",
               "New-DSLogSubscription",
               "New-DSMicrosoftAD",
               "New-DSSnapshot",
               "New-DSTrust",
               "Remove-DSConditionalForwarder",
               "Remove-DSDirectory",
               "Remove-DSLogSubscription",
               "Remove-DSSnapshot",
               "Remove-DSTrust",
               "Unregister-DSCertificate",
               "Unregister-DSEventTopic",
               "Get-DSCertificate",
               "Get-DSClientAuthenticationSetting",
               "Get-DSConditionalForwarder",
               "Get-DSDirectory",
               "Get-DSDomainControllerList",
               "Get-DSEventTopic",
               "Get-DSLDAPSSetting",
               "Get-DSRegion",
               "Get-DSSetting",
               "Get-DSSharedDirectory",
               "Get-DSSnapshot",
               "Get-DSTrust",
               "Get-DSUpdateDirectory",
               "Disable-DSClientAuthentication",
               "Disable-DSLDAPS",
               "Disable-DSRadius",
               "Disable-DSSso",
               "Enable-DSClientAuthentication",
               "Enable-DSLDAPS",
               "Enable-DSRadius",
               "Enable-DSSso",
               "Get-DSDirectoryLimit",
               "Get-DSSnapshotLimit",
               "Get-DSCertificateList",
               "Get-DSIpRouteList",
               "Get-DSLogSubscriptionList",
               "Get-DSSchemaExtension",
               "Get-DSResourceTag",
               "Register-DSCertificate",
               "Register-DSEventTopic",
               "Deny-DSSharedDirectory",
               "Remove-DSIpRoute",
               "Remove-DSRegion",
               "Remove-DSResourceTag",
               "Reset-DSUserPassword",
               "Restore-DSFromSnapshot",
               "Enable-DSDirectoryShare",
               "Start-DSSchemaExtension",
               "Disable-DSDirectoryShare",
               "Update-DSConditionalForwarder",
               "Update-DSDirectorySetup",
               "Set-DSDomainControllerCount",
               "Update-DSRadius",
               "Update-DSSetting",
               "Update-DSTrust",
               "Approve-DSTrust")
}

_awsArgumentCompleterRegistration $DS_SelectCompleters $DS_SelectMap
# Argument completions for service Amazon DynamoDB


$DDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DynamoDBv2.BackupTypeFilter
        "Get-DDBBackupList/BackupType"
        {
            $v = "ALL","AWS_BACKUP","SYSTEM","USER"
            break
        }

        # Amazon.DynamoDBv2.BillingMode
        {
            ($_ -eq "New-DDBTable/BillingMode") -Or
            ($_ -eq "Update-DDBTable/BillingMode") -Or
            ($_ -eq "Restore-DDBTableFromBackup/BillingModeOverride") -Or
            ($_ -eq "Restore-DDBTableToPointInTime/BillingModeOverride") -Or
            ($_ -eq "Update-DDBGlobalTableSetting/GlobalTableBillingMode") -Or
            ($_ -eq "Import-DDBTable/TableCreationParameters_BillingMode")
        }
        {
            $v = "PAY_PER_REQUEST","PROVISIONED"
            break
        }

        # Amazon.DynamoDBv2.ContributorInsightsAction
        "Update-DDBContributorInsight/ContributorInsightsAction"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.DynamoDBv2.ExportFormat
        "Export-DDBTableToPointInTime/ExportFormat"
        {
            $v = "DYNAMODB_JSON","ION"
            break
        }

        # Amazon.DynamoDBv2.InputCompressionType
        "Import-DDBTable/InputCompressionType"
        {
            $v = "GZIP","NONE","ZSTD"
            break
        }

        # Amazon.DynamoDBv2.InputFormat
        "Import-DDBTable/InputFormat"
        {
            $v = "CSV","DYNAMODB_JSON","ION"
            break
        }

        # Amazon.DynamoDBv2.KeyType
        "Add-DDBKeySchema/KeyType"
        {
            $v = "HASH","RANGE"
            break
        }

        # Amazon.DynamoDBv2.ProjectionType
        "Add-DDBIndexSchema/ProjectionType"
        {
            $v = "ALL","INCLUDE","KEYS_ONLY"
            break
        }

        # Amazon.DynamoDBv2.ReturnConsumedCapacity
        {
            ($_ -eq "Get-DDBItemTransactionally/ReturnConsumedCapacity") -Or
            ($_ -eq "Invoke-DDBDDBBatchExecuteStatement/ReturnConsumedCapacity") -Or
            ($_ -eq "Invoke-DDBDDBExecuteStatement/ReturnConsumedCapacity") -Or
            ($_ -eq "Invoke-DDBDDBExecuteTransaction/ReturnConsumedCapacity") -Or
            ($_ -eq "Write-DDBItemTransactionally/ReturnConsumedCapacity")
        }
        {
            $v = "INDEXES","NONE","TOTAL"
            break
        }

        # Amazon.DynamoDBv2.ReturnItemCollectionMetrics
        "Write-DDBItemTransactionally/ReturnItemCollectionMetrics"
        {
            $v = "NONE","SIZE"
            break
        }

        # Amazon.DynamoDBv2.S3SseAlgorithm
        "Export-DDBTableToPointInTime/S3SseAlgorithm"
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.DynamoDBv2.ScalarAttributeType
        {
            ($_ -eq "Add-DDBIndexSchema/HashKeyDataType") -Or
            ($_ -eq "Add-DDBKeySchema/KeyDataType") -Or
            ($_ -eq "Add-DDBIndexSchema/RangeKeyDataType")
        }
        {
            $v = "B","N","S"
            break
        }

        # Amazon.DynamoDBv2.SSEType
        {
            ($_ -eq "Update-DDBTable/SSESpecification_SSEType") -Or
            ($_ -eq "Restore-DDBTableFromBackup/SSESpecificationOverride_SSEType") -Or
            ($_ -eq "Restore-DDBTableToPointInTime/SSESpecificationOverride_SSEType") -Or
            ($_ -eq "Import-DDBTable/TableCreationParameters_SSESpecification_SSEType")
        }
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.DynamoDBv2.StreamViewType
        "Update-DDBTable/StreamSpecification_StreamViewType"
        {
            $v = "KEYS_ONLY","NEW_AND_OLD_IMAGES","NEW_IMAGE","OLD_IMAGE"
            break
        }

        # Amazon.DynamoDBv2.TableClass
        "Update-DDBTable/TableClass"
        {
            $v = "STANDARD","STANDARD_INFREQUENT_ACCESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_map = @{
    "BackupType"=@("Get-DDBBackupList")
    "BillingMode"=@("New-DDBTable","Update-DDBTable")
    "BillingModeOverride"=@("Restore-DDBTableFromBackup","Restore-DDBTableToPointInTime")
    "ContributorInsightsAction"=@("Update-DDBContributorInsight")
    "ExportFormat"=@("Export-DDBTableToPointInTime")
    "GlobalTableBillingMode"=@("Update-DDBGlobalTableSetting")
    "HashKeyDataType"=@("Add-DDBIndexSchema")
    "InputCompressionType"=@("Import-DDBTable")
    "InputFormat"=@("Import-DDBTable")
    "KeyDataType"=@("Add-DDBKeySchema")
    "KeyType"=@("Add-DDBKeySchema")
    "ProjectionType"=@("Add-DDBIndexSchema")
    "RangeKeyDataType"=@("Add-DDBIndexSchema")
    "ReturnConsumedCapacity"=@("Get-DDBItemTransactionally","Invoke-DDBDDBBatchExecuteStatement","Invoke-DDBDDBExecuteStatement","Invoke-DDBDDBExecuteTransaction","Write-DDBItemTransactionally")
    "ReturnItemCollectionMetrics"=@("Write-DDBItemTransactionally")
    "S3SseAlgorithm"=@("Export-DDBTableToPointInTime")
    "SSESpecification_SSEType"=@("Update-DDBTable")
    "SSESpecificationOverride_SSEType"=@("Restore-DDBTableFromBackup","Restore-DDBTableToPointInTime")
    "StreamSpecification_StreamViewType"=@("Update-DDBTable")
    "TableClass"=@("Update-DDBTable")
    "TableCreationParameters_BillingMode"=@("Import-DDBTable")
    "TableCreationParameters_SSESpecification_SSEType"=@("Import-DDBTable")
}

_awsArgumentCompleterRegistration $DDB_Completers $DDB_map

$DDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_SelectMap = @{
    "Select"=@("Invoke-DDBDDBBatchExecuteStatement",
               "New-DDBBackup",
               "New-DDBGlobalTable",
               "Remove-DDBBackup",
               "Remove-DDBTable",
               "Get-DDBBackup",
               "Get-DDBContinuousBackup",
               "Get-DDBContributorInsight",
               "Get-DDBEndpoint",
               "Get-DDBExport",
               "Get-DDBGlobalTable",
               "Get-DDBGlobalTableSetting",
               "Get-DDBImport",
               "Get-DDBKinesisStreamingDestination",
               "Get-DDBProvisionLimit",
               "Get-DDBTable",
               "Get-DDBTableReplicaAutoScaling",
               "Get-DDBTimeToLive",
               "Disable-DDBKinesisStreamingDestination",
               "Enable-DDBKinesisStreamingDestination",
               "Invoke-DDBDDBExecuteStatement",
               "Invoke-DDBDDBExecuteTransaction",
               "Export-DDBTableToPointInTime",
               "Import-DDBTable",
               "Get-DDBBackupList",
               "Get-DDBContributorInsightList",
               "Get-DDBExportList",
               "Get-DDBGlobalTableList",
               "Get-DDBImportList",
               "Get-DDBTableList",
               "Get-DDBResourceTag",
               "Restore-DDBTableFromBackup",
               "Restore-DDBTableToPointInTime",
               "Add-DDBResourceTag",
               "Get-DDBItemTransactionally",
               "Write-DDBItemTransactionally",
               "Remove-DDBResourceTag",
               "Update-DDBContinuousBackup",
               "Update-DDBContributorInsight",
               "Update-DDBGlobalTable",
               "Update-DDBGlobalTableSetting",
               "Update-DDBTable",
               "Update-DDBTableReplicaAutoScaling",
               "Update-DDBTimeToLive",
               "Add-DDBIndexSchema",
               "Add-DDBKeySchema",
               "New-DDBTable",
               "New-DDBTableSchema")
}

_awsArgumentCompleterRegistration $DDB_SelectCompleters $DDB_SelectMap
# Argument completions for service Amazon DynamoDB


$DDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DynamoDBv2.BillingMode
        "New-DDBTable/BillingMode"
        {
            $v = "PAY_PER_REQUEST","PROVISIONED"
            break
        }

        # Amazon.DynamoDBv2.KeyType
        "Add-DDBKeySchema/KeyType"
        {
            $v = "HASH","RANGE"
            break
        }

        # Amazon.DynamoDBv2.ProjectionType
        "Add-DDBIndexSchema/ProjectionType"
        {
            $v = "ALL","INCLUDE","KEYS_ONLY"
            break
        }

        # Amazon.DynamoDBv2.ScalarAttributeType
        {
            ($_ -eq "Add-DDBIndexSchema/HashKeyDataType") -Or
            ($_ -eq "Add-DDBKeySchema/KeyDataType") -Or
            ($_ -eq "Add-DDBIndexSchema/RangeKeyDataType")
        }
        {
            $v = "B","N","S"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_map = @{
    "BillingMode"=@("New-DDBTable")
    "HashKeyDataType"=@("Add-DDBIndexSchema")
    "KeyDataType"=@("Add-DDBKeySchema")
    "KeyType"=@("Add-DDBKeySchema")
    "ProjectionType"=@("Add-DDBIndexSchema")
    "RangeKeyDataType"=@("Add-DDBIndexSchema")
}

_awsArgumentCompleterRegistration $DDB_Completers $DDB_map

$DDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_SelectMap = @{
    "Select"=@("Get-DDBStream",
               "Get-DDBStreamList",
               "Add-DDBIndexSchema",
               "Add-DDBKeySchema",
               "New-DDBTable",
               "New-DDBTableSchema")
}

_awsArgumentCompleterRegistration $DDB_SelectCompleters $DDB_SelectMap
# Argument completions for service Amazon EBS


$EBS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EBS.ChecksumAggregationMethod
        "Complete-EBSSnapshot/ChecksumAggregationMethod"
        {
            $v = "LINEAR"
            break
        }

        # Amazon.EBS.ChecksumAlgorithm
        {
            ($_ -eq "Complete-EBSSnapshot/ChecksumAlgorithm") -Or
            ($_ -eq "Write-EBSSnapshotBlock/ChecksumAlgorithm")
        }
        {
            $v = "SHA256"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EBS_map = @{
    "ChecksumAggregationMethod"=@("Complete-EBSSnapshot")
    "ChecksumAlgorithm"=@("Complete-EBSSnapshot","Write-EBSSnapshotBlock")
}

_awsArgumentCompleterRegistration $EBS_Completers $EBS_map

$EBS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EBS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EBS_SelectMap = @{
    "Select"=@("Complete-EBSSnapshot",
               "Get-EBSSnapshotBlock",
               "Get-EBSChangedBlockList",
               "Get-EBSSnapshotBlockList",
               "Write-EBSSnapshotBlock",
               "Start-EBSSnapshot")
}

_awsArgumentCompleterRegistration $EBS_SelectCompleters $EBS_SelectMap
# Argument completions for service Amazon Elastic Compute Cloud (EC2)


$EC2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EC2.AddressAttributeName
        {
            ($_ -eq "Get-EC2AddressesAttribute/Attribute") -Or
            ($_ -eq "Reset-EC2AddressAttribute/Attribute")
        }
        {
            $v = "domain-name"
            break
        }

        # Amazon.EC2.AddressFamily
        "New-EC2IpamPool/AddressFamily"
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.EC2.Affinity
        "Edit-EC2InstancePlacement/Affinity"
        {
            $v = "default","host"
            break
        }

        # Amazon.EC2.AllocationStrategy
        "Request-EC2SpotFleet/SpotFleetRequestConfig_AllocationStrategy"
        {
            $v = "capacityOptimized","capacityOptimizedPrioritized","diversified","lowestPrice","priceCapacityOptimized"
            break
        }

        # Amazon.EC2.ApplianceModeSupportValue
        {
            ($_ -eq "Edit-EC2TransitGatewayVpcAttachment/Options_ApplianceModeSupport") -Or
            ($_ -eq "New-EC2TransitGatewayVpcAttachment/Options_ApplianceModeSupport")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.ArchitectureValues
        "Register-EC2Image/Architecture"
        {
            $v = "arm64","arm64_mac","i386","x86_64","x86_64_mac"
            break
        }

        # Amazon.EC2.AutoAcceptSharedAssociationsValue
        "New-EC2TransitGatewayMulticastDomain/Options_AutoAcceptSharedAssociations"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.AutoAcceptSharedAttachmentsValue
        {
            ($_ -eq "Edit-EC2TransitGateway/Options_AutoAcceptSharedAttachments") -Or
            ($_ -eq "New-EC2TransitGateway/Options_AutoAcceptSharedAttachments")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.AutoPlacement
        {
            ($_ -eq "Edit-EC2Host/AutoPlacement") -Or
            ($_ -eq "New-EC2Host/AutoPlacement")
        }
        {
            $v = "off","on"
            break
        }

        # Amazon.EC2.BareMetal
        {
            ($_ -eq "Get-EC2InstanceTypesFromInstanceRequirement/InstanceRequirements_BareMetal") -Or
            ($_ -eq "Get-EC2SpotPlacementScore/InstanceRequirementsWithMetadata_InstanceRequirements_BareMetal")
        }
        {
            $v = "excluded","included","required"
            break
        }

        # Amazon.EC2.BootModeValues
        {
            ($_ -eq "Import-EC2Image/BootMode") -Or
            ($_ -eq "Register-EC2Image/BootMode")
        }
        {
            $v = "legacy-bios","uefi"
            break
        }

        # Amazon.EC2.BurstablePerformance
        {
            ($_ -eq "Get-EC2InstanceTypesFromInstanceRequirement/InstanceRequirements_BurstablePerformance") -Or
            ($_ -eq "Get-EC2SpotPlacementScore/InstanceRequirementsWithMetadata_InstanceRequirements_BurstablePerformance")
        }
        {
            $v = "excluded","included","required"
            break
        }

        # Amazon.EC2.CapacityReservationInstancePlatform
        "Add-EC2CapacityReservation/InstancePlatform"
        {
            $v = "Linux with SQL Server Enterprise","Linux with SQL Server Standard","Linux with SQL Server Web","Linux/UNIX","Red Hat Enterprise Linux","RHEL with HA","RHEL with HA and SQL Server Enterprise","RHEL with HA and SQL Server Standard","RHEL with SQL Server Enterprise","RHEL with SQL Server Standard","RHEL with SQL Server Web","SUSE Linux","Windows","Windows with SQL Server","Windows with SQL Server Enterprise","Windows with SQL Server Standard","Windows with SQL Server Web"
            break
        }

        # Amazon.EC2.CapacityReservationPreference
        {
            ($_ -eq "Edit-EC2InstanceCapacityReservationAttribute/CapacityReservationSpecification_CapacityReservationPreference") -Or
            ($_ -eq "New-EC2Instance/CapacityReservationSpecification_CapacityReservationPreference")
        }
        {
            $v = "none","open"
            break
        }

        # Amazon.EC2.CapacityReservationTenancy
        "Add-EC2CapacityReservation/Tenancy"
        {
            $v = "dedicated","default"
            break
        }

        # Amazon.EC2.ConnectivityType
        "New-EC2NatGateway/ConnectivityType"
        {
            $v = "private","public"
            break
        }

        # Amazon.EC2.ContainerFormat
        "New-EC2InstanceExportTask/ExportToS3Task_ContainerFormat"
        {
            $v = "ova"
            break
        }

        # Amazon.EC2.CopyTagsFromSource
        "New-EC2SnapshotBatch/CopyTagsFromSource"
        {
            $v = "volume"
            break
        }

        # Amazon.EC2.CurrencyCodeValues
        {
            ($_ -eq "New-EC2HostReservation/CurrencyCode") -Or
            ($_ -eq "New-EC2ReservedInstance/LimitPrice_CurrencyCode")
        }
        {
            $v = "USD"
            break
        }

        # Amazon.EC2.DefaultRouteTableAssociationValue
        {
            ($_ -eq "Edit-EC2TransitGateway/Options_DefaultRouteTableAssociation") -Or
            ($_ -eq "New-EC2TransitGateway/Options_DefaultRouteTableAssociation")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DefaultRouteTablePropagationValue
        {
            ($_ -eq "Edit-EC2TransitGateway/Options_DefaultRouteTablePropagation") -Or
            ($_ -eq "New-EC2TransitGateway/Options_DefaultRouteTablePropagation")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DefaultTargetCapacityType
        {
            ($_ -eq "Edit-EC2Fleet/TargetCapacitySpecification_DefaultTargetCapacityType") -Or
            ($_ -eq "New-EC2Fleet/TargetCapacitySpecification_DefaultTargetCapacityType")
        }
        {
            $v = "on-demand","spot"
            break
        }

        # Amazon.EC2.DestinationFileFormat
        "New-EC2FlowLog/DestinationOptions_FileFormat"
        {
            $v = "parquet","plain-text"
            break
        }

        # Amazon.EC2.DiskImageFormat
        {
            ($_ -eq "Export-EC2Image/DiskImageFormat") -Or
            ($_ -eq "New-EC2InstanceExportTask/ExportToS3Task_DiskImageFormat")
        }
        {
            $v = "RAW","VHD","VMDK"
            break
        }

        # Amazon.EC2.DnsRecordIpType
        {
            ($_ -eq "Edit-EC2VpcEndpoint/DnsOptions_DnsRecordIpType") -Or
            ($_ -eq "New-EC2VpcEndpoint/DnsOptions_DnsRecordIpType")
        }
        {
            $v = "dualstack","ipv4","ipv6","service-defined"
            break
        }

        # Amazon.EC2.DnsSupportValue
        {
            ($_ -eq "Edit-EC2TransitGateway/Options_DnsSupport") -Or
            ($_ -eq "Edit-EC2TransitGatewayVpcAttachment/Options_DnsSupport") -Or
            ($_ -eq "New-EC2TransitGateway/Options_DnsSupport") -Or
            ($_ -eq "New-EC2TransitGatewayVpcAttachment/Options_DnsSupport")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DomainType
        "New-EC2Address/Domain"
        {
            $v = "standard","vpc"
            break
        }

        # Amazon.EC2.DynamicRoutingValue
        "New-EC2TransitGatewayPeeringAttachment/Options_DynamicRouting"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.EndDateType
        {
            ($_ -eq "Add-EC2CapacityReservation/EndDateType") -Or
            ($_ -eq "Edit-EC2CapacityReservation/EndDateType")
        }
        {
            $v = "limited","unlimited"
            break
        }

        # Amazon.EC2.EventType
        "Get-EC2SpotFleetRequestHistory/EventType"
        {
            $v = "error","fleetRequestChange","information","instanceChange"
            break
        }

        # Amazon.EC2.ExcessCapacityTerminationPolicy
        {
            ($_ -eq "Edit-EC2SpotFleetRequest/ExcessCapacityTerminationPolicy") -Or
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_ExcessCapacityTerminationPolicy")
        }
        {
            $v = "default","noTermination"
            break
        }

        # Amazon.EC2.ExportEnvironment
        "New-EC2InstanceExportTask/TargetEnvironment"
        {
            $v = "citrix","microsoft","vmware"
            break
        }

        # Amazon.EC2.FleetCapacityReservationTenancy
        "New-EC2CapacityReservationFleet/Tenancy"
        {
            $v = "default"
            break
        }

        # Amazon.EC2.FleetCapacityReservationUsageStrategy
        "New-EC2Fleet/OnDemandOptions_CapacityReservationOptions_UsageStrategy"
        {
            $v = "use-capacity-reservations-first"
            break
        }

        # Amazon.EC2.FleetEventType
        "Get-EC2FleetHistory/EventType"
        {
            $v = "fleet-change","instance-change","service-error"
            break
        }

        # Amazon.EC2.FleetExcessCapacityTerminationPolicy
        {
            ($_ -eq "Edit-EC2Fleet/ExcessCapacityTerminationPolicy") -Or
            ($_ -eq "New-EC2Fleet/ExcessCapacityTerminationPolicy")
        }
        {
            $v = "no-termination","termination"
            break
        }

        # Amazon.EC2.FleetInstanceMatchCriteria
        "New-EC2CapacityReservationFleet/InstanceMatchCriteria"
        {
            $v = "open"
            break
        }

        # Amazon.EC2.FleetOnDemandAllocationStrategy
        "New-EC2Fleet/OnDemandOptions_AllocationStrategy"
        {
            $v = "lowest-price","prioritized"
            break
        }

        # Amazon.EC2.FleetReplacementStrategy
        "New-EC2Fleet/SpotOptions_MaintenanceStrategies_CapacityRebalance_ReplacementStrategy"
        {
            $v = "launch","launch-before-terminate"
            break
        }

        # Amazon.EC2.FleetType
        {
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_Type") -Or
            ($_ -eq "New-EC2Fleet/Type")
        }
        {
            $v = "instant","maintain","request"
            break
        }

        # Amazon.EC2.FlowLogsResourceType
        "New-EC2FlowLog/ResourceType"
        {
            $v = "NetworkInterface","Subnet","TransitGateway","TransitGatewayAttachment","VPC"
            break
        }

        # Amazon.EC2.FpgaImageAttributeName
        {
            ($_ -eq "Edit-EC2FpgaImageAttribute/Attribute") -Or
            ($_ -eq "Get-EC2FpgaImageAttribute/Attribute")
        }
        {
            $v = "description","loadPermission","name","productCodes"
            break
        }

        # Amazon.EC2.GatewayType
        {
            ($_ -eq "New-EC2CustomerGateway/Type") -Or
            ($_ -eq "New-EC2VpnGateway/Type")
        }
        {
            $v = "ipsec.1"
            break
        }

        # Amazon.EC2.HostnameType
        {
            ($_ -eq "Edit-EC2PrivateDnsNameOption/PrivateDnsHostnameType") -Or
            ($_ -eq "Edit-EC2SubnetAttribute/PrivateDnsHostnameTypeOnLaunch") -Or
            ($_ -eq "New-EC2Instance/PrivateDnsNameOptions_HostnameType")
        }
        {
            $v = "ip-name","resource-name"
            break
        }

        # Amazon.EC2.HostRecovery
        {
            ($_ -eq "Edit-EC2Host/HostRecovery") -Or
            ($_ -eq "New-EC2Host/HostRecovery")
        }
        {
            $v = "off","on"
            break
        }

        # Amazon.EC2.HostTenancy
        "Edit-EC2InstancePlacement/Tenancy"
        {
            $v = "dedicated","host"
            break
        }

        # Amazon.EC2.HttpTokensState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/HttpTokens") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_HttpTokens")
        }
        {
            $v = "optional","required"
            break
        }

        # Amazon.EC2.Igmpv2SupportValue
        "New-EC2TransitGatewayMulticastDomain/Options_Igmpv2Support"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.ImageAttributeName
        "Get-EC2ImageAttribute/Attribute"
        {
            $v = "blockDeviceMapping","bootMode","description","imdsSupport","kernel","lastLaunchedTime","launchPermission","productCodes","ramdisk","sriovNetSupport","tpmSupport","uefiData"
            break
        }

        # Amazon.EC2.ImdsSupportValues
        "Register-EC2Image/ImdsSupport"
        {
            $v = "v2.0"
            break
        }

        # Amazon.EC2.InstanceAttributeName
        {
            ($_ -eq "Edit-EC2InstanceAttribute/Attribute") -Or
            ($_ -eq "Get-EC2InstanceAttribute/Attribute") -Or
            ($_ -eq "Reset-EC2InstanceAttribute/Attribute")
        }
        {
            $v = "blockDeviceMapping","disableApiStop","disableApiTermination","ebsOptimized","enaSupport","enclaveOptions","groupSet","instanceInitiatedShutdownBehavior","instanceType","kernel","productCodes","ramdisk","rootDeviceName","sourceDestCheck","sriovNetSupport","userData"
            break
        }

        # Amazon.EC2.InstanceAutoRecoveryState
        {
            ($_ -eq "Edit-EC2InstanceMaintenanceOption/AutoRecovery") -Or
            ($_ -eq "New-EC2Instance/MaintenanceOptions_AutoRecovery")
        }
        {
            $v = "default","disabled"
            break
        }

        # Amazon.EC2.InstanceInterruptionBehavior
        {
            ($_ -eq "Request-EC2SpotInstance/InstanceInterruptionBehavior") -Or
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_InstanceInterruptionBehavior")
        }
        {
            $v = "hibernate","stop","terminate"
            break
        }

        # Amazon.EC2.InstanceMatchCriteria
        "Add-EC2CapacityReservation/InstanceMatchCriteria"
        {
            $v = "open","targeted"
            break
        }

        # Amazon.EC2.InstanceMetadataEndpointState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/HttpEndpoint") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_HttpEndpoint")
        }
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.EC2.InstanceMetadataProtocolState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/HttpProtocolIpv6") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_HttpProtocolIpv6")
        }
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.EC2.InstanceMetadataTagsState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/InstanceMetadataTags") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_InstanceMetadataTags")
        }
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.EC2.InstanceType
        {
            ($_ -eq "Get-EC2ReservedInstancesOffering/InstanceType") -Or
            ($_ -eq "New-EC2Instance/InstanceType") -Or
            ($_ -eq "Request-EC2SpotInstance/LaunchSpecification_InstanceType")
        }
        {
            $v = "a1.2xlarge","a1.4xlarge","a1.large","a1.medium","a1.metal","a1.xlarge","c1.medium","c1.xlarge","c3.2xlarge","c3.4xlarge","c3.8xlarge","c3.large","c3.xlarge","c4.2xlarge","c4.4xlarge","c4.8xlarge","c4.large","c4.xlarge","c5.12xlarge","c5.18xlarge","c5.24xlarge","c5.2xlarge","c5.4xlarge","c5.9xlarge","c5.large","c5.metal","c5.xlarge","c5a.12xlarge","c5a.16xlarge","c5a.24xlarge","c5a.2xlarge","c5a.4xlarge","c5a.8xlarge","c5a.large","c5a.xlarge","c5ad.12xlarge","c5ad.16xlarge","c5ad.24xlarge","c5ad.2xlarge","c5ad.4xlarge","c5ad.8xlarge","c5ad.large","c5ad.xlarge","c5d.12xlarge","c5d.18xlarge","c5d.24xlarge","c5d.2xlarge","c5d.4xlarge","c5d.9xlarge","c5d.large","c5d.metal","c5d.xlarge","c5n.18xlarge","c5n.2xlarge","c5n.4xlarge","c5n.9xlarge","c5n.large","c5n.metal","c5n.xlarge","c6a.12xlarge","c6a.16xlarge","c6a.24xlarge","c6a.2xlarge","c6a.32xlarge","c6a.48xlarge","c6a.4xlarge","c6a.8xlarge","c6a.large","c6a.metal","c6a.xlarge","c6g.12xlarge","c6g.16xlarge","c6g.2xlarge","c6g.4xlarge","c6g.8xlarge","c6g.large","c6g.medium","c6g.metal","c6g.xlarge","c6gd.12xlarge","c6gd.16xlarge","c6gd.2xlarge","c6gd.4xlarge","c6gd.8xlarge","c6gd.large","c6gd.medium","c6gd.metal","c6gd.xlarge","c6gn.12xlarge","c6gn.16xlarge","c6gn.2xlarge","c6gn.4xlarge","c6gn.8xlarge","c6gn.large","c6gn.medium","c6gn.xlarge","c6i.12xlarge","c6i.16xlarge","c6i.24xlarge","c6i.2xlarge","c6i.32xlarge","c6i.4xlarge","c6i.8xlarge","c6i.large","c6i.metal","c6i.xlarge","c6id.12xlarge","c6id.16xlarge","c6id.24xlarge","c6id.2xlarge","c6id.32xlarge","c6id.4xlarge","c6id.8xlarge","c6id.large","c6id.metal","c6id.xlarge","c7g.12xlarge","c7g.16xlarge","c7g.2xlarge","c7g.4xlarge","c7g.8xlarge","c7g.large","c7g.medium","c7g.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge","cr1.8xlarge","d2.2xlarge","d2.4xlarge","d2.8xlarge","d2.xlarge","d3.2xlarge","d3.4xlarge","d3.8xlarge","d3.xlarge","d3en.12xlarge","d3en.2xlarge","d3en.4xlarge","d3en.6xlarge","d3en.8xlarge","d3en.xlarge","dl1.24xlarge","f1.16xlarge","f1.2xlarge","f1.4xlarge","g2.2xlarge","g2.8xlarge","g3.16xlarge","g3.4xlarge","g3.8xlarge","g3s.xlarge","g4ad.16xlarge","g4ad.2xlarge","g4ad.4xlarge","g4ad.8xlarge","g4ad.xlarge","g4dn.12xlarge","g4dn.16xlarge","g4dn.2xlarge","g4dn.4xlarge","g4dn.8xlarge","g4dn.metal","g4dn.xlarge","g5.12xlarge","g5.16xlarge","g5.24xlarge","g5.2xlarge","g5.48xlarge","g5.4xlarge","g5.8xlarge","g5.xlarge","g5g.16xlarge","g5g.2xlarge","g5g.4xlarge","g5g.8xlarge","g5g.metal","g5g.xlarge","h1.16xlarge","h1.2xlarge","h1.4xlarge","h1.8xlarge","hi1.4xlarge","hpc6a.48xlarge","hs1.8xlarge","i2.2xlarge","i2.4xlarge","i2.8xlarge","i2.xlarge","i3.16xlarge","i3.2xlarge","i3.4xlarge","i3.8xlarge","i3.large","i3.metal","i3.xlarge","i3en.12xlarge","i3en.24xlarge","i3en.2xlarge","i3en.3xlarge","i3en.6xlarge","i3en.large","i3en.metal","i3en.xlarge","i4i.16xlarge","i4i.2xlarge","i4i.32xlarge","i4i.4xlarge","i4i.8xlarge","i4i.large","i4i.metal","i4i.xlarge","im4gn.16xlarge","im4gn.2xlarge","im4gn.4xlarge","im4gn.8xlarge","im4gn.large","im4gn.xlarge","inf1.24xlarge","inf1.2xlarge","inf1.6xlarge","inf1.xlarge","is4gen.2xlarge","is4gen.4xlarge","is4gen.8xlarge","is4gen.large","is4gen.medium","is4gen.xlarge","m1.large","m1.medium","m1.small","m1.xlarge","m2.2xlarge","m2.4xlarge","m2.xlarge","m3.2xlarge","m3.large","m3.medium","m3.xlarge","m4.10xlarge","m4.16xlarge","m4.2xlarge","m4.4xlarge","m4.large","m4.xlarge","m5.12xlarge","m5.16xlarge","m5.24xlarge","m5.2xlarge","m5.4xlarge","m5.8xlarge","m5.large","m5.metal","m5.xlarge","m5a.12xlarge","m5a.16xlarge","m5a.24xlarge","m5a.2xlarge","m5a.4xlarge","m5a.8xlarge","m5a.large","m5a.xlarge","m5ad.12xlarge","m5ad.16xlarge","m5ad.24xlarge","m5ad.2xlarge","m5ad.4xlarge","m5ad.8xlarge","m5ad.large","m5ad.xlarge","m5d.12xlarge","m5d.16xlarge","m5d.24xlarge","m5d.2xlarge","m5d.4xlarge","m5d.8xlarge","m5d.large","m5d.metal","m5d.xlarge","m5dn.12xlarge","m5dn.16xlarge","m5dn.24xlarge","m5dn.2xlarge","m5dn.4xlarge","m5dn.8xlarge","m5dn.large","m5dn.metal","m5dn.xlarge","m5n.12xlarge","m5n.16xlarge","m5n.24xlarge","m5n.2xlarge","m5n.4xlarge","m5n.8xlarge","m5n.large","m5n.metal","m5n.xlarge","m5zn.12xlarge","m5zn.2xlarge","m5zn.3xlarge","m5zn.6xlarge","m5zn.large","m5zn.metal","m5zn.xlarge","m6a.12xlarge","m6a.16xlarge","m6a.24xlarge","m6a.2xlarge","m6a.32xlarge","m6a.48xlarge","m6a.4xlarge","m6a.8xlarge","m6a.large","m6a.metal","m6a.xlarge","m6g.12xlarge","m6g.16xlarge","m6g.2xlarge","m6g.4xlarge","m6g.8xlarge","m6g.large","m6g.medium","m6g.metal","m6g.xlarge","m6gd.12xlarge","m6gd.16xlarge","m6gd.2xlarge","m6gd.4xlarge","m6gd.8xlarge","m6gd.large","m6gd.medium","m6gd.metal","m6gd.xlarge","m6i.12xlarge","m6i.16xlarge","m6i.24xlarge","m6i.2xlarge","m6i.32xlarge","m6i.4xlarge","m6i.8xlarge","m6i.large","m6i.metal","m6i.xlarge","m6id.12xlarge","m6id.16xlarge","m6id.24xlarge","m6id.2xlarge","m6id.32xlarge","m6id.4xlarge","m6id.8xlarge","m6id.large","m6id.metal","m6id.xlarge","mac1.metal","mac2.metal","p2.16xlarge","p2.8xlarge","p2.xlarge","p3.16xlarge","p3.2xlarge","p3.8xlarge","p3dn.24xlarge","p4d.24xlarge","p4de.24xlarge","r3.2xlarge","r3.4xlarge","r3.8xlarge","r3.large","r3.xlarge","r4.16xlarge","r4.2xlarge","r4.4xlarge","r4.8xlarge","r4.large","r4.xlarge","r5.12xlarge","r5.16xlarge","r5.24xlarge","r5.2xlarge","r5.4xlarge","r5.8xlarge","r5.large","r5.metal","r5.xlarge","r5a.12xlarge","r5a.16xlarge","r5a.24xlarge","r5a.2xlarge","r5a.4xlarge","r5a.8xlarge","r5a.large","r5a.xlarge","r5ad.12xlarge","r5ad.16xlarge","r5ad.24xlarge","r5ad.2xlarge","r5ad.4xlarge","r5ad.8xlarge","r5ad.large","r5ad.xlarge","r5b.12xlarge","r5b.16xlarge","r5b.24xlarge","r5b.2xlarge","r5b.4xlarge","r5b.8xlarge","r5b.large","r5b.metal","r5b.xlarge","r5d.12xlarge","r5d.16xlarge","r5d.24xlarge","r5d.2xlarge","r5d.4xlarge","r5d.8xlarge","r5d.large","r5d.metal","r5d.xlarge","r5dn.12xlarge","r5dn.16xlarge","r5dn.24xlarge","r5dn.2xlarge","r5dn.4xlarge","r5dn.8xlarge","r5dn.large","r5dn.metal","r5dn.xlarge","r5n.12xlarge","r5n.16xlarge","r5n.24xlarge","r5n.2xlarge","r5n.4xlarge","r5n.8xlarge","r5n.large","r5n.metal","r5n.xlarge","r6a.12xlarge","r6a.16xlarge","r6a.24xlarge","r6a.2xlarge","r6a.32xlarge","r6a.48xlarge","r6a.4xlarge","r6a.8xlarge","r6a.large","r6a.metal","r6a.xlarge","r6g.12xlarge","r6g.16xlarge","r6g.2xlarge","r6g.4xlarge","r6g.8xlarge","r6g.large","r6g.medium","r6g.metal","r6g.xlarge","r6gd.12xlarge","r6gd.16xlarge","r6gd.2xlarge","r6gd.4xlarge","r6gd.8xlarge","r6gd.large","r6gd.medium","r6gd.metal","r6gd.xlarge","r6i.12xlarge","r6i.16xlarge","r6i.24xlarge","r6i.2xlarge","r6i.32xlarge","r6i.4xlarge","r6i.8xlarge","r6i.large","r6i.metal","r6i.xlarge","r6id.12xlarge","r6id.16xlarge","r6id.24xlarge","r6id.2xlarge","r6id.32xlarge","r6id.4xlarge","r6id.8xlarge","r6id.large","r6id.metal","r6id.xlarge","t1.micro","t2.2xlarge","t2.large","t2.medium","t2.micro","t2.nano","t2.small","t2.xlarge","t3.2xlarge","t3.large","t3.medium","t3.micro","t3.nano","t3.small","t3.xlarge","t3a.2xlarge","t3a.large","t3a.medium","t3a.micro","t3a.nano","t3a.small","t3a.xlarge","t4g.2xlarge","t4g.large","t4g.medium","t4g.micro","t4g.nano","t4g.small","t4g.xlarge","trn1.2xlarge","trn1.32xlarge","u-12tb1.112xlarge","u-12tb1.metal","u-18tb1.112xlarge","u-18tb1.metal","u-24tb1.112xlarge","u-24tb1.metal","u-3tb1.56xlarge","u-6tb1.112xlarge","u-6tb1.56xlarge","u-6tb1.metal","u-9tb1.112xlarge","u-9tb1.metal","vt1.24xlarge","vt1.3xlarge","vt1.6xlarge","x1.16xlarge","x1.32xlarge","x1e.16xlarge","x1e.2xlarge","x1e.32xlarge","x1e.4xlarge","x1e.8xlarge","x1e.xlarge","x2gd.12xlarge","x2gd.16xlarge","x2gd.2xlarge","x2gd.4xlarge","x2gd.8xlarge","x2gd.large","x2gd.medium","x2gd.metal","x2gd.xlarge","x2idn.16xlarge","x2idn.24xlarge","x2idn.32xlarge","x2idn.metal","x2iedn.16xlarge","x2iedn.24xlarge","x2iedn.2xlarge","x2iedn.32xlarge","x2iedn.4xlarge","x2iedn.8xlarge","x2iedn.metal","x2iedn.xlarge","x2iezn.12xlarge","x2iezn.2xlarge","x2iezn.4xlarge","x2iezn.6xlarge","x2iezn.8xlarge","x2iezn.metal","z1d.12xlarge","z1d.2xlarge","z1d.3xlarge","z1d.6xlarge","z1d.large","z1d.metal","z1d.xlarge"
            break
        }

        # Amazon.EC2.InterfacePermissionType
        "New-EC2NetworkInterfacePermission/Permission"
        {
            $v = "EIP-ASSOCIATE","INSTANCE-ATTACH"
            break
        }

        # Amazon.EC2.IpAddressType
        {
            ($_ -eq "Edit-EC2VpcEndpoint/IpAddressType") -Or
            ($_ -eq "New-EC2VpcEndpoint/IpAddressType")
        }
        {
            $v = "dualstack","ipv4","ipv6"
            break
        }

        # Amazon.EC2.IpamPoolAwsService
        "New-EC2IpamPool/AwsService"
        {
            $v = "ec2"
            break
        }

        # Amazon.EC2.IpamResourceType
        "Get-EC2IpamResourceCidr/ResourceType"
        {
            $v = "eip","ipv6-pool","public-ipv4-pool","subnet","vpc"
            break
        }

        # Amazon.EC2.Ipv6SupportValue
        {
            ($_ -eq "Edit-EC2TransitGatewayVpcAttachment/Options_Ipv6Support") -Or
            ($_ -eq "New-EC2TransitGatewayVpcAttachment/Options_Ipv6Support")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.KeyFormat
        "New-EC2KeyPair/KeyFormat"
        {
            $v = "pem","ppk"
            break
        }

        # Amazon.EC2.KeyType
        "New-EC2KeyPair/KeyType"
        {
            $v = "ed25519","rsa"
            break
        }

        # Amazon.EC2.LocalGatewayRouteTableMode
        "New-EC2LocalGatewayRouteTable/Mode"
        {
            $v = "coip","direct-vpc-routing"
            break
        }

        # Amazon.EC2.LocalStorage
        {
            ($_ -eq "Get-EC2InstanceTypesFromInstanceRequirement/InstanceRequirements_LocalStorage") -Or
            ($_ -eq "Get-EC2SpotPlacementScore/InstanceRequirementsWithMetadata_InstanceRequirements_LocalStorage")
        }
        {
            $v = "excluded","included","required"
            break
        }

        # Amazon.EC2.LocationType
        "Get-EC2InstanceTypeOffering/LocationType"
        {
            $v = "availability-zone","availability-zone-id","region"
            break
        }

        # Amazon.EC2.LogDestinationType
        "New-EC2FlowLog/LogDestinationType"
        {
            $v = "cloud-watch-logs","kinesis-data-firehose","s3"
            break
        }

        # Amazon.EC2.ModifyAvailabilityZoneOptInStatus
        "Edit-EC2AvailabilityZoneGroup/OptInStatus"
        {
            $v = "not-opted-in","opted-in"
            break
        }

        # Amazon.EC2.MulticastSupportValue
        "New-EC2TransitGateway/Options_MulticastSupport"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.NetworkInterfaceAttribute
        "Get-EC2NetworkInterfaceAttribute/Attribute"
        {
            $v = "attachment","description","groupSet","sourceDestCheck"
            break
        }

        # Amazon.EC2.NetworkInterfaceCreationType
        "New-EC2NetworkInterface/InterfaceType"
        {
            $v = "branch","efa","trunk"
            break
        }

        # Amazon.EC2.OfferingClassType
        {
            ($_ -eq "Get-EC2ReservedInstance/OfferingClass") -Or
            ($_ -eq "Get-EC2ReservedInstancesOffering/OfferingClass")
        }
        {
            $v = "convertible","standard"
            break
        }

        # Amazon.EC2.OfferingTypeValues
        {
            ($_ -eq "Get-EC2ReservedInstance/OfferingType") -Or
            ($_ -eq "Get-EC2ReservedInstancesOffering/OfferingType")
        }
        {
            $v = "All Upfront","Heavy Utilization","Light Utilization","Medium Utilization","No Upfront","Partial Upfront"
            break
        }

        # Amazon.EC2.OnDemandAllocationStrategy
        "Request-EC2SpotFleet/SpotFleetRequestConfig_OnDemandAllocationStrategy"
        {
            $v = "lowestPrice","prioritized"
            break
        }

        # Amazon.EC2.OperationType
        {
            ($_ -eq "Edit-EC2FpgaImageAttribute/OperationType") -Or
            ($_ -eq "Edit-EC2ImageAttribute/OperationType") -Or
            ($_ -eq "Edit-EC2SnapshotAttribute/OperationType")
        }
        {
            $v = "add","remove"
            break
        }

        # Amazon.EC2.PayerResponsibility
        "Edit-EC2VpcEndpointServicePayerResponsibility/PayerResponsibility"
        {
            $v = "ServiceOwner"
            break
        }

        # Amazon.EC2.PlacementStrategy
        "New-EC2PlacementGroup/Strategy"
        {
            $v = "cluster","partition","spread"
            break
        }

        # Amazon.EC2.Protocol
        "New-EC2NetworkInsightsPath/Protocol"
        {
            $v = "tcp","udp"
            break
        }

        # Amazon.EC2.ProtocolValue
        "New-EC2TransitGatewayConnect/Options_Protocol"
        {
            $v = "gre"
            break
        }

        # Amazon.EC2.ReplacementStrategy
        "Request-EC2SpotFleet/SpotFleetRequestConfig_SpotMaintenanceStrategies_CapacityRebalance_ReplacementStrategy"
        {
            $v = "launch","launch-before-terminate"
            break
        }

        # Amazon.EC2.ReportStatusType
        "Send-EC2InstanceStatus/Status"
        {
            $v = "impaired","ok"
            break
        }

        # Amazon.EC2.ResetFpgaImageAttributeName
        "Reset-EC2FpgaImageAttribute/Attribute"
        {
            $v = "loadPermission"
            break
        }

        # Amazon.EC2.ResetImageAttributeName
        "Reset-EC2ImageAttribute/Attribute"
        {
            $v = "launchPermission"
            break
        }

        # Amazon.EC2.RIProductDescription
        "Get-EC2ReservedInstancesOffering/ProductDescription"
        {
            $v = "Linux/UNIX","Linux/UNIX (Amazon VPC)","Windows","Windows (Amazon VPC)"
            break
        }

        # Amazon.EC2.RuleAction
        {
            ($_ -eq "New-EC2NetworkAclEntry/RuleAction") -Or
            ($_ -eq "Set-EC2NetworkAclEntry/RuleAction")
        }
        {
            $v = "allow","deny"
            break
        }

        # Amazon.EC2.SelfServicePortal
        {
            ($_ -eq "Edit-EC2ClientVpnEndpoint/SelfServicePortal") -Or
            ($_ -eq "New-EC2ClientVpnEndpoint/SelfServicePortal")
        }
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.EC2.ShutdownBehavior
        "New-EC2Instance/InstanceInitiatedShutdownBehavior"
        {
            $v = "stop","terminate"
            break
        }

        # Amazon.EC2.SnapshotAttributeName
        {
            ($_ -eq "Edit-EC2SnapshotAttribute/Attribute") -Or
            ($_ -eq "Get-EC2SnapshotAttribute/Attribute") -Or
            ($_ -eq "Reset-EC2SnapshotAttribute/Attribute")
        }
        {
            $v = "createVolumePermission","productCodes"
            break
        }

        # Amazon.EC2.SpotAllocationStrategy
        "New-EC2Fleet/SpotOptions_AllocationStrategy"
        {
            $v = "capacity-optimized","capacity-optimized-prioritized","diversified","lowest-price","price-capacity-optimized"
            break
        }

        # Amazon.EC2.SpotInstanceInterruptionBehavior
        "New-EC2Fleet/SpotOptions_InstanceInterruptionBehavior"
        {
            $v = "hibernate","stop","terminate"
            break
        }

        # Amazon.EC2.SpotInstanceType
        "Request-EC2SpotInstance/Type"
        {
            $v = "one-time","persistent"
            break
        }

        # Amazon.EC2.SpreadLevel
        "New-EC2PlacementGroup/SpreadLevel"
        {
            $v = "host","rack"
            break
        }

        # Amazon.EC2.StaticSourcesSupportValue
        "New-EC2TransitGatewayMulticastDomain/Options_StaticSourcesSupport"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.SubnetCidrReservationType
        "New-EC2SubnetCidrReservation/ReservationType"
        {
            $v = "explicit","prefix"
            break
        }

        # Amazon.EC2.TargetCapacityUnitType
        {
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_TargetCapacityUnitType") -Or
            ($_ -eq "Edit-EC2Fleet/TargetCapacitySpecification_TargetCapacityUnitType") -Or
            ($_ -eq "New-EC2Fleet/TargetCapacitySpecification_TargetCapacityUnitType") -Or
            ($_ -eq "Get-EC2SpotPlacementScore/TargetCapacityUnitType")
        }
        {
            $v = "memory-mib","units","vcpu"
            break
        }

        # Amazon.EC2.TargetStorageTier
        "Edit-EC2SnapshotTier/StorageTier"
        {
            $v = "archive"
            break
        }

        # Amazon.EC2.Tenancy
        {
            ($_ -eq "Get-EC2ReservedInstancesOffering/InstanceTenancy") -Or
            ($_ -eq "New-EC2Vpc/InstanceTenancy") -Or
            ($_ -eq "Request-EC2SpotInstance/LaunchSpecification_Placement_Tenancy") -Or
            ($_ -eq "New-EC2Instance/Placement_Tenancy")
        }
        {
            $v = "dedicated","default","host"
            break
        }

        # Amazon.EC2.TpmSupportValues
        "Register-EC2Image/TpmSupport"
        {
            $v = "v2.0"
            break
        }

        # Amazon.EC2.TrafficDirection
        {
            ($_ -eq "Edit-EC2TrafficMirrorFilterRule/TrafficDirection") -Or
            ($_ -eq "New-EC2TrafficMirrorFilterRule/TrafficDirection")
        }
        {
            $v = "egress","ingress"
            break
        }

        # Amazon.EC2.TrafficMirrorRuleAction
        {
            ($_ -eq "Edit-EC2TrafficMirrorFilterRule/RuleAction") -Or
            ($_ -eq "New-EC2TrafficMirrorFilterRule/RuleAction")
        }
        {
            $v = "accept","reject"
            break
        }

        # Amazon.EC2.TrafficType
        "New-EC2FlowLog/TrafficType"
        {
            $v = "ACCEPT","ALL","REJECT"
            break
        }

        # Amazon.EC2.TransportProtocol
        "New-EC2ClientVpnEndpoint/TransportProtocol"
        {
            $v = "tcp","udp"
            break
        }

        # Amazon.EC2.TunnelInsideIpVersion
        "New-EC2VpnConnection/Options_TunnelInsideIpVersion"
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.EC2.UnlimitedSupportedInstanceFamily
        {
            ($_ -eq "Edit-EC2DefaultCreditSpecification/InstanceFamily") -Or
            ($_ -eq "Get-EC2DefaultCreditSpecification/InstanceFamily")
        }
        {
            $v = "t2","t3","t3a","t4g"
            break
        }

        # Amazon.EC2.VolumeAttributeName
        "Get-EC2VolumeAttribute/Attribute"
        {
            $v = "autoEnableIO","productCodes"
            break
        }

        # Amazon.EC2.VolumeType
        {
            ($_ -eq "Edit-EC2Volume/VolumeType") -Or
            ($_ -eq "New-EC2Volume/VolumeType")
        }
        {
            $v = "gp2","gp3","io1","io2","sc1","st1","standard"
            break
        }

        # Amazon.EC2.VpcAttributeName
        "Get-EC2VpcAttribute/Attribute"
        {
            $v = "enableDnsHostnames","enableDnsSupport","enableNetworkAddressUsageMetrics"
            break
        }

        # Amazon.EC2.VpcEndpointType
        "New-EC2VpcEndpoint/VpcEndpointType"
        {
            $v = "Gateway","GatewayLoadBalancer","Interface"
            break
        }

        # Amazon.EC2.VpcTenancy
        "Edit-EC2VpcTenancy/InstanceTenancy"
        {
            $v = "default"
            break
        }

        # Amazon.EC2.VpnEcmpSupportValue
        {
            ($_ -eq "Edit-EC2TransitGateway/Options_VpnEcmpSupport") -Or
            ($_ -eq "New-EC2TransitGateway/Options_VpnEcmpSupport")
        }
        {
            $v = "disable","enable"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2_map = @{
    "AddressFamily"=@("New-EC2IpamPool")
    "Affinity"=@("Edit-EC2InstancePlacement")
    "Architecture"=@("Register-EC2Image")
    "Attribute"=@("Edit-EC2FpgaImageAttribute","Edit-EC2InstanceAttribute","Edit-EC2SnapshotAttribute","Get-EC2AddressesAttribute","Get-EC2FpgaImageAttribute","Get-EC2ImageAttribute","Get-EC2InstanceAttribute","Get-EC2NetworkInterfaceAttribute","Get-EC2SnapshotAttribute","Get-EC2VolumeAttribute","Get-EC2VpcAttribute","Reset-EC2AddressAttribute","Reset-EC2FpgaImageAttribute","Reset-EC2ImageAttribute","Reset-EC2InstanceAttribute","Reset-EC2SnapshotAttribute")
    "AutoPlacement"=@("Edit-EC2Host","New-EC2Host")
    "AutoRecovery"=@("Edit-EC2InstanceMaintenanceOption")
    "AwsService"=@("New-EC2IpamPool")
    "BootMode"=@("Import-EC2Image","Register-EC2Image")
    "CapacityReservationSpecification_CapacityReservationPreference"=@("Edit-EC2InstanceCapacityReservationAttribute","New-EC2Instance")
    "ConnectivityType"=@("New-EC2NatGateway")
    "CopyTagsFromSource"=@("New-EC2SnapshotBatch")
    "CurrencyCode"=@("New-EC2HostReservation")
    "DestinationOptions_FileFormat"=@("New-EC2FlowLog")
    "DiskImageFormat"=@("Export-EC2Image")
    "DnsOptions_DnsRecordIpType"=@("Edit-EC2VpcEndpoint","New-EC2VpcEndpoint")
    "Domain"=@("New-EC2Address")
    "EndDateType"=@("Add-EC2CapacityReservation","Edit-EC2CapacityReservation")
    "EventType"=@("Get-EC2FleetHistory","Get-EC2SpotFleetRequestHistory")
    "ExcessCapacityTerminationPolicy"=@("Edit-EC2Fleet","Edit-EC2SpotFleetRequest","New-EC2Fleet")
    "ExportToS3Task_ContainerFormat"=@("New-EC2InstanceExportTask")
    "ExportToS3Task_DiskImageFormat"=@("New-EC2InstanceExportTask")
    "HostRecovery"=@("Edit-EC2Host","New-EC2Host")
    "HttpEndpoint"=@("Edit-EC2InstanceMetadataOption")
    "HttpProtocolIpv6"=@("Edit-EC2InstanceMetadataOption")
    "HttpTokens"=@("Edit-EC2InstanceMetadataOption")
    "ImdsSupport"=@("Register-EC2Image")
    "InstanceFamily"=@("Edit-EC2DefaultCreditSpecification","Get-EC2DefaultCreditSpecification")
    "InstanceInitiatedShutdownBehavior"=@("New-EC2Instance")
    "InstanceInterruptionBehavior"=@("Request-EC2SpotInstance")
    "InstanceMatchCriteria"=@("Add-EC2CapacityReservation","New-EC2CapacityReservationFleet")
    "InstanceMetadataTags"=@("Edit-EC2InstanceMetadataOption")
    "InstancePlatform"=@("Add-EC2CapacityReservation")
    "InstanceRequirements_BareMetal"=@("Get-EC2InstanceTypesFromInstanceRequirement")
    "InstanceRequirements_BurstablePerformance"=@("Get-EC2InstanceTypesFromInstanceRequirement")
    "InstanceRequirements_LocalStorage"=@("Get-EC2InstanceTypesFromInstanceRequirement")
    "InstanceRequirementsWithMetadata_InstanceRequirements_BareMetal"=@("Get-EC2SpotPlacementScore")
    "InstanceRequirementsWithMetadata_InstanceRequirements_BurstablePerformance"=@("Get-EC2SpotPlacementScore")
    "InstanceRequirementsWithMetadata_InstanceRequirements_LocalStorage"=@("Get-EC2SpotPlacementScore")
    "InstanceTenancy"=@("Edit-EC2VpcTenancy","Get-EC2ReservedInstancesOffering","New-EC2Vpc")
    "InstanceType"=@("Get-EC2ReservedInstancesOffering","New-EC2Instance")
    "InterfaceType"=@("New-EC2NetworkInterface")
    "IpAddressType"=@("Edit-EC2VpcEndpoint","New-EC2VpcEndpoint")
    "KeyFormat"=@("New-EC2KeyPair")
    "KeyType"=@("New-EC2KeyPair")
    "LaunchSpecification_InstanceType"=@("Request-EC2SpotInstance")
    "LaunchSpecification_Placement_Tenancy"=@("Request-EC2SpotInstance")
    "LimitPrice_CurrencyCode"=@("New-EC2ReservedInstance")
    "LocationType"=@("Get-EC2InstanceTypeOffering")
    "LogDestinationType"=@("New-EC2FlowLog")
    "MaintenanceOptions_AutoRecovery"=@("New-EC2Instance")
    "MetadataOptions_HttpEndpoint"=@("New-EC2Instance")
    "MetadataOptions_HttpProtocolIpv6"=@("New-EC2Instance")
    "MetadataOptions_HttpTokens"=@("New-EC2Instance")
    "MetadataOptions_InstanceMetadataTags"=@("New-EC2Instance")
    "Mode"=@("New-EC2LocalGatewayRouteTable")
    "OfferingClass"=@("Get-EC2ReservedInstance","Get-EC2ReservedInstancesOffering")
    "OfferingType"=@("Get-EC2ReservedInstance","Get-EC2ReservedInstancesOffering")
    "OnDemandOptions_AllocationStrategy"=@("New-EC2Fleet")
    "OnDemandOptions_CapacityReservationOptions_UsageStrategy"=@("New-EC2Fleet")
    "OperationType"=@("Edit-EC2FpgaImageAttribute","Edit-EC2ImageAttribute","Edit-EC2SnapshotAttribute")
    "OptInStatus"=@("Edit-EC2AvailabilityZoneGroup")
    "Options_ApplianceModeSupport"=@("Edit-EC2TransitGatewayVpcAttachment","New-EC2TransitGatewayVpcAttachment")
    "Options_AutoAcceptSharedAssociations"=@("New-EC2TransitGatewayMulticastDomain")
    "Options_AutoAcceptSharedAttachments"=@("Edit-EC2TransitGateway","New-EC2TransitGateway")
    "Options_DefaultRouteTableAssociation"=@("Edit-EC2TransitGateway","New-EC2TransitGateway")
    "Options_DefaultRouteTablePropagation"=@("Edit-EC2TransitGateway","New-EC2TransitGateway")
    "Options_DnsSupport"=@("Edit-EC2TransitGateway","Edit-EC2TransitGatewayVpcAttachment","New-EC2TransitGateway","New-EC2TransitGatewayVpcAttachment")
    "Options_DynamicRouting"=@("New-EC2TransitGatewayPeeringAttachment")
    "Options_Igmpv2Support"=@("New-EC2TransitGatewayMulticastDomain")
    "Options_Ipv6Support"=@("Edit-EC2TransitGatewayVpcAttachment","New-EC2TransitGatewayVpcAttachment")
    "Options_MulticastSupport"=@("New-EC2TransitGateway")
    "Options_Protocol"=@("New-EC2TransitGatewayConnect")
    "Options_StaticSourcesSupport"=@("New-EC2TransitGatewayMulticastDomain")
    "Options_TunnelInsideIpVersion"=@("New-EC2VpnConnection")
    "Options_VpnEcmpSupport"=@("Edit-EC2TransitGateway","New-EC2TransitGateway")
    "PayerResponsibility"=@("Edit-EC2VpcEndpointServicePayerResponsibility")
    "Permission"=@("New-EC2NetworkInterfacePermission")
    "Placement_Tenancy"=@("New-EC2Instance")
    "PrivateDnsHostnameType"=@("Edit-EC2PrivateDnsNameOption")
    "PrivateDnsHostnameTypeOnLaunch"=@("Edit-EC2SubnetAttribute")
    "PrivateDnsNameOptions_HostnameType"=@("New-EC2Instance")
    "ProductDescription"=@("Get-EC2ReservedInstancesOffering")
    "Protocol"=@("New-EC2NetworkInsightsPath")
    "ReservationType"=@("New-EC2SubnetCidrReservation")
    "ResourceType"=@("Get-EC2IpamResourceCidr","New-EC2FlowLog")
    "RuleAction"=@("Edit-EC2TrafficMirrorFilterRule","New-EC2NetworkAclEntry","New-EC2TrafficMirrorFilterRule","Set-EC2NetworkAclEntry")
    "SelfServicePortal"=@("Edit-EC2ClientVpnEndpoint","New-EC2ClientVpnEndpoint")
    "SpotFleetRequestConfig_AllocationStrategy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_ExcessCapacityTerminationPolicy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_InstanceInterruptionBehavior"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_OnDemandAllocationStrategy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_SpotMaintenanceStrategies_CapacityRebalance_ReplacementStrategy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_TargetCapacityUnitType"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_Type"=@("Request-EC2SpotFleet")
    "SpotOptions_AllocationStrategy"=@("New-EC2Fleet")
    "SpotOptions_InstanceInterruptionBehavior"=@("New-EC2Fleet")
    "SpotOptions_MaintenanceStrategies_CapacityRebalance_ReplacementStrategy"=@("New-EC2Fleet")
    "SpreadLevel"=@("New-EC2PlacementGroup")
    "Status"=@("Send-EC2InstanceStatus")
    "StorageTier"=@("Edit-EC2SnapshotTier")
    "Strategy"=@("New-EC2PlacementGroup")
    "TargetCapacitySpecification_DefaultTargetCapacityType"=@("Edit-EC2Fleet","New-EC2Fleet")
    "TargetCapacitySpecification_TargetCapacityUnitType"=@("Edit-EC2Fleet","New-EC2Fleet")
    "TargetCapacityUnitType"=@("Get-EC2SpotPlacementScore")
    "TargetEnvironment"=@("New-EC2InstanceExportTask")
    "Tenancy"=@("Add-EC2CapacityReservation","Edit-EC2InstancePlacement","New-EC2CapacityReservationFleet")
    "TpmSupport"=@("Register-EC2Image")
    "TrafficDirection"=@("Edit-EC2TrafficMirrorFilterRule","New-EC2TrafficMirrorFilterRule")
    "TrafficType"=@("New-EC2FlowLog")
    "TransportProtocol"=@("New-EC2ClientVpnEndpoint")
    "Type"=@("New-EC2CustomerGateway","New-EC2Fleet","New-EC2VpnGateway","Request-EC2SpotInstance")
    "VolumeType"=@("Edit-EC2Volume","New-EC2Volume")
    "VpcEndpointType"=@("New-EC2VpcEndpoint")
}

_awsArgumentCompleterRegistration $EC2_Completers $EC2_map

$EC2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2_SelectMap = @{
    "Select"=@("Approve-EC2AddressTransfer",
               "Approve-EC2ReservedInstancesExchangeQuote",
               "Approve-EC2TransitGatewayMulticastDomainAssociation",
               "Approve-EC2TransitGatewayPeeringAttachment",
               "Approve-EC2TransitGatewayVpcAttachment",
               "Approve-EC2EndpointConnection",
               "Approve-EC2VpcPeeringConnection",
               "Start-EC2ByoipCidrAdvertisement",
               "New-EC2Address",
               "New-EC2Host",
               "New-EC2IpamPoolCidr",
               "Add-EC2SecurityGroupToClientVpnTargetNetwork",
               "Register-EC2Ipv6AddressList",
               "Register-EC2PrivateIpAddress",
               "Register-EC2Address",
               "Register-EC2ClientVpnTargetNetwork",
               "Register-EC2DhcpOption",
               "Register-EC2EnclaveCertificateIamRole",
               "Register-EC2IamInstanceProfile",
               "Register-EC2InstanceEventWindow",
               "Register-EC2RouteTable",
               "Register-EC2SubnetCidrBlock",
               "Register-EC2TransitGatewayMulticastDomain",
               "Register-EC2TransitGatewayPolicyTable",
               "Register-EC2TransitGatewayRouteTable",
               "Register-EC2TrunkInterface",
               "Register-EC2VpcCidrBlock",
               "Add-EC2ClassicLinkVpc",
               "Add-EC2InternetGateway",
               "Add-EC2NetworkInterface",
               "Add-EC2Volume",
               "Add-EC2VpnGateway",
               "Grant-EC2ClientVpnIngress",
               "Grant-EC2SecurityGroupEgress",
               "Grant-EC2SecurityGroupIngress",
               "New-EC2InstanceBundle",
               "Stop-EC2BundleTask",
               "Remove-EC2CapacityReservation",
               "Stop-EC2CapacityReservationFleet",
               "Stop-EC2ExportTask",
               "Stop-EC2ImageLaunchPermission",
               "Stop-EC2ImportTask",
               "Stop-EC2ReservedInstancesListing",
               "Stop-EC2SpotFleetRequest",
               "Stop-EC2SpotInstanceRequest",
               "Confirm-EC2ProductInstance",
               "Copy-EC2FpgaImage",
               "Copy-EC2Image",
               "Copy-EC2Snapshot",
               "Add-EC2CapacityReservation",
               "New-EC2CapacityReservationFleet",
               "New-EC2CarrierGateway",
               "New-EC2ClientVpnEndpoint",
               "New-EC2ClientVpnRoute",
               "New-EC2CoipCidr",
               "New-EC2CoipPool",
               "New-EC2CustomerGateway",
               "New-EC2DefaultSubnet",
               "New-EC2DefaultVpc",
               "New-EC2DhcpOption",
               "New-EC2EgressOnlyInternetGateway",
               "New-EC2Fleet",
               "New-EC2FlowLog",
               "New-EC2FpgaImage",
               "New-EC2Image",
               "New-EC2InstanceEventWindow",
               "New-EC2InstanceExportTask",
               "New-EC2InternetGateway",
               "New-EC2Ipam",
               "New-EC2IpamPool",
               "New-EC2IpamScope",
               "New-EC2KeyPair",
               "New-EC2LaunchTemplate",
               "New-EC2LaunchTemplateVersion",
               "New-EC2LocalGatewayRoute",
               "New-EC2LocalGatewayRouteTable",
               "New-EC2LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
               "New-EC2LocalGatewayRouteTableVpcAssociation",
               "New-EC2ManagedPrefixList",
               "New-EC2NatGateway",
               "New-EC2NetworkAcl",
               "New-EC2NetworkAclEntry",
               "New-EC2NetworkInsightsAccessScope",
               "New-EC2NetworkInsightsPath",
               "New-EC2NetworkInterface",
               "New-EC2NetworkInterfacePermission",
               "New-EC2PlacementGroup",
               "New-EC2PublicIpv4Pool",
               "New-EC2ReplaceRootVolumeTask",
               "New-EC2ReservedInstancesListing",
               "New-EC2RestoreImageTask",
               "New-EC2Route",
               "New-EC2RouteTable",
               "New-EC2SecurityGroup",
               "New-EC2Snapshot",
               "New-EC2SnapshotBatch",
               "New-EC2SpotDatafeedSubscription",
               "New-EC2StoreImageTask",
               "New-EC2Subnet",
               "New-EC2SubnetCidrReservation",
               "New-EC2Tag",
               "New-EC2TrafficMirrorFilter",
               "New-EC2TrafficMirrorFilterRule",
               "New-EC2TrafficMirrorSession",
               "New-EC2TrafficMirrorTarget",
               "New-EC2TransitGateway",
               "New-EC2TransitGatewayConnect",
               "New-EC2TransitGatewayConnectPeer",
               "New-EC2TransitGatewayMulticastDomain",
               "New-EC2TransitGatewayPeeringAttachment",
               "New-EC2TransitGatewayPolicyTable",
               "New-EC2TransitGatewayPrefixListReference",
               "New-EC2TransitGatewayRoute",
               "New-EC2TransitGatewayRouteTable",
               "New-EC2TransitGatewayRouteTableAnnouncement",
               "New-EC2TransitGatewayVpcAttachment",
               "New-EC2Volume",
               "New-EC2Vpc",
               "New-EC2VpcEndpoint",
               "New-EC2VpcEndpointConnectionNotification",
               "New-EC2VpcEndpointServiceConfiguration",
               "New-EC2VpcPeeringConnection",
               "New-EC2VpnConnection",
               "New-EC2VpnConnectionRoute",
               "New-EC2VpnGateway",
               "Remove-EC2CarrierGateway",
               "Remove-EC2ClientVpnEndpoint",
               "Remove-EC2ClientVpnRoute",
               "Remove-EC2CoipCidr",
               "Remove-EC2CoipPool",
               "Remove-EC2CustomerGateway",
               "Remove-EC2DhcpOption",
               "Remove-EC2EgressOnlyInternetGateway",
               "Remove-EC2Fleet",
               "Remove-EC2FlowLog",
               "Remove-EC2FpgaImage",
               "Remove-EC2InstanceEventWindow",
               "Remove-EC2InternetGateway",
               "Remove-EC2Ipam",
               "Remove-EC2IpamPool",
               "Remove-EC2IpamScope",
               "Remove-EC2KeyPair",
               "Remove-EC2LaunchTemplate",
               "Remove-EC2TemplateVersion",
               "Remove-EC2LocalGatewayRoute",
               "Remove-EC2LocalGatewayRouteTable",
               "Remove-EC2LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
               "Remove-EC2LocalGatewayRouteTableVpcAssociation",
               "Remove-EC2ManagedPrefixList",
               "Remove-EC2NatGateway",
               "Remove-EC2NetworkAcl",
               "Remove-EC2NetworkAclEntry",
               "Remove-EC2NetworkInsightsAccessScope",
               "Remove-EC2NetworkInsightsAccessScopeAnalysis",
               "Remove-EC2NetworkInsightsAnalysis",
               "Remove-EC2NetworkInsightsPath",
               "Remove-EC2NetworkInterface",
               "Remove-EC2NetworkInterfacePermission",
               "Remove-EC2PlacementGroup",
               "Remove-EC2PublicIpv4Pool",
               "Remove-EC2QueuedReservedInstance",
               "Remove-EC2Route",
               "Remove-EC2RouteTable",
               "Remove-EC2SecurityGroup",
               "Remove-EC2Snapshot",
               "Remove-EC2SpotDatafeedSubscription",
               "Remove-EC2Subnet",
               "Remove-EC2SubnetCidrReservation",
               "Remove-EC2Tag",
               "Remove-EC2TrafficMirrorFilter",
               "Remove-EC2TrafficMirrorFilterRule",
               "Remove-EC2TrafficMirrorSession",
               "Remove-EC2TrafficMirrorTarget",
               "Remove-EC2TransitGateway",
               "Remove-EC2TransitGatewayConnect",
               "Remove-EC2TransitGatewayConnectPeer",
               "Remove-EC2TransitGatewayMulticastDomain",
               "Remove-EC2TransitGatewayPeeringAttachment",
               "Remove-EC2TransitGatewayPolicyTable",
               "Remove-EC2TransitGatewayPrefixListReference",
               "Remove-EC2TransitGatewayRoute",
               "Remove-EC2TransitGatewayRouteTable",
               "Remove-EC2TransitGatewayRouteTableAnnouncement",
               "Remove-EC2TransitGatewayVpcAttachment",
               "Remove-EC2Volume",
               "Remove-EC2Vpc",
               "Remove-EC2EndpointConnectionNotification",
               "Remove-EC2VpcEndpoint",
               "Remove-EC2EndpointServiceConfiguration",
               "Remove-EC2VpcPeeringConnection",
               "Remove-EC2VpnConnection",
               "Remove-EC2VpnConnectionRoute",
               "Remove-EC2VpnGateway",
               "Unregister-EC2ByoipCidr",
               "Unregister-EC2IpamPoolCidr",
               "Unregister-EC2PublicIpv4PoolCidr",
               "Unregister-EC2Image",
               "Unregister-EC2InstanceEventNotificationAttribute",
               "Unregister-EC2TransitGatewayMulticastGroupMember",
               "Unregister-EC2TransitGatewayMulticastGroupSource",
               "Get-EC2AccountAttribute",
               "Get-EC2Address",
               "Get-EC2AddressesAttribute",
               "Get-EC2AddressTransfer",
               "Get-EC2AggregateIdFormat",
               "Get-EC2AvailabilityZone",
               "Get-EC2BundleTask",
               "Get-EC2ByoipCidr",
               "Get-EC2CapacityReservationFleet",
               "Get-EC2CapacityReservation",
               "Get-EC2CarrierGateway",
               "Get-EC2ClassicLinkInstance",
               "Get-EC2ClientVpnAuthorizationRule",
               "Get-EC2ClientVpnConnection",
               "Get-EC2ClientVpnEndpoint",
               "Get-EC2ClientVpnRoute",
               "Get-EC2ClientVpnTargetNetwork",
               "Get-EC2CoipPool",
               "Get-EC2CustomerGateway",
               "Get-EC2DhcpOption",
               "Get-EC2EgressOnlyInternetGatewayList",
               "Get-EC2ElasticGpu",
               "Get-EC2ExportImageTask",
               "Get-EC2ExportTask",
               "Get-EC2FastLaunchImage",
               "Get-EC2FastSnapshotRestore",
               "Get-EC2FleetHistory",
               "Get-EC2FleetInstanceList",
               "Get-EC2FleetList",
               "Get-EC2FlowLog",
               "Get-EC2FpgaImageAttribute",
               "Get-EC2FpgaImage",
               "Get-EC2HostReservationOffering",
               "Get-EC2HostReservation",
               "Get-EC2Host",
               "Get-EC2IamInstanceProfileAssociation",
               "Get-EC2IdentityIdFormat",
               "Get-EC2IdFormat",
               "Get-EC2ImageAttribute",
               "Get-EC2Image",
               "Get-EC2ImportImageTask",
               "Get-EC2ImportSnapshotTask",
               "Get-EC2InstanceAttribute",
               "Get-EC2CreditSpecification",
               "Get-EC2InstanceEventNotificationAttribute",
               "Get-EC2InstanceEventWindow",
               "Get-EC2Instance",
               "Get-EC2InstanceStatus",
               "Get-EC2InstanceTypeOffering",
               "Get-EC2InstanceType",
               "Get-EC2InternetGateway",
               "Get-EC2IpamPool",
               "Get-EC2Ipam",
               "Get-EC2IpamScope",
               "Get-EC2Ipv6Pool",
               "Get-EC2KeyPair",
               "Get-EC2Template",
               "Get-EC2TemplateVersion",
               "Get-EC2LocalGatewayRouteTable",
               "Get-EC2LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
               "Get-EC2LocalGatewayRouteTableVpcAssociation",
               "Get-EC2LocalGateway",
               "Get-EC2LocalGatewayVirtualInterfaceGroup",
               "Get-EC2LocalGatewayVirtualInterface",
               "Get-EC2ManagedPrefixList",
               "Get-EC2MovingAddress",
               "Get-EC2NatGateway",
               "Get-EC2NetworkAcl",
               "Get-EC2NetworkInsightsAccessScopeAnalysis",
               "Get-EC2NetworkInsightsAccessScope",
               "Get-EC2NetworkInsightsAnalysis",
               "Get-EC2NetworkInsightsPath",
               "Get-EC2NetworkInterfaceAttribute",
               "Get-EC2NetworkInterfacePermission",
               "Get-EC2NetworkInterface",
               "Get-EC2PlacementGroup",
               "Get-EC2PrefixList",
               "Get-EC2PrincipalIdFormat",
               "Get-EC2PublicIpv4Pool",
               "Get-EC2Region",
               "Get-EC2ReplaceRootVolumeTask",
               "Get-EC2ReservedInstance",
               "Get-EC2ReservedInstancesListing",
               "Get-EC2ReservedInstancesModification",
               "Get-EC2ReservedInstancesOffering",
               "Get-EC2RouteTable",
               "Get-EC2ScheduledInstanceAvailability",
               "Get-EC2ScheduledInstance",
               "Get-EC2SecurityGroupReference",
               "Get-EC2SecurityGroupRule",
               "Get-EC2SecurityGroup",
               "Get-EC2SnapshotAttribute",
               "Get-EC2Snapshot",
               "Get-EC2SnapshotTierStatus",
               "Get-EC2SpotDatafeedSubscription",
               "Get-EC2SpotFleetInstance",
               "Get-EC2SpotFleetRequestHistory",
               "Get-EC2SpotFleetRequest",
               "Get-EC2SpotInstanceRequest",
               "Get-EC2SpotPriceHistory",
               "Get-EC2StaleSecurityGroup",
               "Get-EC2StoreImageTask",
               "Get-EC2Subnet",
               "Get-EC2Tag",
               "Get-EC2TrafficMirrorFilter",
               "Get-EC2TrafficMirrorSession",
               "Get-EC2TrafficMirrorTarget",
               "Get-EC2TransitGatewayAttachment",
               "Get-EC2TransitGatewayConnectPeer",
               "Get-EC2TransitGatewayConnect",
               "Get-EC2TransitGatewayMulticastDomain",
               "Get-EC2TransitGatewayPeeringAttachment",
               "Get-EC2TransitGatewayPolicyTable",
               "Get-EC2TransitGatewayRouteTableAnnouncement",
               "Get-EC2TransitGatewayRouteTable",
               "Get-EC2TransitGateway",
               "Get-EC2TransitGatewayVpcAttachment",
               "Get-EC2TrunkInterfaceAssociation",
               "Get-EC2VolumeAttribute",
               "Get-EC2Volume",
               "Get-EC2VolumeModification",
               "Get-EC2VolumeStatus",
               "Get-EC2VpcAttribute",
               "Get-EC2VpcClassicLink",
               "Get-EC2VpcClassicLinkDnsSupport",
               "Get-EC2EndpointConnectionNotification",
               "Get-EC2EndpointConnection",
               "Get-EC2VpcEndpoint",
               "Get-EC2EndpointServiceConfiguration",
               "Get-EC2EndpointServicePermission",
               "Get-EC2VpcEndpointService",
               "Get-EC2VpcPeeringConnection",
               "Get-EC2Vpc",
               "Get-EC2VpnConnection",
               "Get-EC2VpnGateway",
               "Dismount-EC2ClassicLinkVpc",
               "Dismount-EC2InternetGateway",
               "Dismount-EC2NetworkInterface",
               "Dismount-EC2Volume",
               "Dismount-EC2VpnGateway",
               "Disable-EC2AddressTransfer",
               "Disable-EC2EbsEncryptionByDefault",
               "Disable-EC2FastLaunch",
               "Disable-EC2FastSnapshotRestore",
               "Disable-EC2ImageDeprecation",
               "Disable-EC2IpamOrganizationAdminAccount",
               "Disable-EC2SerialConsoleAccess",
               "Disable-EC2TransitGatewayRouteTablePropagation",
               "Disable-EC2VgwRoutePropagation",
               "Disable-EC2VpcClassicLink",
               "Disable-EC2VpcClassicLinkDnsSupport",
               "Unregister-EC2Address",
               "Unregister-EC2ClientVpnTargetNetwork",
               "Unregister-EC2EnclaveCertificateIamRole",
               "Unregister-EC2IamInstanceProfile",
               "Unregister-EC2InstanceEventWindow",
               "Unregister-EC2RouteTable",
               "Unregister-EC2SubnetCidrBlock",
               "Unregister-EC2TransitGatewayMulticastDomain",
               "Unregister-EC2TransitGatewayPolicyTable",
               "Unregister-EC2TransitGatewayRouteTable",
               "Unregister-EC2TrunkInterface",
               "Unregister-EC2VpcCidrBlock",
               "Enable-EC2AddressTransfer",
               "Enable-EC2EbsEncryptionByDefault",
               "Enable-EC2FastLaunch",
               "Enable-EC2FastSnapshotRestore",
               "Enable-EC2ImageDeprecation",
               "Enable-EC2IpamOrganizationAdminAccount",
               "Enable-EC2SerialConsoleAccess",
               "Enable-EC2TransitGatewayRouteTablePropagation",
               "Enable-EC2VgwRoutePropagation",
               "Enable-EC2VolumeIO",
               "Enable-EC2VpcClassicLink",
               "Enable-EC2VpcClassicLinkDnsSupport",
               "Export-EC2ClientVpnClientCertificateRevocationList",
               "Export-EC2ClientVpnClientConfiguration",
               "Export-EC2Image",
               "Export-EC2TransitGatewayRoute",
               "Get-EC2AssociatedEnclaveCertificateIamRole",
               "Get-EC2AssociatedIpv6PoolCidr",
               "Get-EC2CapacityReservationUsage",
               "Get-EC2CoipPoolUsage",
               "Get-EC2ConsoleOutput",
               "Get-EC2ConsoleScreenshot",
               "Get-EC2DefaultCreditSpecification",
               "Get-EC2EbsDefaultKmsKeyId",
               "Get-EC2EbsEncryptionByDefault",
               "Get-EC2FlowLogsIntegrationTemplate",
               "Get-EC2GroupsForCapacityReservation",
               "Get-EC2HostReservationPurchasePreview",
               "Get-EC2InstanceTypesFromInstanceRequirement",
               "Get-EC2InstanceUefiData",
               "Get-EC2IpamAddressHistory",
               "Get-EC2IpamPoolAllocation",
               "Get-EC2IpamPoolCidr",
               "Get-EC2IpamResourceCidr",
               "Get-EC2LaunchTemplateData",
               "Get-EC2ManagedPrefixListAssociation",
               "Get-EC2ManagedPrefixListEntry",
               "Get-EC2NetworkInsightsAccessScopeAnalysisFinding",
               "Get-EC2NetworkInsightsAccessScopeContent",
               "Get-EC2ReservedInstancesExchangeQuote",
               "Get-EC2SerialConsoleAccessStatus",
               "Get-EC2SpotPlacementScore",
               "Get-EC2SubnetCidrReservation",
               "Get-EC2TransitGatewayAttachmentPropagation",
               "Get-EC2TransitGatewayMulticastDomainAssociation",
               "Get-EC2TransitGatewayPolicyTableAssociation",
               "Get-EC2TransitGatewayPolicyTableEntry",
               "Get-EC2TransitGatewayPrefixListReference",
               "Get-EC2TransitGatewayRouteTableAssociation",
               "Get-EC2TransitGatewayRouteTablePropagation",
               "Get-EC2VpnConnectionDeviceSampleConfiguration",
               "Get-EC2VpnConnectionDeviceType",
               "Import-EC2ClientVpnClientCertificateRevocationList",
               "Import-EC2Image",
               "Import-EC2KeyPair",
               "Import-EC2Snapshot",
               "Get-EC2ImagesInRecycleBinList",
               "Get-EC2SnapshotsInRecycleBinList",
               "Edit-EC2AddressAttribute",
               "Edit-EC2AvailabilityZoneGroup",
               "Edit-EC2CapacityReservation",
               "Edit-EC2CapacityReservationFleet",
               "Edit-EC2ClientVpnEndpoint",
               "Edit-EC2DefaultCreditSpecification",
               "Edit-EC2EbsDefaultKmsKeyId",
               "Edit-EC2Fleet",
               "Edit-EC2FpgaImageAttribute",
               "Edit-EC2Host",
               "Edit-EC2IdentityIdFormat",
               "Edit-EC2IdFormat",
               "Edit-EC2ImageAttribute",
               "Edit-EC2InstanceAttribute",
               "Edit-EC2InstanceCapacityReservationAttribute",
               "Edit-EC2InstanceCreditSpecification",
               "Edit-EC2InstanceEventStartTime",
               "Edit-EC2InstanceEventWindow",
               "Edit-EC2InstanceMaintenanceOption",
               "Edit-EC2InstanceMetadataOption",
               "Edit-EC2InstancePlacement",
               "Edit-EC2Ipam",
               "Edit-EC2IpamPool",
               "Edit-EC2IpamResourceCidr",
               "Edit-EC2IpamScope",
               "Edit-EC2LaunchTemplate",
               "Edit-EC2LocalGatewayRoute",
               "Edit-EC2ManagedPrefixList",
               "Edit-EC2NetworkInterfaceAttribute",
               "Edit-EC2PrivateDnsNameOption",
               "Edit-EC2ReservedInstance",
               "Edit-EC2SecurityGroupRule",
               "Edit-EC2SnapshotAttribute",
               "Edit-EC2SnapshotTier",
               "Edit-EC2SpotFleetRequest",
               "Edit-EC2SubnetAttribute",
               "Edit-EC2TrafficMirrorFilterNetworkService",
               "Edit-EC2TrafficMirrorFilterRule",
               "Edit-EC2TrafficMirrorSession",
               "Edit-EC2TransitGateway",
               "Edit-EC2TransitGatewayPrefixListReference",
               "Edit-EC2TransitGatewayVpcAttachment",
               "Edit-EC2Volume",
               "Edit-EC2VolumeAttribute",
               "Edit-EC2VpcAttribute",
               "Edit-EC2VpcEndpoint",
               "Edit-EC2VpcEndpointConnectionNotification",
               "Edit-EC2VpcEndpointServiceConfiguration",
               "Edit-EC2VpcEndpointServicePayerResponsibility",
               "Edit-EC2EndpointServicePermission",
               "Edit-EC2VpcPeeringConnectionOption",
               "Edit-EC2VpcTenancy",
               "Edit-EC2VpnConnection",
               "Edit-EC2VpnConnectionOption",
               "Edit-EC2VpnTunnelCertificate",
               "Edit-EC2VpnTunnelOption",
               "Start-EC2InstanceMonitoring",
               "Move-EC2AddressToVpc",
               "Move-EC2ByoipCidrToIpam",
               "Register-EC2ByoipCidr",
               "Register-EC2IpamPoolCidr",
               "Register-EC2PublicIpv4PoolCidr",
               "New-EC2HostReservation",
               "New-EC2ReservedInstance",
               "New-EC2ScheduledInstancePurchase",
               "Restart-EC2Instance",
               "Register-EC2Image",
               "Register-EC2InstanceEventNotificationAttribute",
               "Register-EC2TransitGatewayMulticastGroupMember",
               "Register-EC2TransitGatewayMulticastGroupSource",
               "Deny-EC2TransitGatewayMulticastDomainAssociation",
               "Deny-EC2TransitGatewayPeeringAttachment",
               "Deny-EC2TransitGatewayVpcAttachment",
               "Deny-EC2EndpointConnection",
               "Deny-EC2VpcPeeringConnection",
               "Remove-EC2Address",
               "Remove-EC2Host",
               "Remove-EC2IpamPoolAllocation",
               "Set-EC2IamInstanceProfileAssociation",
               "Set-EC2NetworkAclAssociation",
               "Set-EC2NetworkAclEntry",
               "Set-EC2Route",
               "Set-EC2RouteTableAssociation",
               "Set-EC2TransitGatewayRoute",
               "Send-EC2InstanceStatus",
               "Request-EC2SpotFleet",
               "Request-EC2SpotInstance",
               "Reset-EC2AddressAttribute",
               "Reset-EC2EbsDefaultKmsKeyId",
               "Reset-EC2FpgaImageAttribute",
               "Reset-EC2ImageAttribute",
               "Reset-EC2InstanceAttribute",
               "Reset-EC2NetworkInterfaceAttribute",
               "Reset-EC2SnapshotAttribute",
               "Restore-EC2AddressToClassic",
               "Restore-EC2ImageFromRecycleBin",
               "Restore-EC2ManagedPrefixListVersion",
               "Restore-EC2SnapshotFromRecycleBin",
               "Restore-EC2SnapshotTier",
               "Revoke-EC2ClientVpnIngress",
               "Revoke-EC2SecurityGroupEgress",
               "Revoke-EC2SecurityGroupIngress",
               "New-EC2Instance",
               "New-EC2ScheduledInstance",
               "Search-EC2LocalGatewayRoute",
               "Search-EC2TransitGatewayMulticastGroup",
               "Search-EC2TransitGatewayRoute",
               "Send-EC2DiagnosticInterrupt",
               "Start-EC2Instance",
               "Start-EC2NetworkInsightsAccessScopeAnalysis",
               "Start-EC2NetworkInsightsAnalysis",
               "Start-EC2VpcEndpointServicePrivateDnsVerification",
               "Stop-EC2Instance",
               "Stop-EC2ClientVpnConnection",
               "Remove-EC2Instance",
               "Unregister-EC2Ipv6AddressList",
               "Unregister-EC2PrivateIpAddress",
               "Stop-EC2InstanceMonitoring",
               "Update-EC2SecurityGroupRuleEgressDescription",
               "Update-EC2SecurityGroupRuleIngressDescription",
               "Stop-EC2ByoipCidrAdvertisement",
               "Get-EC2ImageByName",
               "Get-EC2InstanceMetadata",
               "Get-EC2PasswordData")
}

_awsArgumentCompleterRegistration $EC2_SelectCompleters $EC2_SelectMap
# Argument completions for service AWS EC2 Instance Connect


$EC2IC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC2IC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2IC_SelectMap = @{
    "Select"=@("Send-EC2ICSerialConsoleSSHPublicKey",
               "Send-EC2ICSSHPublicKey")
}

_awsArgumentCompleterRegistration $EC2IC_SelectCompleters $EC2IC_SelectMap
# Argument completions for service Amazon EC2 Container Registry


$ECR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ECR.EncryptionType
        "New-ECRRepository/EncryptionConfiguration_EncryptionType"
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.ECR.ImageTagMutability
        {
            ($_ -eq "New-ECRRepository/ImageTagMutability") -Or
            ($_ -eq "Write-ECRImageTagMutability/ImageTagMutability")
        }
        {
            $v = "IMMUTABLE","MUTABLE"
            break
        }

        # Amazon.ECR.ScanType
        "Write-ECRRegistryScanningConfiguration/ScanType"
        {
            $v = "BASIC","ENHANCED"
            break
        }

        # Amazon.ECR.TagStatus
        {
            ($_ -eq "Get-ECRImage/Filter_TagStatus") -Or
            ($_ -eq "Get-ECRImageMetadata/Filter_TagStatus") -Or
            ($_ -eq "Get-ECRLifecyclePolicyPreview/Filter_TagStatus")
        }
        {
            $v = "ANY","TAGGED","UNTAGGED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECR_map = @{
    "EncryptionConfiguration_EncryptionType"=@("New-ECRRepository")
    "Filter_TagStatus"=@("Get-ECRImage","Get-ECRImageMetadata","Get-ECRLifecyclePolicyPreview")
    "ImageTagMutability"=@("New-ECRRepository","Write-ECRImageTagMutability")
    "ScanType"=@("Write-ECRRegistryScanningConfiguration")
}

_awsArgumentCompleterRegistration $ECR_Completers $ECR_map

$ECR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ECR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECR_SelectMap = @{
    "Select"=@("Get-ECRLayerAvailabilityBatch",
               "Remove-ECRImageBatch",
               "Get-ECRImageBatch",
               "Get-ECRRepositoryScanningConfigurationBatch",
               "Complete-ECRLayerUpload",
               "New-ECRPullThroughCacheRule",
               "New-ECRRepository",
               "Remove-ECRLifecyclePolicy",
               "Remove-ECRPullThroughCacheRule",
               "Remove-ECRRegistryPolicy",
               "Remove-ECRRepository",
               "Remove-ECRRepositoryPolicy",
               "Get-ECRImageReplicationStatus",
               "Get-ECRImageMetadata",
               "Get-ECRImageScanFinding",
               "Get-ECRPullThroughCacheRule",
               "Get-ECRRegistry",
               "Get-ECRRepository",
               "Get-ECRAuthorizationToken",
               "Get-ECRDownloadUrlForLayer",
               "Get-ECRLifecyclePolicy",
               "Get-ECRLifecyclePolicyPreview",
               "Get-ECRRegistryPolicy",
               "Get-ECRRegistryScanningConfiguration",
               "Get-ECRRepositoryPolicy",
               "Start-ECRLayerUpload",
               "Get-ECRImage",
               "Get-ECRResourceTag",
               "Write-ECRImage",
               "Write-ECRImageScanningConfiguration",
               "Write-ECRImageTagMutability",
               "Write-ECRLifecyclePolicy",
               "Write-ECRRegistryPolicy",
               "Write-ECRRegistryScanningConfiguration",
               "Write-ECRReplicationConfiguration",
               "Set-ECRRepositoryPolicy",
               "Start-ECRImageScan",
               "Start-ECRLifecyclePolicyPreview",
               "Add-ECRResourceTag",
               "Remove-ECRResourceTag",
               "Send-ECRLayerPart",
               "Get-ECRLoginCommand")
}

_awsArgumentCompleterRegistration $ECR_SelectCompleters $ECR_SelectMap
# Argument completions for service Amazon Elastic Container Registry Public


$ECRP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ECRP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECRP_SelectMap = @{
    "Select"=@("Get-ECRPLayerAvailabilityBatch",
               "Remove-ECRPImageBatch",
               "Complete-ECRPLayerUpload",
               "New-ECRPRepository",
               "Remove-ECRPRepository",
               "Remove-ECRPRepositoryPolicy",
               "Get-ECRPImage",
               "Get-ECRPImageTag",
               "Get-ECRPRegistry",
               "Get-ECRPRepository",
               "Get-ECRPAuthorizationToken",
               "Get-ECRPRegistryCatalogData",
               "Get-ECRPRepositoryCatalogData",
               "Get-ECRPRepositoryPolicy",
               "Start-ECRPLayerUpload",
               "Get-ECRPResourceTag",
               "Write-ECRPImage",
               "Write-ECRPRegistryCatalogData",
               "Write-ECRPRepositoryCatalogData",
               "Set-ECRPRepositoryPolicy",
               "Add-ECRPResourceTag",
               "Remove-ECRPResourceTag",
               "Send-ECRPLayerPart")
}

_awsArgumentCompleterRegistration $ECRP_SelectCompleters $ECRP_SelectMap
# Argument completions for service Amazon EC2 Container Service


$ECS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ECS.AssignPublicIp
        {
            ($_ -eq "New-ECSService/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "New-ECSTask/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "New-ECSTaskSet/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "Start-ECSTask/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "Update-ECSService/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.ContainerInstanceStatus
        {
            ($_ -eq "Get-ECSContainerInstanceList/Status") -Or
            ($_ -eq "Update-ECSContainerInstancesState/Status")
        }
        {
            $v = "ACTIVE","DEREGISTERING","DRAINING","REGISTERING","REGISTRATION_FAILED"
            break
        }

        # Amazon.ECS.CPUArchitecture
        "Register-ECSTaskDefinition/RuntimePlatform_CpuArchitecture"
        {
            $v = "ARM64","X86_64"
            break
        }

        # Amazon.ECS.DeploymentControllerType
        "New-ECSService/DeploymentController_Type"
        {
            $v = "CODE_DEPLOY","ECS","EXTERNAL"
            break
        }

        # Amazon.ECS.DesiredStatus
        "Get-ECSTaskList/DesiredStatus"
        {
            $v = "PENDING","RUNNING","STOPPED"
            break
        }

        # Amazon.ECS.ExecuteCommandLogging
        {
            ($_ -eq "New-ECSCluster/Configuration_ExecuteCommandConfiguration_Logging") -Or
            ($_ -eq "Update-ECSCluster/Configuration_ExecuteCommandConfiguration_Logging")
        }
        {
            $v = "DEFAULT","NONE","OVERRIDE"
            break
        }

        # Amazon.ECS.IpcMode
        "Register-ECSTaskDefinition/IpcMode"
        {
            $v = "host","none","task"
            break
        }

        # Amazon.ECS.LaunchType
        {
            ($_ -eq "Get-ECSClusterService/LaunchType") -Or
            ($_ -eq "Get-ECSTaskList/LaunchType") -Or
            ($_ -eq "New-ECSService/LaunchType") -Or
            ($_ -eq "New-ECSTask/LaunchType") -Or
            ($_ -eq "New-ECSTaskSet/LaunchType")
        }
        {
            $v = "EC2","EXTERNAL","FARGATE"
            break
        }

        # Amazon.ECS.ManagedScalingStatus
        {
            ($_ -eq "New-ECSCapacityProvider/AutoScalingGroupProvider_ManagedScaling_Status") -Or
            ($_ -eq "Update-ECSCapacityProvider/AutoScalingGroupProvider_ManagedScaling_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.ManagedTerminationProtection
        {
            ($_ -eq "New-ECSCapacityProvider/AutoScalingGroupProvider_ManagedTerminationProtection") -Or
            ($_ -eq "Update-ECSCapacityProvider/AutoScalingGroupProvider_ManagedTerminationProtection")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.NetworkMode
        "Register-ECSTaskDefinition/NetworkMode"
        {
            $v = "awsvpc","bridge","host","none"
            break
        }

        # Amazon.ECS.OSFamily
        "Register-ECSTaskDefinition/RuntimePlatform_OperatingSystemFamily"
        {
            $v = "LINUX","WINDOWS_SERVER_2004_CORE","WINDOWS_SERVER_2016_FULL","WINDOWS_SERVER_2019_CORE","WINDOWS_SERVER_2019_FULL","WINDOWS_SERVER_2022_CORE","WINDOWS_SERVER_2022_FULL","WINDOWS_SERVER_20H2_CORE"
            break
        }

        # Amazon.ECS.PidMode
        "Register-ECSTaskDefinition/PidMode"
        {
            $v = "host","task"
            break
        }

        # Amazon.ECS.PropagateTags
        {
            ($_ -eq "New-ECSService/PropagateTags") -Or
            ($_ -eq "New-ECSTask/PropagateTags") -Or
            ($_ -eq "Start-ECSTask/PropagateTags") -Or
            ($_ -eq "Update-ECSService/PropagateTags")
        }
        {
            $v = "NONE","SERVICE","TASK_DEFINITION"
            break
        }

        # Amazon.ECS.ProxyConfigurationType
        "Register-ECSTaskDefinition/ProxyConfiguration_Type"
        {
            $v = "APPMESH"
            break
        }

        # Amazon.ECS.ScaleUnit
        {
            ($_ -eq "New-ECSTaskSet/Scale_Unit") -Or
            ($_ -eq "Update-ECSTaskSet/Scale_Unit")
        }
        {
            $v = "PERCENT"
            break
        }

        # Amazon.ECS.SchedulingStrategy
        {
            ($_ -eq "Get-ECSClusterService/SchedulingStrategy") -Or
            ($_ -eq "New-ECSService/SchedulingStrategy")
        }
        {
            $v = "DAEMON","REPLICA"
            break
        }

        # Amazon.ECS.SettingName
        {
            ($_ -eq "Get-ECSAccountSetting/Name") -Or
            ($_ -eq "Remove-ECSAccountSetting/Name") -Or
            ($_ -eq "Write-ECSAccountSetting/Name") -Or
            ($_ -eq "Write-ECSAccountSettingDefault/Name")
        }
        {
            $v = "awsvpcTrunking","containerInsights","containerInstanceLongArnFormat","serviceLongArnFormat","taskLongArnFormat"
            break
        }

        # Amazon.ECS.SortOrder
        "Get-ECSTaskDefinitionList/Sort"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.ECS.TargetType
        "Get-ECSAttributeList/TargetType"
        {
            $v = "container-instance"
            break
        }

        # Amazon.ECS.TaskDefinitionFamilyStatus
        "Get-ECSTaskDefinitionFamilyList/Status"
        {
            $v = "ACTIVE","ALL","INACTIVE"
            break
        }

        # Amazon.ECS.TaskDefinitionStatus
        "Get-ECSTaskDefinitionList/Status"
        {
            $v = "ACTIVE","INACTIVE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECS_map = @{
    "AutoScalingGroupProvider_ManagedScaling_Status"=@("New-ECSCapacityProvider","Update-ECSCapacityProvider")
    "AutoScalingGroupProvider_ManagedTerminationProtection"=@("New-ECSCapacityProvider","Update-ECSCapacityProvider")
    "Configuration_ExecuteCommandConfiguration_Logging"=@("New-ECSCluster","Update-ECSCluster")
    "DeploymentController_Type"=@("New-ECSService")
    "DesiredStatus"=@("Get-ECSTaskList")
    "IpcMode"=@("Register-ECSTaskDefinition")
    "LaunchType"=@("Get-ECSClusterService","Get-ECSTaskList","New-ECSService","New-ECSTask","New-ECSTaskSet")
    "Name"=@("Get-ECSAccountSetting","Remove-ECSAccountSetting","Write-ECSAccountSetting","Write-ECSAccountSettingDefault")
    "NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp"=@("New-ECSService","New-ECSTask","New-ECSTaskSet","Start-ECSTask","Update-ECSService")
    "NetworkMode"=@("Register-ECSTaskDefinition")
    "PidMode"=@("Register-ECSTaskDefinition")
    "PropagateTags"=@("New-ECSService","New-ECSTask","Start-ECSTask","Update-ECSService")
    "ProxyConfiguration_Type"=@("Register-ECSTaskDefinition")
    "RuntimePlatform_CpuArchitecture"=@("Register-ECSTaskDefinition")
    "RuntimePlatform_OperatingSystemFamily"=@("Register-ECSTaskDefinition")
    "Scale_Unit"=@("New-ECSTaskSet","Update-ECSTaskSet")
    "SchedulingStrategy"=@("Get-ECSClusterService","New-ECSService")
    "Sort"=@("Get-ECSTaskDefinitionList")
    "Status"=@("Get-ECSContainerInstanceList","Get-ECSTaskDefinitionFamilyList","Get-ECSTaskDefinitionList","Update-ECSContainerInstancesState")
    "TargetType"=@("Get-ECSAttributeList")
}

_awsArgumentCompleterRegistration $ECS_Completers $ECS_map

$ECS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ECS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECS_SelectMap = @{
    "Select"=@("New-ECSCapacityProvider",
               "New-ECSCluster",
               "New-ECSService",
               "New-ECSTaskSet",
               "Remove-ECSAccountSetting",
               "Remove-ECSAttribute",
               "Remove-ECSCapacityProvider",
               "Remove-ECSCluster",
               "Remove-ECSService",
               "Remove-ECSTaskSet",
               "Unregister-ECSContainerInstance",
               "Unregister-ECSTaskDefinition",
               "Get-ECSCapacityProvider",
               "Get-ECSClusterDetail",
               "Get-ECSContainerInstanceDetail",
               "Get-ECSService",
               "Get-ECSTaskDefinitionDetail",
               "Get-ECSTaskDetail",
               "Get-ECSTaskSet",
               "Invoke-ECSCommand",
               "Get-ECSTaskProtection",
               "Get-ECSAccountSetting",
               "Get-ECSAttributeList",
               "Get-ECSClusterList",
               "Get-ECSContainerInstanceList",
               "Get-ECSClusterService",
               "Get-ECSTagsForResource",
               "Get-ECSTaskDefinitionFamilyList",
               "Get-ECSTaskDefinitionList",
               "Get-ECSTaskList",
               "Write-ECSAccountSetting",
               "Write-ECSAccountSettingDefault",
               "Write-ECSAttribute",
               "Write-ECSClusterCapacityProvider",
               "Register-ECSTaskDefinition",
               "New-ECSTask",
               "Start-ECSTask",
               "Stop-ECSTask",
               "Submit-ECSAttachmentStateChange",
               "Add-ECSResourceTag",
               "Remove-ECSResourceTag",
               "Update-ECSCapacityProvider",
               "Update-ECSCluster",
               "Update-ECSClusterSetting",
               "Update-ECSContainerAgent",
               "Update-ECSContainerInstancesState",
               "Update-ECSService",
               "Update-ECSServicePrimaryTaskSet",
               "Update-ECSTaskProtection",
               "Update-ECSTaskSet")
}

_awsArgumentCompleterRegistration $ECS_SelectCompleters $ECS_SelectMap
# Argument completions for service Amazon Elastic Container Service for Kubernetes


$EKS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EKS.AMITypes
        "New-EKSNodegroup/AmiType"
        {
            $v = "AL2_ARM_64","AL2_x86_64","AL2_x86_64_GPU","BOTTLEROCKET_ARM_64","BOTTLEROCKET_ARM_64_NVIDIA","BOTTLEROCKET_x86_64","BOTTLEROCKET_x86_64_NVIDIA","CUSTOM"
            break
        }

        # Amazon.EKS.CapacityTypes
        "New-EKSNodegroup/CapacityType"
        {
            $v = "ON_DEMAND","SPOT"
            break
        }

        # Amazon.EKS.ConnectorConfigProvider
        "Register-EKSCluster/ConnectorConfig_Provider"
        {
            $v = "AKS","ANTHOS","EC2","EKS_ANYWHERE","GKE","OPENSHIFT","OTHER","RANCHER","TANZU"
            break
        }

        # Amazon.EKS.IpFamily
        "New-EKSCluster/KubernetesNetworkConfig_IpFamily"
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.EKS.ResolveConflicts
        {
            ($_ -eq "New-EKSAddon/ResolveConflicts") -Or
            ($_ -eq "Update-EKSAddon/ResolveConflicts")
        }
        {
            $v = "NONE","OVERWRITE","PRESERVE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EKS_map = @{
    "AmiType"=@("New-EKSNodegroup")
    "CapacityType"=@("New-EKSNodegroup")
    "ConnectorConfig_Provider"=@("Register-EKSCluster")
    "KubernetesNetworkConfig_IpFamily"=@("New-EKSCluster")
    "ResolveConflicts"=@("New-EKSAddon","Update-EKSAddon")
}

_awsArgumentCompleterRegistration $EKS_Completers $EKS_map

$EKS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EKS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EKS_SelectMap = @{
    "Select"=@("Add-EKSEncryptionConfig",
               "Add-EKSIdentityProviderConfig",
               "New-EKSAddon",
               "New-EKSCluster",
               "New-EKSFargateProfile",
               "New-EKSNodegroup",
               "Remove-EKSAddon",
               "Remove-EKSCluster",
               "Remove-EKSFargateProfile",
               "Remove-EKSNodegroup",
               "Unregister-EKSCluster",
               "Get-EKSAddon",
               "Get-EKSAddonVersion",
               "Get-EKSCluster",
               "Get-EKSFargateProfile",
               "Get-EKSIdentityProviderConfig",
               "Get-EKSNodegroup",
               "Get-EKSUpdate",
               "Remove-EKSIdentityProviderConfig",
               "Get-EKSAddonList",
               "Get-EKSClusterList",
               "Get-EKSFargateProfileList",
               "Get-EKSIdentityProviderConfigList",
               "Get-EKSNodegroupList",
               "Get-EKSResourceTag",
               "Get-EKSUpdateList",
               "Register-EKSCluster",
               "Add-EKSResourceTag",
               "Remove-EKSResourceTag",
               "Update-EKSAddon",
               "Update-EKSClusterConfig",
               "Update-EKSClusterVersion",
               "Update-EKSNodegroupConfig",
               "Update-EKSNodegroupVersion")
}

_awsArgumentCompleterRegistration $EKS_SelectCompleters $EKS_SelectMap
# Argument completions for service Amazon ElastiCache


$EC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElastiCache.AuthTokenUpdateStrategyType
        {
            ($_ -eq "Edit-ECCacheCluster/AuthTokenUpdateStrategy") -Or
            ($_ -eq "Edit-ECReplicationGroup/AuthTokenUpdateStrategy")
        }
        {
            $v = "DELETE","ROTATE","SET"
            break
        }

        # Amazon.ElastiCache.AZMode
        {
            ($_ -eq "Edit-ECCacheCluster/AZMode") -Or
            ($_ -eq "New-ECCacheCluster/AZMode")
        }
        {
            $v = "cross-az","single-az"
            break
        }

        # Amazon.ElastiCache.InputAuthenticationType
        {
            ($_ -eq "Edit-ECUser/AuthenticationMode_Type") -Or
            ($_ -eq "New-ECUser/AuthenticationMode_Type")
        }
        {
            $v = "iam","no-password-required","password"
            break
        }

        # Amazon.ElastiCache.IpDiscovery
        {
            ($_ -eq "Edit-ECCacheCluster/IpDiscovery") -Or
            ($_ -eq "Edit-ECReplicationGroup/IpDiscovery") -Or
            ($_ -eq "New-ECCacheCluster/IpDiscovery") -Or
            ($_ -eq "New-ECReplicationGroup/IpDiscovery")
        }
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.ElastiCache.NetworkType
        {
            ($_ -eq "New-ECCacheCluster/NetworkType") -Or
            ($_ -eq "New-ECReplicationGroup/NetworkType")
        }
        {
            $v = "dual_stack","ipv4","ipv6"
            break
        }

        # Amazon.ElastiCache.OutpostMode
        "New-ECCacheCluster/OutpostMode"
        {
            $v = "cross-outpost","single-outpost"
            break
        }

        # Amazon.ElastiCache.SourceType
        "Get-ECEvent/SourceType"
        {
            $v = "cache-cluster","cache-parameter-group","cache-security-group","cache-subnet-group","replication-group","user","user-group"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC_map = @{
    "AuthenticationMode_Type"=@("Edit-ECUser","New-ECUser")
    "AuthTokenUpdateStrategy"=@("Edit-ECCacheCluster","Edit-ECReplicationGroup")
    "AZMode"=@("Edit-ECCacheCluster","New-ECCacheCluster")
    "IpDiscovery"=@("Edit-ECCacheCluster","Edit-ECReplicationGroup","New-ECCacheCluster","New-ECReplicationGroup")
    "NetworkType"=@("New-ECCacheCluster","New-ECReplicationGroup")
    "OutpostMode"=@("New-ECCacheCluster")
    "SourceType"=@("Get-ECEvent")
}

_awsArgumentCompleterRegistration $EC_Completers $EC_map

$EC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC_SelectMap = @{
    "Select"=@("Add-ECTag",
               "Approve-ECCacheSecurityGroupIngress",
               "Start-ECUpdateActionBatch",
               "Stop-ECUpdateActionBatch",
               "Complete-ECMigration",
               "Copy-ECSnapshot",
               "New-ECCacheCluster",
               "New-ECCacheParameterGroup",
               "New-ECCacheSecurityGroup",
               "New-ECCacheSubnetGroup",
               "New-ECGlobalReplicationGroup",
               "New-ECReplicationGroup",
               "New-ECSnapshot",
               "New-ECUser",
               "New-ECUserGroup",
               "Request-ECNodeGroupDecreaseInGlobalReplicationGroup",
               "Request-ECReplicaCountDecrease",
               "Remove-ECCacheCluster",
               "Remove-ECCacheParameterGroup",
               "Remove-ECCacheSecurityGroup",
               "Remove-ECCacheSubnetGroup",
               "Remove-ECGlobalReplicationGroup",
               "Remove-ECReplicationGroup",
               "Remove-ECSnapshot",
               "Remove-ECUser",
               "Remove-ECUserGroup",
               "Get-ECCacheCluster",
               "Get-ECCacheEngineVersion",
               "Get-ECCacheParameterGroup",
               "Get-ECCacheParameter",
               "Get-ECCacheSecurityGroup",
               "Get-ECCacheSubnetGroup",
               "Get-ECEngineDefaultParameter",
               "Get-ECEvent",
               "Get-ECGlobalReplicationGroup",
               "Get-ECReplicationGroup",
               "Get-ECReservedCacheNode",
               "Get-ECReservedCacheNodesOffering",
               "Get-ECServiceUpdate",
               "Get-ECSnapshot",
               "Get-ECUpdateAction",
               "Get-ECUserGroup",
               "Get-ECUser",
               "Remove-ECReplicationGroupFromGlobalReplicationGroup",
               "Request-ECGlobalReplicationGroupFailover",
               "Request-ECNodeGroupIncreaseInGlobalReplicationGroup",
               "Request-ECReplicaCountIncrease",
               "Get-ECAllowedNodeTypeModification",
               "Get-ECTag",
               "Edit-ECCacheCluster",
               "Edit-ECCacheParameterGroup",
               "Edit-ECCacheSubnetGroup",
               "Edit-ECGlobalReplicationGroup",
               "Edit-ECReplicationGroup",
               "Edit-ECReplicationGroupShardConfiguration",
               "Edit-ECUser",
               "Edit-ECUserGroup",
               "Request-ECReservedCacheNodesOffering",
               "Request-ECSlotRebalanceInGlobalReplicationGroup",
               "Restart-ECCacheCluster",
               "Remove-ECTag",
               "Reset-ECCacheParameterGroup",
               "Revoke-ECCacheSecurityGroupIngress",
               "Start-ECMigration",
               "Test-ECFailover")
}

_awsArgumentCompleterRegistration $EC_SelectCompleters $EC_SelectMap
# Argument completions for service AWS Elastic Beanstalk


$EB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticBeanstalk.ActionStatus
        "Get-EBEnvironmentManagedAction/Status"
        {
            $v = "Pending","Running","Scheduled","Unknown"
            break
        }

        # Amazon.ElasticBeanstalk.ComputeType
        "New-EBApplicationVersion/BuildConfiguration_ComputeType"
        {
            $v = "BUILD_GENERAL1_LARGE","BUILD_GENERAL1_MEDIUM","BUILD_GENERAL1_SMALL"
            break
        }

        # Amazon.ElasticBeanstalk.EnvironmentInfoType
        {
            ($_ -eq "Get-EBEnvironmentInfo/InfoType") -Or
            ($_ -eq "Request-EBEnvironmentInfo/InfoType")
        }
        {
            $v = "bundle","tail"
            break
        }

        # Amazon.ElasticBeanstalk.EventSeverity
        "Get-EBEvent/Severity"
        {
            $v = "DEBUG","ERROR","FATAL","INFO","TRACE","WARN"
            break
        }

        # Amazon.ElasticBeanstalk.SourceRepository
        "New-EBApplicationVersion/SourceBuildInformation_SourceRepository"
        {
            $v = "CodeCommit","S3"
            break
        }

        # Amazon.ElasticBeanstalk.SourceType
        "New-EBApplicationVersion/SourceBuildInformation_SourceType"
        {
            $v = "Git","Zip"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EB_map = @{
    "BuildConfiguration_ComputeType"=@("New-EBApplicationVersion")
    "InfoType"=@("Get-EBEnvironmentInfo","Request-EBEnvironmentInfo")
    "Severity"=@("Get-EBEvent")
    "SourceBuildInformation_SourceRepository"=@("New-EBApplicationVersion")
    "SourceBuildInformation_SourceType"=@("New-EBApplicationVersion")
    "Status"=@("Get-EBEnvironmentManagedAction")
}

_awsArgumentCompleterRegistration $EB_Completers $EB_map

$EB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EB_SelectMap = @{
    "Select"=@("Stop-EBEnvironmentUpdate",
               "Submit-EBEnvironmentManagedAction",
               "Register-EBEnvironmentOperationsRole",
               "Get-EBDNSAvailability",
               "Group-EBEnvironment",
               "New-EBApplication",
               "New-EBApplicationVersion",
               "New-EBConfigurationTemplate",
               "New-EBEnvironment",
               "New-EBPlatformVersion",
               "New-EBStorageLocation",
               "Remove-EBApplication",
               "Remove-EBApplicationVersion",
               "Remove-EBConfigurationTemplate",
               "Remove-EBEnvironmentConfiguration",
               "Remove-EBPlatformVersion",
               "Get-EBAccountAttribute",
               "Get-EBApplication",
               "Get-EBApplicationVersion",
               "Get-EBConfigurationOption",
               "Get-EBConfigurationSetting",
               "Get-EBEnvironmentHealth",
               "Get-EBEnvironmentManagedActionHistory",
               "Get-EBEnvironmentManagedAction",
               "Get-EBEnvironmentResource",
               "Get-EBEnvironment",
               "Get-EBEvent",
               "Get-EBInstanceHealth",
               "Get-EBPlatformVersionDetail",
               "Unregister-EBEnvironmentOperationsRole",
               "Get-EBAvailableSolutionStackList",
               "Get-EBPlatformBranch",
               "Get-EBPlatformVersion",
               "Get-EBResourceTag",
               "Start-EBEnvironmentRebuild",
               "Request-EBEnvironmentInfo",
               "Restart-EBAppServer",
               "Get-EBEnvironmentInfo",
               "Set-EBEnvironmentCNAME",
               "Stop-EBEnvironment",
               "Update-EBApplication",
               "Update-EBApplicationResourceLifecycle",
               "Update-EBApplicationVersion",
               "Update-EBConfigurationTemplate",
               "Update-EBEnvironment",
               "Update-EBResourceTag",
               "Test-EBConfigurationSetting")
}

_awsArgumentCompleterRegistration $EB_SelectCompleters $EB_SelectMap
# Argument completions for service Amazon Elastic File System


$EFS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticFileSystem.PerformanceMode
        "New-EFSFileSystem/PerformanceMode"
        {
            $v = "generalPurpose","maxIO"
            break
        }

        # Amazon.ElasticFileSystem.ResourceIdType
        "Write-EFSAccountPreference/ResourceIdType"
        {
            $v = "LONG_ID","SHORT_ID"
            break
        }

        # Amazon.ElasticFileSystem.Status
        "Write-EFSBackupPolicy/BackupPolicy_Status"
        {
            $v = "DISABLED","DISABLING","ENABLED","ENABLING"
            break
        }

        # Amazon.ElasticFileSystem.ThroughputMode
        {
            ($_ -eq "New-EFSFileSystem/ThroughputMode") -Or
            ($_ -eq "Update-EFSFileSystem/ThroughputMode")
        }
        {
            $v = "bursting","provisioned"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EFS_map = @{
    "BackupPolicy_Status"=@("Write-EFSBackupPolicy")
    "PerformanceMode"=@("New-EFSFileSystem")
    "ResourceIdType"=@("Write-EFSAccountPreference")
    "ThroughputMode"=@("New-EFSFileSystem","Update-EFSFileSystem")
}

_awsArgumentCompleterRegistration $EFS_Completers $EFS_map

$EFS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EFS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EFS_SelectMap = @{
    "Select"=@("New-EFSAccessPoint",
               "New-EFSFileSystem",
               "New-EFSMountTarget",
               "New-EFSReplicationConfiguration",
               "New-EFSTag",
               "Remove-EFSAccessPoint",
               "Remove-EFSFileSystem",
               "Remove-EFSFileSystemPolicy",
               "Remove-EFSMountTarget",
               "Remove-EFSReplicationConfiguration",
               "Remove-EFSTag",
               "Get-EFSAccessPoint",
               "Get-EFSAccountPreference",
               "Get-EFSBackupPolicy",
               "Get-EFSFileSystemPolicy",
               "Get-EFSFileSystem",
               "Get-EFSLifecycleConfiguration",
               "Get-EFSMountTarget",
               "Get-EFSMountTargetSecurityGroup",
               "Get-EFSReplicationConfiguration",
               "Get-EFSTag",
               "Get-EFSResourceTag",
               "Edit-EFSMountTargetSecurityGroup",
               "Write-EFSAccountPreference",
               "Write-EFSBackupPolicy",
               "Write-EFSFileSystemPolicy",
               "Write-EFSLifecycleConfiguration",
               "Add-EFSResourceTag",
               "Remove-EFSResourceTag",
               "Update-EFSFileSystem")
}

_awsArgumentCompleterRegistration $EFS_SelectCompleters $EFS_SelectMap
# Argument completions for service Amazon Elastic Inference


$EI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticInference.LocationType
        "Get-EIAcceleratorOffering/LocationType"
        {
            $v = "availability-zone","availability-zone-id","region"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EI_map = @{
    "LocationType"=@("Get-EIAcceleratorOffering")
}

_awsArgumentCompleterRegistration $EI_Completers $EI_map

$EI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EI_SelectMap = @{
    "Select"=@("Get-EIAcceleratorOffering",
               "Get-EIAccelerator",
               "Get-EIAcceleratorType",
               "Get-EIResourceTag",
               "Add-EIResourceTag",
               "Remove-EIResourceTag")
}

_awsArgumentCompleterRegistration $EI_SelectCompleters $EI_SelectMap
# Argument completions for service Elastic Load Balancing


$ELB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ELB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB_SelectMap = @{
    "Select"=@("Add-ELBResourceTag",
               "Join-ELBSecurityGroupToLoadBalancer",
               "Add-ELBLoadBalancerToSubnet",
               "Set-ELBHealthCheck",
               "New-ELBAppCookieStickinessPolicy",
               "New-ELBLBCookieStickinessPolicy",
               "New-ELBLoadBalancer",
               "New-ELBLoadBalancerListener",
               "New-ELBLoadBalancerPolicy",
               "Remove-ELBLoadBalancer",
               "Remove-ELBLoadBalancerListener",
               "Remove-ELBLoadBalancerPolicy",
               "Remove-ELBInstanceFromLoadBalancer",
               "Get-ELBAccountLimit",
               "Get-ELBInstanceHealth",
               "Get-ELBLoadBalancerAttribute",
               "Get-ELBLoadBalancerPolicy",
               "Get-ELBLoadBalancerPolicyType",
               "Get-ELBLoadBalancer",
               "Get-ELBResourceTag",
               "Dismount-ELBLoadBalancerFromSubnet",
               "Disable-ELBAvailabilityZoneForLoadBalancer",
               "Enable-ELBAvailabilityZoneForLoadBalancer",
               "Edit-ELBLoadBalancerAttribute",
               "Register-ELBInstanceWithLoadBalancer",
               "Remove-ELBResourceTag",
               "Set-ELBLoadBalancerListenerSSLCertificate",
               "Set-ELBLoadBalancerPolicyForBackendServer",
               "Set-ELBLoadBalancerPolicyOfListener")
}

_awsArgumentCompleterRegistration $ELB_SelectCompleters $ELB_SelectMap
# Argument completions for service Elastic Load Balancing V2


$ELB2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticLoadBalancingV2.IpAddressType
        {
            ($_ -eq "New-ELB2LoadBalancer/IpAddressType") -Or
            ($_ -eq "Set-ELB2IpAddressType/IpAddressType") -Or
            ($_ -eq "Set-ELB2Subnet/IpAddressType")
        }
        {
            $v = "dualstack","ipv4"
            break
        }

        # Amazon.ElasticLoadBalancingV2.LoadBalancerSchemeEnum
        "New-ELB2LoadBalancer/Scheme"
        {
            $v = "internal","internet-facing"
            break
        }

        # Amazon.ElasticLoadBalancingV2.LoadBalancerTypeEnum
        {
            ($_ -eq "Get-ELB2SSLPolicy/LoadBalancerType") -Or
            ($_ -eq "New-ELB2LoadBalancer/Type")
        }
        {
            $v = "application","gateway","network"
            break
        }

        # Amazon.ElasticLoadBalancingV2.ProtocolEnum
        {
            ($_ -eq "Edit-ELB2TargetGroup/HealthCheckProtocol") -Or
            ($_ -eq "New-ELB2TargetGroup/HealthCheckProtocol") -Or
            ($_ -eq "Edit-ELB2Listener/Protocol") -Or
            ($_ -eq "New-ELB2Listener/Protocol") -Or
            ($_ -eq "New-ELB2TargetGroup/Protocol")
        }
        {
            $v = "GENEVE","HTTP","HTTPS","TCP","TCP_UDP","TLS","UDP"
            break
        }

        # Amazon.ElasticLoadBalancingV2.TargetGroupIpAddressTypeEnum
        "New-ELB2TargetGroup/IpAddressType"
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.ElasticLoadBalancingV2.TargetTypeEnum
        "New-ELB2TargetGroup/TargetType"
        {
            $v = "alb","instance","ip","lambda"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB2_map = @{
    "HealthCheckProtocol"=@("Edit-ELB2TargetGroup","New-ELB2TargetGroup")
    "IpAddressType"=@("New-ELB2LoadBalancer","New-ELB2TargetGroup","Set-ELB2IpAddressType","Set-ELB2Subnet")
    "LoadBalancerType"=@("Get-ELB2SSLPolicy")
    "Protocol"=@("Edit-ELB2Listener","New-ELB2Listener","New-ELB2TargetGroup")
    "Scheme"=@("New-ELB2LoadBalancer")
    "TargetType"=@("New-ELB2TargetGroup")
    "Type"=@("New-ELB2LoadBalancer")
}

_awsArgumentCompleterRegistration $ELB2_Completers $ELB2_map

$ELB2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ELB2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB2_SelectMap = @{
    "Select"=@("Add-ELB2ListenerCertificate",
               "Add-ELB2Tag",
               "New-ELB2Listener",
               "New-ELB2LoadBalancer",
               "New-ELB2Rule",
               "New-ELB2TargetGroup",
               "Remove-ELB2Listener",
               "Remove-ELB2LoadBalancer",
               "Remove-ELB2Rule",
               "Remove-ELB2TargetGroup",
               "Unregister-ELB2Target",
               "Get-ELB2AccountLimit",
               "Get-ELB2ListenerCertificate",
               "Get-ELB2Listener",
               "Get-ELB2LoadBalancerAttribute",
               "Get-ELB2LoadBalancer",
               "Get-ELB2Rule",
               "Get-ELB2SSLPolicy",
               "Get-ELB2Tag",
               "Get-ELB2TargetGroupAttribute",
               "Get-ELB2TargetGroup",
               "Get-ELB2TargetHealth",
               "Edit-ELB2Listener",
               "Edit-ELB2LoadBalancerAttribute",
               "Edit-ELB2Rule",
               "Edit-ELB2TargetGroup",
               "Edit-ELB2TargetGroupAttribute",
               "Register-ELB2Target",
               "Remove-ELB2ListenerCertificate",
               "Remove-ELB2Tag",
               "Set-ELB2IpAddressType",
               "Set-ELB2RulePriority",
               "Set-ELB2SecurityGroup",
               "Set-ELB2Subnet")
}

_awsArgumentCompleterRegistration $ELB2_SelectCompleters $ELB2_SelectMap
# Argument completions for service Amazon Elastic MapReduce


$EMR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticMapReduce.AuthMode
        "New-EMRStudio/AuthMode"
        {
            $v = "IAM","SSO"
            break
        }

        # Amazon.ElasticMapReduce.ComputeLimitsUnitType
        {
            ($_ -eq "Start-EMRJobFlow/ManagedScalingPolicy_ComputeLimits_UnitType") -Or
            ($_ -eq "Write-EMRManagedScalingPolicy/ManagedScalingPolicy_ComputeLimits_UnitType")
        }
        {
            $v = "InstanceFleetUnits","Instances","VCPU"
            break
        }

        # Amazon.ElasticMapReduce.ExecutionEngineType
        "Start-EMRNotebookExecution/ExecutionEngine_Type"
        {
            $v = "EMR"
            break
        }

        # Amazon.ElasticMapReduce.IdentityType
        {
            ($_ -eq "Get-EMRStudioSessionMapping/IdentityType") -Or
            ($_ -eq "Get-EMRStudioSessionMappingList/IdentityType") -Or
            ($_ -eq "New-EMRStudioSessionMapping/IdentityType") -Or
            ($_ -eq "Remove-EMRStudioSessionMapping/IdentityType") -Or
            ($_ -eq "Update-EMRStudioSessionMapping/IdentityType")
        }
        {
            $v = "GROUP","USER"
            break
        }

        # Amazon.ElasticMapReduce.InstanceFleetType
        {
            ($_ -eq "Add-EMRInstanceFleet/InstanceFleet_InstanceFleetType") -Or
            ($_ -eq "Get-EMRInstanceList/InstanceFleetType")
        }
        {
            $v = "CORE","MASTER","TASK"
            break
        }

        # Amazon.ElasticMapReduce.NotebookExecutionStatus
        "Get-EMRNotebookExecutionList/Status"
        {
            $v = "FAILED","FAILING","FINISHED","FINISHING","RUNNING","STARTING","START_PENDING","STOPPED","STOPPING","STOP_PENDING"
            break
        }

        # Amazon.ElasticMapReduce.OnDemandCapacityReservationPreference
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_OnDemandSpecification_CapacityReservationOptions_CapacityReservationPreference"
        {
            $v = "none","open"
            break
        }

        # Amazon.ElasticMapReduce.OnDemandCapacityReservationUsageStrategy
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_OnDemandSpecification_CapacityReservationOptions_UsageStrategy"
        {
            $v = "use-capacity-reservations-first"
            break
        }

        # Amazon.ElasticMapReduce.OnDemandProvisioningAllocationStrategy
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_OnDemandSpecification_AllocationStrategy"
        {
            $v = "lowest-price"
            break
        }

        # Amazon.ElasticMapReduce.RepoUpgradeOnBoot
        "Start-EMRJobFlow/RepoUpgradeOnBoot"
        {
            $v = "NONE","SECURITY"
            break
        }

        # Amazon.ElasticMapReduce.ScaleDownBehavior
        "Start-EMRJobFlow/ScaleDownBehavior"
        {
            $v = "TERMINATE_AT_INSTANCE_HOUR","TERMINATE_AT_TASK_COMPLETION"
            break
        }

        # Amazon.ElasticMapReduce.SpotProvisioningAllocationStrategy
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_SpotSpecification_AllocationStrategy"
        {
            $v = "capacity-optimized"
            break
        }

        # Amazon.ElasticMapReduce.SpotProvisioningTimeoutAction
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_SpotSpecification_TimeoutAction"
        {
            $v = "SWITCH_TO_ON_DEMAND","TERMINATE_CLUSTER"
            break
        }

        # Amazon.ElasticMapReduce.StepCancellationOption
        "Stop-EMRStep/StepCancellationOption"
        {
            $v = "SEND_INTERRUPT","TERMINATE_PROCESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMR_map = @{
    "AuthMode"=@("New-EMRStudio")
    "ExecutionEngine_Type"=@("Start-EMRNotebookExecution")
    "IdentityType"=@("Get-EMRStudioSessionMapping","Get-EMRStudioSessionMappingList","New-EMRStudioSessionMapping","Remove-EMRStudioSessionMapping","Update-EMRStudioSessionMapping")
    "InstanceFleet_InstanceFleetType"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_OnDemandSpecification_AllocationStrategy"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_OnDemandSpecification_CapacityReservationOptions_CapacityReservationPreference"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_OnDemandSpecification_CapacityReservationOptions_UsageStrategy"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_SpotSpecification_AllocationStrategy"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_SpotSpecification_TimeoutAction"=@("Add-EMRInstanceFleet")
    "InstanceFleetType"=@("Get-EMRInstanceList")
    "ManagedScalingPolicy_ComputeLimits_UnitType"=@("Start-EMRJobFlow","Write-EMRManagedScalingPolicy")
    "RepoUpgradeOnBoot"=@("Start-EMRJobFlow")
    "ScaleDownBehavior"=@("Start-EMRJobFlow")
    "Status"=@("Get-EMRNotebookExecutionList")
    "StepCancellationOption"=@("Stop-EMRStep")
}

_awsArgumentCompleterRegistration $EMR_Completers $EMR_map

$EMR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMR_SelectMap = @{
    "Select"=@("Add-EMRInstanceFleet",
               "Add-EMRInstanceGroup",
               "Add-EMRJobFlowStep",
               "Add-EMRResourceTag",
               "Stop-EMRStep",
               "New-EMRSecurityConfiguration",
               "New-EMRStudio",
               "New-EMRStudioSessionMapping",
               "Remove-EMRSecurityConfiguration",
               "Remove-EMRStudio",
               "Remove-EMRStudioSessionMapping",
               "Get-EMRCluster",
               "Get-EMRJobFlow",
               "Get-EMRNotebookExecution",
               "Get-EMRReleaseLabel",
               "Get-EMRSecurityConfiguration",
               "Get-EMRStep",
               "Get-EMRStudio",
               "Get-EMRAutoTerminationPolicy",
               "Get-EMRBlockPublicAccessConfiguration",
               "Get-EMRManagedScalingPolicy",
               "Get-EMRStudioSessionMapping",
               "Get-EMRBootstrapActionList",
               "Get-EMRClusterList",
               "Get-EMRInstanceFleetList",
               "Get-EMRInstanceGroupList",
               "Get-EMRInstanceList",
               "Get-EMRNotebookExecutionList",
               "Find-EMRReleaseLabel",
               "Get-EMRSecurityConfigurationList",
               "Get-EMRStepList",
               "Get-EMRStudioList",
               "Get-EMRStudioSessionMappingList",
               "Edit-EMRCluster",
               "Edit-EMRInstanceFleet",
               "Edit-EMRInstanceGroup",
               "Write-EMRAutoScalingPolicy",
               "Write-EMRAutoTerminationPolicy",
               "Write-EMRBlockPublicAccessConfiguration",
               "Write-EMRManagedScalingPolicy",
               "Remove-EMRAutoScalingPolicy",
               "Remove-EMRAutoTerminationPolicy",
               "Remove-EMRManagedScalingPolicy",
               "Remove-EMRResourceTag",
               "Start-EMRJobFlow",
               "Set-EMRTerminationProtection",
               "Set-EMRVisibleToAllUser",
               "Start-EMRNotebookExecution",
               "Stop-EMRNotebookExecution",
               "Stop-EMRJobFlow",
               "Update-EMRStudio",
               "Update-EMRStudioSessionMapping")
}

_awsArgumentCompleterRegistration $EMR_SelectCompleters $EMR_SelectMap
# Argument completions for service Amazon Elastic Transcoder


$ETS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ETS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ETS_SelectMap = @{
    "Select"=@("Stop-ETSJob",
               "New-ETSJob",
               "New-ETSPipeline",
               "New-ETSPreset",
               "Remove-ETSPipeline",
               "Remove-ETSPreset",
               "Get-ETSJobsByPipeline",
               "Get-ETSJobsByStatus",
               "Get-ETSPipeline",
               "Get-ETSPreset",
               "Read-ETSJob",
               "Read-ETSPipeline",
               "Read-ETSPreset",
               "Test-ETSRole",
               "Update-ETSPipeline",
               "Update-ETSPipelineNotification",
               "Update-ETSPipelineStatus")
}

_awsArgumentCompleterRegistration $ETS_SelectCompleters $ETS_SelectMap
# Argument completions for service Amazon Simple Email Service (SES)


$SES_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleEmail.BehaviorOnMXFailure
        "Set-SESIdentityMailFromDomain/BehaviorOnMXFailure"
        {
            $v = "RejectMessage","UseDefaultValue"
            break
        }

        # Amazon.SimpleEmail.IdentityType
        "Get-SESIdentity/IdentityType"
        {
            $v = "Domain","EmailAddress"
            break
        }

        # Amazon.SimpleEmail.NotificationType
        {
            ($_ -eq "Set-SESIdentityHeadersInNotificationsEnabled/NotificationType") -Or
            ($_ -eq "Set-SESIdentityNotificationTopic/NotificationType")
        }
        {
            $v = "Bounce","Complaint","Delivery"
            break
        }

        # Amazon.SimpleEmail.ReceiptFilterPolicy
        "New-SESReceiptFilter/Filter_IpFilter_Policy"
        {
            $v = "Allow","Block"
            break
        }

        # Amazon.SimpleEmail.TlsPolicy
        {
            ($_ -eq "Write-SESConfigurationSetDeliveryOption/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "New-SESReceiptRule/Rule_TlsPolicy") -Or
            ($_ -eq "Update-SESReceiptRule/Rule_TlsPolicy")
        }
        {
            $v = "Optional","Require"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES_map = @{
    "BehaviorOnMXFailure"=@("Set-SESIdentityMailFromDomain")
    "DeliveryOptions_TlsPolicy"=@("Write-SESConfigurationSetDeliveryOption")
    "Filter_IpFilter_Policy"=@("New-SESReceiptFilter")
    "IdentityType"=@("Get-SESIdentity")
    "NotificationType"=@("Set-SESIdentityHeadersInNotificationsEnabled","Set-SESIdentityNotificationTopic")
    "Rule_TlsPolicy"=@("New-SESReceiptRule","Update-SESReceiptRule")
}

_awsArgumentCompleterRegistration $SES_Completers $SES_map

$SES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES_SelectMap = @{
    "Select"=@("Copy-SESReceiptRuleSet",
               "New-SESConfigurationSet",
               "New-SESConfigurationSetEventDestination",
               "New-SESConfigurationSetTrackingOption",
               "New-SESCustomVerificationEmailTemplate",
               "New-SESReceiptFilter",
               "New-SESReceiptRule",
               "New-SESReceiptRuleSet",
               "New-SESTemplate",
               "Remove-SESConfigurationSet",
               "Remove-SESConfigurationSetEventDestination",
               "Remove-SESConfigurationSetTrackingOption",
               "Remove-SESCustomVerificationEmailTemplate",
               "Remove-SESIdentity",
               "Remove-SESIdentityPolicy",
               "Remove-SESReceiptFilter",
               "Remove-SESReceiptRule",
               "Remove-SESReceiptRuleSet",
               "Remove-SESTemplate",
               "Remove-SESVerifiedEmailAddress",
               "Get-SESActiveReceiptRuleSet",
               "Get-SESConfigurationSet",
               "Get-SESReceiptRule",
               "Get-SESReceiptRuleSet",
               "Get-SESAccountSendingEnabled",
               "Get-SESCustomVerificationEmailTemplate",
               "Get-SESIdentityDkimAttribute",
               "Get-SESIdentityMailFromDomainAttribute",
               "Get-SESIdentityNotificationAttribute",
               "Get-SESIdentityPolicy",
               "Get-SESIdentityVerificationAttribute",
               "Get-SESSendQuota",
               "Get-SESSendStatistic",
               "Get-SESTemplate",
               "Get-SESConfigurationSetList",
               "Get-SESCustomVerificationEmailTemplateList",
               "Get-SESIdentity",
               "Get-SESIdentityPolicyList",
               "Get-SESReceiptFilterList",
               "Get-SESReceiptRuleSetList",
               "Get-SESTemplateList",
               "Get-SESVerifiedEmailAddress",
               "Write-SESConfigurationSetDeliveryOption",
               "Write-SESIdentityPolicy",
               "Set-SESReceiptRuleSetOrder",
               "Send-SESBounce",
               "Send-SESBulkTemplatedEmail",
               "Send-SESCustomVerificationEmail",
               "Send-SESEmail",
               "Send-SESRawEmail",
               "Send-SESTemplatedEmail",
               "Set-SESActiveReceiptRuleSet",
               "Set-SESIdentityDkimEnabled",
               "Set-SESIdentityFeedbackForwardingEnabled",
               "Set-SESIdentityHeadersInNotificationsEnabled",
               "Set-SESIdentityMailFromDomain",
               "Set-SESIdentityNotificationTopic",
               "Set-SESReceiptRulePosition",
               "Test-SESRenderTemplate",
               "Update-SESAccountSendingEnabled",
               "Update-SESConfigurationSetEventDestination",
               "Update-SESConfigurationSetReputationMetricsEnabled",
               "Update-SESConfigurationSetSendingEnabled",
               "Update-SESConfigurationSetTrackingOption",
               "Update-SESCustomVerificationEmailTemplate",
               "Update-SESReceiptRule",
               "Update-SESTemplate",
               "Confirm-SESDomainDkim",
               "Confirm-SESDomainIdentity",
               "Confirm-SESEmailAddress",
               "Confirm-SESEmailIdentity")
}

_awsArgumentCompleterRegistration $SES_SelectCompleters $SES_SelectMap
# Argument completions for service Amazon EMR Containers


$EMRC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EMRContainers.ContainerProviderType
        {
            ($_ -eq "New-EMRCVirtualCluster/ContainerProvider_Type") -Or
            ($_ -eq "Get-EMRCVirtualClusterList/ContainerProviderType")
        }
        {
            $v = "EKS"
            break
        }

        # Amazon.EMRContainers.PersistentAppUI
        {
            ($_ -eq "New-EMRCManagedEndpoint/ConfigurationOverrides_MonitoringConfiguration_PersistentAppUI") -Or
            ($_ -eq "Start-EMRCJobRun/ConfigurationOverrides_MonitoringConfiguration_PersistentAppUI")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMRC_map = @{
    "ConfigurationOverrides_MonitoringConfiguration_PersistentAppUI"=@("New-EMRCManagedEndpoint","Start-EMRCJobRun")
    "ContainerProvider_Type"=@("New-EMRCVirtualCluster")
    "ContainerProviderType"=@("Get-EMRCVirtualClusterList")
}

_awsArgumentCompleterRegistration $EMRC_Completers $EMRC_map

$EMRC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMRC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMRC_SelectMap = @{
    "Select"=@("Stop-EMRCJobRun",
               "New-EMRCJobTemplate",
               "New-EMRCManagedEndpoint",
               "New-EMRCVirtualCluster",
               "Remove-EMRCJobTemplate",
               "Remove-EMRCManagedEndpoint",
               "Remove-EMRCVirtualCluster",
               "Get-EMRCJobRun",
               "Get-EMRCJobTemplate",
               "Get-EMRCManagedEndpoint",
               "Get-EMRCVirtualCluster",
               "Get-EMRCJobRunList",
               "Get-EMRCJobTemplateList",
               "Get-EMRCManagedEndpointList",
               "Get-EMRCResourceTag",
               "Get-EMRCVirtualClusterList",
               "Start-EMRCJobRun",
               "Add-EMRCResourceTag",
               "Remove-EMRCResourceTag")
}

_awsArgumentCompleterRegistration $EMRC_SelectCompleters $EMRC_SelectMap
# Argument completions for service EMR Serverless


$EMRServerless_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMRServerless.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMRServerless_SelectMap = @{
    "Select"=@("Stop-EMRServerlessJobRun",
               "New-EMRServerlessApplication",
               "Remove-EMRServerlessApplication",
               "Get-EMRServerlessApplication",
               "Get-EMRServerlessDashboardForJobRun",
               "Get-EMRServerlessJobRun",
               "Get-EMRServerlessApplicationList",
               "Get-EMRServerlessJobRunList",
               "Get-EMRServerlessResourceTagList",
               "Start-EMRServerlessApplication",
               "Start-EMRServerlessJobRun",
               "Stop-EMRServerlessApplication",
               "Add-EMRServerlessResourceTag",
               "Remove-EMRServerlessResourceTag",
               "Update-EMRServerlessApplication")
}

_awsArgumentCompleterRegistration $EMRServerless_SelectCompleters $EMRServerless_SelectMap
# Argument completions for service AWS Marketplace Entitlement Service


$MES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MES_SelectMap = @{
    "Select"=@("Get-MESEntitlementList")
}

_awsArgumentCompleterRegistration $MES_SelectCompleters $MES_SelectMap
# Argument completions for service Amazon Elasticsearch


$ES_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Elasticsearch.AutoTuneDesiredState
        {
            ($_ -eq "New-ESDomain/AutoTuneOptions_DesiredState") -Or
            ($_ -eq "Update-ESDomainConfig/AutoTuneOptions_DesiredState")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Elasticsearch.EngineType
        "Get-ESDomainNameList/EngineType"
        {
            $v = "Elasticsearch","OpenSearch"
            break
        }

        # Amazon.Elasticsearch.ESPartitionInstanceType
        {
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_InstanceType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_InstanceType") -Or
            ($_ -eq "Get-ESInstanceTypeLimit/InstanceType")
        }
        {
            $v = "c4.2xlarge.elasticsearch","c4.4xlarge.elasticsearch","c4.8xlarge.elasticsearch","c4.large.elasticsearch","c4.xlarge.elasticsearch","c5.18xlarge.elasticsearch","c5.2xlarge.elasticsearch","c5.4xlarge.elasticsearch","c5.9xlarge.elasticsearch","c5.large.elasticsearch","c5.xlarge.elasticsearch","d2.2xlarge.elasticsearch","d2.4xlarge.elasticsearch","d2.8xlarge.elasticsearch","d2.xlarge.elasticsearch","i2.2xlarge.elasticsearch","i2.xlarge.elasticsearch","i3.16xlarge.elasticsearch","i3.2xlarge.elasticsearch","i3.4xlarge.elasticsearch","i3.8xlarge.elasticsearch","i3.large.elasticsearch","i3.xlarge.elasticsearch","m3.2xlarge.elasticsearch","m3.large.elasticsearch","m3.medium.elasticsearch","m3.xlarge.elasticsearch","m4.10xlarge.elasticsearch","m4.2xlarge.elasticsearch","m4.4xlarge.elasticsearch","m4.large.elasticsearch","m4.xlarge.elasticsearch","m5.12xlarge.elasticsearch","m5.2xlarge.elasticsearch","m5.4xlarge.elasticsearch","m5.large.elasticsearch","m5.xlarge.elasticsearch","r3.2xlarge.elasticsearch","r3.4xlarge.elasticsearch","r3.8xlarge.elasticsearch","r3.large.elasticsearch","r3.xlarge.elasticsearch","r4.16xlarge.elasticsearch","r4.2xlarge.elasticsearch","r4.4xlarge.elasticsearch","r4.8xlarge.elasticsearch","r4.large.elasticsearch","r4.xlarge.elasticsearch","r5.12xlarge.elasticsearch","r5.2xlarge.elasticsearch","r5.4xlarge.elasticsearch","r5.large.elasticsearch","r5.xlarge.elasticsearch","t2.medium.elasticsearch","t2.micro.elasticsearch","t2.small.elasticsearch","ultrawarm1.large.elasticsearch","ultrawarm1.medium.elasticsearch"
            break
        }

        # Amazon.Elasticsearch.ESWarmPartitionInstanceType
        {
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_WarmType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_WarmType")
        }
        {
            $v = "ultrawarm1.large.elasticsearch","ultrawarm1.medium.elasticsearch"
            break
        }

        # Amazon.Elasticsearch.PackageType
        "New-ESPackage/PackageType"
        {
            $v = "TXT-DICTIONARY"
            break
        }

        # Amazon.Elasticsearch.RollbackOnDisable
        "Update-ESDomainConfig/AutoTuneOptions_RollbackOnDisable"
        {
            $v = "DEFAULT_ROLLBACK","NO_ROLLBACK"
            break
        }

        # Amazon.Elasticsearch.TLSSecurityPolicy
        {
            ($_ -eq "New-ESDomain/DomainEndpointOptions_TLSSecurityPolicy") -Or
            ($_ -eq "Update-ESDomainConfig/DomainEndpointOptions_TLSSecurityPolicy")
        }
        {
            $v = "Policy-Min-TLS-1-0-2019-07","Policy-Min-TLS-1-2-2019-07"
            break
        }

        # Amazon.Elasticsearch.VolumeType
        {
            ($_ -eq "New-ESDomain/EBSOptions_VolumeType") -Or
            ($_ -eq "Update-ESDomainConfig/EBSOptions_VolumeType")
        }
        {
            $v = "gp2","gp3","io1","standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ES_map = @{
    "AutoTuneOptions_DesiredState"=@("New-ESDomain","Update-ESDomainConfig")
    "AutoTuneOptions_RollbackOnDisable"=@("Update-ESDomainConfig")
    "DomainEndpointOptions_TLSSecurityPolicy"=@("New-ESDomain","Update-ESDomainConfig")
    "EBSOptions_VolumeType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_DedicatedMasterType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_InstanceType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_WarmType"=@("New-ESDomain","Update-ESDomainConfig")
    "EngineType"=@("Get-ESDomainNameList")
    "InstanceType"=@("Get-ESInstanceTypeLimit")
    "PackageType"=@("New-ESPackage")
}

_awsArgumentCompleterRegistration $ES_Completers $ES_map

$ES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ES_SelectMap = @{
    "Select"=@("Approve-ESInboundCrossClusterSearchConnection",
               "Add-ESResourceTag",
               "Start-ESAssociatePackage",
               "Approve-ESVpcEndpointAccess",
               "Stop-ESElasticsearchServiceSoftwareUpdate",
               "New-ESDomain",
               "New-ESOutboundCrossClusterSearchConnection",
               "New-ESPackage",
               "New-ESVpcEndpoint",
               "Remove-ESDomain",
               "Remove-ESElasticsearchServiceRole",
               "Remove-ESInboundCrossClusterSearchConnection",
               "Remove-ESOutboundCrossClusterSearchConnection",
               "Remove-ESPackage",
               "Remove-ESVpcEndpoint",
               "Get-ESDomainAutoTune",
               "Get-ESDomainChangeProgress",
               "Get-ESDomain",
               "Get-ESDomainConfig",
               "Get-ESDomainList",
               "Get-ESInstanceTypeLimit",
               "Get-ESInboundCrossClusterSearchConnection",
               "Get-ESOutboundCrossClusterSearchConnection",
               "Get-ESPackage",
               "Get-ESReservedElasticsearchInstanceOfferingList",
               "Get-ESReservedElasticsearchInstanceList",
               "Get-ESVpcEndpoint",
               "Start-ESDissociatePackage",
               "Get-ESCompatibleElasticsearchVersion",
               "Get-ESPackageVersionHistory",
               "Get-ESUpgradeHistory",
               "Get-ESUpgradeStatus",
               "Get-ESDomainNameList",
               "Get-ESDomainsForPackageList",
               "Get-ESInstanceTypeList",
               "Get-ESVersionList",
               "Get-ESPackagesForDomainList",
               "Get-ESResourceTag",
               "Get-ESVpcEndpointAccessList",
               "Get-ESVpcEndpointList",
               "Get-ESVpcEndpointsForDomainList",
               "New-ESReservedElasticsearchInstanceOffering",
               "Deny-ESInboundCrossClusterSearchConnection",
               "Remove-ESResourceTag",
               "Revoke-ESVpcEndpointAccess",
               "Start-ESElasticsearchServiceSoftwareUpdate",
               "Update-ESDomainConfig",
               "Update-ESPackage",
               "Update-ESVpcEndpoint",
               "Update-ESElasticsearchDomain")
}

_awsArgumentCompleterRegistration $ES_SelectCompleters $ES_SelectMap
# Argument completions for service Amazon EventBridge


$EVB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EventBridge.ApiDestinationHttpMethod
        {
            ($_ -eq "New-EVBApiDestination/HttpMethod") -Or
            ($_ -eq "Update-EVBApiDestination/HttpMethod")
        }
        {
            $v = "DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT"
            break
        }

        # Amazon.EventBridge.ArchiveState
        "Get-EVBArchiveList/State"
        {
            $v = "CREATE_FAILED","CREATING","DISABLED","ENABLED","UPDATE_FAILED","UPDATING"
            break
        }

        # Amazon.EventBridge.ConnectionAuthorizationType
        {
            ($_ -eq "New-EVBConnection/AuthorizationType") -Or
            ($_ -eq "Update-EVBConnection/AuthorizationType")
        }
        {
            $v = "API_KEY","BASIC","OAUTH_CLIENT_CREDENTIALS"
            break
        }

        # Amazon.EventBridge.ConnectionOAuthHttpMethod
        {
            ($_ -eq "New-EVBConnection/AuthParameters_OAuthParameters_HttpMethod") -Or
            ($_ -eq "Update-EVBConnection/AuthParameters_OAuthParameters_HttpMethod")
        }
        {
            $v = "GET","POST","PUT"
            break
        }

        # Amazon.EventBridge.ConnectionState
        "Get-EVBConnectionList/ConnectionState"
        {
            $v = "AUTHORIZED","AUTHORIZING","CREATING","DEAUTHORIZED","DEAUTHORIZING","DELETING","UPDATING"
            break
        }

        # Amazon.EventBridge.ReplayState
        "Get-EVBReplayList/State"
        {
            $v = "CANCELLED","CANCELLING","COMPLETED","FAILED","RUNNING","STARTING"
            break
        }

        # Amazon.EventBridge.ReplicationState
        {
            ($_ -eq "New-EVBEndpoint/ReplicationConfig_State") -Or
            ($_ -eq "Update-EVBEndpoint/ReplicationConfig_State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.EventBridge.RuleState
        "Write-EVBRule/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EVB_map = @{
    "AuthorizationType"=@("New-EVBConnection","Update-EVBConnection")
    "AuthParameters_OAuthParameters_HttpMethod"=@("New-EVBConnection","Update-EVBConnection")
    "ConnectionState"=@("Get-EVBConnectionList")
    "HttpMethod"=@("New-EVBApiDestination","Update-EVBApiDestination")
    "ReplicationConfig_State"=@("New-EVBEndpoint","Update-EVBEndpoint")
    "State"=@("Get-EVBArchiveList","Get-EVBReplayList","Write-EVBRule")
}

_awsArgumentCompleterRegistration $EVB_Completers $EVB_map

$EVB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EVB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EVB_SelectMap = @{
    "Select"=@("Enable-EVBEventSource",
               "Stop-EVBReplay",
               "New-EVBApiDestination",
               "New-EVBArchive",
               "New-EVBConnection",
               "New-EVBEndpoint",
               "New-EVBEventBus",
               "New-EVBPartnerEventSource",
               "Disable-EVBEventSource",
               "Clear-EVBConnection",
               "Remove-EVBApiDestination",
               "Remove-EVBArchive",
               "Remove-EVBConnection",
               "Remove-EVBEndpoint",
               "Remove-EVBEventBus",
               "Remove-EVBPartnerEventSource",
               "Remove-EVBRule",
               "Get-EVBApiDestination",
               "Get-EVBArchive",
               "Get-EVBConnection",
               "Get-EVBEndpoint",
               "Get-EVBEventBus",
               "Get-EVBEventSource",
               "Get-EVBPartnerEventSource",
               "Get-EVBReplay",
               "Get-EVBRuleDetail",
               "Disable-EVBRule",
               "Enable-EVBRule",
               "Get-EVBApiDestinationList",
               "Get-EVBArchiveList",
               "Get-EVBConnectionList",
               "Get-EVBEndpointList",
               "Get-EVBEventBusList",
               "Get-EVBEventSourceList",
               "Get-EVBPartnerEventSourceAccountList",
               "Get-EVBPartnerEventSourceList",
               "Get-EVBReplayList",
               "Get-EVBRuleNamesByTarget",
               "Get-EVBRule",
               "Get-EVBResourceTag",
               "Get-EVBTargetsByRule",
               "Write-EVBEvent",
               "Write-EVBPartnerEvent",
               "Write-EVBPermission",
               "Write-EVBRule",
               "Write-EVBTarget",
               "Remove-EVBPermission",
               "Remove-EVBTarget",
               "Start-EVBReplay",
               "Add-EVBResourceTag",
               "Test-EVBEventPattern",
               "Remove-EVBResourceTag",
               "Update-EVBApiDestination",
               "Update-EVBArchive",
               "Update-EVBConnection",
               "Update-EVBEndpoint")
}

_awsArgumentCompleterRegistration $EVB_SelectCompleters $EVB_SelectMap
# Argument completions for service Amazon CloudWatch Events


$CWE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchEvents.ApiDestinationHttpMethod
        {
            ($_ -eq "New-CWEApiDestination/HttpMethod") -Or
            ($_ -eq "Update-CWEApiDestination/HttpMethod")
        }
        {
            $v = "DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT"
            break
        }

        # Amazon.CloudWatchEvents.ArchiveState
        "Get-CWEArchiveList/State"
        {
            $v = "CREATE_FAILED","CREATING","DISABLED","ENABLED","UPDATE_FAILED","UPDATING"
            break
        }

        # Amazon.CloudWatchEvents.ConnectionAuthorizationType
        {
            ($_ -eq "New-CWEConnection/AuthorizationType") -Or
            ($_ -eq "Update-CWEConnection/AuthorizationType")
        }
        {
            $v = "API_KEY","BASIC","OAUTH_CLIENT_CREDENTIALS"
            break
        }

        # Amazon.CloudWatchEvents.ConnectionOAuthHttpMethod
        {
            ($_ -eq "New-CWEConnection/AuthParameters_OAuthParameters_HttpMethod") -Or
            ($_ -eq "Update-CWEConnection/AuthParameters_OAuthParameters_HttpMethod")
        }
        {
            $v = "GET","POST","PUT"
            break
        }

        # Amazon.CloudWatchEvents.ConnectionState
        "Get-CWEConnectionList/ConnectionState"
        {
            $v = "AUTHORIZED","AUTHORIZING","CREATING","DEAUTHORIZED","DEAUTHORIZING","DELETING","UPDATING"
            break
        }

        # Amazon.CloudWatchEvents.ReplayState
        "Get-CWEReplayList/State"
        {
            $v = "CANCELLED","CANCELLING","COMPLETED","FAILED","RUNNING","STARTING"
            break
        }

        # Amazon.CloudWatchEvents.RuleState
        "Write-CWERule/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWE_map = @{
    "AuthorizationType"=@("New-CWEConnection","Update-CWEConnection")
    "AuthParameters_OAuthParameters_HttpMethod"=@("New-CWEConnection","Update-CWEConnection")
    "ConnectionState"=@("Get-CWEConnectionList")
    "HttpMethod"=@("New-CWEApiDestination","Update-CWEApiDestination")
    "State"=@("Get-CWEArchiveList","Get-CWEReplayList","Write-CWERule")
}

_awsArgumentCompleterRegistration $CWE_Completers $CWE_map

$CWE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWE_SelectMap = @{
    "Select"=@("Enable-CWEEventSource",
               "Stop-CWEReplay",
               "New-CWEApiDestination",
               "New-CWEArchive",
               "New-CWEConnection",
               "New-CWEEventBus",
               "New-CWEPartnerEventSource",
               "Disable-CWEEventSource",
               "Clear-CWEConnection",
               "Remove-CWEApiDestination",
               "Remove-CWEArchive",
               "Remove-CWEConnection",
               "Remove-CWEEventBus",
               "Remove-CWEPartnerEventSource",
               "Remove-CWERule",
               "Get-CWEApiDestination",
               "Get-CWEArchive",
               "Get-CWEConnection",
               "Get-CWEEventBus",
               "Get-CWEEventSource",
               "Get-CWEPartnerEventSource",
               "Get-CWEReplay",
               "Get-CWERuleDetail",
               "Disable-CWERule",
               "Enable-CWERule",
               "Get-CWEApiDestinationList",
               "Get-CWEArchiveList",
               "Get-CWEConnectionList",
               "Get-CWEEventBusList",
               "Get-CWEEventSourceList",
               "Get-CWEPartnerEventSourceAccountList",
               "Get-CWEPartnerEventSourceList",
               "Get-CWEReplayList",
               "Get-CWERuleNamesByTarget",
               "Get-CWERule",
               "Get-CWEResourceTag",
               "Get-CWETargetsByRule",
               "Write-CWEEvent",
               "Write-CWEPartnerEvent",
               "Write-CWEPermission",
               "Write-CWERule",
               "Write-CWETarget",
               "Remove-CWEPermission",
               "Remove-CWETarget",
               "Start-CWEReplay",
               "Add-CWEResourceTag",
               "Test-CWEEventPattern",
               "Remove-CWEResourceTag",
               "Update-CWEApiDestination",
               "Update-CWEArchive",
               "Update-CWEConnection")
}

_awsArgumentCompleterRegistration $CWE_SelectCompleters $CWE_SelectMap
# Argument completions for service Amazon CloudWatch Evidently


$CWEVD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchEvidently.ExperimentBaseStat
        "Get-CWEVDExperimentResult/BaseStat"
        {
            $v = "Mean"
            break
        }

        # Amazon.CloudWatchEvidently.ExperimentStatus
        "Get-CWEVDExperimentList/Status"
        {
            $v = "CANCELLED","COMPLETED","CREATED","RUNNING","UPDATING"
            break
        }

        # Amazon.CloudWatchEvidently.ExperimentStopDesiredState
        "Stop-CWEVDExperiment/DesiredState"
        {
            $v = "CANCELLED","COMPLETED"
            break
        }

        # Amazon.CloudWatchEvidently.FeatureEvaluationStrategy
        {
            ($_ -eq "New-CWEVDFeature/EvaluationStrategy") -Or
            ($_ -eq "Update-CWEVDFeature/EvaluationStrategy")
        }
        {
            $v = "ALL_RULES","DEFAULT_VARIATION"
            break
        }

        # Amazon.CloudWatchEvidently.LaunchStatus
        "Get-CWEVDLaunchList/Status"
        {
            $v = "CANCELLED","COMPLETED","CREATED","RUNNING","UPDATING"
            break
        }

        # Amazon.CloudWatchEvidently.LaunchStopDesiredState
        "Stop-CWEVDLaunch/DesiredState"
        {
            $v = "CANCELLED","COMPLETED"
            break
        }

        # Amazon.CloudWatchEvidently.SegmentReferenceResourceType
        "Get-CWEVDSegmentReferenceList/Type"
        {
            $v = "EXPERIMENT","LAUNCH"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWEVD_map = @{
    "BaseStat"=@("Get-CWEVDExperimentResult")
    "DesiredState"=@("Stop-CWEVDExperiment","Stop-CWEVDLaunch")
    "EvaluationStrategy"=@("New-CWEVDFeature","Update-CWEVDFeature")
    "Status"=@("Get-CWEVDExperimentList","Get-CWEVDLaunchList")
    "Type"=@("Get-CWEVDSegmentReferenceList")
}

_awsArgumentCompleterRegistration $CWEVD_Completers $CWEVD_map

$CWEVD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWEVD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWEVD_SelectMap = @{
    "Select"=@("Get-CWEVDFeatureEvaluationBatch",
               "New-CWEVDExperiment",
               "New-CWEVDFeature",
               "New-CWEVDLaunch",
               "New-CWEVDProject",
               "New-CWEVDSegment",
               "Remove-CWEVDExperiment",
               "Remove-CWEVDFeature",
               "Remove-CWEVDLaunch",
               "Remove-CWEVDProject",
               "Remove-CWEVDSegment",
               "Get-CWEVDFeatureEvaluation",
               "Get-CWEVDExperiment",
               "Get-CWEVDExperimentResult",
               "Get-CWEVDFeature",
               "Get-CWEVDLaunch",
               "Get-CWEVDProject",
               "Get-CWEVDSegment",
               "Get-CWEVDExperimentList",
               "Get-CWEVDFeatureList",
               "Get-CWEVDLaunchList",
               "Get-CWEVDProjectList",
               "Get-CWEVDSegmentReferenceList",
               "Get-CWEVDSegmentList",
               "Get-CWEVDResourceTag",
               "Write-CWEVDProjectEvent",
               "Start-CWEVDExperiment",
               "Start-CWEVDLaunch",
               "Stop-CWEVDExperiment",
               "Stop-CWEVDLaunch",
               "Add-CWEVDResourceTag",
               "Test-CWEVDSegmentPattern",
               "Remove-CWEVDResourceTag",
               "Update-CWEVDExperiment",
               "Update-CWEVDFeature",
               "Update-CWEVDLaunch",
               "Update-CWEVDProject",
               "Update-CWEVDProjectDataDelivery")
}

_awsArgumentCompleterRegistration $CWEVD_SelectCompleters $CWEVD_SelectMap
# Argument completions for service FinSpace User Environment Management Service


$FINSP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Finspace.FederationMode
        {
            ($_ -eq "New-FINSPEnvironment/FederationMode") -Or
            ($_ -eq "Update-FINSPEnvironment/FederationMode")
        }
        {
            $v = "FEDERATED","LOCAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FINSP_map = @{
    "FederationMode"=@("New-FINSPEnvironment","Update-FINSPEnvironment")
}

_awsArgumentCompleterRegistration $FINSP_Completers $FINSP_map

$FINSP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FINSP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FINSP_SelectMap = @{
    "Select"=@("New-FINSPEnvironment",
               "Remove-FINSPEnvironment",
               "Get-FINSPEnvironment",
               "Get-FINSPEnvironmentList",
               "Get-FINSPResourceTag",
               "Add-FINSPResourceTag",
               "Remove-FINSPResourceTag",
               "Update-FINSPEnvironment")
}

_awsArgumentCompleterRegistration $FINSP_SelectCompleters $FINSP_SelectMap
# Argument completions for service FinSpace Public API


$FNSP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FinSpaceData.ApiAccess
        {
            ($_ -eq "New-FNSPUser/ApiAccess") -Or
            ($_ -eq "Update-FNSPUser/ApiAccess")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.FinSpaceData.ChangeType
        "New-FNSPChangeset/ChangeType"
        {
            $v = "APPEND","MODIFY","REPLACE"
            break
        }

        # Amazon.FinSpaceData.DatasetKind
        {
            ($_ -eq "New-FNSPDataset/Kind") -Or
            ($_ -eq "Update-FNSPDataset/Kind")
        }
        {
            $v = "NON_TABULAR","TABULAR"
            break
        }

        # Amazon.FinSpaceData.ExportFileFormat
        "New-FNSPDataView/DestinationTypeParams_S3DestinationExportFileFormat"
        {
            $v = "DELIMITED_TEXT","PARQUET"
            break
        }

        # Amazon.FinSpaceData.LocationType
        "Get-FNSPWorkingLocation/LocationType"
        {
            $v = "INGESTION","SAGEMAKER"
            break
        }

        # Amazon.FinSpaceData.UserType
        {
            ($_ -eq "New-FNSPUser/Type") -Or
            ($_ -eq "Update-FNSPUser/Type")
        }
        {
            $v = "APP_USER","SUPER_USER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FNSP_map = @{
    "ApiAccess"=@("New-FNSPUser","Update-FNSPUser")
    "ChangeType"=@("New-FNSPChangeset")
    "DestinationTypeParams_S3DestinationExportFileFormat"=@("New-FNSPDataView")
    "Kind"=@("New-FNSPDataset","Update-FNSPDataset")
    "LocationType"=@("Get-FNSPWorkingLocation")
    "Type"=@("New-FNSPUser","Update-FNSPUser")
}

_awsArgumentCompleterRegistration $FNSP_Completers $FNSP_map

$FNSP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FNSP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FNSP_SelectMap = @{
    "Select"=@("Add-FNSPUserToPermissionGroup",
               "New-FNSPChangeset",
               "New-FNSPDataset",
               "New-FNSPDataView",
               "New-FNSPPermissionGroup",
               "New-FNSPUser",
               "Remove-FNSPDataset",
               "Remove-FNSPPermissionGroup",
               "Disable-FNSPUser",
               "Remove-FNSPUserFromPermissionGroup",
               "Enable-FNSPUser",
               "Get-FNSPChangeset",
               "Get-FNSPDataset",
               "Get-FNSPDataView",
               "Get-FNSPExternalDataViewAccessDetail",
               "Get-FNSPPermissionGroup",
               "Get-FNSPProgrammaticAccessCredential",
               "Get-FNSPUser",
               "Get-FNSPWorkingLocation",
               "Get-FNSPChangesetList",
               "Get-FNSPDatasetList",
               "Get-FNSPDataViewList",
               "Get-FNSPPermissionGroupList",
               "Get-FNSPPermissionGroupsByUserList",
               "Get-FNSPUserList",
               "Get-FNSPUsersByPermissionGroupList",
               "Reset-FNSPUserPassword",
               "Update-FNSPChangeset",
               "Update-FNSPDataset",
               "Update-FNSPPermissionGroup",
               "Update-FNSPUser")
}

_awsArgumentCompleterRegistration $FNSP_SelectCompleters $FNSP_SelectMap
# Argument completions for service Amazon Kinesis Firehose


$KINF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisFirehose.AmazonopensearchserviceIndexRotationPeriod
        {
            ($_ -eq "New-KINFDeliveryStream/AmazonopensearchserviceDestinationConfiguration_IndexRotationPeriod") -Or
            ($_ -eq "Update-KINFDestination/AmazonopensearchserviceDestinationUpdate_IndexRotationPeriod")
        }
        {
            $v = "NoRotation","OneDay","OneHour","OneMonth","OneWeek"
            break
        }

        # Amazon.KinesisFirehose.AmazonopensearchserviceS3BackupMode
        "New-KINFDeliveryStream/AmazonopensearchserviceDestinationConfiguration_S3BackupMode"
        {
            $v = "AllDocuments","FailedDocumentsOnly"
            break
        }

        # Amazon.KinesisFirehose.ContentEncoding
        {
            ($_ -eq "New-KINFDeliveryStream/HttpEndpointDestinationConfiguration_RequestConfiguration_ContentEncoding") -Or
            ($_ -eq "Update-KINFDestination/HttpEndpointDestinationUpdate_RequestConfiguration_ContentEncoding")
        }
        {
            $v = "GZIP","NONE"
            break
        }

        # Amazon.KinesisFirehose.DeliveryStreamType
        {
            ($_ -eq "Get-KINFDeliveryStreamList/DeliveryStreamType") -Or
            ($_ -eq "New-KINFDeliveryStream/DeliveryStreamType")
        }
        {
            $v = "DirectPut","KinesisStreamAsSource"
            break
        }

        # Amazon.KinesisFirehose.ElasticsearchIndexRotationPeriod
        {
            ($_ -eq "New-KINFDeliveryStream/ElasticsearchDestinationConfiguration_IndexRotationPeriod") -Or
            ($_ -eq "Update-KINFDestination/ElasticsearchDestinationUpdate_IndexRotationPeriod")
        }
        {
            $v = "NoRotation","OneDay","OneHour","OneMonth","OneWeek"
            break
        }

        # Amazon.KinesisFirehose.ElasticsearchS3BackupMode
        "New-KINFDeliveryStream/ElasticsearchDestinationConfiguration_S3BackupMode"
        {
            $v = "AllDocuments","FailedDocumentsOnly"
            break
        }

        # Amazon.KinesisFirehose.HttpEndpointS3BackupMode
        {
            ($_ -eq "New-KINFDeliveryStream/HttpEndpointDestinationConfiguration_S3BackupMode") -Or
            ($_ -eq "Update-KINFDestination/HttpEndpointDestinationUpdate_S3BackupMode")
        }
        {
            $v = "AllData","FailedDataOnly"
            break
        }

        # Amazon.KinesisFirehose.KeyType
        {
            ($_ -eq "New-KINFDeliveryStream/DeliveryStreamEncryptionConfigurationInput_KeyType") -Or
            ($_ -eq "Start-KINFDeliveryStreamEncryption/DeliveryStreamEncryptionConfigurationInput_KeyType")
        }
        {
            $v = "AWS_OWNED_CMK","CUSTOMER_MANAGED_CMK"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINF_map = @{
    "AmazonopensearchserviceDestinationConfiguration_IndexRotationPeriod"=@("New-KINFDeliveryStream")
    "AmazonopensearchserviceDestinationConfiguration_S3BackupMode"=@("New-KINFDeliveryStream")
    "AmazonopensearchserviceDestinationUpdate_IndexRotationPeriod"=@("Update-KINFDestination")
    "DeliveryStreamEncryptionConfigurationInput_KeyType"=@("New-KINFDeliveryStream","Start-KINFDeliveryStreamEncryption")
    "DeliveryStreamType"=@("Get-KINFDeliveryStreamList","New-KINFDeliveryStream")
    "ElasticsearchDestinationConfiguration_IndexRotationPeriod"=@("New-KINFDeliveryStream")
    "ElasticsearchDestinationConfiguration_S3BackupMode"=@("New-KINFDeliveryStream")
    "ElasticsearchDestinationUpdate_IndexRotationPeriod"=@("Update-KINFDestination")
    "HttpEndpointDestinationConfiguration_RequestConfiguration_ContentEncoding"=@("New-KINFDeliveryStream")
    "HttpEndpointDestinationConfiguration_S3BackupMode"=@("New-KINFDeliveryStream")
    "HttpEndpointDestinationUpdate_RequestConfiguration_ContentEncoding"=@("Update-KINFDestination")
    "HttpEndpointDestinationUpdate_S3BackupMode"=@("Update-KINFDestination")
}

_awsArgumentCompleterRegistration $KINF_Completers $KINF_map

$KINF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINF_SelectMap = @{
    "Select"=@("New-KINFDeliveryStream",
               "Remove-KINFDeliveryStream",
               "Get-KINFDeliveryStream",
               "Get-KINFDeliveryStreamList",
               "Get-KINFTagsForDeliveryStream",
               "Write-KINFRecord",
               "Write-KINFRecordBatch",
               "Start-KINFDeliveryStreamEncryption",
               "Stop-KINFDeliveryStreamEncryption",
               "Add-KINFDeliveryStreamTag",
               "Remove-KINFDeliveryStreamTag",
               "Update-KINFDestination")
}

_awsArgumentCompleterRegistration $KINF_SelectCompleters $KINF_SelectMap
# Argument completions for service AWS Fault Injection Simulator


$FIS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FIS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FIS_SelectMap = @{
    "Select"=@("New-FISExperimentTemplate",
               "Remove-FISExperimentTemplate",
               "Get-FISAction",
               "Get-FISExperiment",
               "Get-FISExperimentTemplate",
               "Get-FISTargetResourceType",
               "Get-FISActionList",
               "Get-FISExperimentList",
               "Get-FISExperimentTemplateList",
               "Get-FISResourceTag",
               "Get-FISTargetResourceTypeList",
               "Start-FISExperiment",
               "Stop-FISExperiment",
               "Add-FISResourceTag",
               "Remove-FISResourceTag",
               "Update-FISExperimentTemplate")
}

_awsArgumentCompleterRegistration $FIS_SelectCompleters $FIS_SelectMap
# Argument completions for service Firewall Management Service


$FMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FMS.ThirdPartyFirewall
        {
            ($_ -eq "Get-FMSThirdPartyFirewallAssociationStatus/ThirdPartyFirewall") -Or
            ($_ -eq "Get-FMSThirdPartyFirewallFirewallPolicyList/ThirdPartyFirewall") -Or
            ($_ -eq "Register-FMSThirdPartyFirewall/ThirdPartyFirewall") -Or
            ($_ -eq "Unregister-FMSThirdPartyFirewall/ThirdPartyFirewall")
        }
        {
            $v = "PALO_ALTO_NETWORKS_CLOUD_NGFW"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FMS_map = @{
    "ThirdPartyFirewall"=@("Get-FMSThirdPartyFirewallAssociationStatus","Get-FMSThirdPartyFirewallFirewallPolicyList","Register-FMSThirdPartyFirewall","Unregister-FMSThirdPartyFirewall")
}

_awsArgumentCompleterRegistration $FMS_Completers $FMS_map

$FMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FMS_SelectMap = @{
    "Select"=@("Add-FMSAdminAccountAssociation",
               "Register-FMSThirdPartyFirewall",
               "Add-FMSAssociatedResource",
               "Remove-FMSAssociatedResource",
               "Remove-FMSAppList",
               "Remove-FMSNotificationChannel",
               "Remove-FMSPolicy",
               "Remove-FMSProtocolList",
               "Remove-FMSResourceSet",
               "Remove-FMSAdminAccountAssociation",
               "Unregister-FMSThirdPartyFirewall",
               "Get-FMSAdminAccount",
               "Get-FMSAppList",
               "Get-FMSComplianceDetail",
               "Get-FMSNotificationChannel",
               "Get-FMSPolicy",
               "Get-FMSProtectionStatus",
               "Get-FMSProtocolList",
               "Get-FMSResourceSet",
               "Get-FMSThirdPartyFirewallAssociationStatus",
               "Get-FMSViolationDetail",
               "Get-FMSAppsListList",
               "Get-FMSComplianceStatusList",
               "Read-FMSDiscoveredResourceList",
               "Get-FMSMemberAccountList",
               "Get-FMSPolicyList",
               "Get-FMSProtocolsListList",
               "Read-FMSResourceSetResourceList",
               "Get-FMSResourceSetList",
               "Get-FMSResourceTag",
               "Get-FMSThirdPartyFirewallFirewallPolicyList",
               "Write-FMSAppList",
               "Write-FMSNotificationChannel",
               "Set-FMSPolicy",
               "Write-FMSProtocolList",
               "Write-FMSResourceSet",
               "Add-FMSResourceTag",
               "Remove-FMSResourceTag")
}

_awsArgumentCompleterRegistration $FMS_SelectCompleters $FMS_SelectMap
# Argument completions for service Amazon Forecast Service


$FRC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ForecastService.AutoMLOverrideStrategy
        "New-FRCPredictor/AutoMLOverrideStrategy"
        {
            $v = "AccuracyOptimized","LatencyOptimized"
            break
        }

        # Amazon.ForecastService.DatasetType
        "New-FRCDataset/DatasetType"
        {
            $v = "ITEM_METADATA","RELATED_TIME_SERIES","TARGET_TIME_SERIES"
            break
        }

        # Amazon.ForecastService.DayOfWeek
        "New-FRCAutoPredictor/TimeAlignmentBoundary_DayOfWeek"
        {
            $v = "FRIDAY","MONDAY","SATURDAY","SUNDAY","THURSDAY","TUESDAY","WEDNESDAY"
            break
        }

        # Amazon.ForecastService.Domain
        {
            ($_ -eq "New-FRCDataset/Domain") -Or
            ($_ -eq "New-FRCDatasetGroup/Domain")
        }
        {
            $v = "CUSTOM","EC2_CAPACITY","INVENTORY_PLANNING","METRICS","RETAIL","WEB_TRAFFIC","WORK_FORCE"
            break
        }

        # Amazon.ForecastService.Month
        "New-FRCAutoPredictor/TimeAlignmentBoundary_Month"
        {
            $v = "APRIL","AUGUST","DECEMBER","FEBRUARY","JANUARY","JULY","JUNE","MARCH","MAY","NOVEMBER","OCTOBER","SEPTEMBER"
            break
        }

        # Amazon.ForecastService.OptimizationMetric
        {
            ($_ -eq "New-FRCAutoPredictor/OptimizationMetric") -Or
            ($_ -eq "New-FRCPredictor/OptimizationMetric")
        }
        {
            $v = "AverageWeightedQuantileLoss","MAPE","MASE","RMSE","WAPE"
            break
        }

        # Amazon.ForecastService.TimePointGranularity
        "New-FRCExplainability/ExplainabilityConfig_TimePointGranularity"
        {
            $v = "ALL","SPECIFIC"
            break
        }

        # Amazon.ForecastService.TimeSeriesGranularity
        "New-FRCExplainability/ExplainabilityConfig_TimeSeriesGranularity"
        {
            $v = "ALL","SPECIFIC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRC_map = @{
    "AutoMLOverrideStrategy"=@("New-FRCPredictor")
    "DatasetType"=@("New-FRCDataset")
    "Domain"=@("New-FRCDataset","New-FRCDatasetGroup")
    "ExplainabilityConfig_TimePointGranularity"=@("New-FRCExplainability")
    "ExplainabilityConfig_TimeSeriesGranularity"=@("New-FRCExplainability")
    "OptimizationMetric"=@("New-FRCAutoPredictor","New-FRCPredictor")
    "TimeAlignmentBoundary_DayOfWeek"=@("New-FRCAutoPredictor")
    "TimeAlignmentBoundary_Month"=@("New-FRCAutoPredictor")
}

_awsArgumentCompleterRegistration $FRC_Completers $FRC_map

$FRC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FRC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRC_SelectMap = @{
    "Select"=@("New-FRCAutoPredictor",
               "New-FRCDataset",
               "New-FRCDatasetGroup",
               "New-FRCDatasetImportJob",
               "New-FRCExplainability",
               "New-FRCExplainabilityExport",
               "New-FRCForecast",
               "New-FRCForecastExportJob",
               "New-FRCMonitor",
               "New-FRCPredictor",
               "New-FRCPredictorBacktestExportJob",
               "New-FRCWhatIfAnalysis",
               "New-FRCWhatIfForecast",
               "New-FRCWhatIfForecastExport",
               "Remove-FRCDataset",
               "Remove-FRCDatasetGroup",
               "Remove-FRCDatasetImportJob",
               "Remove-FRCExplainability",
               "Remove-FRCExplainabilityExport",
               "Remove-FRCForecast",
               "Remove-FRCForecastExportJob",
               "Remove-FRCMonitor",
               "Remove-FRCPredictor",
               "Remove-FRCPredictorBacktestExportJob",
               "Remove-FRCResourceTree",
               "Remove-FRCWhatIfAnalysis",
               "Remove-FRCWhatIfForecast",
               "Remove-FRCWhatIfForecastExport",
               "Get-FRCAutoPredictor",
               "Get-FRCDataset",
               "Get-FRCDatasetGroup",
               "Get-FRCDatasetImportJob",
               "Get-FRCExplainability",
               "Get-FRCExplainabilityExport",
               "Get-FRCForecast",
               "Get-FRCForecastExportJob",
               "Get-FRCMonitor",
               "Get-FRCPredictor",
               "Get-FRCPredictorBacktestExportJob",
               "Get-FRCWhatIfAnalysis",
               "Get-FRCWhatIfForecast",
               "Get-FRCWhatIfForecastExport",
               "Get-FRCAccuracyMetric",
               "Get-FRCDatasetGroupList",
               "Get-FRCDatasetImportJobList",
               "Get-FRCDatasetList",
               "Get-FRCExplainabilityList",
               "Get-FRCExplainabilityExportList",
               "Get-FRCForecastExportJobList",
               "Get-FRCForecastList",
               "Get-FRCMonitorEvaluationList",
               "Get-FRCMonitorList",
               "Get-FRCPredictorBacktestExportJobList",
               "Get-FRCPredictorList",
               "Get-FRCResourceTag",
               "Get-FRCWhatIfAnalysisList",
               "Get-FRCWhatIfForecastExportList",
               "Get-FRCWhatIfForecastList",
               "Resume-FRCResource",
               "Stop-FRCResource",
               "Add-FRCResourceTag",
               "Remove-FRCResourceTag",
               "Update-FRCDatasetGroup")
}

_awsArgumentCompleterRegistration $FRC_SelectCompleters $FRC_SelectMap
# Argument completions for service Amazon Forecast Query Service


$FRCQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FRCQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRCQ_SelectMap = @{
    "Select"=@("Select-FRCQForecast",
               "Select-FRCQWhatIfForecast")
}

_awsArgumentCompleterRegistration $FRCQ_SelectCompleters $FRCQ_SelectMap
# Argument completions for service Amazon Fraud Detector


$FD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FraudDetector.DataSource
        "New-FDVariable/DataSource"
        {
            $v = "EVENT","EXTERNAL_MODEL_SCORE","MODEL_SCORE"
            break
        }

        # Amazon.FraudDetector.DataType
        "New-FDVariable/DataType"
        {
            $v = "BOOLEAN","FLOAT","INTEGER","STRING"
            break
        }

        # Amazon.FraudDetector.DetectorVersionStatus
        "Update-FDDetectorVersionStatus/Status"
        {
            $v = "ACTIVE","DRAFT","INACTIVE"
            break
        }

        # Amazon.FraudDetector.EventIngestion
        "Write-FDEventType/EventIngestion"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.FraudDetector.Language
        {
            ($_ -eq "New-FDRule/Language") -Or
            ($_ -eq "Update-FDRuleVersion/Language")
        }
        {
            $v = "DETECTORPL"
            break
        }

        # Amazon.FraudDetector.ModelEndpointStatus
        "Write-FDExternalModel/ModelEndpointStatus"
        {
            $v = "ASSOCIATED","DISSOCIATED"
            break
        }

        # Amazon.FraudDetector.ModelInputDataFormat
        "Write-FDExternalModel/InputConfiguration_Format"
        {
            $v = "APPLICATION_JSON","TEXT_CSV"
            break
        }

        # Amazon.FraudDetector.ModelOutputDataFormat
        "Write-FDExternalModel/OutputConfiguration_Format"
        {
            $v = "APPLICATION_JSONLINES","TEXT_CSV"
            break
        }

        # Amazon.FraudDetector.ModelSource
        "Write-FDExternalModel/ModelSource"
        {
            $v = "SAGEMAKER"
            break
        }

        # Amazon.FraudDetector.ModelTypeEnum
        {
            ($_ -eq "Get-FDModel/ModelType") -Or
            ($_ -eq "Get-FDModelVersion/ModelType") -Or
            ($_ -eq "Get-FDModelVersionList/ModelType") -Or
            ($_ -eq "New-FDModel/ModelType") -Or
            ($_ -eq "New-FDModelVersion/ModelType") -Or
            ($_ -eq "Remove-FDModel/ModelType") -Or
            ($_ -eq "Remove-FDModelVersion/ModelType") -Or
            ($_ -eq "Update-FDModel/ModelType") -Or
            ($_ -eq "Update-FDModelVersion/ModelType") -Or
            ($_ -eq "Update-FDModelVersionStatus/ModelType")
        }
        {
            $v = "ACCOUNT_TAKEOVER_INSIGHTS","ONLINE_FRAUD_INSIGHTS","TRANSACTION_FRAUD_INSIGHTS"
            break
        }

        # Amazon.FraudDetector.ModelVersionStatus
        "Update-FDModelVersionStatus/Status"
        {
            $v = "ACTIVE","INACTIVE","TRAINING_CANCELLED"
            break
        }

        # Amazon.FraudDetector.RuleExecutionMode
        {
            ($_ -eq "New-FDDetectorVersion/RuleExecutionMode") -Or
            ($_ -eq "Update-FDDetectorVersion/RuleExecutionMode")
        }
        {
            $v = "ALL_MATCHED","FIRST_MATCHED"
            break
        }

        # Amazon.FraudDetector.TrainingDataSourceEnum
        "New-FDModelVersion/TrainingDataSource"
        {
            $v = "EXTERNAL_EVENTS","INGESTED_EVENTS"
            break
        }

        # Amazon.FraudDetector.UnlabeledEventsTreatment
        "New-FDModelVersion/TrainingDataSchema_LabelSchema_UnlabeledEventsTreatment"
        {
            $v = "FRAUD","IGNORE","LEGIT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FD_map = @{
    "DataSource"=@("New-FDVariable")
    "DataType"=@("New-FDVariable")
    "EventIngestion"=@("Write-FDEventType")
    "InputConfiguration_Format"=@("Write-FDExternalModel")
    "Language"=@("New-FDRule","Update-FDRuleVersion")
    "ModelEndpointStatus"=@("Write-FDExternalModel")
    "ModelSource"=@("Write-FDExternalModel")
    "ModelType"=@("Get-FDModel","Get-FDModelVersion","Get-FDModelVersionList","New-FDModel","New-FDModelVersion","Remove-FDModel","Remove-FDModelVersion","Update-FDModel","Update-FDModelVersion","Update-FDModelVersionStatus")
    "OutputConfiguration_Format"=@("Write-FDExternalModel")
    "RuleExecutionMode"=@("New-FDDetectorVersion","Update-FDDetectorVersion")
    "Status"=@("Update-FDDetectorVersionStatus","Update-FDModelVersionStatus")
    "TrainingDataSchema_LabelSchema_UnlabeledEventsTreatment"=@("New-FDModelVersion")
    "TrainingDataSource"=@("New-FDModelVersion")
}

_awsArgumentCompleterRegistration $FD_Completers $FD_map

$FD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FD_SelectMap = @{
    "Select"=@("New-FDVariableBatch",
               "Get-FDVariableBatch",
               "Stop-FDBatchImportJob",
               "Stop-FDBatchPredictionJob",
               "New-FDBatchImportJob",
               "New-FDBatchPredictionJob",
               "New-FDDetectorVersion",
               "New-FDModel",
               "New-FDModelVersion",
               "New-FDRule",
               "New-FDVariable",
               "Remove-FDBatchImportJob",
               "Remove-FDBatchPredictionJob",
               "Remove-FDDetector",
               "Remove-FDDetectorVersion",
               "Remove-FDEntityType",
               "Remove-FDEvent",
               "Remove-FDEventsByEventType",
               "Remove-FDEventType",
               "Remove-FDExternalModel",
               "Remove-FDLabel",
               "Remove-FDModel",
               "Remove-FDModelVersion",
               "Remove-FDOutcome",
               "Remove-FDRule",
               "Remove-FDVariable",
               "Get-FDDetectorVersionList",
               "Get-FDModelVersionList",
               "Get-FDBatchImportJob",
               "Get-FDBatchPredictionJob",
               "Get-FDDeleteEventsByEventTypeStatus",
               "Get-FDDetector",
               "Get-FDDetectorVersion",
               "Get-FDEntityType",
               "Get-FDEvent",
               "Get-FDEventPrediction",
               "Get-FDEventPredictionMetadata",
               "Get-FDEventType",
               "Get-FDExternalModel",
               "Get-FDKMSEncryptionKey",
               "Get-FDLabel",
               "Get-FDModel",
               "Get-FDModelVersion",
               "Get-FDOutcome",
               "Get-FDRule",
               "Get-FDVariable",
               "Get-FDEventPredictionList",
               "Get-FDResourceTag",
               "Write-FDDetector",
               "Write-FDEntityType",
               "Write-FDEventType",
               "Write-FDExternalModel",
               "Write-FDKMSEncryptionKey",
               "Write-FDLabel",
               "Write-FDOutcome",
               "Send-FDEvent",
               "Add-FDResourceTag",
               "Remove-FDResourceTag",
               "Update-FDDetectorVersion",
               "Update-FDDetectorVersionMetadata",
               "Update-FDDetectorVersionStatus",
               "Update-FDEventLabel",
               "Update-FDModel",
               "Update-FDModelVersion",
               "Update-FDModelVersionStatus",
               "Update-FDRuleMetadata",
               "Update-FDRuleVersion",
               "Update-FDVariable")
}

_awsArgumentCompleterRegistration $FD_SelectCompleters $FD_SelectMap
# Argument completions for service Amazon FSx


$FSX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FSx.DataRepositoryTaskType
        "New-FSXDataRepositoryTask/Type"
        {
            $v = "AUTO_RELEASE_DATA","EXPORT_TO_REPOSITORY","IMPORT_METADATA_FROM_REPOSITORY","RELEASE_DATA_FROM_FILESYSTEM"
            break
        }

        # Amazon.FSx.DiskIopsConfigurationMode
        {
            ($_ -eq "New-FSXFileSystem/OntapConfiguration_DiskIopsConfiguration_Mode") -Or
            ($_ -eq "Update-FSXFileSystem/OntapConfiguration_DiskIopsConfiguration_Mode") -Or
            ($_ -eq "New-FSXFileSystem/OpenZFSConfiguration_DiskIopsConfiguration_Mode") -Or
            ($_ -eq "New-FSXFileSystemFromBackup/OpenZFSConfiguration_DiskIopsConfiguration_Mode") -Or
            ($_ -eq "Update-FSXFileSystem/OpenZFSConfiguration_DiskIopsConfiguration_Mode")
        }
        {
            $v = "AUTOMATIC","USER_PROVISIONED"
            break
        }

        # Amazon.FSx.FileCacheLustreDeploymentType
        "New-FSXFileCache/LustreConfiguration_DeploymentType"
        {
            $v = "CACHE_1"
            break
        }

        # Amazon.FSx.FileCacheType
        "New-FSXFileCache/FileCacheType"
        {
            $v = "LUSTRE"
            break
        }

        # Amazon.FSx.FileSystemType
        "New-FSXFileSystem/FileSystemType"
        {
            $v = "LUSTRE","ONTAP","OPENZFS","WINDOWS"
            break
        }

        # Amazon.FSx.OntapDeploymentType
        "New-FSXFileSystem/OntapConfiguration_DeploymentType"
        {
            $v = "MULTI_AZ_1","SINGLE_AZ_1"
            break
        }

        # Amazon.FSx.OpenZFSCopyStrategy
        "New-FSXVolume/OpenZFSConfiguration_OriginSnapshot_CopyStrategy"
        {
            $v = "CLONE","FULL_COPY"
            break
        }

        # Amazon.FSx.OpenZFSDataCompressionType
        {
            ($_ -eq "New-FSXVolume/OpenZFSConfiguration_DataCompressionType") -Or
            ($_ -eq "Update-FSXVolume/OpenZFSConfiguration_DataCompressionType") -Or
            ($_ -eq "New-FSXFileSystem/OpenZFSConfiguration_RootVolumeConfiguration_DataCompressionType") -Or
            ($_ -eq "New-FSXFileSystemFromBackup/OpenZFSConfiguration_RootVolumeConfiguration_DataCompressionType")
        }
        {
            $v = "LZ4","NONE","ZSTD"
            break
        }

        # Amazon.FSx.OpenZFSDeploymentType
        {
            ($_ -eq "New-FSXFileSystem/OpenZFSConfiguration_DeploymentType") -Or
            ($_ -eq "New-FSXFileSystemFromBackup/OpenZFSConfiguration_DeploymentType")
        }
        {
            $v = "SINGLE_AZ_1"
            break
        }

        # Amazon.FSx.ReportFormat
        "New-FSXDataRepositoryTask/Report_Format"
        {
            $v = "REPORT_CSV_20191124"
            break
        }

        # Amazon.FSx.ReportScope
        "New-FSXDataRepositoryTask/Report_Scope"
        {
            $v = "FAILED_FILES_ONLY"
            break
        }

        # Amazon.FSx.SecurityStyle
        {
            ($_ -eq "New-FSXVolume/OntapConfiguration_SecurityStyle") -Or
            ($_ -eq "New-FSXVolumeFromBackup/OntapConfiguration_SecurityStyle") -Or
            ($_ -eq "Update-FSXVolume/OntapConfiguration_SecurityStyle")
        }
        {
            $v = "MIXED","NTFS","UNIX"
            break
        }

        # Amazon.FSx.StorageType
        {
            ($_ -eq "New-FSXFileSystem/StorageType") -Or
            ($_ -eq "New-FSXFileSystemFromBackup/StorageType")
        }
        {
            $v = "HDD","SSD"
            break
        }

        # Amazon.FSx.StorageVirtualMachineRootVolumeSecurityStyle
        "New-FSXStorageVirtualMachine/RootVolumeSecurityStyle"
        {
            $v = "MIXED","NTFS","UNIX"
            break
        }

        # Amazon.FSx.TieringPolicyName
        {
            ($_ -eq "New-FSXVolume/OntapConfiguration_TieringPolicy_Name") -Or
            ($_ -eq "New-FSXVolumeFromBackup/OntapConfiguration_TieringPolicy_Name") -Or
            ($_ -eq "Update-FSXVolume/OntapConfiguration_TieringPolicy_Name")
        }
        {
            $v = "ALL","AUTO","NONE","SNAPSHOT_ONLY"
            break
        }

        # Amazon.FSx.VolumeType
        "New-FSXVolume/VolumeType"
        {
            $v = "ONTAP","OPENZFS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FSX_map = @{
    "FileCacheType"=@("New-FSXFileCache")
    "FileSystemType"=@("New-FSXFileSystem")
    "LustreConfiguration_DeploymentType"=@("New-FSXFileCache")
    "OntapConfiguration_DeploymentType"=@("New-FSXFileSystem")
    "OntapConfiguration_DiskIopsConfiguration_Mode"=@("New-FSXFileSystem","Update-FSXFileSystem")
    "OntapConfiguration_SecurityStyle"=@("New-FSXVolume","New-FSXVolumeFromBackup","Update-FSXVolume")
    "OntapConfiguration_TieringPolicy_Name"=@("New-FSXVolume","New-FSXVolumeFromBackup","Update-FSXVolume")
    "OpenZFSConfiguration_DataCompressionType"=@("New-FSXVolume","Update-FSXVolume")
    "OpenZFSConfiguration_DeploymentType"=@("New-FSXFileSystem","New-FSXFileSystemFromBackup")
    "OpenZFSConfiguration_DiskIopsConfiguration_Mode"=@("New-FSXFileSystem","New-FSXFileSystemFromBackup","Update-FSXFileSystem")
    "OpenZFSConfiguration_OriginSnapshot_CopyStrategy"=@("New-FSXVolume")
    "OpenZFSConfiguration_RootVolumeConfiguration_DataCompressionType"=@("New-FSXFileSystem","New-FSXFileSystemFromBackup")
    "Report_Format"=@("New-FSXDataRepositoryTask")
    "Report_Scope"=@("New-FSXDataRepositoryTask")
    "RootVolumeSecurityStyle"=@("New-FSXStorageVirtualMachine")
    "StorageType"=@("New-FSXFileSystem","New-FSXFileSystemFromBackup")
    "Type"=@("New-FSXDataRepositoryTask")
    "VolumeType"=@("New-FSXVolume")
}

_awsArgumentCompleterRegistration $FSX_Completers $FSX_map

$FSX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FSX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FSX_SelectMap = @{
    "Select"=@("Register-FSXFileSystemAlias",
               "Stop-FSXDataRepositoryTask",
               "Copy-FSXBackup",
               "New-FSXBackup",
               "New-FSXDataRepositoryAssociation",
               "New-FSXDataRepositoryTask",
               "New-FSXFileCache",
               "New-FSXFileSystem",
               "New-FSXFileSystemFromBackup",
               "New-FSXSnapshot",
               "New-FSXStorageVirtualMachine",
               "New-FSXVolume",
               "New-FSXVolumeFromBackup",
               "Remove-FSXBackup",
               "Remove-FSXDataRepositoryAssociation",
               "Remove-FSXFileCache",
               "Remove-FSXFileSystem",
               "Remove-FSXSnapshot",
               "Remove-FSXStorageVirtualMachine",
               "Remove-FSXVolume",
               "Get-FSXBackup",
               "Get-FSXDataRepositoryAssociation",
               "Get-FSXDataRepositoryTask",
               "Get-FSXFileCach",
               "Get-FSXFileSystemAlias",
               "Get-FSXFileSystem",
               "Get-FSXSnapshot",
               "Get-FSXStorageVirtualMachine",
               "Get-FSXVolume",
               "Unregister-FSXFileSystemAlias",
               "Get-FSXResourceTagList",
               "Clear-FSXFileSystemNfsV3Lock",
               "Restore-FSXVolumeFromSnapshot",
               "Add-FSXResourceTag",
               "Remove-FSXResourceTag",
               "Update-FSXDataRepositoryAssociation",
               "Update-FSXFileCache",
               "Update-FSXFileSystem",
               "Update-FSXSnapshot",
               "Update-FSXStorageVirtualMachine",
               "Update-FSXVolume")
}

_awsArgumentCompleterRegistration $FSX_SelectCompleters $FSX_SelectMap
# Argument completions for service Amazon GameLift Service


$GML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GameLift.AcceptanceType
        "Confirm-GMLMatch/AcceptanceType"
        {
            $v = "ACCEPT","REJECT"
            break
        }

        # Amazon.GameLift.BackfillMode
        {
            ($_ -eq "New-GMLMatchmakingConfiguration/BackfillMode") -Or
            ($_ -eq "Update-GMLMatchmakingConfiguration/BackfillMode")
        }
        {
            $v = "AUTOMATIC","MANUAL"
            break
        }

        # Amazon.GameLift.BalancingStrategy
        {
            ($_ -eq "New-GMLGameServerGroup/BalancingStrategy") -Or
            ($_ -eq "Update-GMLGameServerGroup/BalancingStrategy")
        }
        {
            $v = "ON_DEMAND_ONLY","SPOT_ONLY","SPOT_PREFERRED"
            break
        }

        # Amazon.GameLift.BuildStatus
        "Get-GMLBuild/Status"
        {
            $v = "FAILED","INITIALIZED","READY"
            break
        }

        # Amazon.GameLift.CertificateType
        "New-GMLFleet/CertificateConfiguration_CertificateType"
        {
            $v = "DISABLED","GENERATED"
            break
        }

        # Amazon.GameLift.ComparisonOperatorType
        "Write-GMLScalingPolicy/ComparisonOperator"
        {
            $v = "GreaterThanOrEqualToThreshold","GreaterThanThreshold","LessThanOrEqualToThreshold","LessThanThreshold"
            break
        }

        # Amazon.GameLift.EC2InstanceType
        {
            ($_ -eq "Get-GMLEC2InstanceLimit/EC2InstanceType") -Or
            ($_ -eq "New-GMLFleet/EC2InstanceType")
        }
        {
            $v = "c3.2xlarge","c3.4xlarge","c3.8xlarge","c3.large","c3.xlarge","c4.2xlarge","c4.4xlarge","c4.8xlarge","c4.large","c4.xlarge","c5.12xlarge","c5.18xlarge","c5.24xlarge","c5.2xlarge","c5.4xlarge","c5.9xlarge","c5.large","c5.xlarge","c5a.12xlarge","c5a.16xlarge","c5a.24xlarge","c5a.2xlarge","c5a.4xlarge","c5a.8xlarge","c5a.large","c5a.xlarge","c5d.12xlarge","c5d.18xlarge","c5d.24xlarge","c5d.2xlarge","c5d.4xlarge","c5d.9xlarge","c5d.large","c5d.xlarge","c6a.12xlarge","c6a.16xlarge","c6a.24xlarge","c6a.2xlarge","c6a.4xlarge","c6a.8xlarge","c6a.large","c6a.xlarge","c6i.12xlarge","c6i.16xlarge","c6i.24xlarge","c6i.2xlarge","c6i.4xlarge","c6i.8xlarge","c6i.large","c6i.xlarge","m3.2xlarge","m3.large","m3.medium","m3.xlarge","m4.10xlarge","m4.2xlarge","m4.4xlarge","m4.large","m4.xlarge","m5.12xlarge","m5.16xlarge","m5.24xlarge","m5.2xlarge","m5.4xlarge","m5.8xlarge","m5.large","m5.xlarge","m5a.12xlarge","m5a.16xlarge","m5a.24xlarge","m5a.2xlarge","m5a.4xlarge","m5a.8xlarge","m5a.large","m5a.xlarge","r3.2xlarge","r3.4xlarge","r3.8xlarge","r3.large","r3.xlarge","r4.16xlarge","r4.2xlarge","r4.4xlarge","r4.8xlarge","r4.large","r4.xlarge","r5.12xlarge","r5.16xlarge","r5.24xlarge","r5.2xlarge","r5.4xlarge","r5.8xlarge","r5.large","r5.xlarge","r5a.12xlarge","r5a.16xlarge","r5a.24xlarge","r5a.2xlarge","r5a.4xlarge","r5a.8xlarge","r5a.large","r5a.xlarge","r5d.12xlarge","r5d.16xlarge","r5d.24xlarge","r5d.2xlarge","r5d.4xlarge","r5d.8xlarge","r5d.large","r5d.xlarge","t2.large","t2.medium","t2.micro","t2.small"
            break
        }

        # Amazon.GameLift.FleetType
        "New-GMLFleet/FleetType"
        {
            $v = "ON_DEMAND","SPOT"
            break
        }

        # Amazon.GameLift.FlexMatchMode
        {
            ($_ -eq "New-GMLMatchmakingConfiguration/FlexMatchMode") -Or
            ($_ -eq "Update-GMLMatchmakingConfiguration/FlexMatchMode")
        }
        {
            $v = "STANDALONE","WITH_QUEUE"
            break
        }

        # Amazon.GameLift.GameServerGroupDeleteOption
        "Remove-GMLGameServerGroup/DeleteOption"
        {
            $v = "FORCE_DELETE","RETAIN","SAFE_DELETE"
            break
        }

        # Amazon.GameLift.GameServerHealthCheck
        "Update-GMLGameServer/HealthCheck"
        {
            $v = "HEALTHY"
            break
        }

        # Amazon.GameLift.GameServerProtectionPolicy
        {
            ($_ -eq "New-GMLGameServerGroup/GameServerProtectionPolicy") -Or
            ($_ -eq "Update-GMLGameServerGroup/GameServerProtectionPolicy")
        }
        {
            $v = "FULL_PROTECTION","NO_PROTECTION"
            break
        }

        # Amazon.GameLift.GameServerUtilizationStatus
        "Update-GMLGameServer/UtilizationStatus"
        {
            $v = "AVAILABLE","UTILIZED"
            break
        }

        # Amazon.GameLift.MetricName
        "Write-GMLScalingPolicy/MetricName"
        {
            $v = "ActivatingGameSessions","ActiveGameSessions","ActiveInstances","AvailableGameSessions","AvailablePlayerSessions","CurrentPlayerSessions","IdleInstances","PercentAvailableGameSessions","PercentIdleInstances","QueueDepth","WaitTime"
            break
        }

        # Amazon.GameLift.OperatingSystem
        "New-GMLBuild/OperatingSystem"
        {
            $v = "AMAZON_LINUX","AMAZON_LINUX_2","WINDOWS_2012"
            break
        }

        # Amazon.GameLift.PlayerSessionCreationPolicy
        "Update-GMLGameSession/PlayerSessionCreationPolicy"
        {
            $v = "ACCEPT_ALL","DENY_ALL"
            break
        }

        # Amazon.GameLift.PolicyType
        "Write-GMLScalingPolicy/PolicyType"
        {
            $v = "RuleBased","TargetBased"
            break
        }

        # Amazon.GameLift.ProtectionPolicy
        {
            ($_ -eq "New-GMLFleet/NewGameSessionProtectionPolicy") -Or
            ($_ -eq "Update-GMLFleetAttribute/NewGameSessionProtectionPolicy") -Or
            ($_ -eq "Update-GMLGameSession/ProtectionPolicy")
        }
        {
            $v = "FullProtection","NoProtection"
            break
        }

        # Amazon.GameLift.RoutingStrategyType
        {
            ($_ -eq "New-GMLAlias/RoutingStrategy_Type") -Or
            ($_ -eq "Update-GMLAlias/RoutingStrategy_Type") -Or
            ($_ -eq "Get-GMLAlias/RoutingStrategyType")
        }
        {
            $v = "SIMPLE","TERMINAL"
            break
        }

        # Amazon.GameLift.ScalingAdjustmentType
        "Write-GMLScalingPolicy/ScalingAdjustmentType"
        {
            $v = "ChangeInCapacity","ExactCapacity","PercentChangeInCapacity"
            break
        }

        # Amazon.GameLift.ScalingStatusType
        "Get-GMLScalingPolicy/StatusFilter"
        {
            $v = "ACTIVE","DELETED","DELETE_REQUESTED","DELETING","ERROR","UPDATE_REQUESTED","UPDATING"
            break
        }

        # Amazon.GameLift.SortOrder
        "Get-GMLGameServerList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GML_map = @{
    "AcceptanceType"=@("Confirm-GMLMatch")
    "BackfillMode"=@("New-GMLMatchmakingConfiguration","Update-GMLMatchmakingConfiguration")
    "BalancingStrategy"=@("New-GMLGameServerGroup","Update-GMLGameServerGroup")
    "CertificateConfiguration_CertificateType"=@("New-GMLFleet")
    "ComparisonOperator"=@("Write-GMLScalingPolicy")
    "DeleteOption"=@("Remove-GMLGameServerGroup")
    "EC2InstanceType"=@("Get-GMLEC2InstanceLimit","New-GMLFleet")
    "FleetType"=@("New-GMLFleet")
    "FlexMatchMode"=@("New-GMLMatchmakingConfiguration","Update-GMLMatchmakingConfiguration")
    "GameServerProtectionPolicy"=@("New-GMLGameServerGroup","Update-GMLGameServerGroup")
    "HealthCheck"=@("Update-GMLGameServer")
    "MetricName"=@("Write-GMLScalingPolicy")
    "NewGameSessionProtectionPolicy"=@("New-GMLFleet","Update-GMLFleetAttribute")
    "OperatingSystem"=@("New-GMLBuild")
    "PlayerSessionCreationPolicy"=@("Update-GMLGameSession")
    "PolicyType"=@("Write-GMLScalingPolicy")
    "ProtectionPolicy"=@("Update-GMLGameSession")
    "RoutingStrategy_Type"=@("New-GMLAlias","Update-GMLAlias")
    "RoutingStrategyType"=@("Get-GMLAlias")
    "ScalingAdjustmentType"=@("Write-GMLScalingPolicy")
    "SortOrder"=@("Get-GMLGameServerList")
    "Status"=@("Get-GMLBuild")
    "StatusFilter"=@("Get-GMLScalingPolicy")
    "UtilizationStatus"=@("Update-GMLGameServer")
}

_awsArgumentCompleterRegistration $GML_Completers $GML_map

$GML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GML_SelectMap = @{
    "Select"=@("Confirm-GMLMatch",
               "Request-GMLGameServer",
               "New-GMLAlias",
               "New-GMLBuild",
               "New-GMLFleet",
               "New-GMLFleetLocation",
               "New-GMLGameServerGroup",
               "New-GMLGameSession",
               "New-GMLGameSessionQueue",
               "New-GMLMatchmakingConfiguration",
               "New-GMLMatchmakingRuleSet",
               "New-GMLPlayerSession",
               "New-GMLScript",
               "New-GMLVpcPeeringAuthorization",
               "New-GMLVpcPeeringConnection",
               "Remove-GMLAlias",
               "Remove-GMLBuild",
               "Remove-GMLFleet",
               "Remove-GMLFleetLocation",
               "Remove-GMLGameServerGroup",
               "Remove-GMLGameSessionQueue",
               "Remove-GMLMatchmakingConfiguration",
               "Remove-GMLMatchmakingRuleSet",
               "Remove-GMLScalingPolicy",
               "Remove-GMLScript",
               "Remove-GMLVpcPeeringAuthorization",
               "Remove-GMLVpcPeeringConnection",
               "Unregister-GMLGameServer",
               "Get-GMLAliasDetail",
               "Get-GMLBuildDetail",
               "Get-GMLEC2InstanceLimit",
               "Get-GMLFleetAttribute",
               "Get-GMLFleetCapacity",
               "Get-GMLFleetEvent",
               "Get-GMLFleetLocationAttribute",
               "Get-GMLFleetLocationCapacity",
               "Get-GMLFleetLocationUtilization",
               "Get-GMLFleetPortSetting",
               "Get-GMLFleetUtilization",
               "Get-GMLGameServer",
               "Get-GMLGameServerGroup",
               "Get-GMLGameServerInstance",
               "Get-GMLGameSessionDetail",
               "Get-GMLGameSessionPlacement",
               "Get-GMLGameSessionQueue",
               "Get-GMLGameSession",
               "Get-GMLInstance",
               "Get-GMLMatchmaking",
               "Get-GMLMatchmakingConfiguration",
               "Get-GMLMatchmakingRuleSet",
               "Get-GMLPlayerSession",
               "Get-GMLRuntimeConfiguration",
               "Get-GMLScalingPolicy",
               "Get-GMLScript",
               "Get-GMLVpcPeeringAuthorization",
               "Get-GMLVpcPeeringConnection",
               "Get-GMLGameSessionLogUrl",
               "Get-GMLInstanceAccess",
               "Get-GMLAlias",
               "Get-GMLBuild",
               "Get-GMLFleet",
               "Get-GMLGameServerGroupList",
               "Get-GMLGameServerList",
               "Get-GMLScriptList",
               "Get-GMLResourceTag",
               "Write-GMLScalingPolicy",
               "Register-GMLGameServer",
               "Request-GMLUploadCredential",
               "Resolve-GMLAlias",
               "Resume-GMLGameServerGroup",
               "Find-GMLGameSession",
               "Start-GMLFleetAction",
               "Start-GMLGameSessionPlacement",
               "Start-GMLMatchBackfill",
               "Start-GMLMatchmaking",
               "Stop-GMLFleetAction",
               "Stop-GMLGameSessionPlacement",
               "Stop-GMLMatchmaking",
               "Suspend-GMLGameServerGroup",
               "Add-GMLResourceTag",
               "Remove-GMLResourceTag",
               "Update-GMLAlias",
               "Update-GMLBuild",
               "Update-GMLFleetAttribute",
               "Update-GMLFleetCapacity",
               "Update-GMLFleetPortSetting",
               "Update-GMLGameServer",
               "Update-GMLGameServerGroup",
               "Update-GMLGameSession",
               "Update-GMLGameSessionQueue",
               "Update-GMLMatchmakingConfiguration",
               "Update-GMLRuntimeConfiguration",
               "Update-GMLScript",
               "Test-GMLMatchmakingRuleSetValidity")
}

_awsArgumentCompleterRegistration $GML_SelectCompleters $GML_SelectMap
# Argument completions for service Amazon GameSparks


$GMESP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GMESP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GMESP_SelectMap = @{
    "Select"=@("New-GMESPGame",
               "New-GMESPSnapshot",
               "New-GMESPStage",
               "Remove-GMESPGame",
               "Remove-GMESPStage",
               "Disconnect-GMESPPlayer",
               "Export-GMESPSnapshot",
               "Get-GMESPExtension",
               "Get-GMESPExtensionVersion",
               "Get-GMESPGame",
               "Get-GMESPGameConfiguration",
               "Get-GMESPGeneratedCodeJob",
               "Get-GMESPPlayerConnectionStatus",
               "Get-GMESPSnapshot",
               "Get-GMESPStage",
               "Get-GMESPStageDeployment",
               "Import-GMESPGameConfiguration",
               "Get-GMESPExtensionList",
               "Get-GMESPExtensionVersionList",
               "Get-GMESPGameList",
               "Get-GMESPGeneratedCodeJobList",
               "Get-GMESPSnapshotList",
               "Get-GMESPStageDeploymentList",
               "Get-GMESPStageList",
               "Get-GMESPResourceTag",
               "Start-GMESPGeneratedCodeJob",
               "Start-GMESPStageDeployment",
               "Add-GMESPResourceTag",
               "Remove-GMESPResourceTag",
               "Update-GMESPGame",
               "Update-GMESPGameConfiguration",
               "Update-GMESPSnapshot",
               "Update-GMESPStage")
}

_awsArgumentCompleterRegistration $GMESP_SelectCompleters $GMESP_SelectMap
# Argument completions for service Amazon Glacier


$GLC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GLC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLC_SelectMap = @{
    "Select"=@("Remove-GLCMultipartUpload",
               "Stop-GLCVaultLock",
               "Add-GLCTagsToVault",
               "Complete-GLCVaultLock",
               "New-GLCVault",
               "Remove-GLCArchive",
               "Remove-GLCVault",
               "Remove-GLCVaultAccessPolicy",
               "Remove-GLCVaultNotification",
               "Get-GLCJob",
               "Get-GLCVault",
               "Get-GLCDataRetrievalPolicy",
               "Get-GLCVaultAccessPolicy",
               "Get-GLCVaultLock",
               "Get-GLCVaultNotification",
               "Start-GLCJob",
               "Start-GLCVaultLock",
               "Get-GLCJobList",
               "Get-GLCMultipartUploadList",
               "Get-GLCProvisionedCapacityList",
               "Get-GLCVaultTagList",
               "Get-GLCVaultList",
               "New-GLCProvisionedCapacityPurchase",
               "Remove-GLCTagsFromVault",
               "Set-GLCDataRetrievalPolicy",
               "Set-GLCVaultAccessPolicy",
               "Set-GLCVaultNotification",
               "Read-GLCJobOutput",
               "Write-GLCArchive")
}

_awsArgumentCompleterRegistration $GLC_SelectCompleters $GLC_SelectMap
# Argument completions for service AWS Global Accelerator


$GACL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GlobalAccelerator.ClientAffinity
        {
            ($_ -eq "New-GACLListener/ClientAffinity") -Or
            ($_ -eq "Update-GACLListener/ClientAffinity")
        }
        {
            $v = "NONE","SOURCE_IP"
            break
        }

        # Amazon.GlobalAccelerator.HealthCheckProtocol
        {
            ($_ -eq "New-GACLEndpointGroup/HealthCheckProtocol") -Or
            ($_ -eq "Update-GACLEndpointGroup/HealthCheckProtocol")
        }
        {
            $v = "HTTP","HTTPS","TCP"
            break
        }

        # Amazon.GlobalAccelerator.IpAddressType
        {
            ($_ -eq "New-GACLAccelerator/IpAddressType") -Or
            ($_ -eq "New-GACLCustomRoutingAccelerator/IpAddressType") -Or
            ($_ -eq "Update-GACLAccelerator/IpAddressType") -Or
            ($_ -eq "Update-GACLCustomRoutingAccelerator/IpAddressType")
        }
        {
            $v = "DUAL_STACK","IPV4"
            break
        }

        # Amazon.GlobalAccelerator.Protocol
        {
            ($_ -eq "New-GACLListener/Protocol") -Or
            ($_ -eq "Update-GACLListener/Protocol")
        }
        {
            $v = "TCP","UDP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GACL_map = @{
    "ClientAffinity"=@("New-GACLListener","Update-GACLListener")
    "HealthCheckProtocol"=@("New-GACLEndpointGroup","Update-GACLEndpointGroup")
    "IpAddressType"=@("New-GACLAccelerator","New-GACLCustomRoutingAccelerator","Update-GACLAccelerator","Update-GACLCustomRoutingAccelerator")
    "Protocol"=@("New-GACLListener","Update-GACLListener")
}

_awsArgumentCompleterRegistration $GACL_Completers $GACL_map

$GACL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GACL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GACL_SelectMap = @{
    "Select"=@("Add-GACLCustomRoutingEndpoint",
               "Add-GACLEndpoint",
               "Start-GACLAdvertisingByoipCidr",
               "Enable-GACLCustomRoutingTraffic",
               "New-GACLAccelerator",
               "New-GACLCustomRoutingAccelerator",
               "New-GACLCustomRoutingEndpointGroup",
               "New-GACLCustomRoutingListener",
               "New-GACLEndpointGroup",
               "New-GACLListener",
               "Remove-GACLAccelerator",
               "Remove-GACLCustomRoutingAccelerator",
               "Remove-GACLCustomRoutingEndpointGroup",
               "Remove-GACLCustomRoutingListener",
               "Remove-GACLEndpointGroup",
               "Remove-GACLListener",
               "Disable-GACLCustomRoutingTraffic",
               "Remove-GACLByoipCidrProvision",
               "Get-GACLAccelerator",
               "Get-GACLAcceleratorAttribute",
               "Get-GACLCustomRoutingAccelerator",
               "Get-GACLCustomRoutingAcceleratorAttribute",
               "Get-GACLCustomRoutingEndpointGroup",
               "Get-GACLCustomRoutingListener",
               "Get-GACLEndpointGroup",
               "Get-GACLListener",
               "Get-GACLAcceleratorList",
               "Get-GACLByoipCidrList",
               "Get-GACLCustomRoutingAcceleratorList",
               "Get-GACLCustomRoutingEndpointGroupList",
               "Get-GACLCustomRoutingListenerList",
               "Get-GACLCustomRoutingPortMappingList",
               "Get-GACLCustomRoutingPortMappingsByDestinationList",
               "Get-GACLEndpointGroupList",
               "Get-GACLListenerList",
               "Get-GACLResourceTag",
               "Add-GACLByoipCidrProvision",
               "Remove-GACLCustomRoutingEndpoint",
               "Remove-GACLEndpoint",
               "Add-GACLResourceTag",
               "Remove-GACLResourceTag",
               "Update-GACLAccelerator",
               "Update-GACLAcceleratorAttribute",
               "Update-GACLCustomRoutingAccelerator",
               "Update-GACLCustomRoutingAcceleratorAttribute",
               "Update-GACLCustomRoutingListener",
               "Update-GACLEndpointGroup",
               "Update-GACLListener",
               "Stop-GACLAdvertisingByoipCidr")
}

_awsArgumentCompleterRegistration $GACL_SelectCompleters $GACL_SelectMap
# Argument completions for service AWS Glue


$GLUE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Glue.CatalogEncryptionMode
        "Set-GLUEDataCatalogEncryptionSetting/DataCatalogEncryptionSettings_EncryptionAtRest_CatalogEncryptionMode"
        {
            $v = "DISABLED","SSE-KMS"
            break
        }

        # Amazon.Glue.CloudWatchEncryptionMode
        "New-GLUESecurityConfiguration/EncryptionConfiguration_CloudWatchEncryption_CloudWatchEncryptionMode"
        {
            $v = "DISABLED","SSE-KMS"
            break
        }

        # Amazon.Glue.Compatibility
        {
            ($_ -eq "New-GLUESchema/Compatibility") -Or
            ($_ -eq "Update-GLUESchema/Compatibility")
        }
        {
            $v = "BACKWARD","BACKWARD_ALL","DISABLED","FORWARD","FORWARD_ALL","FULL","FULL_ALL","NONE"
            break
        }

        # Amazon.Glue.CrawlerLineageSettings
        {
            ($_ -eq "New-GLUECrawler/LineageConfiguration_CrawlerLineageSettings") -Or
            ($_ -eq "Update-GLUECrawler/LineageConfiguration_CrawlerLineageSettings")
        }
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.Glue.CsvHeaderOption
        {
            ($_ -eq "New-GLUEClassifier/CsvClassifier_ContainsHeader") -Or
            ($_ -eq "Update-GLUEClassifier/CsvClassifier_ContainsHeader")
        }
        {
            $v = "ABSENT","PRESENT","UNKNOWN"
            break
        }

        # Amazon.Glue.DataFormat
        {
            ($_ -eq "Get-GLUESchemaVersionValidity/DataFormat") -Or
            ($_ -eq "New-GLUESchema/DataFormat")
        }
        {
            $v = "AVRO","JSON","PROTOBUF"
            break
        }

        # Amazon.Glue.EnableHybridValues
        "Set-GLUEResourcePolicy/EnableHybrid"
        {
            $v = "FALSE","TRUE"
            break
        }

        # Amazon.Glue.ExecutionClass
        {
            ($_ -eq "New-GLUEJob/ExecutionClass") -Or
            ($_ -eq "Start-GLUEJobRun/ExecutionClass")
        }
        {
            $v = "FLEX","STANDARD"
            break
        }

        # Amazon.Glue.ExistCondition
        "Set-GLUEResourcePolicy/PolicyExistsCondition"
        {
            $v = "MUST_EXIST","NONE","NOT_EXIST"
            break
        }

        # Amazon.Glue.JobBookmarksEncryptionMode
        "New-GLUESecurityConfiguration/EncryptionConfiguration_JobBookmarksEncryption_JobBookmarksEncryptionMode"
        {
            $v = "CSE-KMS","DISABLED"
            break
        }

        # Amazon.Glue.Language
        {
            ($_ -eq "Get-GLUEPlan/Language") -Or
            ($_ -eq "New-GLUEScript/Language")
        }
        {
            $v = "PYTHON","SCALA"
            break
        }

        # Amazon.Glue.MLUserDataEncryptionModeString
        "New-GLUEMLTransform/TransformEncryption_MlUserDataEncryption_MlUserDataEncryptionMode"
        {
            $v = "DISABLED","SSE-KMS"
            break
        }

        # Amazon.Glue.RecrawlBehavior
        {
            ($_ -eq "New-GLUECrawler/RecrawlPolicy_RecrawlBehavior") -Or
            ($_ -eq "Update-GLUECrawler/RecrawlPolicy_RecrawlBehavior")
        }
        {
            $v = "CRAWL_EVENT_MODE","CRAWL_EVERYTHING","CRAWL_NEW_FOLDERS_ONLY"
            break
        }

        # Amazon.Glue.ResourceShareType
        {
            ($_ -eq "Find-GLUETable/ResourceShareType") -Or
            ($_ -eq "Get-GLUEDatabaseList/ResourceShareType")
        }
        {
            $v = "ALL","FOREIGN"
            break
        }

        # Amazon.Glue.SchemaDiffType
        "Get-GLUESchemaVersionsDiff/SchemaDiffType"
        {
            $v = "SYNTAX_DIFF"
            break
        }

        # Amazon.Glue.SortDirectionType
        {
            ($_ -eq "Get-GLUEMLTaskRunList/Sort_SortDirection") -Or
            ($_ -eq "Get-GLUEMLTransformIdentifier/Sort_SortDirection") -Or
            ($_ -eq "Get-GLUEMLTransformList/Sort_SortDirection")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Glue.SourceControlAuthStrategy
        {
            ($_ -eq "Update-GLUEJobFromSourceControl/AuthStrategy") -Or
            ($_ -eq "Update-GLUESourceControlFromJob/AuthStrategy") -Or
            ($_ -eq "New-GLUEJob/SourceControlDetails_AuthStrategy")
        }
        {
            $v = "AWS_SECRETS_MANAGER","PERSONAL_ACCESS_TOKEN"
            break
        }

        # Amazon.Glue.SourceControlProvider
        {
            ($_ -eq "Update-GLUEJobFromSourceControl/Provider") -Or
            ($_ -eq "Update-GLUESourceControlFromJob/Provider") -Or
            ($_ -eq "New-GLUEJob/SourceControlDetails_Provider")
        }
        {
            $v = "AWS_CODE_COMMIT","GITHUB"
            break
        }

        # Amazon.Glue.TaskRunSortColumnType
        "Get-GLUEMLTaskRunList/Sort_Column"
        {
            $v = "STARTED","STATUS","TASK_RUN_TYPE"
            break
        }

        # Amazon.Glue.TaskStatusType
        "Get-GLUEMLTaskRunList/Filter_Status"
        {
            $v = "FAILED","RUNNING","STARTING","STOPPED","STOPPING","SUCCEEDED","TIMEOUT"
            break
        }

        # Amazon.Glue.TaskType
        "Get-GLUEMLTaskRunList/Filter_TaskRunType"
        {
            $v = "EVALUATION","EXPORT_LABELS","FIND_MATCHES","IMPORT_LABELS","LABELING_SET_GENERATION"
            break
        }

        # Amazon.Glue.TransformSortColumnType
        {
            ($_ -eq "Get-GLUEMLTransformIdentifier/Sort_Column") -Or
            ($_ -eq "Get-GLUEMLTransformList/Sort_Column")
        }
        {
            $v = "CREATED","LAST_MODIFIED","NAME","STATUS","TRANSFORM_TYPE"
            break
        }

        # Amazon.Glue.TransformStatusType
        {
            ($_ -eq "Get-GLUEMLTransformIdentifier/Filter_Status") -Or
            ($_ -eq "Get-GLUEMLTransformList/Filter_Status")
        }
        {
            $v = "DELETING","NOT_READY","READY"
            break
        }

        # Amazon.Glue.TransformType
        {
            ($_ -eq "Get-GLUEMLTransformIdentifier/Filter_TransformType") -Or
            ($_ -eq "Get-GLUEMLTransformList/Filter_TransformType") -Or
            ($_ -eq "New-GLUEMLTransform/Parameters_TransformType") -Or
            ($_ -eq "Update-GLUEMLTransform/Parameters_TransformType")
        }
        {
            $v = "FIND_MATCHES"
            break
        }

        # Amazon.Glue.TriggerType
        "New-GLUETrigger/Type"
        {
            $v = "CONDITIONAL","EVENT","ON_DEMAND","SCHEDULED"
            break
        }

        # Amazon.Glue.WorkerType
        {
            ($_ -eq "New-GLUEDevEndpoint/WorkerType") -Or
            ($_ -eq "New-GLUEJob/WorkerType") -Or
            ($_ -eq "New-GLUEMLTransform/WorkerType") -Or
            ($_ -eq "New-GLUESession/WorkerType") -Or
            ($_ -eq "Start-GLUEJobRun/WorkerType") -Or
            ($_ -eq "Update-GLUEMLTransform/WorkerType")
        }
        {
            $v = "G.025X","G.1X","G.2X","Standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLUE_map = @{
    "AuthStrategy"=@("Update-GLUEJobFromSourceControl","Update-GLUESourceControlFromJob")
    "Compatibility"=@("New-GLUESchema","Update-GLUESchema")
    "CsvClassifier_ContainsHeader"=@("New-GLUEClassifier","Update-GLUEClassifier")
    "DataCatalogEncryptionSettings_EncryptionAtRest_CatalogEncryptionMode"=@("Set-GLUEDataCatalogEncryptionSetting")
    "DataFormat"=@("Get-GLUESchemaVersionValidity","New-GLUESchema")
    "EnableHybrid"=@("Set-GLUEResourcePolicy")
    "EncryptionConfiguration_CloudWatchEncryption_CloudWatchEncryptionMode"=@("New-GLUESecurityConfiguration")
    "EncryptionConfiguration_JobBookmarksEncryption_JobBookmarksEncryptionMode"=@("New-GLUESecurityConfiguration")
    "ExecutionClass"=@("New-GLUEJob","Start-GLUEJobRun")
    "Filter_Status"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformIdentifier","Get-GLUEMLTransformList")
    "Filter_TaskRunType"=@("Get-GLUEMLTaskRunList")
    "Filter_TransformType"=@("Get-GLUEMLTransformIdentifier","Get-GLUEMLTransformList")
    "Language"=@("Get-GLUEPlan","New-GLUEScript")
    "LineageConfiguration_CrawlerLineageSettings"=@("New-GLUECrawler","Update-GLUECrawler")
    "Parameters_TransformType"=@("New-GLUEMLTransform","Update-GLUEMLTransform")
    "PolicyExistsCondition"=@("Set-GLUEResourcePolicy")
    "Provider"=@("Update-GLUEJobFromSourceControl","Update-GLUESourceControlFromJob")
    "RecrawlPolicy_RecrawlBehavior"=@("New-GLUECrawler","Update-GLUECrawler")
    "ResourceShareType"=@("Find-GLUETable","Get-GLUEDatabaseList")
    "SchemaDiffType"=@("Get-GLUESchemaVersionsDiff")
    "Sort_Column"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformIdentifier","Get-GLUEMLTransformList")
    "Sort_SortDirection"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformIdentifier","Get-GLUEMLTransformList")
    "SourceControlDetails_AuthStrategy"=@("New-GLUEJob")
    "SourceControlDetails_Provider"=@("New-GLUEJob")
    "TransformEncryption_MlUserDataEncryption_MlUserDataEncryptionMode"=@("New-GLUEMLTransform")
    "Type"=@("New-GLUETrigger")
    "WorkerType"=@("New-GLUEDevEndpoint","New-GLUEJob","New-GLUEMLTransform","New-GLUESession","Start-GLUEJobRun","Update-GLUEMLTransform")
}

_awsArgumentCompleterRegistration $GLUE_Completers $GLUE_map

$GLUE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GLUE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLUE_SelectMap = @{
    "Select"=@("New-GLUEPartitionBatch",
               "Remove-GLUEConnectionBatch",
               "Remove-GLUEPartitionBatch",
               "Remove-GLUETableBatch",
               "Remove-GLUETableVersionBatch",
               "Get-GLUEBlueprintBatch",
               "Get-GLUECrawlerBatch",
               "Get-GLUEGetCustomEntityType",
               "Get-GLUEDevEndpointBatch",
               "Get-GLUEJobBatch",
               "Get-GLUEPartitionBatch",
               "Get-GLUETriggerBatch",
               "Get-GLUEWorkflowBatch",
               "Stop-GLUEJobRunBatch",
               "Update-GLUEPartitionBatch",
               "Stop-GLUEMLTaskRun",
               "Stop-GLUEStatement",
               "Get-GLUESchemaVersionValidity",
               "New-GLUEBlueprint",
               "New-GLUEClassifier",
               "New-GLUEConnection",
               "New-GLUECrawler",
               "New-GLUECustomEntityType",
               "New-GLUEDatabase",
               "New-GLUEDevEndpoint",
               "New-GLUEJob",
               "New-GLUEMLTransform",
               "New-GLUEPartition",
               "New-GLUEPartitionIndex",
               "New-GLUERegistry",
               "New-GLUESchema",
               "New-GLUEScript",
               "New-GLUESecurityConfiguration",
               "New-GLUESession",
               "New-GLUETable",
               "New-GLUETrigger",
               "New-GLUEUserDefinedFunction",
               "New-GLUEWorkflow",
               "Remove-GLUEBlueprint",
               "Remove-GLUEClassifier",
               "Remove-GLUEColumnStatisticsForPartition",
               "Remove-GLUEColumnStatisticsForTable",
               "Remove-GLUEConnection",
               "Remove-GLUECrawler",
               "Remove-GLUECustomEntityType",
               "Remove-GLUEDatabase",
               "Remove-GLUEDevEndpoint",
               "Remove-GLUEJob",
               "Remove-GLUEMLTransform",
               "Remove-GLUEPartition",
               "Remove-GLUEPartitionIndex",
               "Remove-GLUERegistry",
               "Remove-GLUEResourcePolicy",
               "Remove-GLUESchema",
               "Remove-GLUESchemaVersion",
               "Remove-GLUESecurityConfiguration",
               "Remove-GLUESession",
               "Remove-GLUETable",
               "Remove-GLUETableVersion",
               "Remove-GLUETrigger",
               "Remove-GLUEUserDefinedFunction",
               "Remove-GLUEWorkflow",
               "Get-GLUEBlueprint",
               "Get-GLUEBlueprintRun",
               "Get-GLUEBlueprintRunList",
               "Get-GLUECatalogImportStatus",
               "Get-GLUEClassifier",
               "Get-GLUEClassifierList",
               "Get-GLUEColumnStatisticsForPartition",
               "Get-GLUEColumnStatisticsForTable",
               "Get-GLUEConnection",
               "Get-GLUEConnectionList",
               "Get-GLUECrawler",
               "Get-GLUECrawlerMetricList",
               "Get-GLUECrawlerList",
               "Get-GLUECustomEntityType",
               "Get-GLUEDatabase",
               "Get-GLUEDatabaseList",
               "Get-GLUEDataCatalogEncryptionSetting",
               "Get-GLUEDataflowGraph",
               "Get-GLUEDevEndpoint",
               "Get-GLUEDevEndpointList",
               "Get-GLUEJob",
               "Get-GLUEJobBookmark",
               "Get-GLUEJobRun",
               "Get-GLUEJobRunList",
               "Get-GLUEJobList",
               "Get-GLUEMapping",
               "Get-GLUEMLTaskRun",
               "Get-GLUEMLTaskRunList",
               "Get-GLUEMLTransform",
               "Get-GLUEMLTransformList",
               "Get-GLUEPartition",
               "Get-GLUEPartitionIndex",
               "Get-GLUEPartitionList",
               "Get-GLUEPlan",
               "Get-GLUERegistry",
               "Get-GLUEGluePolicyList",
               "Get-GLUEResourcePolicy",
               "Get-GLUESchema",
               "Get-GLUESchemaByDefinition",
               "Get-GLUESchemaVersion",
               "Get-GLUESchemaVersionsDiff",
               "Get-GLUESecurityConfiguration",
               "Get-GLUESecurityConfigurationList",
               "Get-GLUESession",
               "Get-GLUEStatement",
               "Get-GLUETable",
               "Get-GLUETableList",
               "Get-GLUETableVersion",
               "Get-GLUETableVersionList",
               "Get-GLUETag",
               "Get-GLUETrigger",
               "Get-GLUETriggerList",
               "Get-GLUEUnfilteredPartitionMetadata",
               "Get-GLUEUnfilteredPartitionsMetadata",
               "Get-GLUEUnfilteredTableMetadata",
               "Get-GLUEUserDefinedFunction",
               "Get-GLUEUserDefinedFunctionList",
               "Get-GLUEWorkflow",
               "Get-GLUEWorkflowRun",
               "Get-GLUEWorkflowRunProperty",
               "Get-GLUEWorkflowRunList",
               "Import-GLUECatalog",
               "Get-GLUEBlueprintList",
               "Get-GLUECrawlerNameList",
               "Get-GLUECrawlList",
               "Get-GLUECustomEntityTypeList",
               "Get-GLUEDevEndpointNameList",
               "Get-GLUEJobNameList",
               "Get-GLUEMLTransformIdentifier",
               "Get-GLUERegistryList",
               "Get-GLUESchemaList",
               "Get-GLUESchemaVersionList",
               "Get-GLUESessionList",
               "Get-GLUEStatementList",
               "Get-GLUETriggerNameList",
               "Get-GLUEWorkflowList",
               "Set-GLUEDataCatalogEncryptionSetting",
               "Set-GLUEResourcePolicy",
               "Write-GLUESchemaVersionMetadata",
               "Write-GLUEWorkflowRunProperty",
               "Find-GLUESchemaVersionMetadata",
               "Register-GLUESchemaVersion",
               "Remove-GLUESchemaVersionMetadata",
               "Reset-GLUEJobBookmark",
               "Resume-GLUEWorkflowRun",
               "Invoke-GLUEStatement",
               "Find-GLUETable",
               "Start-GLUEBlueprintRun",
               "Start-GLUECrawler",
               "Start-GLUECrawlerSchedule",
               "Start-GLUEExportLabelsTaskRun",
               "Start-GLUEImportLabelsTaskRun",
               "Start-GLUEJobRun",
               "Start-GLUEMLEvaluationTaskRun",
               "Start-GLUEMLLabelingSetGenerationTaskRun",
               "Start-GLUETrigger",
               "Start-GLUEWorkflowRun",
               "Stop-GLUECrawler",
               "Stop-GLUECrawlerSchedule",
               "Stop-GLUESession",
               "Stop-GLUETrigger",
               "Stop-GLUEWorkflowRun",
               "Add-GLUEResourceTag",
               "Remove-GLUEResourceTag",
               "Update-GLUEBlueprint",
               "Update-GLUEClassifier",
               "Update-GLUEColumnStatisticsForPartition",
               "Update-GLUEColumnStatisticsForTable",
               "Update-GLUEConnection",
               "Update-GLUECrawler",
               "Update-GLUECrawlerSchedule",
               "Update-GLUEDatabase",
               "Update-GLUEDevEndpoint",
               "Update-GLUEJob",
               "Update-GLUEJobFromSourceControl",
               "Update-GLUEMLTransform",
               "Update-GLUEPartition",
               "Update-GLUERegistry",
               "Update-GLUESchema",
               "Update-GLUESourceControlFromJob",
               "Update-GLUETable",
               "Update-GLUETrigger",
               "Update-GLUEUserDefinedFunction",
               "Update-GLUEWorkflow")
}

_awsArgumentCompleterRegistration $GLUE_SelectCompleters $GLUE_SelectMap
# Argument completions for service Amazon Managed Grafana


$MGRF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ManagedGrafana.AccountAccessType
        {
            ($_ -eq "New-MGRFWorkspace/AccountAccessType") -Or
            ($_ -eq "Update-MGRFWorkspace/AccountAccessType")
        }
        {
            $v = "CURRENT_ACCOUNT","ORGANIZATION"
            break
        }

        # Amazon.ManagedGrafana.LicenseType
        {
            ($_ -eq "Add-MGRFLicense/LicenseType") -Or
            ($_ -eq "Remove-MGRFLicense/LicenseType")
        }
        {
            $v = "ENTERPRISE","ENTERPRISE_FREE_TRIAL"
            break
        }

        # Amazon.ManagedGrafana.PermissionType
        {
            ($_ -eq "New-MGRFWorkspace/PermissionType") -Or
            ($_ -eq "Update-MGRFWorkspace/PermissionType")
        }
        {
            $v = "CUSTOMER_MANAGED","SERVICE_MANAGED"
            break
        }

        # Amazon.ManagedGrafana.UserType
        "Get-MGRFPermissionList/UserType"
        {
            $v = "SSO_GROUP","SSO_USER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MGRF_map = @{
    "AccountAccessType"=@("New-MGRFWorkspace","Update-MGRFWorkspace")
    "LicenseType"=@("Add-MGRFLicense","Remove-MGRFLicense")
    "PermissionType"=@("New-MGRFWorkspace","Update-MGRFWorkspace")
    "UserType"=@("Get-MGRFPermissionList")
}

_awsArgumentCompleterRegistration $MGRF_Completers $MGRF_map

$MGRF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MGRF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MGRF_SelectMap = @{
    "Select"=@("Add-MGRFLicense",
               "New-MGRFWorkspace",
               "New-MGRFWorkspaceApiKey",
               "Remove-MGRFWorkspace",
               "Remove-MGRFWorkspaceApiKey",
               "Get-MGRFWorkspace",
               "Get-MGRFWorkspaceAuthentication",
               "Remove-MGRFLicense",
               "Get-MGRFPermissionList",
               "Get-MGRFResourceTag",
               "Get-MGRFWorkspaceList",
               "Add-MGRFResourceTag",
               "Remove-MGRFResourceTag",
               "Update-MGRFPermission",
               "Update-MGRFWorkspace",
               "Update-MGRFWorkspaceAuthentication")
}

_awsArgumentCompleterRegistration $MGRF_SelectCompleters $MGRF_SelectMap
# Argument completions for service AWS Greengrass


$GG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Greengrass.DeploymentType
        "New-GGDeployment/DeploymentType"
        {
            $v = "ForceResetDeployment","NewDeployment","Redeployment","ResetDeployment"
            break
        }

        # Amazon.Greengrass.FunctionIsolationMode
        {
            ($_ -eq "New-GGFunctionDefinitionVersion/DefaultConfig_Execution_IsolationMode") -Or
            ($_ -eq "New-GGFunctionDefinition/InitialVersion_DefaultConfig_Execution_IsolationMode")
        }
        {
            $v = "GreengrassContainer","NoContainer"
            break
        }

        # Amazon.Greengrass.SoftwareToUpdate
        "New-GGSoftwareUpdateJob/SoftwareToUpdate"
        {
            $v = "core","ota_agent"
            break
        }

        # Amazon.Greengrass.Telemetry
        "Update-GGThingRuntimeConfiguration/TelemetryConfiguration_Telemetry"
        {
            $v = "Off","On"
            break
        }

        # Amazon.Greengrass.UpdateAgentLogLevel
        "New-GGSoftwareUpdateJob/UpdateAgentLogLevel"
        {
            $v = "DEBUG","ERROR","FATAL","INFO","NONE","TRACE","VERBOSE","WARN"
            break
        }

        # Amazon.Greengrass.UpdateTargetsArchitecture
        "New-GGSoftwareUpdateJob/UpdateTargetsArchitecture"
        {
            $v = "aarch64","armv6l","armv7l","x86_64"
            break
        }

        # Amazon.Greengrass.UpdateTargetsOperatingSystem
        "New-GGSoftwareUpdateJob/UpdateTargetsOperatingSystem"
        {
            $v = "amazon_linux","openwrt","raspbian","ubuntu"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GG_map = @{
    "DefaultConfig_Execution_IsolationMode"=@("New-GGFunctionDefinitionVersion")
    "DeploymentType"=@("New-GGDeployment")
    "InitialVersion_DefaultConfig_Execution_IsolationMode"=@("New-GGFunctionDefinition")
    "SoftwareToUpdate"=@("New-GGSoftwareUpdateJob")
    "TelemetryConfiguration_Telemetry"=@("Update-GGThingRuntimeConfiguration")
    "UpdateAgentLogLevel"=@("New-GGSoftwareUpdateJob")
    "UpdateTargetsArchitecture"=@("New-GGSoftwareUpdateJob")
    "UpdateTargetsOperatingSystem"=@("New-GGSoftwareUpdateJob")
}

_awsArgumentCompleterRegistration $GG_Completers $GG_map

$GG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GG_SelectMap = @{
    "Select"=@("Add-GGRoleToGroup",
               "Add-GGServiceRoleToAccount",
               "New-GGConnectorDefinition",
               "New-GGConnectorDefinitionVersion",
               "New-GGCoreDefinition",
               "New-GGCoreDefinitionVersion",
               "New-GGDeployment",
               "New-GGDeviceDefinition",
               "New-GGDeviceDefinitionVersion",
               "New-GGFunctionDefinition",
               "New-GGFunctionDefinitionVersion",
               "New-GGGroup",
               "New-GGGroupCertificateAuthority",
               "New-GGGroupVersion",
               "New-GGLoggerDefinition",
               "New-GGLoggerDefinitionVersion",
               "New-GGResourceDefinition",
               "New-GGResourceDefinitionVersion",
               "New-GGSoftwareUpdateJob",
               "New-GGSubscriptionDefinition",
               "New-GGSubscriptionDefinitionVersion",
               "Remove-GGConnectorDefinition",
               "Remove-GGCoreDefinition",
               "Remove-GGDeviceDefinition",
               "Remove-GGFunctionDefinition",
               "Remove-GGGroup",
               "Remove-GGLoggerDefinition",
               "Remove-GGResourceDefinition",
               "Remove-GGSubscriptionDefinition",
               "Remove-GGRoleFromGroup",
               "Remove-GGServiceRoleFromAccount",
               "Get-GGAssociatedRole",
               "Get-GGBulkDeploymentStatus",
               "Get-GGConnectivityInfo",
               "Get-GGConnectorDefinition",
               "Get-GGConnectorDefinitionVersion",
               "Get-GGCoreDefinition",
               "Get-GGCoreDefinitionVersion",
               "Get-GGDeploymentStatus",
               "Get-GGDeviceDefinition",
               "Get-GGDeviceDefinitionVersion",
               "Get-GGFunctionDefinition",
               "Get-GGFunctionDefinitionVersion",
               "Get-GGGroup",
               "Get-GGGroupCertificateAuthority",
               "Get-GGGroupCertificateConfiguration",
               "Get-GGGroupVersion",
               "Get-GGLoggerDefinition",
               "Get-GGLoggerDefinitionVersion",
               "Get-GGResourceDefinition",
               "Get-GGResourceDefinitionVersion",
               "Get-GGServiceRoleForAccount",
               "Get-GGSubscriptionDefinition",
               "Get-GGSubscriptionDefinitionVersion",
               "Get-GGThingRuntimeConfiguration",
               "Get-GGBulkDeploymentDetailedReportList",
               "Get-GGBulkDeploymentList",
               "Get-GGConnectorDefinitionList",
               "Get-GGConnectorDefinitionVersionList",
               "Get-GGCoreDefinitionList",
               "Get-GGCoreDefinitionVersionList",
               "Get-GGDeploymentList",
               "Get-GGDeviceDefinitionList",
               "Get-GGDeviceDefinitionVersionList",
               "Get-GGFunctionDefinitionList",
               "Get-GGFunctionDefinitionVersionList",
               "Get-GGGroupCertificateAuthorityList",
               "Get-GGGroupList",
               "Get-GGGroupVersionList",
               "Get-GGLoggerDefinitionList",
               "Get-GGLoggerDefinitionVersionList",
               "Get-GGResourceDefinitionList",
               "Get-GGResourceDefinitionVersionList",
               "Get-GGSubscriptionDefinitionList",
               "Get-GGSubscriptionDefinitionVersionList",
               "Get-GGResourceTag",
               "Reset-GGDeployment",
               "Start-GGBulkDeployment",
               "Stop-GGBulkDeployment",
               "Add-GGResourceTag",
               "Remove-GGResourceTag",
               "Update-GGConnectivityInfo",
               "Update-GGConnectorDefinition",
               "Update-GGCoreDefinition",
               "Update-GGDeviceDefinition",
               "Update-GGFunctionDefinition",
               "Update-GGGroup",
               "Update-GGGroupCertificateConfiguration",
               "Update-GGLoggerDefinition",
               "Update-GGResourceDefinition",
               "Update-GGSubscriptionDefinition",
               "Update-GGThingRuntimeConfiguration")
}

_awsArgumentCompleterRegistration $GG_SelectCompleters $GG_SelectMap
# Argument completions for service AWS GreengrassV2


$GGV2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GreengrassV2.ComponentVisibilityScope
        "Get-GGV2ComponentList/Scope"
        {
            $v = "PRIVATE","PUBLIC"
            break
        }

        # Amazon.GreengrassV2.CoreDeviceStatus
        "Get-GGV2CoreDeviceList/Status"
        {
            $v = "HEALTHY","UNHEALTHY"
            break
        }

        # Amazon.GreengrassV2.DeploymentComponentUpdatePolicyAction
        "New-GGV2Deployment/DeploymentPolicies_ComponentUpdatePolicy_Action"
        {
            $v = "NOTIFY_COMPONENTS","SKIP_NOTIFY_COMPONENTS"
            break
        }

        # Amazon.GreengrassV2.DeploymentFailureHandlingPolicy
        "New-GGV2Deployment/DeploymentPolicies_FailureHandlingPolicy"
        {
            $v = "DO_NOTHING","ROLLBACK"
            break
        }

        # Amazon.GreengrassV2.DeploymentHistoryFilter
        "Get-GGV2DeploymentList/HistoryFilter"
        {
            $v = "ALL","LATEST_ONLY"
            break
        }

        # Amazon.GreengrassV2.InstalledComponentTopologyFilter
        "Get-GGV2InstalledComponentList/TopologyFilter"
        {
            $v = "ALL","ROOT"
            break
        }

        # Amazon.GreengrassV2.LambdaInputPayloadEncodingType
        "New-GGV2ComponentVersion/LambdaFunction_ComponentLambdaParameters_InputPayloadEncodingType"
        {
            $v = "binary","json"
            break
        }

        # Amazon.GreengrassV2.LambdaIsolationMode
        "New-GGV2ComponentVersion/LambdaFunction_ComponentLambdaParameters_LinuxProcessParams_IsolationMode"
        {
            $v = "GreengrassContainer","NoContainer"
            break
        }

        # Amazon.GreengrassV2.RecipeOutputFormat
        "Get-GGV2Component/RecipeOutputFormat"
        {
            $v = "JSON","YAML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GGV2_map = @{
    "DeploymentPolicies_ComponentUpdatePolicy_Action"=@("New-GGV2Deployment")
    "DeploymentPolicies_FailureHandlingPolicy"=@("New-GGV2Deployment")
    "HistoryFilter"=@("Get-GGV2DeploymentList")
    "LambdaFunction_ComponentLambdaParameters_InputPayloadEncodingType"=@("New-GGV2ComponentVersion")
    "LambdaFunction_ComponentLambdaParameters_LinuxProcessParams_IsolationMode"=@("New-GGV2ComponentVersion")
    "RecipeOutputFormat"=@("Get-GGV2Component")
    "Scope"=@("Get-GGV2ComponentList")
    "Status"=@("Get-GGV2CoreDeviceList")
    "TopologyFilter"=@("Get-GGV2InstalledComponentList")
}

_awsArgumentCompleterRegistration $GGV2_Completers $GGV2_map

$GGV2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GGV2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GGV2_SelectMap = @{
    "Select"=@("Add-GGV2ServiceRoleToAccount",
               "Add-GGV2BatchClientDeviceWithCoreDevice",
               "Remove-GGV2BatchClientDeviceFromCoreDevice",
               "Stop-GGV2Deployment",
               "New-GGV2ComponentVersion",
               "New-GGV2Deployment",
               "Remove-GGV2Component",
               "Remove-GGV2CoreDevice",
               "Remove-GGV2Deployment",
               "Get-GGV2ComponentMetadata",
               "Remove-GGV2ServiceRoleFromAccount",
               "Get-GGV2Component",
               "Get-GGV2ComponentVersionArtifact",
               "Get-GGV2ConnectivityInfo",
               "Get-GGV2CoreDevice",
               "Get-GGV2Deployment",
               "Get-GGV2ServiceRoleForAccount",
               "Get-GGV2ClientDevicesAssociatedWithCoreDeviceList",
               "Get-GGV2ComponentList",
               "Get-GGV2ComponentVersionList",
               "Get-GGV2CoreDeviceList",
               "Get-GGV2DeploymentList",
               "Get-GGV2EffectiveDeploymentList",
               "Get-GGV2InstalledComponentList",
               "Get-GGV2ResourceTag",
               "Resolve-GGV2ComponentCandidate",
               "Add-GGV2ResourceTag",
               "Remove-GGV2ResourceTag",
               "Update-GGV2ConnectivityInfo")
}

_awsArgumentCompleterRegistration $GGV2_SelectCompleters $GGV2_SelectMap
# Argument completions for service AWS Ground Station


$GS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GroundStation.ConfigCapabilityType
        {
            ($_ -eq "Get-GSConfig/ConfigType") -Or
            ($_ -eq "Remove-GSConfig/ConfigType") -Or
            ($_ -eq "Update-GSConfig/ConfigType")
        }
        {
            $v = "antenna-downlink","antenna-downlink-demod-decode","antenna-uplink","dataflow-endpoint","s3-recording","tracking","uplink-echo"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GS_map = @{
    "ConfigType"=@("Get-GSConfig","Remove-GSConfig","Update-GSConfig")
}

_awsArgumentCompleterRegistration $GS_Completers $GS_map

$GS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GS_SelectMap = @{
    "Select"=@("Stop-GSContact",
               "New-GSConfig",
               "New-GSDataflowEndpointGroup",
               "New-GSEphemeris",
               "New-GSMissionProfile",
               "Remove-GSConfig",
               "Remove-GSDataflowEndpointGroup",
               "Remove-GSEphemeris",
               "Remove-GSMissionProfile",
               "Get-GSContact",
               "Get-GSEphemeris",
               "Get-GSConfig",
               "Get-GSDataflowEndpointGroup",
               "Get-GSMinuteUsage",
               "Get-GSMissionProfile",
               "Get-GSSatellite",
               "Get-GSConfigList",
               "Get-GSContactList",
               "Get-GSDataflowEndpointGroupList",
               "Get-GSEphemerideList",
               "Get-GSGroundStationList",
               "Get-GSMissionProfileList",
               "Get-GSSatelliteList",
               "Get-GSResourceTag",
               "Add-GSReservedContact",
               "Add-GSResourceTag",
               "Remove-GSResourceTag",
               "Update-GSConfig",
               "Update-GSEphemeris",
               "Update-GSMissionProfile")
}

_awsArgumentCompleterRegistration $GS_SelectCompleters $GS_SelectMap
# Argument completions for service Amazon GuardDuty


$GD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GuardDuty.DestinationType
        "New-GDPublishingDestination/DestinationType"
        {
            $v = "S3"
            break
        }

        # Amazon.GuardDuty.EbsSnapshotPreservation
        "Update-GDMalwareScanSetting/EbsSnapshotPreservation"
        {
            $v = "NO_RETENTION","RETENTION_WITH_FINDING"
            break
        }

        # Amazon.GuardDuty.Feedback
        "Update-GDFindingFeedback/Feedback"
        {
            $v = "NOT_USEFUL","USEFUL"
            break
        }

        # Amazon.GuardDuty.FilterAction
        {
            ($_ -eq "New-GDFilter/Action") -Or
            ($_ -eq "Update-GDFilter/Action")
        }
        {
            $v = "ARCHIVE","NOOP"
            break
        }

        # Amazon.GuardDuty.FindingPublishingFrequency
        {
            ($_ -eq "New-GDDetector/FindingPublishingFrequency") -Or
            ($_ -eq "Update-GDDetector/FindingPublishingFrequency")
        }
        {
            $v = "FIFTEEN_MINUTES","ONE_HOUR","SIX_HOURS"
            break
        }

        # Amazon.GuardDuty.IpSetFormat
        "New-GDIPSet/Format"
        {
            $v = "ALIEN_VAULT","FIRE_EYE","OTX_CSV","PROOF_POINT","STIX","TXT"
            break
        }

        # Amazon.GuardDuty.ThreatIntelSetFormat
        "New-GDThreatIntelSet/Format"
        {
            $v = "ALIEN_VAULT","FIRE_EYE","OTX_CSV","PROOF_POINT","STIX","TXT"
            break
        }

        # Amazon.GuardDuty.UsageStatisticType
        "Get-GDUsageStatistic/UsageStatisticType"
        {
            $v = "SUM_BY_ACCOUNT","SUM_BY_DATA_SOURCE","SUM_BY_RESOURCE","TOP_RESOURCES"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GD_map = @{
    "Action"=@("New-GDFilter","Update-GDFilter")
    "DestinationType"=@("New-GDPublishingDestination")
    "EbsSnapshotPreservation"=@("Update-GDMalwareScanSetting")
    "Feedback"=@("Update-GDFindingFeedback")
    "FindingPublishingFrequency"=@("New-GDDetector","Update-GDDetector")
    "Format"=@("New-GDIPSet","New-GDThreatIntelSet")
    "UsageStatisticType"=@("Get-GDUsageStatistic")
}

_awsArgumentCompleterRegistration $GD_Completers $GD_map

$GD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GD_SelectMap = @{
    "Select"=@("Receive-GDAdministratorInvitation",
               "Confirm-GDInvitation",
               "Backup-GDFinding",
               "New-GDDetector",
               "New-GDFilter",
               "New-GDIPSet",
               "New-GDMember",
               "New-GDPublishingDestination",
               "New-GDSampleFinding",
               "New-GDThreatIntelSet",
               "Deny-GDInvitation",
               "Remove-GDDetector",
               "Remove-GDFilter",
               "Remove-GDInvitation",
               "Remove-GDIPSet",
               "Remove-GDMember",
               "Remove-GDPublishingDestination",
               "Remove-GDThreatIntelSet",
               "Get-GDMalwareScan",
               "Get-GDOrganizationConfiguration",
               "Get-GDPublishingDestination",
               "Disable-GDOrganizationAdminAccount",
               "Remove-GDFromAdministratorAccount",
               "Unregister-GDFromMasterAccount",
               "Unregister-GDMember",
               "Enable-GDOrganizationAdminAccount",
               "Get-GDAdministratorAccount",
               "Get-GDDetector",
               "Get-GDFilter",
               "Get-GDFinding",
               "Get-GDFindingStatistic",
               "Get-GDInvitationCount",
               "Get-GDIPSet",
               "Get-GDMalwareScanSetting",
               "Get-GDMasterAccount",
               "Get-GDMemberDetector",
               "Get-GDMember",
               "Get-GDRemainingFreeTrialDay",
               "Get-GDThreatIntelSet",
               "Get-GDUsageStatistic",
               "Send-GDMemberInvitation",
               "Get-GDDetectorList",
               "Get-GDFilterList",
               "Get-GDFindingList",
               "Get-GDInvitationList",
               "Get-GDIPSetList",
               "Get-GDMemberList",
               "Get-GDOrganizationAdminAccountList",
               "Get-GDPublishingDestinationList",
               "Get-GDResourceTag",
               "Get-GDThreatIntelSetList",
               "Start-GDMonitoringMember",
               "Stop-GDMonitoringMember",
               "Add-GDResourceTag",
               "Restore-GDFinding",
               "Remove-GDResourceTag",
               "Update-GDDetector",
               "Update-GDFilter",
               "Update-GDFindingFeedback",
               "Update-GDIPSet",
               "Update-GDMalwareScanSetting",
               "Update-GDMemberDetector",
               "Update-GDOrganizationConfiguration",
               "Update-GDPublishingDestination",
               "Update-GDThreatIntelSet")
}

_awsArgumentCompleterRegistration $GD_SelectCompleters $GD_SelectMap
# Argument completions for service AWS Health


$HLTH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AWSHealth.EventAggregateField
        "Get-HLTHEventAggregate/AggregateField"
        {
            $v = "eventTypeCategory"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HLTH_map = @{
    "AggregateField"=@("Get-HLTHEventAggregate")
}

_awsArgumentCompleterRegistration $HLTH_Completers $HLTH_map

$HLTH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HLTH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HLTH_SelectMap = @{
    "Select"=@("Get-HLTHAffectedAccountsForOrganization",
               "Get-HLTHAffectedEntity",
               "Get-HLTHAffectedEntitiesForOrganization",
               "Get-HLTHEntityAggregate",
               "Get-HLTHEventAggregate",
               "Get-HLTHEventDetail",
               "Get-HLTHEventDetailsForOrganization",
               "Get-HLTHEvent",
               "Get-HLTHEventsForOrganization",
               "Get-HLTHEventType",
               "Get-HLTHHealthServiceStatusForOrganization",
               "Disable-HLTHHealthServiceAccessForOrganization",
               "Enable-HLTHHealthServiceAccessForOrganization")
}

_awsArgumentCompleterRegistration $HLTH_SelectCompleters $HLTH_SelectMap
# Argument completions for service Amazon HealthLake


$AHL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.HealthLake.CmkType
        "New-AHLFHIRDatastore/SseConfiguration_KmsEncryptionConfig_CmkType"
        {
            $v = "AWS_OWNED_KMS_KEY","CUSTOMER_MANAGED_KMS_KEY"
            break
        }

        # Amazon.HealthLake.DatastoreStatus
        "Get-AHLFHIRDatastoreList/Filter_DatastoreStatus"
        {
            $v = "ACTIVE","CREATING","DELETED","DELETING"
            break
        }

        # Amazon.HealthLake.FHIRVersion
        "New-AHLFHIRDatastore/DatastoreTypeVersion"
        {
            $v = "R4"
            break
        }

        # Amazon.HealthLake.JobStatus
        {
            ($_ -eq "Get-AHLFHIRExportJobList/JobStatus") -Or
            ($_ -eq "Get-AHLFHIRImportJobList/JobStatus")
        }
        {
            $v = "COMPLETED","COMPLETED_WITH_ERRORS","FAILED","IN_PROGRESS","SUBMITTED"
            break
        }

        # Amazon.HealthLake.PreloadDataType
        "New-AHLFHIRDatastore/PreloadDataConfig_PreloadDataType"
        {
            $v = "SYNTHEA"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AHL_map = @{
    "DatastoreTypeVersion"=@("New-AHLFHIRDatastore")
    "Filter_DatastoreStatus"=@("Get-AHLFHIRDatastoreList")
    "JobStatus"=@("Get-AHLFHIRExportJobList","Get-AHLFHIRImportJobList")
    "PreloadDataConfig_PreloadDataType"=@("New-AHLFHIRDatastore")
    "SseConfiguration_KmsEncryptionConfig_CmkType"=@("New-AHLFHIRDatastore")
}

_awsArgumentCompleterRegistration $AHL_Completers $AHL_map

$AHL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AHL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AHL_SelectMap = @{
    "Select"=@("New-AHLFHIRDatastore",
               "Remove-AHLFHIRDatastore",
               "Get-AHLFHIRDatastore",
               "Get-AHLFHIRExportJob",
               "Get-AHLFHIRImportJob",
               "Get-AHLFHIRDatastoreList",
               "Get-AHLFHIRExportJobList",
               "Get-AHLFHIRImportJobList",
               "Get-AHLResourceTag",
               "Start-AHLFHIRExportJob",
               "Start-AHLFHIRImportJob",
               "Add-AHLResourceTag",
               "Remove-AHLResourceTag")
}

_awsArgumentCompleterRegistration $AHL_SelectCompleters $AHL_SelectMap
# Argument completions for service Amazon Honeycode


$HC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Honeycode.ImportDataCharacterEncoding
        "Start-HCTableDataImportJob/ImportOptions_DelimitedTextOptions_DataCharacterEncoding"
        {
            $v = "ISO-8859-1","US-ASCII","UTF-16","UTF-16BE","UTF-16LE","UTF-8"
            break
        }

        # Amazon.Honeycode.ImportSourceDataFormat
        "Start-HCTableDataImportJob/DataFormat"
        {
            $v = "DELIMITED_TEXT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HC_map = @{
    "DataFormat"=@("Start-HCTableDataImportJob")
    "ImportOptions_DelimitedTextOptions_DataCharacterEncoding"=@("Start-HCTableDataImportJob")
}

_awsArgumentCompleterRegistration $HC_Completers $HC_map

$HC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HC_SelectMap = @{
    "Select"=@("New-HCTableRowsBatch",
               "Remove-HCTableRowsBatch",
               "Update-HCTableRowsBatch",
               "Invoke-HCUpsertTableRowsBatch",
               "Get-HCTableDataImportJob",
               "Get-HCScreenData",
               "Invoke-HCScreenAutomation",
               "Get-HCTableColumnList",
               "Get-HCTableRowList",
               "Get-HCTableList",
               "Get-HCResourceTag",
               "Invoke-HCQueryTableRow",
               "Start-HCTableDataImportJob",
               "Add-HCResourceTag",
               "Remove-HCResourceTag")
}

_awsArgumentCompleterRegistration $HC_SelectCompleters $HC_SelectMap
# Argument completions for service AWS Identity and Access Management


$IAM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IdentityManagement.AccessAdvisorUsageGranularityType
        "Request-IAMServiceLastAccessedDetail/Granularity"
        {
            $v = "ACTION_LEVEL","SERVICE_LEVEL"
            break
        }

        # Amazon.IdentityManagement.AssignmentStatusType
        "Get-IAMVirtualMFADevice/AssignmentStatus"
        {
            $v = "Any","Assigned","Unassigned"
            break
        }

        # Amazon.IdentityManagement.EncodingType
        "Get-IAMSSHPublicKey/Encoding"
        {
            $v = "PEM","SSH"
            break
        }

        # Amazon.IdentityManagement.EntityType
        "Get-IAMEntitiesForPolicy/EntityFilter"
        {
            $v = "AWSManagedPolicy","Group","LocalManagedPolicy","Role","User"
            break
        }

        # Amazon.IdentityManagement.GlobalEndpointTokenVersion
        "Set-IAMSecurityTokenServicePreference/GlobalEndpointTokenVersion"
        {
            $v = "v1Token","v2Token"
            break
        }

        # Amazon.IdentityManagement.PolicyScopeType
        "Get-IAMPolicyList/Scope"
        {
            $v = "All","AWS","Local"
            break
        }

        # Amazon.IdentityManagement.PolicyUsageType
        {
            ($_ -eq "Get-IAMEntitiesForPolicy/PolicyUsageFilter") -Or
            ($_ -eq "Get-IAMPolicyList/PolicyUsageFilter")
        }
        {
            $v = "PermissionsBoundary","PermissionsPolicy"
            break
        }

        # Amazon.IdentityManagement.SortKeyType
        "Get-IAMOrganizationsAccessReport/SortKey"
        {
            $v = "LAST_AUTHENTICATED_TIME_ASCENDING","LAST_AUTHENTICATED_TIME_DESCENDING","SERVICE_NAMESPACE_ASCENDING","SERVICE_NAMESPACE_DESCENDING"
            break
        }

        # Amazon.IdentityManagement.StatusType
        {
            ($_ -eq "Update-IAMAccessKey/Status") -Or
            ($_ -eq "Update-IAMServiceSpecificCredential/Status") -Or
            ($_ -eq "Update-IAMSigningCertificate/Status") -Or
            ($_ -eq "Update-IAMSSHPublicKey/Status")
        }
        {
            $v = "Active","Inactive"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAM_map = @{
    "AssignmentStatus"=@("Get-IAMVirtualMFADevice")
    "Encoding"=@("Get-IAMSSHPublicKey")
    "EntityFilter"=@("Get-IAMEntitiesForPolicy")
    "GlobalEndpointTokenVersion"=@("Set-IAMSecurityTokenServicePreference")
    "Granularity"=@("Request-IAMServiceLastAccessedDetail")
    "PolicyUsageFilter"=@("Get-IAMEntitiesForPolicy","Get-IAMPolicyList")
    "Scope"=@("Get-IAMPolicyList")
    "SortKey"=@("Get-IAMOrganizationsAccessReport")
    "Status"=@("Update-IAMAccessKey","Update-IAMServiceSpecificCredential","Update-IAMSigningCertificate","Update-IAMSSHPublicKey")
}

_awsArgumentCompleterRegistration $IAM_Completers $IAM_map

$IAM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IAM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAM_SelectMap = @{
    "Select"=@("Add-IAMClientIDToOpenIDConnectProvider",
               "Add-IAMRoleToInstanceProfile",
               "Add-IAMUserToGroup",
               "Register-IAMGroupPolicy",
               "Register-IAMRolePolicy",
               "Register-IAMUserPolicy",
               "Edit-IAMPassword",
               "New-IAMAccessKey",
               "New-IAMAccountAlias",
               "New-IAMGroup",
               "New-IAMInstanceProfile",
               "New-IAMLoginProfile",
               "New-IAMOpenIDConnectProvider",
               "New-IAMPolicy",
               "New-IAMPolicyVersion",
               "New-IAMRole",
               "New-IAMSAMLProvider",
               "New-IAMServiceLinkedRole",
               "New-IAMServiceSpecificCredential",
               "New-IAMUser",
               "New-IAMVirtualMFADevice",
               "Disable-IAMMFADevice",
               "Remove-IAMAccessKey",
               "Remove-IAMAccountAlias",
               "Remove-IAMAccountPasswordPolicy",
               "Remove-IAMGroup",
               "Remove-IAMGroupPolicy",
               "Remove-IAMInstanceProfile",
               "Remove-IAMLoginProfile",
               "Remove-IAMOpenIDConnectProvider",
               "Remove-IAMPolicy",
               "Remove-IAMPolicyVersion",
               "Remove-IAMRole",
               "Remove-IAMRolePermissionsBoundary",
               "Remove-IAMRolePolicy",
               "Remove-IAMSAMLProvider",
               "Remove-IAMServerCertificate",
               "Remove-IAMServiceLinkedRole",
               "Remove-IAMServiceSpecificCredential",
               "Remove-IAMSigningCertificate",
               "Remove-IAMSSHPublicKey",
               "Remove-IAMUser",
               "Remove-IAMUserPermissionsBoundary",
               "Remove-IAMUserPolicy",
               "Remove-IAMVirtualMFADevice",
               "Unregister-IAMGroupPolicy",
               "Unregister-IAMRolePolicy",
               "Unregister-IAMUserPolicy",
               "Enable-IAMMFADevice",
               "Request-IAMCredentialReport",
               "New-IAMOrganizationsAccessReport",
               "Request-IAMServiceLastAccessedDetail",
               "Get-IAMAccessKeyLastUsed",
               "Get-IAMAccountAuthorizationDetail",
               "Get-IAMAccountPasswordPolicy",
               "Get-IAMAccountSummary",
               "Get-IAMContextKeysForCustomPolicy",
               "Get-IAMContextKeysForPrincipalPolicy",
               "Get-IAMCredentialReport",
               "Get-IAMGroup",
               "Get-IAMGroupPolicy",
               "Get-IAMInstanceProfile",
               "Get-IAMLoginProfile",
               "Get-IAMOpenIDConnectProvider",
               "Get-IAMOrganizationsAccessReport",
               "Get-IAMPolicy",
               "Get-IAMPolicyVersion",
               "Get-IAMRole",
               "Get-IAMRolePolicy",
               "Get-IAMSAMLProvider",
               "Get-IAMServerCertificate",
               "Get-IAMServiceLastAccessedDetail",
               "Get-IAMServiceLastAccessedDetailWithEntity",
               "Get-IAMServiceLinkedRoleDeletionStatus",
               "Get-IAMSSHPublicKey",
               "Get-IAMUser",
               "Get-IAMUserPolicy",
               "Get-IAMAccessKey",
               "Get-IAMAccountAlias",
               "Get-IAMAttachedGroupPolicyList",
               "Get-IAMAttachedRolePolicyList",
               "Get-IAMAttachedUserPolicyList",
               "Get-IAMEntitiesForPolicy",
               "Get-IAMGroupPolicyList",
               "Get-IAMGroupList",
               "Get-IAMGroupForUser",
               "Get-IAMInstanceProfileList",
               "Get-IAMInstanceProfileForRole",
               "Get-IAMInstanceProfileTagList",
               "Get-IAMMFADevice",
               "Get-IAMMFADeviceTagList",
               "Get-IAMOpenIDConnectProviderList",
               "Get-IAMOpenIDConnectProviderTagList",
               "Get-IAMPolicyList",
               "Get-IAMPolicyGrantingServiceAccessList",
               "Get-IAMPolicyTagList",
               "Get-IAMPolicyVersionList",
               "Get-IAMRolePolicyList",
               "Get-IAMRoleList",
               "Get-IAMRoleTagList",
               "Get-IAMSAMLProviderList",
               "Get-IAMSAMLProviderTagList",
               "Get-IAMServerCertificateList",
               "Get-IAMServerCertificateTagList",
               "Get-IAMServiceSpecificCredentialList",
               "Get-IAMSigningCertificate",
               "Get-IAMSSHPublicKeyList",
               "Get-IAMUserPolicyList",
               "Get-IAMUserList",
               "Get-IAMUserTagList",
               "Get-IAMVirtualMFADevice",
               "Write-IAMGroupPolicy",
               "Set-IAMRolePermissionsBoundary",
               "Write-IAMRolePolicy",
               "Set-IAMUserPermissionsBoundary",
               "Write-IAMUserPolicy",
               "Remove-IAMClientIDFromOpenIDConnectProvider",
               "Remove-IAMRoleFromInstanceProfile",
               "Remove-IAMUserFromGroup",
               "Reset-IAMServiceSpecificCredential",
               "Sync-IAMMFADevice",
               "Set-IAMDefaultPolicyVersion",
               "Set-IAMSecurityTokenServicePreference",
               "Test-IAMCustomPolicy",
               "Test-IAMPrincipalPolicy",
               "Add-IAMInstanceProfileTag",
               "Add-IAMMFADeviceTag",
               "Add-IAMOpenIDConnectProviderTag",
               "Add-IAMPolicyTag",
               "Add-IAMRoleTag",
               "Add-IAMSAMLProviderTag",
               "Add-IAMServerCertificateTag",
               "Add-IAMUserTag",
               "Remove-IAMInstanceProfileTag",
               "Remove-IAMMFADeviceTag",
               "Remove-IAMOpenIDConnectProviderTag",
               "Remove-IAMPolicyTag",
               "Remove-IAMRoleTag",
               "Remove-IAMSAMLProviderTag",
               "Remove-IAMServerCertificateTag",
               "Remove-IAMUserTag",
               "Update-IAMAccessKey",
               "Update-IAMAccountPasswordPolicy",
               "Update-IAMAssumeRolePolicy",
               "Update-IAMGroup",
               "Update-IAMLoginProfile",
               "Update-IAMOpenIDConnectProviderThumbprint",
               "Update-IAMRole",
               "Update-IAMRoleDescription",
               "Update-IAMSAMLProvider",
               "Update-IAMServerCertificate",
               "Update-IAMServiceSpecificCredential",
               "Update-IAMSigningCertificate",
               "Update-IAMSSHPublicKey",
               "Update-IAMUser",
               "Publish-IAMServerCertificate",
               "Publish-IAMSigningCertificate",
               "Publish-IAMSSHPublicKey")
}

_awsArgumentCompleterRegistration $IAM_SelectCompleters $IAM_SelectMap
# Argument completions for service AWS Identity Store


$IDS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IDS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IDS_SelectMap = @{
    "Select"=@("New-IDSGroup",
               "New-IDSGroupMembership",
               "New-IDSUser",
               "Remove-IDSGroup",
               "Remove-IDSGroupMembership",
               "Remove-IDSUser",
               "Get-IDSGroup",
               "Get-IDSGroupMembership",
               "Get-IDSUser",
               "Get-IDSGroupId",
               "Get-IDSGroupMembershipId",
               "Get-IDSUserId",
               "Assert-IDSMemberInGroup",
               "Get-IDSGroupMembershipList",
               "Get-IDSGroupMembershipsForMemberList",
               "Find-IDSGroupList",
               "Find-IDSUserList",
               "Update-IDSGroup",
               "Update-IDSUser")
}

_awsArgumentCompleterRegistration $IDS_SelectCompleters $IDS_SelectMap
# Argument completions for service EC2 Image Builder


$EC2IB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Imagebuilder.ComponentFormat
        "Import-EC2IBComponent/Format"
        {
            $v = "SHELL"
            break
        }

        # Amazon.Imagebuilder.ComponentType
        "Import-EC2IBComponent/Type"
        {
            $v = "BUILD","TEST"
            break
        }

        # Amazon.Imagebuilder.ContainerRepositoryService
        "New-EC2IBContainerRecipe/TargetRepository_Service"
        {
            $v = "ECR"
            break
        }

        # Amazon.Imagebuilder.ContainerType
        "New-EC2IBContainerRecipe/ContainerType"
        {
            $v = "DOCKER"
            break
        }

        # Amazon.Imagebuilder.Ownership
        {
            ($_ -eq "Get-EC2IBComponentList/Owner") -Or
            ($_ -eq "Get-EC2IBContainerRecipeList/Owner") -Or
            ($_ -eq "Get-EC2IBImageList/Owner") -Or
            ($_ -eq "Get-EC2IBImageRecipeList/Owner")
        }
        {
            $v = "Amazon","Self","Shared"
            break
        }

        # Amazon.Imagebuilder.PipelineExecutionStartCondition
        {
            ($_ -eq "New-EC2IBImagePipeline/Schedule_PipelineExecutionStartCondition") -Or
            ($_ -eq "Update-EC2IBImagePipeline/Schedule_PipelineExecutionStartCondition")
        }
        {
            $v = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE","EXPRESSION_MATCH_ONLY"
            break
        }

        # Amazon.Imagebuilder.PipelineStatus
        {
            ($_ -eq "New-EC2IBImagePipeline/Status") -Or
            ($_ -eq "Update-EC2IBImagePipeline/Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Imagebuilder.Platform
        {
            ($_ -eq "Import-EC2IBComponent/Platform") -Or
            ($_ -eq "Import-EC2IBVmImage/Platform") -Or
            ($_ -eq "New-EC2IBComponent/Platform") -Or
            ($_ -eq "New-EC2IBContainerRecipe/PlatformOverride")
        }
        {
            $v = "Linux","Windows"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2IB_map = @{
    "ContainerType"=@("New-EC2IBContainerRecipe")
    "Format"=@("Import-EC2IBComponent")
    "Owner"=@("Get-EC2IBComponentList","Get-EC2IBContainerRecipeList","Get-EC2IBImageList","Get-EC2IBImageRecipeList")
    "Platform"=@("Import-EC2IBComponent","Import-EC2IBVmImage","New-EC2IBComponent")
    "PlatformOverride"=@("New-EC2IBContainerRecipe")
    "Schedule_PipelineExecutionStartCondition"=@("New-EC2IBImagePipeline","Update-EC2IBImagePipeline")
    "Status"=@("New-EC2IBImagePipeline","Update-EC2IBImagePipeline")
    "TargetRepository_Service"=@("New-EC2IBContainerRecipe")
    "Type"=@("Import-EC2IBComponent")
}

_awsArgumentCompleterRegistration $EC2IB_Completers $EC2IB_map

$EC2IB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC2IB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2IB_SelectMap = @{
    "Select"=@("Stop-EC2IBImageCreation",
               "New-EC2IBComponent",
               "New-EC2IBContainerRecipe",
               "New-EC2IBDistributionConfiguration",
               "New-EC2IBImage",
               "New-EC2IBImagePipeline",
               "New-EC2IBImageRecipe",
               "New-EC2IBInfrastructureConfiguration",
               "Remove-EC2IBComponent",
               "Remove-EC2IBContainerRecipe",
               "Remove-EC2IBDistributionConfiguration",
               "Remove-EC2IBImage",
               "Remove-EC2IBImagePipeline",
               "Remove-EC2IBImageRecipe",
               "Remove-EC2IBInfrastructureConfiguration",
               "Get-EC2IBComponent",
               "Get-EC2IBComponentPolicy",
               "Get-EC2IBContainerRecipe",
               "Get-EC2IBContainerRecipePolicy",
               "Get-EC2IBDistributionConfiguration",
               "Get-EC2IBImage",
               "Get-EC2IBImagePipeline",
               "Get-EC2IBImagePolicy",
               "Get-EC2IBImageRecipe",
               "Get-EC2IBImageRecipePolicy",
               "Get-EC2IBInfrastructureConfiguration",
               "Import-EC2IBComponent",
               "Import-EC2IBVmImage",
               "Get-EC2IBComponentBuildVersionList",
               "Get-EC2IBComponentList",
               "Get-EC2IBContainerRecipeList",
               "Get-EC2IBDistributionConfigurationList",
               "Get-EC2IBImageBuildVersionList",
               "Get-EC2IBImagePackageList",
               "Get-EC2IBImagePipelineImageList",
               "Get-EC2IBImagePipelineList",
               "Get-EC2IBImageRecipeList",
               "Get-EC2IBImageList",
               "Get-EC2IBInfrastructureConfigurationList",
               "Get-EC2IBResourceTag",
               "Write-EC2IBComponentPolicy",
               "Write-EC2IBContainerRecipePolicy",
               "Write-EC2IBImagePolicy",
               "Write-EC2IBImageRecipePolicy",
               "Start-EC2IBImagePipelineExecution",
               "Add-EC2IBResourceTag",
               "Remove-EC2IBResourceTag",
               "Update-EC2IBDistributionConfiguration",
               "Update-EC2IBImagePipeline",
               "Update-EC2IBInfrastructureConfiguration")
}

_awsArgumentCompleterRegistration $EC2IB_SelectCompleters $EC2IB_SelectMap
# Argument completions for service AWS Import/Export


$IE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ImportExport.JobType
        {
            ($_ -eq "New-IEJob/JobType") -Or
            ($_ -eq "Update-IEJob/JobType")
        }
        {
            $v = "Export","Import"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IE_map = @{
    "JobType"=@("New-IEJob","Update-IEJob")
}

_awsArgumentCompleterRegistration $IE_Completers $IE_map

$IE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IE_SelectMap = @{
    "Select"=@("Stop-IEJob",
               "New-IEJob",
               "Get-IEShippingLabel",
               "Get-IEStatus",
               "Get-IEJob",
               "Update-IEJob")
}

_awsArgumentCompleterRegistration $IE_SelectCompleters $IE_SelectMap
# Argument completions for service Amazon Inspector


$INS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Inspector.InspectorEvent
        {
            ($_ -eq "Add-INSEventSubscription/Event") -Or
            ($_ -eq "Remove-INSEventSubscription/Event")
        }
        {
            $v = "ASSESSMENT_RUN_COMPLETED","ASSESSMENT_RUN_STARTED","ASSESSMENT_RUN_STATE_CHANGED","FINDING_REPORTED","OTHER"
            break
        }

        # Amazon.Inspector.Locale
        {
            ($_ -eq "Get-INSExclusion/Locale") -Or
            ($_ -eq "Get-INSExclusionsPreview/Locale") -Or
            ($_ -eq "Get-INSFinding/Locale") -Or
            ($_ -eq "Get-INSRulesPackage/Locale")
        }
        {
            $v = "EN_US"
            break
        }

        # Amazon.Inspector.ReportFileFormat
        "Get-INSAssessmentReport/ReportFileFormat"
        {
            $v = "HTML","PDF"
            break
        }

        # Amazon.Inspector.ReportType
        "Get-INSAssessmentReport/ReportType"
        {
            $v = "FINDING","FULL"
            break
        }

        # Amazon.Inspector.StopAction
        "Stop-INSAssessmentRun/StopAction"
        {
            $v = "SKIP_EVALUATION","START_EVALUATION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS_map = @{
    "Event"=@("Add-INSEventSubscription","Remove-INSEventSubscription")
    "Locale"=@("Get-INSExclusion","Get-INSExclusionsPreview","Get-INSFinding","Get-INSRulesPackage")
    "ReportFileFormat"=@("Get-INSAssessmentReport")
    "ReportType"=@("Get-INSAssessmentReport")
    "StopAction"=@("Stop-INSAssessmentRun")
}

_awsArgumentCompleterRegistration $INS_Completers $INS_map

$INS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.INS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS_SelectMap = @{
    "Select"=@("Add-INSFindingAttribute",
               "New-INSAssessmentTarget",
               "New-INSAssessmentTemplate",
               "New-INSExclusionsPreview",
               "New-INSResourceGroup",
               "Remove-INSAssessmentRun",
               "Remove-INSAssessmentTarget",
               "Remove-INSAssessmentTemplate",
               "Get-INSAssessmentRun",
               "Get-INSAssessmentTarget",
               "Get-INSAssessmentTemplate",
               "Get-INSCrossAccountAccessRole",
               "Get-INSExclusion",
               "Get-INSFinding",
               "Get-INSResourceGroup",
               "Get-INSRulesPackage",
               "Get-INSAssessmentReport",
               "Get-INSExclusionsPreview",
               "Get-INSTelemetryMetadata",
               "Get-INSAssessmentRunAgent",
               "Get-INSAssessmentRunList",
               "Get-INSAssessmentTargetList",
               "Get-INSAssessmentTemplateList",
               "Get-INSEventSubscription",
               "Get-INSExclusionList",
               "Get-INSFindingList",
               "Get-INSRulesPackageList",
               "Get-INSResourceTagList",
               "Get-INSAgentPreview",
               "Register-INSCrossAccountAccessRole",
               "Remove-INSFindingAttribute",
               "Set-INSResourceTag",
               "Start-INSAssessmentRun",
               "Stop-INSAssessmentRun",
               "Add-INSEventSubscription",
               "Remove-INSEventSubscription",
               "Update-INSAssessmentTarget")
}

_awsArgumentCompleterRegistration $INS_SelectCompleters $INS_SelectMap
# Argument completions for service Inspector2


$INS2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Inspector2.AccountSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_AccountAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.AggregationFindingType
        {
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_AccountAggregation_FindingType") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_FindingTypeAggregation_FindingType")
        }
        {
            $v = "NETWORK_REACHABILITY","PACKAGE_VULNERABILITY"
            break
        }

        # Amazon.Inspector2.AggregationResourceType
        {
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_AccountAggregation_ResourceType") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_FindingTypeAggregation_ResourceType") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_TitleAggregation_ResourceType")
        }
        {
            $v = "AWS_EC2_INSTANCE","AWS_ECR_CONTAINER_IMAGE"
            break
        }

        # Amazon.Inspector2.AggregationType
        "Get-INS2FindingAggregationList/AggregationType"
        {
            $v = "ACCOUNT","AMI","AWS_EC2_INSTANCE","AWS_ECR_CONTAINER","FINDING_TYPE","IMAGE_LAYER","PACKAGE","REPOSITORY","TITLE"
            break
        }

        # Amazon.Inspector2.AmiSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_AmiAggregation_SortBy"
        {
            $v = "AFFECTED_INSTANCES","ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.AwsEcrContainerSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_AwsEcrContainerAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.Ec2InstanceSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_Ec2InstanceAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH","NETWORK_FINDINGS"
            break
        }

        # Amazon.Inspector2.EcrRescanDuration
        "Update-INS2Configuration/EcrConfiguration_RescanDuration"
        {
            $v = "DAYS_180","DAYS_30","LIFETIME"
            break
        }

        # Amazon.Inspector2.FilterAction
        {
            ($_ -eq "Get-INS2FilterList/Action") -Or
            ($_ -eq "New-INS2Filter/Action") -Or
            ($_ -eq "Update-INS2Filter/Action")
        }
        {
            $v = "NONE","SUPPRESS"
            break
        }

        # Amazon.Inspector2.FindingTypeSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_FindingTypeAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.GroupKey
        "Get-INS2CoverageStatisticList/GroupBy"
        {
            $v = "ACCOUNT_ID","ECR_REPOSITORY_NAME","RESOURCE_TYPE","SCAN_STATUS_CODE","SCAN_STATUS_REASON"
            break
        }

        # Amazon.Inspector2.ImageLayerSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_ImageLayerAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.PackageSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_PackageAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.ReportFormat
        "New-INS2FindingsReport/ReportFormat"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.Inspector2.RepositorySortBy
        "Get-INS2FindingAggregationList/AggregationRequest_RepositoryAggregation_SortBy"
        {
            $v = "AFFECTED_IMAGES","ALL","CRITICAL","HIGH"
            break
        }

        # Amazon.Inspector2.Service
        "Get-INS2AccountPermissionList/Service"
        {
            $v = "EC2","ECR"
            break
        }

        # Amazon.Inspector2.SortField
        "Get-INS2FindingList/SortCriteria_Field"
        {
            $v = "AWS_ACCOUNT_ID","COMPONENT_TYPE","ECR_IMAGE_PUSHED_AT","ECR_IMAGE_REGISTRY","ECR_IMAGE_REPOSITORY_NAME","FINDING_STATUS","FINDING_TYPE","FIRST_OBSERVED_AT","INSPECTOR_SCORE","LAST_OBSERVED_AT","NETWORK_PROTOCOL","RESOURCE_TYPE","SEVERITY","VENDOR_SEVERITY","VULNERABILITY_ID","VULNERABILITY_SOURCE"
            break
        }

        # Amazon.Inspector2.SortOrder
        {
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_AccountAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_AmiAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_AwsEcrContainerAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_Ec2InstanceAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_FindingTypeAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_ImageLayerAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_PackageAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_RepositoryAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingAggregationList/AggregationRequest_TitleAggregation_SortOrder") -Or
            ($_ -eq "Get-INS2FindingList/SortCriteria_SortOrder")
        }
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.Inspector2.TitleSortBy
        "Get-INS2FindingAggregationList/AggregationRequest_TitleAggregation_SortBy"
        {
            $v = "ALL","CRITICAL","HIGH"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS2_map = @{
    "Action"=@("Get-INS2FilterList","New-INS2Filter","Update-INS2Filter")
    "AggregationRequest_AccountAggregation_FindingType"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AccountAggregation_ResourceType"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AccountAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AccountAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AmiAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AmiAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AwsEcrContainerAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_AwsEcrContainerAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_Ec2InstanceAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_Ec2InstanceAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_FindingTypeAggregation_FindingType"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_FindingTypeAggregation_ResourceType"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_FindingTypeAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_FindingTypeAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_ImageLayerAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_ImageLayerAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_PackageAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_PackageAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_RepositoryAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_RepositoryAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_TitleAggregation_ResourceType"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_TitleAggregation_SortBy"=@("Get-INS2FindingAggregationList")
    "AggregationRequest_TitleAggregation_SortOrder"=@("Get-INS2FindingAggregationList")
    "AggregationType"=@("Get-INS2FindingAggregationList")
    "EcrConfiguration_RescanDuration"=@("Update-INS2Configuration")
    "GroupBy"=@("Get-INS2CoverageStatisticList")
    "ReportFormat"=@("New-INS2FindingsReport")
    "Service"=@("Get-INS2AccountPermissionList")
    "SortCriteria_Field"=@("Get-INS2FindingList")
    "SortCriteria_SortOrder"=@("Get-INS2FindingList")
}

_awsArgumentCompleterRegistration $INS2_Completers $INS2_map

$INS2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.INS2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS2_SelectMap = @{
    "Select"=@("Register-INS2Member",
               "Get-INS2GetAccountStatus",
               "Get-INS2GetFreeTrialInfo",
               "Stop-INS2FindingsReport",
               "New-INS2Filter",
               "New-INS2FindingsReport",
               "Remove-INS2Filter",
               "Get-INS2OrganizationConfiguration",
               "Stop-INS2Service",
               "Disable-INS2DelegatedAdminAccount",
               "Unregister-INS2Member",
               "Stop-INS2Inspector",
               "Enable-INS2DelegatedAdminAccount",
               "Get-INS2Configuration",
               "Get-INS2DelegatedAdminAccount",
               "Get-INS2FindingsReportStatus",
               "Get-INS2Member",
               "Get-INS2AccountPermissionList",
               "Get-INS2CoverageList",
               "Get-INS2CoverageStatisticList",
               "Get-INS2DelegatedAdminAccountList",
               "Get-INS2FilterList",
               "Get-INS2FindingAggregationList",
               "Get-INS2FindingList",
               "Get-INS2MemberList",
               "Get-INS2ResourceTag",
               "Get-INS2UsageTotalList",
               "Add-INS2ResourceTag",
               "Remove-INS2ResourceTag",
               "Update-INS2Configuration",
               "Update-INS2Filter",
               "Update-INS2OrganizationConfiguration")
}

_awsArgumentCompleterRegistration $INS2_SelectCompleters $INS2_SelectMap
# Argument completions for service AWS IoT


$IOT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoT.AggregationTypeName
        {
            ($_ -eq "New-IOTFleetMetric/AggregationType_Name") -Or
            ($_ -eq "Update-IOTFleetMetric/AggregationType_Name")
        }
        {
            $v = "Cardinality","Percentiles","Statistics"
            break
        }

        # Amazon.IoT.AuditFrequency
        {
            ($_ -eq "New-IOTScheduledAudit/Frequency") -Or
            ($_ -eq "Update-IOTScheduledAudit/Frequency")
        }
        {
            $v = "BIWEEKLY","DAILY","MONTHLY","WEEKLY"
            break
        }

        # Amazon.IoT.AuditMitigationActionsExecutionStatus
        "Get-IOTAuditMitigationActionsExecutionList/ActionStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS","PENDING","SKIPPED"
            break
        }

        # Amazon.IoT.AuditMitigationActionsTaskStatus
        "Get-IOTAuditMitigationActionsTaskList/TaskStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.IoT.AuditTaskStatus
        "Get-IOTTaskList/TaskStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.IoT.AuditTaskType
        "Get-IOTTaskList/TaskType"
        {
            $v = "ON_DEMAND_AUDIT_TASK","SCHEDULED_AUDIT_TASK"
            break
        }

        # Amazon.IoT.AuthorizerStatus
        {
            ($_ -eq "Get-IOTAuthorizerList/Status") -Or
            ($_ -eq "New-IOTAuthorizer/Status") -Or
            ($_ -eq "Update-IOTAuthorizer/Status")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.IoT.AutoRegistrationStatus
        "Update-IOTCACertificate/NewAutoRegistrationStatus"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.IoT.BehaviorCriteriaType
        {
            ($_ -eq "Get-IOTActiveViolationList/BehaviorCriteriaType") -Or
            ($_ -eq "Get-IOTViolationEventList/BehaviorCriteriaType")
        }
        {
            $v = "MACHINE_LEARNING","STATIC","STATISTICAL"
            break
        }

        # Amazon.IoT.CACertificateStatus
        "Update-IOTCACertificate/NewStatus"
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.IoT.CACertificateUpdateAction
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_UpdateCACertificateParams_Action") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_UpdateCACertificateParams_Action")
        }
        {
            $v = "DEACTIVATE"
            break
        }

        # Amazon.IoT.CannedAccessControlList
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_S3_CannedAcl") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_S3_CannedAcl")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","log-delivery-write","private","public-read","public-read-write"
            break
        }

        # Amazon.IoT.CertificateMode
        "Register-IOTCACertificate/CertificateMode"
        {
            $v = "DEFAULT","SNI_ONLY"
            break
        }

        # Amazon.IoT.CertificateStatus
        {
            ($_ -eq "Update-IOTCertificate/NewStatus") -Or
            ($_ -eq "Register-IOTCertificate/Status") -Or
            ($_ -eq "Register-IOTCertificateWithoutCA/Status")
        }
        {
            $v = "ACTIVE","INACTIVE","PENDING_ACTIVATION","PENDING_TRANSFER","REGISTER_INACTIVE","REVOKED"
            break
        }

        # Amazon.IoT.CustomMetricType
        "New-IOTCustomMetric/MetricType"
        {
            $v = "ip-address-list","number","number-list","string-list"
            break
        }

        # Amazon.IoT.DayOfWeek
        {
            ($_ -eq "New-IOTScheduledAudit/DayOfWeek") -Or
            ($_ -eq "Update-IOTScheduledAudit/DayOfWeek")
        }
        {
            $v = "FRI","MON","SAT","SUN","THU","TUE","WED"
            break
        }

        # Amazon.IoT.DeviceCertificateUpdateAction
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_UpdateDeviceCertificateParams_Action") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_UpdateDeviceCertificateParams_Action")
        }
        {
            $v = "DEACTIVATE"
            break
        }

        # Amazon.IoT.DeviceDefenderIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_DeviceDefenderIndexingMode"
        {
            $v = "OFF","VIOLATIONS"
            break
        }

        # Amazon.IoT.DimensionType
        "New-IOTDimension/Type"
        {
            $v = "TOPIC_FILTER"
            break
        }

        # Amazon.IoT.DimensionValueOperator
        "Get-IOTMetricValueList/DimensionValueOperator"
        {
            $v = "IN","NOT_IN"
            break
        }

        # Amazon.IoT.DomainConfigurationStatus
        "Update-IOTDomainConfiguration/DomainConfigurationStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.IoT.DynamoKeyType
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_HashKeyType") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_HashKeyType") -Or
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType")
        }
        {
            $v = "NUMBER","STRING"
            break
        }

        # Amazon.IoT.FleetMetricUnit
        {
            ($_ -eq "New-IOTFleetMetric/Unit") -Or
            ($_ -eq "Update-IOTFleetMetric/Unit")
        }
        {
            $v = "Bits","Bits/Second","Bytes","Bytes/Second","Count","Count/Second","Gigabits","Gigabits/Second","Gigabytes","Gigabytes/Second","Kilobits","Kilobits/Second","Kilobytes","Kilobytes/Second","Megabits","Megabits/Second","Megabytes","Megabytes/Second","Microseconds","Milliseconds","None","Percent","Seconds","Terabits","Terabits/Second","Terabytes","Terabytes/Second"
            break
        }

        # Amazon.IoT.JobExecutionStatus
        {
            ($_ -eq "Get-IOTJobExecutionsForJobList/Status") -Or
            ($_ -eq "Get-IOTJobExecutionsForThingList/Status")
        }
        {
            $v = "CANCELED","FAILED","IN_PROGRESS","QUEUED","REJECTED","REMOVED","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.IoT.JobStatus
        "Get-IOTJobList/Status"
        {
            $v = "CANCELED","COMPLETED","DELETION_IN_PROGRESS","IN_PROGRESS"
            break
        }

        # Amazon.IoT.LogLevel
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_EnableIoTLoggingParams_LogLevel") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_EnableIoTLoggingParams_LogLevel") -Or
            ($_ -eq "Set-IOTV2LoggingOption/DefaultLogLevel") -Or
            ($_ -eq "Set-IOTLoggingOption/LoggingOptionsPayload_LogLevel") -Or
            ($_ -eq "Set-IOTV2LoggingLevel/LogLevel")
        }
        {
            $v = "DEBUG","DISABLED","ERROR","INFO","WARN"
            break
        }

        # Amazon.IoT.LogTargetType
        {
            ($_ -eq "Set-IOTV2LoggingLevel/LogTarget_TargetType") -Or
            ($_ -eq "Get-IOTV2LoggingLevelList/TargetType") -Or
            ($_ -eq "Remove-IOTV2LoggingLevel/TargetType")
        }
        {
            $v = "CLIENT_ID","DEFAULT","PRINCIPAL_ID","SOURCE_IP","THING_GROUP"
            break
        }

        # Amazon.IoT.MessageFormat
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_Sns_MessageFormat") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_Sns_MessageFormat")
        }
        {
            $v = "JSON","RAW"
            break
        }

        # Amazon.IoT.MitigationActionType
        "Get-IOTMitigationActionList/ActionType"
        {
            $v = "ADD_THINGS_TO_THING_GROUP","ENABLE_IOT_LOGGING","PUBLISH_FINDING_TO_SNS","REPLACE_DEFAULT_POLICY_VERSION","UPDATE_CA_CERTIFICATE","UPDATE_DEVICE_CERTIFICATE"
            break
        }

        # Amazon.IoT.NamedShadowIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_NamedShadowIndexingMode"
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.IoT.OTAUpdateStatus
        "Get-IOTOTAUpdateList/OtaUpdateStatus"
        {
            $v = "CREATE_COMPLETE","CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_PENDING"
            break
        }

        # Amazon.IoT.PolicyTemplateName
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName")
        }
        {
            $v = "BLANK_POLICY"
            break
        }

        # Amazon.IoT.ReportType
        "Get-IOTThingRegistrationTaskReportList/ReportType"
        {
            $v = "ERRORS","RESULTS"
            break
        }

        # Amazon.IoT.ServiceType
        {
            ($_ -eq "Get-IOTDomainConfigurationList/ServiceType") -Or
            ($_ -eq "New-IOTDomainConfiguration/ServiceType")
        }
        {
            $v = "CREDENTIAL_PROVIDER","DATA","JOBS"
            break
        }

        # Amazon.IoT.Status
        "Get-IOTThingRegistrationTaskList/Status"
        {
            $v = "Cancelled","Cancelling","Completed","Failed","InProgress"
            break
        }

        # Amazon.IoT.TargetSelection
        {
            ($_ -eq "Get-IOTJobList/TargetSelection") -Or
            ($_ -eq "New-IOTJob/TargetSelection") -Or
            ($_ -eq "New-IOTOTAUpdate/TargetSelection")
        }
        {
            $v = "CONTINUOUS","SNAPSHOT"
            break
        }

        # Amazon.IoT.TemplateType
        "New-IOTProvisioningTemplate/Type"
        {
            $v = "FLEET_PROVISIONING","JITP"
            break
        }

        # Amazon.IoT.ThingConnectivityIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_ThingConnectivityIndexingMode"
        {
            $v = "OFF","STATUS"
            break
        }

        # Amazon.IoT.ThingGroupIndexingMode
        "Update-IOTIndexingConfiguration/ThingGroupIndexingConfiguration_ThingGroupIndexingMode"
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.IoT.ThingIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_ThingIndexingMode"
        {
            $v = "OFF","REGISTRY","REGISTRY_AND_SHADOW"
            break
        }

        # Amazon.IoT.TopicRuleDestinationStatus
        "Update-IOTTopicRuleDestination/Status"
        {
            $v = "DELETING","DISABLED","ENABLED","ERROR","IN_PROGRESS"
            break
        }

        # Amazon.IoT.VerificationState
        {
            ($_ -eq "Get-IOTActiveViolationList/VerificationState") -Or
            ($_ -eq "Get-IOTViolationEventList/VerificationState") -Or
            ($_ -eq "Write-IOTVerificationStateOnViolation/VerificationState")
        }
        {
            $v = "BENIGN_POSITIVE","FALSE_POSITIVE","TRUE_POSITIVE","UNKNOWN"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOT_map = @{
    "ActionParams_EnableIoTLoggingParams_LogLevel"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_UpdateCACertificateParams_Action"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_UpdateDeviceCertificateParams_Action"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionStatus"=@("Get-IOTAuditMitigationActionsExecutionList")
    "ActionType"=@("Get-IOTMitigationActionList")
    "AggregationType_Name"=@("New-IOTFleetMetric","Update-IOTFleetMetric")
    "BehaviorCriteriaType"=@("Get-IOTActiveViolationList","Get-IOTViolationEventList")
    "CertificateMode"=@("Register-IOTCACertificate")
    "DayOfWeek"=@("New-IOTScheduledAudit","Update-IOTScheduledAudit")
    "DefaultLogLevel"=@("Set-IOTV2LoggingOption")
    "DimensionValueOperator"=@("Get-IOTMetricValueList")
    "DomainConfigurationStatus"=@("Update-IOTDomainConfiguration")
    "Frequency"=@("New-IOTScheduledAudit","Update-IOTScheduledAudit")
    "LoggingOptionsPayload_LogLevel"=@("Set-IOTLoggingOption")
    "LogLevel"=@("Set-IOTV2LoggingLevel")
    "LogTarget_TargetType"=@("Set-IOTV2LoggingLevel")
    "MetricType"=@("New-IOTCustomMetric")
    "NewAutoRegistrationStatus"=@("Update-IOTCACertificate")
    "NewStatus"=@("Update-IOTCACertificate","Update-IOTCertificate")
    "OtaUpdateStatus"=@("Get-IOTOTAUpdateList")
    "ReportType"=@("Get-IOTThingRegistrationTaskReportList")
    "ServiceType"=@("Get-IOTDomainConfigurationList","New-IOTDomainConfiguration")
    "Status"=@("Get-IOTAuthorizerList","Get-IOTJobExecutionsForJobList","Get-IOTJobExecutionsForThingList","Get-IOTJobList","Get-IOTThingRegistrationTaskList","New-IOTAuthorizer","Register-IOTCertificate","Register-IOTCertificateWithoutCA","Update-IOTAuthorizer","Update-IOTTopicRuleDestination")
    "TargetSelection"=@("Get-IOTJobList","New-IOTJob","New-IOTOTAUpdate")
    "TargetType"=@("Get-IOTV2LoggingLevelList","Remove-IOTV2LoggingLevel")
    "TaskStatus"=@("Get-IOTAuditMitigationActionsTaskList","Get-IOTTaskList")
    "TaskType"=@("Get-IOTTaskList")
    "ThingGroupIndexingConfiguration_ThingGroupIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_DeviceDefenderIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_NamedShadowIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_ThingConnectivityIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_ThingIndexingMode"=@("Update-IOTIndexingConfiguration")
    "TopicRulePayload_ErrorAction_DynamoDB_HashKeyType"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_S3_CannedAcl"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_Sns_MessageFormat"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "Type"=@("New-IOTDimension","New-IOTProvisioningTemplate")
    "Unit"=@("New-IOTFleetMetric","Update-IOTFleetMetric")
    "VerificationState"=@("Get-IOTActiveViolationList","Get-IOTViolationEventList","Write-IOTVerificationStateOnViolation")
}

_awsArgumentCompleterRegistration $IOT_Completers $IOT_map

$IOT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOT_SelectMap = @{
    "Select"=@("Confirm-IOTCertificateTransfer",
               "Add-IOTThingToBillingGroup",
               "Add-IOTThingToThingGroup",
               "Add-IOTTargetsWithJob",
               "Add-IOTPolicy",
               "Add-IOTPrincipalPolicy",
               "Mount-IOTSecurityProfile",
               "Add-IOTThingPrincipal",
               "Stop-IOTAuditMitigationActionsTask",
               "Stop-IOTAuditTask",
               "Stop-IOTCertificateTransfer",
               "Stop-IOTDetectMitigationActionsTask",
               "Stop-IOTJob",
               "Stop-IOTJobExecution",
               "Clear-IOTDefaultAuthorizer",
               "Confirm-IOTTopicRuleDestination",
               "New-IOTAuditSuppression",
               "New-IOTAuthorizer",
               "New-IOTBillingGroup",
               "New-IOTCertificateFromCsr",
               "New-IOTCustomMetric",
               "New-IOTDimension",
               "New-IOTDomainConfiguration",
               "New-IOTDynamicThingGroup",
               "New-IOTFleetMetric",
               "New-IOTJob",
               "New-IOTJobTemplate",
               "New-IOTKeysAndCertificate",
               "New-IOTMitigationAction",
               "New-IOTOTAUpdate",
               "New-IOTPolicy",
               "New-IOTPolicyVersion",
               "New-IOTProvisioningClaim",
               "New-IOTProvisioningTemplate",
               "New-IOTProvisioningTemplateVersion",
               "New-IOTRoleAlias",
               "New-IOTScheduledAudit",
               "New-IOTSecurityProfile",
               "New-IOTStream",
               "New-IOTThing",
               "New-IOTThingGroup",
               "New-IOTThingType",
               "New-IOTTopicRule",
               "New-IOTTopicRuleDestination",
               "Remove-IOTAccountAuditConfiguration",
               "Remove-IOTAuditSuppression",
               "Remove-IOTAuthorizer",
               "Remove-IOTBillingGroup",
               "Remove-IOTCACertificate",
               "Remove-IOTCertificate",
               "Remove-IOTCustomMetric",
               "Remove-IOTDimension",
               "Remove-IOTDomainConfiguration",
               "Remove-IOTDynamicThingGroup",
               "Remove-IOTFleetMetric",
               "Remove-IOTJob",
               "Remove-IOTJobExecution",
               "Remove-IOTJobTemplate",
               "Remove-IOTMitigationAction",
               "Remove-IOTOTAUpdate",
               "Remove-IOTPolicy",
               "Remove-IOTPolicyVersion",
               "Remove-IOTProvisioningTemplate",
               "Remove-IOTProvisioningTemplateVersion",
               "Remove-IOTRegistrationCode",
               "Remove-IOTRoleAlias",
               "Remove-IOTScheduledAudit",
               "Remove-IOTSecurityProfile",
               "Remove-IOTStream",
               "Remove-IOTThing",
               "Remove-IOTThingGroup",
               "Remove-IOTThingType",
               "Remove-IOTTopicRule",
               "Remove-IOTTopicRuleDestination",
               "Remove-IOTV2LoggingLevel",
               "Set-IOTThingTypeDeprecation",
               "Get-IOTAccountAuditConfiguration",
               "Get-IOTAuditFinding",
               "Get-IOTAuditMitigationActionsTask",
               "Get-IOTAuditSuppression",
               "Get-IOTAuditTask",
               "Get-IOTAuthorizer",
               "Get-IOTBillingGroup",
               "Get-IOTCACertificate",
               "Get-IOTCertificate",
               "Get-IOTCustomMetric",
               "Get-IOTDefaultAuthorizer",
               "Get-IOTDetectMitigationActionsTask",
               "Get-IOTDimension",
               "Get-IOTDomainConfiguration",
               "Get-IOTEndpoint",
               "Get-IOTEventConfiguration",
               "Get-IOTFleetMetric",
               "Get-IOTIndex",
               "Get-IOTJob",
               "Get-IOTJobExecution",
               "Get-IOTJobTemplate",
               "Get-IOTManagedJobTemplate",
               "Get-IOTMitigationAction",
               "Get-IOTProvisioningTemplate",
               "Get-IOTProvisioningTemplateVersion",
               "Get-IOTRoleAlias",
               "Get-IOTScheduledAudit",
               "Get-IOTSecurityProfile",
               "Get-IOTStream",
               "Get-IOTThing",
               "Get-IOTThingGroup",
               "Get-IOTThingRegistrationTask",
               "Get-IOTThingType",
               "Dismount-IOTPolicy",
               "Remove-IOTPrincipalPolicy",
               "Dismount-IOTSecurityProfile",
               "Remove-IOTThingPrincipal",
               "Disable-IOTTopicRule",
               "Enable-IOTTopicRule",
               "Get-IOTBehaviorModelTrainingSummary",
               "Get-IOTBucketsAggregation",
               "Get-IOTCardinality",
               "Get-IOTEffectivePolicy",
               "Get-IOTIndexingConfiguration",
               "Get-IOTJobDocument",
               "Get-IOTLoggingOption",
               "Get-IOTOTAUpdate",
               "Get-IOTPercentile",
               "Get-IOTPolicy",
               "Get-IOTPolicyVersion",
               "Get-IOTRegistrationCode",
               "Get-IOTStatistic",
               "Get-IOTTopicRule",
               "Get-IOTTopicRuleDestination",
               "Get-IOTV2LoggingOption",
               "Get-IOTActiveViolationList",
               "Get-IOTAttachedPolicyList",
               "Get-IOTAuditFindingList",
               "Get-IOTAuditMitigationActionsExecutionList",
               "Get-IOTAuditMitigationActionsTaskList",
               "Get-IOTAuditSuppressionList",
               "Get-IOTTaskList",
               "Get-IOTAuthorizerList",
               "Get-IOTBillingGroupList",
               "Get-IOTCACertificateList",
               "Get-IOTCertificateList",
               "Get-IOTCertificateListByCA",
               "Get-IOTCustomMetricList",
               "Get-IOTDetectMitigationActionsExecutionList",
               "Get-IOTDetectMitigationActionsTaskList",
               "Get-IOTDimensionList",
               "Get-IOTDomainConfigurationList",
               "Get-IOTFleetMetricList",
               "Get-IOTIndexList",
               "Get-IOTJobExecutionsForJobList",
               "Get-IOTJobExecutionsForThingList",
               "Get-IOTJobList",
               "Get-IOTJobTemplateList",
               "Get-IOTManagedJobTemplateList",
               "Get-IOTMetricValueList",
               "Get-IOTMitigationActionList",
               "Get-IOTOTAUpdateList",
               "Get-IOTOutgoingCertificate",
               "Get-IOTPolicyList",
               "Get-IOTPolicyPrincipalList",
               "Get-IOTPolicyVersionList",
               "Get-IOTPrincipalPolicyList",
               "Get-IOTPrincipalThingList",
               "Get-IOTProvisioningTemplateList",
               "Get-IOTProvisioningTemplateVersionList",
               "Get-IOTRelatedResourcesForAuditFindingList",
               "Get-IOTRoleAliasList",
               "Get-IOTScheduledAuditList",
               "Get-IOTSecurityProfileList",
               "Get-IOTSecurityProfilesForTargetList",
               "Get-IOTStreamList",
               "Get-IOTTagListForResource",
               "Get-IOTTargetsForPolicyList",
               "Get-IOTTargetsForSecurityProfileList",
               "Get-IOTThingGroupList",
               "Get-IOTThingGroupsForThingList",
               "Get-IOTThingPrincipalList",
               "Get-IOTThingRegistrationTaskReportList",
               "Get-IOTThingRegistrationTaskList",
               "Get-IOTThingList",
               "Get-IOTThingsInBillingGroupList",
               "Get-IOTThingsInThingGroupList",
               "Get-IOTThingTypeList",
               "Get-IOTTopicRuleDestinationList",
               "Get-IOTTopicRuleList",
               "Get-IOTV2LoggingLevelList",
               "Get-IOTViolationEventList",
               "Write-IOTVerificationStateOnViolation",
               "Register-IOTCACertificate",
               "Register-IOTCertificate",
               "Register-IOTCertificateWithoutCA",
               "Register-IOTThing",
               "Deny-IOTCertificateTransfer",
               "Remove-IOTThingFromBillingGroup",
               "Remove-IOTThingFromThingGroup",
               "Set-IOTTopicRule",
               "Search-IOTIndex",
               "Set-IOTDefaultAuthorizer",
               "Set-IOTDefaultPolicyVersion",
               "Set-IOTLoggingOption",
               "Set-IOTV2LoggingLevel",
               "Set-IOTV2LoggingOption",
               "Start-IOTAuditMitigationActionsTask",
               "Start-IOTDetectMitigationActionsTask",
               "Start-IOTOnDemandAuditTask",
               "Start-IOTThingRegistrationTask",
               "Stop-IOTThingRegistrationTask",
               "Add-IOTResourceTag",
               "Test-IOTAuthorization",
               "Test-IOTInvokeAuthorizer",
               "Request-IOTCertificateTransfer",
               "Remove-IOTResourceTag",
               "Update-IOTAccountAuditConfiguration",
               "Update-IOTAuditSuppression",
               "Update-IOTAuthorizer",
               "Update-IOTBillingGroup",
               "Update-IOTCACertificate",
               "Update-IOTCertificate",
               "Update-IOTCustomMetric",
               "Update-IOTDimension",
               "Update-IOTDomainConfiguration",
               "Update-IOTDynamicThingGroup",
               "Update-IOTEventConfiguration",
               "Update-IOTFleetMetric",
               "Update-IOTIndexingConfiguration",
               "Update-IOTJob",
               "Update-IOTMitigationAction",
               "Update-IOTProvisioningTemplate",
               "Update-IOTRoleAlias",
               "Update-IOTScheduledAudit",
               "Update-IOTSecurityProfile",
               "Update-IOTStream",
               "Update-IOTThing",
               "Update-IOTThingGroup",
               "Update-IOTThingGroupsForThing",
               "Update-IOTTopicRuleDestination",
               "Test-IOTValidSecurityProfileBehavior")
}

_awsArgumentCompleterRegistration $IOT_SelectCompleters $IOT_SelectMap
# Argument completions for service AWS IoT Core Device Advisor


$IOTDA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTDeviceAdvisor.Protocol
        {
            ($_ -eq "New-IOTDASuiteDefinition/SuiteDefinitionConfiguration_Protocol") -Or
            ($_ -eq "Update-IOTDASuiteDefinition/SuiteDefinitionConfiguration_Protocol")
        }
        {
            $v = "MqttV3_1_1","MqttV5"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTDA_map = @{
    "SuiteDefinitionConfiguration_Protocol"=@("New-IOTDASuiteDefinition","Update-IOTDASuiteDefinition")
}

_awsArgumentCompleterRegistration $IOTDA_Completers $IOTDA_map

$IOTDA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTDA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTDA_SelectMap = @{
    "Select"=@("New-IOTDASuiteDefinition",
               "Remove-IOTDASuiteDefinition",
               "Get-IOTDAEndpoint",
               "Get-IOTDASuiteDefinition",
               "Get-IOTDASuiteRun",
               "Get-IOTDASuiteRunReport",
               "Get-IOTDASuiteDefinitionList",
               "Get-IOTDASuiteRunList",
               "Get-IOTDAResourceTag",
               "Start-IOTDASuiteRun",
               "Stop-IOTDASuiteRun",
               "Add-IOTDAResourceTag",
               "Remove-IOTDAResourceTag",
               "Update-IOTDASuiteDefinition")
}

_awsArgumentCompleterRegistration $IOTDA_SelectCompleters $IOTDA_SelectMap
# Argument completions for service AWS IoT Events


$IOTE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTEvents.ComparisonOperator
        {
            ($_ -eq "New-IOTEAlarmModel/AlarmRule_SimpleRule_ComparisonOperator") -Or
            ($_ -eq "Update-IOTEAlarmModel/AlarmRule_SimpleRule_ComparisonOperator")
        }
        {
            $v = "EQUAL","GREATER","GREATER_OR_EQUAL","LESS","LESS_OR_EQUAL","NOT_EQUAL"
            break
        }

        # Amazon.IoTEvents.EvaluationMethod
        {
            ($_ -eq "New-IOTEDetectorModel/EvaluationMethod") -Or
            ($_ -eq "Update-IOTEDetectorModel/EvaluationMethod")
        }
        {
            $v = "BATCH","SERIAL"
            break
        }

        # Amazon.IoTEvents.LoggingLevel
        "Write-IOTELoggingOption/LoggingOptions_Level"
        {
            $v = "DEBUG","ERROR","INFO"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTE_map = @{
    "AlarmRule_SimpleRule_ComparisonOperator"=@("New-IOTEAlarmModel","Update-IOTEAlarmModel")
    "EvaluationMethod"=@("New-IOTEDetectorModel","Update-IOTEDetectorModel")
    "LoggingOptions_Level"=@("Write-IOTELoggingOption")
}

_awsArgumentCompleterRegistration $IOTE_Completers $IOTE_map

$IOTE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTE_SelectMap = @{
    "Select"=@("New-IOTEAlarmModel",
               "New-IOTEDetectorModel",
               "New-IOTEInput",
               "Remove-IOTEAlarmModel",
               "Remove-IOTEDetectorModel",
               "Remove-IOTEInput",
               "Get-IOTEAlarmModel",
               "Get-IOTEDetectorModel",
               "Get-IOTEDetectorModelAnalysis",
               "Get-IOTEInput",
               "Get-IOTELoggingOption",
               "Get-IOTEDetectorModelAnalysisResult",
               "Get-IOTEAlarmModelList",
               "Get-IOTEAlarmModelVersionList",
               "Get-IOTEDetectorModelList",
               "Get-IOTEDetectorModelVersionList",
               "Get-IOTEInputRoutingList",
               "Get-IOTEInputList",
               "Get-IOTEResourceTag",
               "Write-IOTELoggingOption",
               "Start-IOTEDetectorModelAnalysis",
               "Add-IOTEResourceTag",
               "Remove-IOTEResourceTag",
               "Update-IOTEAlarmModel",
               "Update-IOTEDetectorModel",
               "Update-IOTEInput")
}

_awsArgumentCompleterRegistration $IOTE_SelectCompleters $IOTE_SelectMap
# Argument completions for service AWS IoT Events Data


$IOTED_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTED.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTED_SelectMap = @{
    "Select"=@("Send-IOTEDAcknowledgeAlarm",
               "Remove-IOTEDDetectorBatch",
               "Send-IOTEDDisableAlarm",
               "Send-IOTEDEnableAlarm",
               "Send-IOTEDMessageBatch",
               "Send-IOTEDResetAlarm",
               "Send-IOTEDSnoozeAlarm",
               "Update-IOTEDDetectorBatch",
               "Get-IOTEDAlarm",
               "Get-IOTEDDetector",
               "Get-IOTEDAlarmList",
               "Get-IOTEDDetectorList")
}

_awsArgumentCompleterRegistration $IOTED_SelectCompleters $IOTED_SelectMap
# Argument completions for service AWS IoT Fleet Hub


$IOTFH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTFH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTFH_SelectMap = @{
    "Select"=@("New-IOTFHApplication",
               "Remove-IOTFHApplication",
               "Get-IOTFHApplication",
               "Get-IOTFHApplicationList",
               "Get-IOTFHResourceTag",
               "Add-IOTFHResourceTag",
               "Remove-IOTFHResourceTag",
               "Update-IOTFHApplication")
}

_awsArgumentCompleterRegistration $IOTFH_SelectCompleters $IOTFH_SelectMap
# Argument completions for service AWS IoT FleetWise


$IFW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTFleetWise.Compression
        "New-IFWCampaign/Compression"
        {
            $v = "OFF","SNAPPY"
            break
        }

        # Amazon.IoTFleetWise.DiagnosticsMode
        "New-IFWCampaign/DiagnosticsMode"
        {
            $v = "OFF","SEND_ACTIVE_DTCS"
            break
        }

        # Amazon.IoTFleetWise.LogType
        "Write-IFWLoggingOption/CloudWatchLogDelivery_LogType"
        {
            $v = "ERROR","OFF"
            break
        }

        # Amazon.IoTFleetWise.ManifestStatus
        {
            ($_ -eq "Update-IFWDecoderManifest/Status") -Or
            ($_ -eq "Update-IFWModelManifest/Status")
        }
        {
            $v = "ACTIVE","DRAFT"
            break
        }

        # Amazon.IoTFleetWise.SpoolingMode
        "New-IFWCampaign/SpoolingMode"
        {
            $v = "OFF","TO_DISK"
            break
        }

        # Amazon.IoTFleetWise.TriggerMode
        "New-IFWCampaign/CollectionScheme_ConditionBasedCollectionScheme_TriggerMode"
        {
            $v = "ALWAYS","RISING_EDGE"
            break
        }

        # Amazon.IoTFleetWise.UpdateCampaignAction
        "Update-IFWCampaign/Action"
        {
            $v = "APPROVE","RESUME","SUSPEND","UPDATE"
            break
        }

        # Amazon.IoTFleetWise.UpdateMode
        "Update-IFWVehicle/AttributeUpdateMode"
        {
            $v = "Merge","Overwrite"
            break
        }

        # Amazon.IoTFleetWise.VehicleAssociationBehavior
        "New-IFWVehicle/AssociationBehavior"
        {
            $v = "CreateIotThing","ValidateIotThingExists"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IFW_map = @{
    "Action"=@("Update-IFWCampaign")
    "AssociationBehavior"=@("New-IFWVehicle")
    "AttributeUpdateMode"=@("Update-IFWVehicle")
    "CloudWatchLogDelivery_LogType"=@("Write-IFWLoggingOption")
    "CollectionScheme_ConditionBasedCollectionScheme_TriggerMode"=@("New-IFWCampaign")
    "Compression"=@("New-IFWCampaign")
    "DiagnosticsMode"=@("New-IFWCampaign")
    "SpoolingMode"=@("New-IFWCampaign")
    "Status"=@("Update-IFWDecoderManifest","Update-IFWModelManifest")
}

_awsArgumentCompleterRegistration $IFW_Completers $IFW_map

$IFW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IFW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IFW_SelectMap = @{
    "Select"=@("New-IFWVehicleFleet",
               "New-IFWCreateVehicle",
               "New-IFWUpdateVehicle",
               "New-IFWCampaign",
               "New-IFWDecoderManifest",
               "New-IFWFleet",
               "New-IFWModelManifest",
               "New-IFWSignalCatalog",
               "New-IFWVehicle",
               "Remove-IFWCampaign",
               "Remove-IFWDecoderManifest",
               "Remove-IFWFleet",
               "Remove-IFWModelManifest",
               "Remove-IFWSignalCatalog",
               "Remove-IFWVehicle",
               "Remove-IFWVehicleFleet",
               "Get-IFWCampaign",
               "Get-IFWDecoderManifest",
               "Get-IFWFleet",
               "Get-IFWLoggingOption",
               "Get-IFWModelManifest",
               "Get-IFWRegisterAccountStatus",
               "Get-IFWSignalCatalog",
               "Get-IFWVehicle",
               "Get-IFWVehicleStatus",
               "Import-IFWDecoderManifest",
               "Import-IFWSignalCatalog",
               "Get-IFWCampaignList",
               "Get-IFWDecoderManifestNetworkInterfaceList",
               "Get-IFWDecoderManifestList",
               "Get-IFWDecoderManifestSignalList",
               "Get-IFWFleetList",
               "Get-IFWFleetsForVehicleList",
               "Get-IFWModelManifestNodeList",
               "Get-IFWModelManifestList",
               "Get-IFWSignalCatalogNodeList",
               "Get-IFWSignalCatalogList",
               "Get-IFWResourceTag",
               "Get-IFWVehicleList",
               "Get-IFWVehiclesInFleetList",
               "Write-IFWLoggingOption",
               "Register-IFWAccount",
               "Add-IFWResourceTag",
               "Remove-IFWResourceTag",
               "Update-IFWCampaign",
               "Update-IFWDecoderManifest",
               "Update-IFWFleet",
               "Update-IFWModelManifest",
               "Update-IFWSignalCatalog",
               "Update-IFWVehicle")
}

_awsArgumentCompleterRegistration $IFW_SelectCompleters $IFW_SelectMap
# Argument completions for service AWS IoT Jobs Data Plane


$IOTJ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTJobsDataPlane.JobExecutionStatus
        "Update-IOTJJobExecution/Status"
        {
            $v = "CANCELED","FAILED","IN_PROGRESS","QUEUED","REJECTED","REMOVED","SUCCEEDED","TIMED_OUT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTJ_map = @{
    "Status"=@("Update-IOTJJobExecution")
}

_awsArgumentCompleterRegistration $IOTJ_Completers $IOTJ_map

$IOTJ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTJ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTJ_SelectMap = @{
    "Select"=@("Get-IOTJJobExecution",
               "Get-IOTJPendingJobExecution",
               "Start-IOTJNextPendingJobExecution",
               "Update-IOTJJobExecution")
}

_awsArgumentCompleterRegistration $IOTJ_SelectCompleters $IOTJ_SelectMap
# Argument completions for service AWS IoT Secure Tunneling


$IOTST_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTSecureTunneling.ClientMode
        "Invoke-IOTSTTunnelAccessTokenRotation/ClientMode"
        {
            $v = "ALL","DESTINATION","SOURCE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTST_map = @{
    "ClientMode"=@("Invoke-IOTSTTunnelAccessTokenRotation")
}

_awsArgumentCompleterRegistration $IOTST_Completers $IOTST_map

$IOTST_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTST.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTST_SelectMap = @{
    "Select"=@("Close-IOTSTTunnel",
               "Get-IOTSTTunnel",
               "Get-IOTSTResourceTag",
               "Get-IOTSTTunnelList",
               "Open-IOTSTTunnel",
               "Invoke-IOTSTTunnelAccessTokenRotation",
               "Add-IOTSTResourceTag",
               "Remove-IOTSTResourceTag")
}

_awsArgumentCompleterRegistration $IOTST_SelectCompleters $IOTST_SelectMap
# Argument completions for service AWS IoT SiteWise


$IOTSW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTSiteWise.AuthMode
        "New-IOTSWPortal/PortalAuthMode"
        {
            $v = "IAM","SSO"
            break
        }

        # Amazon.IoTSiteWise.DisassociatedDataStorageState
        "Write-IOTSWStorageConfiguration/DisassociatedDataStorage"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.IoTSiteWise.EncryptionType
        "Write-IOTSWDefaultEncryptionConfiguration/EncryptionType"
        {
            $v = "KMS_BASED_ENCRYPTION","SITEWISE_DEFAULT_ENCRYPTION"
            break
        }

        # Amazon.IoTSiteWise.IdentityType
        "Get-IOTSWAccessPolicyList/IdentityType"
        {
            $v = "GROUP","IAM","USER"
            break
        }

        # Amazon.IoTSiteWise.ImageFileType
        {
            ($_ -eq "Update-IOTSWPortal/PortalLogoImage_File_Type") -Or
            ($_ -eq "New-IOTSWPortal/PortalLogoImageFile_Type")
        }
        {
            $v = "PNG"
            break
        }

        # Amazon.IoTSiteWise.ListAssetModelPropertiesFilter
        "Get-IOTSWAssetModelPropertyList/Filter"
        {
            $v = "ALL","BASE"
            break
        }

        # Amazon.IoTSiteWise.ListAssetPropertiesFilter
        "Get-IOTSWAssetPropertyList/Filter"
        {
            $v = "ALL","BASE"
            break
        }

        # Amazon.IoTSiteWise.ListAssetsFilter
        "Get-IOTSWAssetList/Filter"
        {
            $v = "ALL","TOP_LEVEL"
            break
        }

        # Amazon.IoTSiteWise.ListBulkImportJobsFilter
        "Get-IOTSWBulkImportJobList/Filter"
        {
            $v = "ALL","CANCELLED","COMPLETED","COMPLETED_WITH_FAILURES","FAILED","PENDING","RUNNING"
            break
        }

        # Amazon.IoTSiteWise.ListTimeSeriesType
        "Get-IOTSWTimeSeriesList/TimeSeriesType"
        {
            $v = "ASSOCIATED","DISASSOCIATED"
            break
        }

        # Amazon.IoTSiteWise.LoggingLevel
        "Write-IOTSWLoggingOption/LoggingOptions_Level"
        {
            $v = "ERROR","INFO","OFF"
            break
        }

        # Amazon.IoTSiteWise.Permission
        {
            ($_ -eq "New-IOTSWAccessPolicy/AccessPolicyPermission") -Or
            ($_ -eq "Update-IOTSWAccessPolicy/AccessPolicyPermission")
        }
        {
            $v = "ADMINISTRATOR","VIEWER"
            break
        }

        # Amazon.IoTSiteWise.PropertyNotificationState
        "Update-IOTSWAssetProperty/PropertyNotificationState"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.IoTSiteWise.Quality
        "Get-IOTSWInterpolatedAssetPropertyValue/Quality"
        {
            $v = "BAD","GOOD","UNCERTAIN"
            break
        }

        # Amazon.IoTSiteWise.ResourceType
        "Get-IOTSWAccessPolicyList/ResourceType"
        {
            $v = "PORTAL","PROJECT"
            break
        }

        # Amazon.IoTSiteWise.StorageType
        "Write-IOTSWStorageConfiguration/StorageType"
        {
            $v = "MULTI_LAYER_STORAGE","SITEWISE_DEFAULT_STORAGE"
            break
        }

        # Amazon.IoTSiteWise.TimeOrdering
        {
            ($_ -eq "Get-IOTSWAssetPropertyAggregate/TimeOrdering") -Or
            ($_ -eq "Get-IOTSWAssetPropertyValueHistory/TimeOrdering")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.IoTSiteWise.TraversalDirection
        "Get-IOTSWAssociatedAssetList/TraversalDirection"
        {
            $v = "CHILD","PARENT"
            break
        }

        # Amazon.IoTSiteWise.TraversalType
        "Get-IOTSWAssetRelationshipList/TraversalType"
        {
            $v = "PATH_TO_ROOT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTSW_map = @{
    "AccessPolicyPermission"=@("New-IOTSWAccessPolicy","Update-IOTSWAccessPolicy")
    "DisassociatedDataStorage"=@("Write-IOTSWStorageConfiguration")
    "EncryptionType"=@("Write-IOTSWDefaultEncryptionConfiguration")
    "Filter"=@("Get-IOTSWAssetList","Get-IOTSWAssetModelPropertyList","Get-IOTSWAssetPropertyList","Get-IOTSWBulkImportJobList")
    "IdentityType"=@("Get-IOTSWAccessPolicyList")
    "LoggingOptions_Level"=@("Write-IOTSWLoggingOption")
    "PortalAuthMode"=@("New-IOTSWPortal")
    "PortalLogoImage_File_Type"=@("Update-IOTSWPortal")
    "PortalLogoImageFile_Type"=@("New-IOTSWPortal")
    "PropertyNotificationState"=@("Update-IOTSWAssetProperty")
    "Quality"=@("Get-IOTSWInterpolatedAssetPropertyValue")
    "ResourceType"=@("Get-IOTSWAccessPolicyList")
    "StorageType"=@("Write-IOTSWStorageConfiguration")
    "TimeOrdering"=@("Get-IOTSWAssetPropertyAggregate","Get-IOTSWAssetPropertyValueHistory")
    "TimeSeriesType"=@("Get-IOTSWTimeSeriesList")
    "TraversalDirection"=@("Get-IOTSWAssociatedAssetList")
    "TraversalType"=@("Get-IOTSWAssetRelationshipList")
}

_awsArgumentCompleterRegistration $IOTSW_Completers $IOTSW_map

$IOTSW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTSW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTSW_SelectMap = @{
    "Select"=@("Connect-IOTSWAsset",
               "Add-IOTSWTimeSeriesToAssetProperty",
               "Connect-IOTSWAssociateProjectAsset",
               "Disconnect-IOTSWDisassociateProjectAsset",
               "Get-IOTSWBatchAssetPropertyAggregate",
               "Get-IOTSWBatchAssetPropertyValue",
               "Get-IOTSWBatchAssetPropertyValueHistory",
               "Import-IOTSWPutAssetPropertyValue",
               "New-IOTSWAccessPolicy",
               "New-IOTSWAsset",
               "New-IOTSWAssetModel",
               "New-IOTSWBulkImportJob",
               "New-IOTSWDashboard",
               "New-IOTSWGateway",
               "New-IOTSWPortal",
               "New-IOTSWProject",
               "Remove-IOTSWAccessPolicy",
               "Remove-IOTSWAsset",
               "Remove-IOTSWAssetModel",
               "Remove-IOTSWDashboard",
               "Remove-IOTSWGateway",
               "Remove-IOTSWPortal",
               "Remove-IOTSWProject",
               "Remove-IOTSWTimeSeries",
               "Get-IOTSWAccessPolicy",
               "Get-IOTSWAsset",
               "Get-IOTSWAssetModel",
               "Get-IOTSWAssetProperty",
               "Get-IOTSWBulkImportJob",
               "Get-IOTSWDashboard",
               "Get-IOTSWDefaultEncryptionConfiguration",
               "Get-IOTSWGateway",
               "Get-IOTSWGatewayCapabilityConfiguration",
               "Get-IOTSWLoggingOption",
               "Get-IOTSWPortal",
               "Get-IOTSWProject",
               "Get-IOTSWStorageConfiguration",
               "Get-IOTSWTimeSeries",
               "Disconnect-IOTSWAsset",
               "Remove-IOTSWTimeSeriesFromAssetProperty",
               "Get-IOTSWAssetPropertyAggregate",
               "Get-IOTSWAssetPropertyValue",
               "Get-IOTSWAssetPropertyValueHistory",
               "Get-IOTSWInterpolatedAssetPropertyValue",
               "Get-IOTSWAccessPolicyList",
               "Get-IOTSWAssetModelPropertyList",
               "Get-IOTSWAssetModelList",
               "Get-IOTSWAssetPropertyList",
               "Get-IOTSWAssetRelationshipList",
               "Get-IOTSWAssetList",
               "Get-IOTSWAssociatedAssetList",
               "Get-IOTSWBulkImportJobList",
               "Get-IOTSWDashboardList",
               "Get-IOTSWGatewayList",
               "Get-IOTSWPortalList",
               "Get-IOTSWProjectAssetList",
               "Get-IOTSWProjectList",
               "Get-IOTSWResourceTag",
               "Get-IOTSWTimeSeriesList",
               "Write-IOTSWDefaultEncryptionConfiguration",
               "Write-IOTSWLoggingOption",
               "Write-IOTSWStorageConfiguration",
               "Add-IOTSWResourceTag",
               "Remove-IOTSWResourceTag",
               "Update-IOTSWAccessPolicy",
               "Update-IOTSWAsset",
               "Update-IOTSWAssetModel",
               "Update-IOTSWAssetProperty",
               "Update-IOTSWDashboard",
               "Update-IOTSWGateway",
               "Update-IOTSWGatewayCapabilityConfiguration",
               "Update-IOTSWPortal",
               "Update-IOTSWProject")
}

_awsArgumentCompleterRegistration $IOTSW_SelectCompleters $IOTSW_SelectMap
# Argument completions for service AWS IoT Things Graph


$IOTTG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTThingsGraph.DefinitionLanguage
        {
            ($_ -eq "New-IOTTGFlowTemplate/Definition_Language") -Or
            ($_ -eq "New-IOTTGSystemInstance/Definition_Language") -Or
            ($_ -eq "New-IOTTGSystemTemplate/Definition_Language") -Or
            ($_ -eq "Update-IOTTGFlowTemplate/Definition_Language") -Or
            ($_ -eq "Update-IOTTGSystemTemplate/Definition_Language") -Or
            ($_ -eq "Set-IOTTGEntityDefinition/Document_Language")
        }
        {
            $v = "GRAPHQL"
            break
        }

        # Amazon.IoTThingsGraph.DeploymentTarget
        "New-IOTTGSystemInstance/Target"
        {
            $v = "CLOUD","GREENGRASS"
            break
        }

        # Amazon.IoTThingsGraph.EntityType
        "Remove-IOTTGEntityFromThing/EntityType"
        {
            $v = "ACTION","CAPABILITY","DEVICE","DEVICE_MODEL","ENUM","EVENT","MAPPING","PROPERTY","SERVICE","STATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTG_map = @{
    "Definition_Language"=@("New-IOTTGFlowTemplate","New-IOTTGSystemInstance","New-IOTTGSystemTemplate","Update-IOTTGFlowTemplate","Update-IOTTGSystemTemplate")
    "Document_Language"=@("Set-IOTTGEntityDefinition")
    "EntityType"=@("Remove-IOTTGEntityFromThing")
    "Target"=@("New-IOTTGSystemInstance")
}

_awsArgumentCompleterRegistration $IOTTG_Completers $IOTTG_map

$IOTTG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTTG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTG_SelectMap = @{
    "Select"=@("Add-IOTTGEntityToThing",
               "New-IOTTGFlowTemplate",
               "New-IOTTGSystemInstance",
               "New-IOTTGSystemTemplate",
               "Remove-IOTTGFlowTemplate",
               "Remove-IOTTGNamespace",
               "Remove-IOTTGSystemInstance",
               "Remove-IOTTGSystemTemplate",
               "Add-IOTTGSystemInstanceDeployment",
               "Set-IOTTGFlowTemplateDeprecation",
               "Set-IOTTGSystemTemplateDeprecation",
               "Get-IOTTGNamespace",
               "Remove-IOTTGEntityFromThing",
               "Get-IOTTGEntity",
               "Get-IOTTGFlowTemplate",
               "Get-IOTTGFlowTemplateRevision",
               "Get-IOTTGNamespaceDeletionStatus",
               "Get-IOTTGSystemInstance",
               "Get-IOTTGSystemTemplate",
               "Get-IOTTGSystemTemplateRevision",
               "Get-IOTTGUploadStatus",
               "Get-IOTTGFlowExecutionMessageList",
               "Get-IOTTGResourceTag",
               "Search-IOTTGEntity",
               "Search-IOTTGFlowExecution",
               "Search-IOTTGFlowTemplate",
               "Search-IOTTGSystemInstance",
               "Search-IOTTGSystemTemplate",
               "Search-IOTTGThing",
               "Add-IOTTGResourceTag",
               "Remove-IOTTGSystemInstanceDeployment",
               "Remove-IOTTGResourceTag",
               "Update-IOTTGFlowTemplate",
               "Update-IOTTGSystemTemplate",
               "Set-IOTTGEntityDefinition")
}

_awsArgumentCompleterRegistration $IOTTG_SelectCompleters $IOTTG_SelectMap
# Argument completions for service AWS IoT TwinMaker


$IOTTM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTTwinMaker.InterpolationType
        "Get-IOTTMPropertyValueHistory/Interpolation_InterpolationType"
        {
            $v = "LINEAR"
            break
        }

        # Amazon.IoTTwinMaker.OrderByTime
        "Get-IOTTMPropertyValueHistory/OrderByTime"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.IoTTwinMaker.ParentEntityUpdateType
        "Update-IOTTMEntity/ParentEntityUpdate_UpdateType"
        {
            $v = "DELETE","UPDATE"
            break
        }

        # Amazon.IoTTwinMaker.PricingMode
        "Update-IOTTMPricingPlan/PricingMode"
        {
            $v = "BASIC","STANDARD","TIERED_BUNDLE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTM_map = @{
    "Interpolation_InterpolationType"=@("Get-IOTTMPropertyValueHistory")
    "OrderByTime"=@("Get-IOTTMPropertyValueHistory")
    "ParentEntityUpdate_UpdateType"=@("Update-IOTTMEntity")
    "PricingMode"=@("Update-IOTTMPricingPlan")
}

_awsArgumentCompleterRegistration $IOTTM_Completers $IOTTM_map

$IOTTM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTTM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTM_SelectMap = @{
    "Select"=@("Import-IOTTMPutPropertyValue",
               "New-IOTTMComponentType",
               "New-IOTTMEntity",
               "New-IOTTMScene",
               "New-IOTTMWorkspace",
               "Remove-IOTTMComponentType",
               "Remove-IOTTMEntity",
               "Remove-IOTTMScene",
               "Remove-IOTTMWorkspace",
               "Invoke-IOTTMQuery",
               "Get-IOTTMComponentType",
               "Get-IOTTMEntity",
               "Get-IOTTMPricingPlan",
               "Get-IOTTMPropertyValue",
               "Get-IOTTMPropertyValueHistory",
               "Get-IOTTMScene",
               "Get-IOTTMWorkspace",
               "Get-IOTTMComponentTypeList",
               "Get-IOTTMEntityList",
               "Get-IOTTMSceneList",
               "Get-IOTTMResourceTag",
               "Get-IOTTMWorkspaceList",
               "Add-IOTTMResourceTag",
               "Remove-IOTTMResourceTag",
               "Update-IOTTMComponentType",
               "Update-IOTTMEntity",
               "Update-IOTTMPricingPlan",
               "Update-IOTTMScene",
               "Update-IOTTMWorkspace")
}

_awsArgumentCompleterRegistration $IOTTM_SelectCompleters $IOTTM_SelectMap
# Argument completions for service AWS IoT Wireless


$IOTW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTWireless.DlClass
        {
            ($_ -eq "New-IOTWMulticastGroup/LoRaWAN_DlClass") -Or
            ($_ -eq "Update-IOTWMulticastGroup/LoRaWAN_DlClass")
        }
        {
            $v = "ClassB","ClassC"
            break
        }

        # Amazon.IoTWireless.DownlinkMode
        "Send-IOTWDataToWirelessDevice/WirelessMetadata_LoRaWAN_ParticipatingGateways_DownlinkMode"
        {
            $v = "CONCURRENT","SEQUENTIAL","USING_UPLINK_GATEWAY"
            break
        }

        # Amazon.IoTWireless.EventNotificationPartnerType
        {
            ($_ -eq "Get-IOTWResourceEventConfiguration/PartnerType") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/PartnerType")
        }
        {
            $v = "Sidewalk"
            break
        }

        # Amazon.IoTWireless.EventNotificationResourceType
        "Get-IOTWEventConfigurationList/ResourceType"
        {
            $v = "SidewalkAccount","WirelessDevice","WirelessGateway"
            break
        }

        # Amazon.IoTWireless.EventNotificationTopicStatus
        {
            ($_ -eq "Update-IOTWResourceEventConfiguration/ConnectionStatus_LoRaWAN_GatewayEuiEventTopic") -Or
            ($_ -eq "Update-IOTWEventConfigurationByResourceType/ConnectionStatus_LoRaWAN_WirelessGatewayEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/ConnectionStatus_WirelessGatewayIdEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/DeviceRegistrationState_Sidewalk_AmazonIdEventTopic") -Or
            ($_ -eq "Update-IOTWEventConfigurationByResourceType/DeviceRegistrationState_Sidewalk_WirelessDeviceEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/DeviceRegistrationState_WirelessDeviceIdEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/Join_LoRaWAN_DevEuiEventTopic") -Or
            ($_ -eq "Update-IOTWEventConfigurationByResourceType/Join_LoRaWAN_WirelessDeviceEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/Join_WirelessDeviceIdEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/MessageDeliveryStatus_Sidewalk_AmazonIdEventTopic") -Or
            ($_ -eq "Update-IOTWEventConfigurationByResourceType/MessageDeliveryStatus_Sidewalk_WirelessDeviceEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/MessageDeliveryStatus_WirelessDeviceIdEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/Proximity_Sidewalk_AmazonIdEventTopic") -Or
            ($_ -eq "Update-IOTWEventConfigurationByResourceType/Proximity_Sidewalk_WirelessDeviceEventTopic") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/Proximity_WirelessDeviceIdEventTopic")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.IoTWireless.ExpressionType
        {
            ($_ -eq "New-IOTWDestination/ExpressionType") -Or
            ($_ -eq "Update-IOTWDestination/ExpressionType")
        }
        {
            $v = "MqttTopic","RuleName"
            break
        }

        # Amazon.IoTWireless.IdentifierType
        {
            ($_ -eq "Get-IOTWResourceEventConfiguration/IdentifierType") -Or
            ($_ -eq "Update-IOTWResourceEventConfiguration/IdentifierType")
        }
        {
            $v = "DevEui","GatewayEui","PartnerAccountId","WirelessDeviceId","WirelessGatewayId"
            break
        }

        # Amazon.IoTWireless.LogLevel
        {
            ($_ -eq "Update-IOTWLogLevelsByResourceType/DefaultLogLevel") -Or
            ($_ -eq "Write-IOTWResourceLogLevel/LogLevel") -Or
            ($_ -eq "New-IOTWNetworkAnalyzerConfiguration/TraceContent_LogLevel") -Or
            ($_ -eq "Update-IOTWNetworkAnalyzerConfiguration/TraceContent_LogLevel")
        }
        {
            $v = "DISABLED","ERROR","INFO"
            break
        }

        # Amazon.IoTWireless.MessageType
        "Send-IOTWDataToWirelessDevice/WirelessMetadata_Sidewalk_MessageType"
        {
            $v = "CUSTOM_COMMAND_ID_GET","CUSTOM_COMMAND_ID_NOTIFY","CUSTOM_COMMAND_ID_RESP","CUSTOM_COMMAND_ID_SET"
            break
        }

        # Amazon.IoTWireless.PartnerType
        {
            ($_ -eq "Get-IOTWPartnerAccount/PartnerType") -Or
            ($_ -eq "Split-IOTWAwsAccountFromPartnerAccount/PartnerType") -Or
            ($_ -eq "Update-IOTWPartnerAccount/PartnerType")
        }
        {
            $v = "Sidewalk"
            break
        }

        # Amazon.IoTWireless.PositionConfigurationFec
        "Write-IOTWPositionConfiguration/Solvers_SemtechGnss_Fec"
        {
            $v = "NONE","ROSE"
            break
        }

        # Amazon.IoTWireless.PositionConfigurationStatus
        "Write-IOTWPositionConfiguration/Solvers_SemtechGnss_Status"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.IoTWireless.PositionResourceType
        {
            ($_ -eq "Get-IOTWPosition/ResourceType") -Or
            ($_ -eq "Get-IOTWPositionConfiguration/ResourceType") -Or
            ($_ -eq "Get-IOTWPositionConfigurationList/ResourceType") -Or
            ($_ -eq "Update-IOTWPosition/ResourceType") -Or
            ($_ -eq "Write-IOTWPositionConfiguration/ResourceType")
        }
        {
            $v = "WirelessDevice","WirelessGateway"
            break
        }

        # Amazon.IoTWireless.SupportedRfRegion
        {
            ($_ -eq "New-IOTWFuotaTask/LoRaWAN_RfRegion") -Or
            ($_ -eq "New-IOTWMulticastGroup/LoRaWAN_RfRegion") -Or
            ($_ -eq "Update-IOTWFuotaTask/LoRaWAN_RfRegion") -Or
            ($_ -eq "Update-IOTWMulticastGroup/LoRaWAN_RfRegion")
        }
        {
            $v = "AS923-1","AU915","EU868","US915"
            break
        }

        # Amazon.IoTWireless.WirelessDeviceFrameInfo
        {
            ($_ -eq "New-IOTWNetworkAnalyzerConfiguration/TraceContent_WirelessDeviceFrameInfo") -Or
            ($_ -eq "Update-IOTWNetworkAnalyzerConfiguration/TraceContent_WirelessDeviceFrameInfo")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.IoTWireless.WirelessDeviceIdType
        "Get-IOTWWirelessDevice/IdentifierType"
        {
            $v = "DevEui","SidewalkManufacturingSn","ThingName","WirelessDeviceId"
            break
        }

        # Amazon.IoTWireless.WirelessDeviceType
        {
            ($_ -eq "New-IOTWWirelessDevice/Type") -Or
            ($_ -eq "Get-IOTWQueuedMessageList/WirelessDeviceType") -Or
            ($_ -eq "Get-IOTWWirelessDeviceList/WirelessDeviceType") -Or
            ($_ -eq "Remove-IOTWQueuedMessage/WirelessDeviceType")
        }
        {
            $v = "LoRaWAN","Sidewalk"
            break
        }

        # Amazon.IoTWireless.WirelessGatewayIdType
        "Get-IOTWWirelessGateway/IdentifierType"
        {
            $v = "GatewayEui","ThingName","WirelessGatewayId"
            break
        }

        # Amazon.IoTWireless.WirelessGatewayServiceType
        "Get-IOTWServiceEndpoint/ServiceType"
        {
            $v = "CUPS","LNS"
            break
        }

        # Amazon.IoTWireless.WirelessGatewayTaskDefinitionType
        "Get-IOTWWirelessGatewayTaskDefinitionList/TaskDefinitionType"
        {
            $v = "UPDATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTW_map = @{
    "ConnectionStatus_LoRaWAN_GatewayEuiEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "ConnectionStatus_LoRaWAN_WirelessGatewayEventTopic"=@("Update-IOTWEventConfigurationByResourceType")
    "ConnectionStatus_WirelessGatewayIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "DefaultLogLevel"=@("Update-IOTWLogLevelsByResourceType")
    "DeviceRegistrationState_Sidewalk_AmazonIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "DeviceRegistrationState_Sidewalk_WirelessDeviceEventTopic"=@("Update-IOTWEventConfigurationByResourceType")
    "DeviceRegistrationState_WirelessDeviceIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "ExpressionType"=@("New-IOTWDestination","Update-IOTWDestination")
    "IdentifierType"=@("Get-IOTWResourceEventConfiguration","Get-IOTWWirelessDevice","Get-IOTWWirelessGateway","Update-IOTWResourceEventConfiguration")
    "Join_LoRaWAN_DevEuiEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "Join_LoRaWAN_WirelessDeviceEventTopic"=@("Update-IOTWEventConfigurationByResourceType")
    "Join_WirelessDeviceIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "LogLevel"=@("Write-IOTWResourceLogLevel")
    "LoRaWAN_DlClass"=@("New-IOTWMulticastGroup","Update-IOTWMulticastGroup")
    "LoRaWAN_RfRegion"=@("New-IOTWFuotaTask","New-IOTWMulticastGroup","Update-IOTWFuotaTask","Update-IOTWMulticastGroup")
    "MessageDeliveryStatus_Sidewalk_AmazonIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "MessageDeliveryStatus_Sidewalk_WirelessDeviceEventTopic"=@("Update-IOTWEventConfigurationByResourceType")
    "MessageDeliveryStatus_WirelessDeviceIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "PartnerType"=@("Get-IOTWPartnerAccount","Get-IOTWResourceEventConfiguration","Split-IOTWAwsAccountFromPartnerAccount","Update-IOTWPartnerAccount","Update-IOTWResourceEventConfiguration")
    "Proximity_Sidewalk_AmazonIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "Proximity_Sidewalk_WirelessDeviceEventTopic"=@("Update-IOTWEventConfigurationByResourceType")
    "Proximity_WirelessDeviceIdEventTopic"=@("Update-IOTWResourceEventConfiguration")
    "ResourceType"=@("Get-IOTWEventConfigurationList","Get-IOTWPosition","Get-IOTWPositionConfiguration","Get-IOTWPositionConfigurationList","Update-IOTWPosition","Write-IOTWPositionConfiguration")
    "ServiceType"=@("Get-IOTWServiceEndpoint")
    "Solvers_SemtechGnss_Fec"=@("Write-IOTWPositionConfiguration")
    "Solvers_SemtechGnss_Status"=@("Write-IOTWPositionConfiguration")
    "TaskDefinitionType"=@("Get-IOTWWirelessGatewayTaskDefinitionList")
    "TraceContent_LogLevel"=@("New-IOTWNetworkAnalyzerConfiguration","Update-IOTWNetworkAnalyzerConfiguration")
    "TraceContent_WirelessDeviceFrameInfo"=@("New-IOTWNetworkAnalyzerConfiguration","Update-IOTWNetworkAnalyzerConfiguration")
    "Type"=@("New-IOTWWirelessDevice")
    "WirelessDeviceType"=@("Get-IOTWQueuedMessageList","Get-IOTWWirelessDeviceList","Remove-IOTWQueuedMessage")
    "WirelessMetadata_LoRaWAN_ParticipatingGateways_DownlinkMode"=@("Send-IOTWDataToWirelessDevice")
    "WirelessMetadata_Sidewalk_MessageType"=@("Send-IOTWDataToWirelessDevice")
}

_awsArgumentCompleterRegistration $IOTW_Completers $IOTW_map

$IOTW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTW_SelectMap = @{
    "Select"=@("Join-IOTWAwsAccountWithPartnerAccount",
               "Join-IOTWMulticastGroupWithFuotaTask",
               "Join-IOTWWirelessDeviceWithFuotaTask",
               "Join-IOTWWirelessDeviceWithMulticastGroup",
               "Join-IOTWWirelessDeviceWithThing",
               "Join-IOTWWirelessGatewayWithCertificate",
               "Join-IOTWWirelessGatewayWithThing",
               "Stop-IOTWMulticastGroupSession",
               "New-IOTWDestination",
               "New-IOTWDeviceProfile",
               "New-IOTWFuotaTask",
               "New-IOTWMulticastGroup",
               "New-IOTWNetworkAnalyzerConfiguration",
               "New-IOTWServiceProfile",
               "New-IOTWWirelessDevice",
               "New-IOTWWirelessGateway",
               "New-IOTWWirelessGatewayTask",
               "New-IOTWWirelessGatewayTaskDefinition",
               "Remove-IOTWDestination",
               "Remove-IOTWDeviceProfile",
               "Remove-IOTWFuotaTask",
               "Remove-IOTWMulticastGroup",
               "Remove-IOTWNetworkAnalyzerConfiguration",
               "Remove-IOTWQueuedMessage",
               "Remove-IOTWServiceProfile",
               "Remove-IOTWWirelessDevice",
               "Remove-IOTWWirelessGateway",
               "Remove-IOTWWirelessGatewayTask",
               "Remove-IOTWWirelessGatewayTaskDefinition",
               "Split-IOTWAwsAccountFromPartnerAccount",
               "Split-IOTWMulticastGroupFromFuotaTask",
               "Split-IOTWWirelessDeviceFromFuotaTask",
               "Split-IOTWWirelessDeviceFromMulticastGroup",
               "Split-IOTWWirelessDeviceFromThing",
               "Split-IOTWWirelessGatewayFromCertificate",
               "Split-IOTWWirelessGatewayFromThing",
               "Get-IOTWDestination",
               "Get-IOTWDeviceProfile",
               "Get-IOTWEventConfigurationByResourceType",
               "Get-IOTWFuotaTask",
               "Get-IOTWLogLevelsByResourceType",
               "Get-IOTWMulticastGroup",
               "Get-IOTWMulticastGroupSession",
               "Get-IOTWNetworkAnalyzerConfiguration",
               "Get-IOTWPartnerAccount",
               "Get-IOTWPosition",
               "Get-IOTWPositionConfiguration",
               "Get-IOTWResourceEventConfiguration",
               "Get-IOTWResourceLogLevel",
               "Get-IOTWServiceEndpoint",
               "Get-IOTWServiceProfile",
               "Get-IOTWWirelessDevice",
               "Get-IOTWWirelessDeviceStatistic",
               "Get-IOTWWirelessGateway",
               "Get-IOTWWirelessGatewayCertificate",
               "Get-IOTWWirelessGatewayFirmwareInformation",
               "Get-IOTWWirelessGatewayStatistic",
               "Get-IOTWWirelessGatewayTask",
               "Get-IOTWWirelessGatewayTaskDefinition",
               "Get-IOTWDestinationList",
               "Get-IOTWDeviceProfileList",
               "Get-IOTWEventConfigurationList",
               "Get-IOTWFuotaTaskList",
               "Get-IOTWMulticastGroupList",
               "Get-IOTWMulticastGroupsByFuotaTaskList",
               "Get-IOTWNetworkAnalyzerConfigurationList",
               "Get-IOTWPartnerAccountList",
               "Get-IOTWPositionConfigurationList",
               "Get-IOTWQueuedMessageList",
               "Get-IOTWServiceProfileList",
               "Get-IOTWResourceTag",
               "Get-IOTWWirelessDeviceList",
               "Get-IOTWWirelessGatewayList",
               "Get-IOTWWirelessGatewayTaskDefinitionList",
               "Write-IOTWPositionConfiguration",
               "Write-IOTWResourceLogLevel",
               "Reset-IOTWAllResourceLogLevel",
               "Reset-IOTWResourceLogLevel",
               "Send-IOTWDataToMulticastGroup",
               "Send-IOTWDataToWirelessDevice",
               "Start-IOTWBulkAssociateWirelessDeviceWithMulticastGroup",
               "Start-IOTWBulkDisassociateWirelessDeviceFromMulticastGroup",
               "Start-IOTWFuotaTask",
               "Start-IOTWMulticastGroupSession",
               "Add-IOTWResourceTag",
               "Test-IOTWWirelessDevice",
               "Remove-IOTWResourceTag",
               "Update-IOTWDestination",
               "Update-IOTWEventConfigurationByResourceType",
               "Update-IOTWFuotaTask",
               "Update-IOTWLogLevelsByResourceType",
               "Update-IOTWMulticastGroup",
               "Update-IOTWNetworkAnalyzerConfiguration",
               "Update-IOTWPartnerAccount",
               "Update-IOTWPosition",
               "Update-IOTWResourceEventConfiguration",
               "Update-IOTWWirelessDevice",
               "Update-IOTWWirelessGateway")
}

_awsArgumentCompleterRegistration $IOTW_SelectCompleters $IOTW_SelectMap
# Argument completions for service Amazon Interactive Video Service


$IVS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IVS.ChannelLatencyMode
        {
            ($_ -eq "New-IVSChannel/LatencyMode") -Or
            ($_ -eq "Update-IVSChannel/LatencyMode")
        }
        {
            $v = "LOW","NORMAL"
            break
        }

        # Amazon.IVS.ChannelType
        {
            ($_ -eq "New-IVSChannel/Type") -Or
            ($_ -eq "Update-IVSChannel/Type")
        }
        {
            $v = "BASIC","STANDARD"
            break
        }

        # Amazon.IVS.RecordingMode
        "New-IVSRecordingConfiguration/ThumbnailConfiguration_RecordingMode"
        {
            $v = "DISABLED","INTERVAL"
            break
        }

        # Amazon.IVS.StreamHealth
        "Get-IVSStreamList/FilterBy_Health"
        {
            $v = "HEALTHY","STARVING","UNKNOWN"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IVS_map = @{
    "FilterBy_Health"=@("Get-IVSStreamList")
    "LatencyMode"=@("New-IVSChannel","Update-IVSChannel")
    "ThumbnailConfiguration_RecordingMode"=@("New-IVSRecordingConfiguration")
    "Type"=@("New-IVSChannel","Update-IVSChannel")
}

_awsArgumentCompleterRegistration $IVS_Completers $IVS_map

$IVS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IVS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IVS_SelectMap = @{
    "Select"=@("Get-IVSChannelBatch",
               "Get-IVSStreamKeyBatch",
               "New-IVSChannel",
               "New-IVSRecordingConfiguration",
               "New-IVSStreamKey",
               "Remove-IVSChannel",
               "Remove-IVSPlaybackKeyPair",
               "Remove-IVSRecordingConfiguration",
               "Remove-IVSStreamKey",
               "Get-IVSChannel",
               "Get-IVSPlaybackKeyPair",
               "Get-IVSRecordingConfiguration",
               "Get-IVSStream",
               "Get-IVSStreamKey",
               "Get-IVSStreamSession",
               "Import-IVSPlaybackKeyPair",
               "Get-IVSChannelList",
               "Get-IVSPlaybackKeyPairList",
               "Get-IVSRecordingConfigurationList",
               "Get-IVSStreamKeyList",
               "Get-IVSStreamList",
               "Get-IVSStreamSessionList",
               "Get-IVSResourceTag",
               "Write-IVSMetadata",
               "Stop-IVSStream",
               "Add-IVSResourceTag",
               "Remove-IVSResourceTag",
               "Update-IVSChannel")
}

_awsArgumentCompleterRegistration $IVS_SelectCompleters $IVS_SelectMap
# Argument completions for service Amazon Interactive Video Service Chat


$IVSC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Ivschat.FallbackResult
        {
            ($_ -eq "New-IVSCRoom/MessageReviewHandler_FallbackResult") -Or
            ($_ -eq "Update-IVSCRoom/MessageReviewHandler_FallbackResult")
        }
        {
            $v = "ALLOW","DENY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IVSC_map = @{
    "MessageReviewHandler_FallbackResult"=@("New-IVSCRoom","Update-IVSCRoom")
}

_awsArgumentCompleterRegistration $IVSC_Completers $IVSC_map

$IVSC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IVSC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IVSC_SelectMap = @{
    "Select"=@("New-IVSCChatToken",
               "New-IVSCRoom",
               "Remove-IVSCMessage",
               "Remove-IVSCRoom",
               "Disconnect-IVSCUser",
               "Get-IVSCRoom",
               "Get-IVSCRoomList",
               "Get-IVSCResourceTag",
               "Send-IVSCEvent",
               "Add-IVSCResourceTag",
               "Remove-IVSCResourceTag",
               "Update-IVSCRoom")
}

_awsArgumentCompleterRegistration $IVSC_SelectCompleters $IVSC_SelectMap
# Argument completions for service Amazon Managed Streaming for Apache Kafka (MSK)


$MSK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kafka.ClientBroker
        {
            ($_ -eq "New-MSKCluster/EncryptionInfo_EncryptionInTransit_ClientBroker") -Or
            ($_ -eq "Update-MSKSecurity/EncryptionInfo_EncryptionInTransit_ClientBroker") -Or
            ($_ -eq "New-MSKClusterV2/Provisioned_EncryptionInfo_EncryptionInTransit_ClientBroker")
        }
        {
            $v = "PLAINTEXT","TLS","TLS_PLAINTEXT"
            break
        }

        # Amazon.Kafka.EnhancedMonitoring
        {
            ($_ -eq "New-MSKCluster/EnhancedMonitoring") -Or
            ($_ -eq "Update-MSKMonitoring/EnhancedMonitoring") -Or
            ($_ -eq "New-MSKClusterV2/Provisioned_EnhancedMonitoring")
        }
        {
            $v = "DEFAULT","PER_BROKER","PER_TOPIC_PER_BROKER","PER_TOPIC_PER_PARTITION"
            break
        }

        # Amazon.Kafka.StorageMode
        {
            ($_ -eq "New-MSKClusterV2/Provisioned_StorageMode") -Or
            ($_ -eq "New-MSKCluster/StorageMode") -Or
            ($_ -eq "Update-MSKStorage/StorageMode")
        }
        {
            $v = "LOCAL","TIERED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSK_map = @{
    "EncryptionInfo_EncryptionInTransit_ClientBroker"=@("New-MSKCluster","Update-MSKSecurity")
    "EnhancedMonitoring"=@("New-MSKCluster","Update-MSKMonitoring")
    "Provisioned_EncryptionInfo_EncryptionInTransit_ClientBroker"=@("New-MSKClusterV2")
    "Provisioned_EnhancedMonitoring"=@("New-MSKClusterV2")
    "Provisioned_StorageMode"=@("New-MSKClusterV2")
    "StorageMode"=@("New-MSKCluster","Update-MSKStorage")
}

_awsArgumentCompleterRegistration $MSK_Completers $MSK_map

$MSK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MSK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSK_SelectMap = @{
    "Select"=@("Register-MSKAssociateScramSecret",
               "Unregister-MSKDisassociateScramSecret",
               "New-MSKCluster",
               "New-MSKClusterV2",
               "New-MSKConfiguration",
               "Remove-MSKCluster",
               "Remove-MSKConfiguration",
               "Get-MSKCluster",
               "Get-MSKClusterOperation",
               "Get-MSKClusterV2",
               "Get-MSKConfiguration",
               "Get-MSKConfigurationRevision",
               "Get-MSKBootstrapBroker",
               "Get-MSKCompatibleKafkaVersion",
               "Get-MSKClusterOperationList",
               "Get-MSKClusterList",
               "Get-MSKClustersV2List",
               "Get-MSKConfigurationRevisionList",
               "Get-MSKConfigurationList",
               "Get-MSKKafkaVersionList",
               "Get-MSKNodeList",
               "Get-MSKScramSecretList",
               "Get-MSKResourceTag",
               "Restart-MSKBroker",
               "Add-MSKResourceTag",
               "Remove-MSKResourceTag",
               "Update-MSKBrokerCount",
               "Update-MSKBrokerStorage",
               "Update-MSKBrokerType",
               "Update-MSKClusterConfiguration",
               "Update-MSKClusterKafkaVersion",
               "Update-MSKConfiguration",
               "Update-MSKConnectivity",
               "Update-MSKMonitoring",
               "Update-MSKSecurity",
               "Update-MSKStorage")
}

_awsArgumentCompleterRegistration $MSK_SelectCompleters $MSK_SelectMap
# Argument completions for service Managed Streaming for Kafka Connect


$MSKC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KafkaConnect.CustomPluginContentType
        "New-MSKCCustomPlugin/ContentType"
        {
            $v = "JAR","ZIP"
            break
        }

        # Amazon.KafkaConnect.KafkaClusterClientAuthenticationType
        "New-MSKCConnector/KafkaClusterClientAuthentication_AuthenticationType"
        {
            $v = "IAM","NONE"
            break
        }

        # Amazon.KafkaConnect.KafkaClusterEncryptionInTransitType
        "New-MSKCConnector/KafkaClusterEncryptionInTransit_EncryptionType"
        {
            $v = "PLAINTEXT","TLS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSKC_map = @{
    "ContentType"=@("New-MSKCCustomPlugin")
    "KafkaClusterClientAuthentication_AuthenticationType"=@("New-MSKCConnector")
    "KafkaClusterEncryptionInTransit_EncryptionType"=@("New-MSKCConnector")
}

_awsArgumentCompleterRegistration $MSKC_Completers $MSKC_map

$MSKC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MSKC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSKC_SelectMap = @{
    "Select"=@("New-MSKCConnector",
               "New-MSKCCustomPlugin",
               "New-MSKCWorkerConfiguration",
               "Remove-MSKCConnector",
               "Remove-MSKCCustomPlugin",
               "Get-MSKCConnector",
               "Get-MSKCCustomPlugin",
               "Get-MSKCWorkerConfiguration",
               "Get-MSKCConnectorList",
               "Get-MSKCCustomPluginList",
               "Get-MSKCWorkerConfigurationList",
               "Update-MSKCConnector")
}

_awsArgumentCompleterRegistration $MSKC_SelectCompleters $MSKC_SelectMap
# Argument completions for service Amazon Kendra


$KNDR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kendra.ConditionOperator
        {
            ($_ -eq "New-KNDRDataSource/CustomDocumentEnrichmentConfiguration_PostExtractionHookConfiguration_InvocationCondition_Operator") -Or
            ($_ -eq "Update-KNDRDataSource/CustomDocumentEnrichmentConfiguration_PostExtractionHookConfiguration_InvocationCondition_Operator") -Or
            ($_ -eq "Write-KNDRDocumentBatch/CustomDocumentEnrichmentConfiguration_PostExtractionHookConfiguration_InvocationCondition_Operator") -Or
            ($_ -eq "New-KNDRDataSource/CustomDocumentEnrichmentConfiguration_PreExtractionHookConfiguration_InvocationCondition_Operator") -Or
            ($_ -eq "Update-KNDRDataSource/CustomDocumentEnrichmentConfiguration_PreExtractionHookConfiguration_InvocationCondition_Operator") -Or
            ($_ -eq "Write-KNDRDocumentBatch/CustomDocumentEnrichmentConfiguration_PreExtractionHookConfiguration_InvocationCondition_Operator")
        }
        {
            $v = "BeginsWith","Contains","Equals","Exists","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","NotContains","NotEquals","NotExists"
            break
        }

        # Amazon.Kendra.DataSourceSyncJobStatus
        "Get-KNDRDataSourceSyncJobList/StatusFilter"
        {
            $v = "ABORTED","FAILED","INCOMPLETE","STOPPING","SUCCEEDED","SYNCING","SYNCING_INDEXING"
            break
        }

        # Amazon.Kendra.DataSourceType
        "New-KNDRDataSource/Type"
        {
            $v = "ALFRESCO","BOX","CONFLUENCE","CUSTOM","DATABASE","FSX","GITHUB","GOOGLEDRIVE","JIRA","ONEDRIVE","QUIP","S3","SALESFORCE","SERVICENOW","SHAREPOINT","SLACK","TEMPLATE","WEBCRAWLER","WORKDOCS"
            break
        }

        # Amazon.Kendra.FaqFileFormat
        "New-KNDRFaq/FileFormat"
        {
            $v = "CSV","CSV_WITH_HEADER","JSON"
            break
        }

        # Amazon.Kendra.IndexEdition
        "New-KNDRIndex/Edition"
        {
            $v = "DEVELOPER_EDITION","ENTERPRISE_EDITION"
            break
        }

        # Amazon.Kendra.Interval
        "Get-KNDRSnapshot/Interval"
        {
            $v = "ONE_MONTH_AGO","ONE_WEEK_AGO","THIS_MONTH","THIS_WEEK","TWO_MONTHS_AGO","TWO_WEEKS_AGO"
            break
        }

        # Amazon.Kendra.MetricType
        "Get-KNDRSnapshot/MetricType"
        {
            $v = "AGG_QUERY_DOC_METRICS","DOCS_BY_CLICK_COUNT","QUERIES_BY_COUNT","QUERIES_BY_ZERO_CLICK_RATE","QUERIES_BY_ZERO_RESULT_RATE","TREND_QUERY_DOC_METRICS"
            break
        }

        # Amazon.Kendra.Mode
        "Update-KNDRQuerySuggestionsConfig/Mode"
        {
            $v = "ENABLED","LEARN_ONLY"
            break
        }

        # Amazon.Kendra.QueryResultType
        "Invoke-KNDRQuery/QueryResultTypeFilter"
        {
            $v = "ANSWER","DOCUMENT","QUESTION_ANSWER"
            break
        }

        # Amazon.Kendra.SortOrder
        "Invoke-KNDRQuery/SortingConfiguration_SortOrder"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.Kendra.UserContextPolicy
        {
            ($_ -eq "New-KNDRIndex/UserContextPolicy") -Or
            ($_ -eq "Update-KNDRIndex/UserContextPolicy")
        }
        {
            $v = "ATTRIBUTE_FILTER","USER_TOKEN"
            break
        }

        # Amazon.Kendra.UserGroupResolutionMode
        {
            ($_ -eq "New-KNDRIndex/UserGroupResolutionConfiguration_UserGroupResolutionMode") -Or
            ($_ -eq "Update-KNDRIndex/UserGroupResolutionConfiguration_UserGroupResolutionMode")
        }
        {
            $v = "AWS_SSO","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KNDR_map = @{
    "CustomDocumentEnrichmentConfiguration_PostExtractionHookConfiguration_InvocationCondition_Operator"=@("New-KNDRDataSource","Update-KNDRDataSource","Write-KNDRDocumentBatch")
    "CustomDocumentEnrichmentConfiguration_PreExtractionHookConfiguration_InvocationCondition_Operator"=@("New-KNDRDataSource","Update-KNDRDataSource","Write-KNDRDocumentBatch")
    "Edition"=@("New-KNDRIndex")
    "FileFormat"=@("New-KNDRFaq")
    "Interval"=@("Get-KNDRSnapshot")
    "MetricType"=@("Get-KNDRSnapshot")
    "Mode"=@("Update-KNDRQuerySuggestionsConfig")
    "QueryResultTypeFilter"=@("Invoke-KNDRQuery")
    "SortingConfiguration_SortOrder"=@("Invoke-KNDRQuery")
    "StatusFilter"=@("Get-KNDRDataSourceSyncJobList")
    "Type"=@("New-KNDRDataSource")
    "UserContextPolicy"=@("New-KNDRIndex","Update-KNDRIndex")
    "UserGroupResolutionConfiguration_UserGroupResolutionMode"=@("New-KNDRIndex","Update-KNDRIndex")
}

_awsArgumentCompleterRegistration $KNDR_Completers $KNDR_map

$KNDR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KNDR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KNDR_SelectMap = @{
    "Select"=@("Add-KNDREntitiesToExperience",
               "Add-KNDRPersonasToEntity",
               "Remove-KNDRDocumentBatch",
               "Get-KNDRGetDocumentStatus",
               "Write-KNDRDocumentBatch",
               "Clear-KNDRQuerySuggestion",
               "New-KNDRAccessControlConfiguration",
               "New-KNDRDataSource",
               "New-KNDRExperience",
               "New-KNDRFaq",
               "New-KNDRIndex",
               "New-KNDRQuerySuggestionsBlockList",
               "New-KNDRThesaurus",
               "Remove-KNDRAccessControlConfiguration",
               "Remove-KNDRDataSource",
               "Remove-KNDRExperience",
               "Remove-KNDRFaq",
               "Remove-KNDRIndex",
               "Remove-KNDRPrincipalMapping",
               "Remove-KNDRQuerySuggestionsBlockList",
               "Remove-KNDRThesaurus",
               "Get-KNDRAccessControlConfiguration",
               "Get-KNDRDataSource",
               "Get-KNDRExperience",
               "Get-KNDRFaq",
               "Get-KNDRIndex",
               "Get-KNDRPrincipalMapping",
               "Get-KNDRQuerySuggestionsBlockList",
               "Get-KNDRQuerySuggestionsConfig",
               "Get-KNDRThesaurus",
               "Remove-KNDREntitiesFromExperience",
               "Remove-KNDRPersonasFromEntity",
               "Get-KNDRQuerySuggestion",
               "Get-KNDRSnapshot",
               "Get-KNDRAccessControlConfigurationList",
               "Get-KNDRDataSourceList",
               "Get-KNDRDataSourceSyncJobList",
               "Get-KNDREntityPersonaList",
               "Get-KNDRExperienceEntityList",
               "Get-KNDRExperienceList",
               "Get-KNDRFaqList",
               "Get-KNDRGroupsOlderThanOrderingIdList",
               "Get-KNDRIndexList",
               "Get-KNDRQuerySuggestionsBlockListList",
               "Get-KNDRResourceTag",
               "Get-KNDRThesauriList",
               "Write-KNDRPrincipalMapping",
               "Invoke-KNDRQuery",
               "Start-KNDRDataSourceSyncJob",
               "Stop-KNDRDataSourceSyncJob",
               "Send-KNDRFeedback",
               "Add-KNDRResourceTag",
               "Remove-KNDRResourceTag",
               "Update-KNDRAccessControlConfiguration",
               "Update-KNDRDataSource",
               "Update-KNDRExperience",
               "Update-KNDRIndex",
               "Update-KNDRQuerySuggestionsBlockList",
               "Update-KNDRQuerySuggestionsConfig",
               "Update-KNDRThesaurus")
}

_awsArgumentCompleterRegistration $KNDR_SelectCompleters $KNDR_SelectMap
# Argument completions for service Amazon Keyspaces


$KS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Keyspaces.EncryptionType
        {
            ($_ -eq "New-KSTable/EncryptionSpecification_Type") -Or
            ($_ -eq "Update-KSTable/EncryptionSpecification_Type") -Or
            ($_ -eq "Restore-KSTable/EncryptionSpecificationOverride_Type")
        }
        {
            $v = "AWS_OWNED_KMS_KEY","CUSTOMER_MANAGED_KMS_KEY"
            break
        }

        # Amazon.Keyspaces.PointInTimeRecoveryStatus
        {
            ($_ -eq "New-KSTable/PointInTimeRecovery_Status") -Or
            ($_ -eq "Update-KSTable/PointInTimeRecovery_Status") -Or
            ($_ -eq "Restore-KSTable/PointInTimeRecoveryOverride_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Keyspaces.ThroughputMode
        {
            ($_ -eq "New-KSTable/CapacitySpecification_ThroughputMode") -Or
            ($_ -eq "Update-KSTable/CapacitySpecification_ThroughputMode") -Or
            ($_ -eq "Restore-KSTable/CapacitySpecificationOverride_ThroughputMode")
        }
        {
            $v = "PAY_PER_REQUEST","PROVISIONED"
            break
        }

        # Amazon.Keyspaces.TimeToLiveStatus
        {
            ($_ -eq "New-KSTable/Ttl_Status") -Or
            ($_ -eq "Update-KSTable/Ttl_Status")
        }
        {
            $v = "ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KS_map = @{
    "CapacitySpecification_ThroughputMode"=@("New-KSTable","Update-KSTable")
    "CapacitySpecificationOverride_ThroughputMode"=@("Restore-KSTable")
    "EncryptionSpecification_Type"=@("New-KSTable","Update-KSTable")
    "EncryptionSpecificationOverride_Type"=@("Restore-KSTable")
    "PointInTimeRecovery_Status"=@("New-KSTable","Update-KSTable")
    "PointInTimeRecoveryOverride_Status"=@("Restore-KSTable")
    "Ttl_Status"=@("New-KSTable","Update-KSTable")
}

_awsArgumentCompleterRegistration $KS_Completers $KS_map

$KS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KS_SelectMap = @{
    "Select"=@("New-KSKeyspace",
               "New-KSTable",
               "Remove-KSKeyspace",
               "Remove-KSTable",
               "Get-KSKeyspace",
               "Get-KSTable",
               "Get-KSKeyspaceList",
               "Get-KSTableList",
               "Get-KSResourceTag",
               "Restore-KSTable",
               "Add-KSResourceTag",
               "Remove-KSResourceTag",
               "Update-KSTable")
}

_awsArgumentCompleterRegistration $KS_SelectCompleters $KS_SelectMap
# Argument completions for service Amazon Kinesis


$KIN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kinesis.EncryptionType
        {
            ($_ -eq "Start-KINStreamEncryption/EncryptionType") -Or
            ($_ -eq "Stop-KINStreamEncryption/EncryptionType")
        }
        {
            $v = "KMS","NONE"
            break
        }

        # Amazon.Kinesis.ScalingType
        "Update-KINShardCount/ScalingType"
        {
            $v = "UNIFORM_SCALING"
            break
        }

        # Amazon.Kinesis.ShardFilterType
        "Get-KINShardList/ShardFilter_Type"
        {
            $v = "AFTER_SHARD_ID","AT_LATEST","AT_TIMESTAMP","AT_TRIM_HORIZON","FROM_TIMESTAMP","FROM_TRIM_HORIZON"
            break
        }

        # Amazon.Kinesis.ShardIteratorType
        "Get-KINShardIterator/ShardIteratorType"
        {
            $v = "AFTER_SEQUENCE_NUMBER","AT_SEQUENCE_NUMBER","AT_TIMESTAMP","LATEST","TRIM_HORIZON"
            break
        }

        # Amazon.Kinesis.StreamMode
        {
            ($_ -eq "New-KINStream/StreamModeDetails_StreamMode") -Or
            ($_ -eq "Update-KINStreamMode/StreamModeDetails_StreamMode")
        }
        {
            $v = "ON_DEMAND","PROVISIONED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KIN_map = @{
    "EncryptionType"=@("Start-KINStreamEncryption","Stop-KINStreamEncryption")
    "ScalingType"=@("Update-KINShardCount")
    "ShardFilter_Type"=@("Get-KINShardList")
    "ShardIteratorType"=@("Get-KINShardIterator")
    "StreamModeDetails_StreamMode"=@("New-KINStream","Update-KINStreamMode")
}

_awsArgumentCompleterRegistration $KIN_Completers $KIN_map

$KIN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KIN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KIN_SelectMap = @{
    "Select"=@("Add-KINTagsToStream",
               "New-KINStream",
               "Request-KINStreamRetentionPeriodDecrease",
               "Remove-KINStream",
               "Unregister-KINStreamConsumer",
               "Get-KINLimit",
               "Get-KINStream",
               "Get-KINStreamConsumer",
               "Get-KINStreamSummary",
               "Disable-KINEnhancedMonitoring",
               "Enable-KINEnhancedMonitoring",
               "Get-KINRecord",
               "Get-KINShardIterator",
               "Request-KINStreamRetentionPeriodIncrease",
               "Get-KINShardList",
               "Get-KINStreamConsumerList",
               "Get-KINStreamList",
               "Get-KINTagsForStream",
               "Merge-KINShard",
               "Write-KINRecord",
               "Write-KINMultipleRecord",
               "Register-KINStreamConsumer",
               "Remove-KINTagsFromStream",
               "Split-KINShard",
               "Start-KINStreamEncryption",
               "Stop-KINStreamEncryption",
               "Update-KINShardCount",
               "Update-KINStreamMode")
}

_awsArgumentCompleterRegistration $KIN_SelectCompleters $KIN_SelectMap
# Argument completions for service Amazon Kinesis Analytics


$KINA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisAnalytics.InputStartingPosition
        "Find-KINAInputSchema/InputStartingPositionConfiguration_InputStartingPosition"
        {
            $v = "LAST_STOPPED_POINT","NOW","TRIM_HORIZON"
            break
        }

        # Amazon.KinesisAnalytics.RecordFormatType
        {
            ($_ -eq "Add-KINAApplicationInput/Input_InputSchema_RecordFormat_RecordFormatType") -Or
            ($_ -eq "Add-KINAApplicationOutput/Output_DestinationSchema_RecordFormatType") -Or
            ($_ -eq "Add-KINAApplicationReferenceDataSource/ReferenceDataSource_ReferenceSchema_RecordFormat_RecordFormatType")
        }
        {
            $v = "CSV","JSON"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA_map = @{
    "Input_InputSchema_RecordFormat_RecordFormatType"=@("Add-KINAApplicationInput")
    "InputStartingPositionConfiguration_InputStartingPosition"=@("Find-KINAInputSchema")
    "Output_DestinationSchema_RecordFormatType"=@("Add-KINAApplicationOutput")
    "ReferenceDataSource_ReferenceSchema_RecordFormat_RecordFormatType"=@("Add-KINAApplicationReferenceDataSource")
}

_awsArgumentCompleterRegistration $KINA_Completers $KINA_map

$KINA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA_SelectMap = @{
    "Select"=@("Add-KINAApplicationCloudWatchLoggingOption",
               "Add-KINAApplicationInput",
               "Add-KINAApplicationInputProcessingConfiguration",
               "Add-KINAApplicationOutput",
               "Add-KINAApplicationReferenceDataSource",
               "New-KINAApplication",
               "Remove-KINAApplication",
               "Remove-KINAApplicationCloudWatchLoggingOption",
               "Remove-KINAApplicationInputProcessingConfiguration",
               "Remove-KINAApplicationOutput",
               "Remove-KINAApplicationReferenceDataSource",
               "Get-KINAApplication",
               "Find-KINAInputSchema",
               "Get-KINAResourceTag",
               "Start-KINAApplication",
               "Stop-KINAApplication",
               "Add-KINAResourceTag",
               "Remove-KINAResourceTag",
               "Update-KINAApplication",
               "Get-KINAApplicationList")
}

_awsArgumentCompleterRegistration $KINA_SelectCompleters $KINA_SelectMap
# Argument completions for service Amazon Kinesis Analytics V2


$KINA2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisAnalyticsV2.ApplicationMode
        "New-KINA2Application/ApplicationMode"
        {
            $v = "INTERACTIVE","STREAMING"
            break
        }

        # Amazon.KinesisAnalyticsV2.RuntimeEnvironment
        "New-KINA2Application/RuntimeEnvironment"
        {
            $v = "FLINK-1_11","FLINK-1_13","FLINK-1_6","FLINK-1_8","SQL-1_0","ZEPPELIN-FLINK-1_0","ZEPPELIN-FLINK-2_0"
            break
        }

        # Amazon.KinesisAnalyticsV2.UrlType
        "New-KINA2ApplicationPresignedUrl/UrlType"
        {
            $v = "FLINK_DASHBOARD_URL","ZEPPELIN_UI_URL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA2_map = @{
    "ApplicationMode"=@("New-KINA2Application")
    "RuntimeEnvironment"=@("New-KINA2Application")
    "UrlType"=@("New-KINA2ApplicationPresignedUrl")
}

_awsArgumentCompleterRegistration $KINA2_Completers $KINA2_map

$KINA2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINA2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA2_SelectMap = @{
    "Select"=@("Add-KINA2ApplicationCloudWatchLoggingOption",
               "Add-KINA2ApplicationInput",
               "Add-KINA2ApplicationInputProcessingConfiguration",
               "Add-KINA2ApplicationOutput",
               "Add-KINA2ApplicationReferenceDataSource",
               "Add-KINA2ApplicationVpcConfiguration",
               "New-KINA2Application",
               "New-KINA2ApplicationPresignedUrl",
               "New-KINA2ApplicationSnapshot",
               "Remove-KINA2Application",
               "Remove-KINA2ApplicationCloudWatchLoggingOption",
               "Remove-KINA2ApplicationInputProcessingConfiguration",
               "Remove-KINA2ApplicationOutput",
               "Remove-KINA2ApplicationReferenceDataSource",
               "Remove-KINA2ApplicationSnapshot",
               "Remove-KINA2ApplicationVpcConfiguration",
               "Get-KINA2Application",
               "Get-KINA2ApplicationSnapshot",
               "Get-KINA2ApplicationVersion",
               "Find-KINA2InputSchema",
               "Get-KINA2ApplicationList",
               "Get-KINA2ApplicationSnapshotList",
               "Get-KINA2ApplicationVersionList",
               "Get-KINA2ResourceTag",
               "Undo-KINA2Application",
               "Start-KINA2Application",
               "Stop-KINA2Application",
               "Add-KINA2ResourceTag",
               "Remove-KINA2ResourceTag",
               "Update-KINA2Application",
               "Update-KINA2ApplicationMaintenanceConfiguration")
}

_awsArgumentCompleterRegistration $KINA2_SelectCompleters $KINA2_SelectMap
# Argument completions for service Amazon Kinesis Video Streams


$KV_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisVideo.APIName
        "Get-KVDataEndpoint/APIName"
        {
            $v = "GET_CLIP","GET_DASH_STREAMING_SESSION_URL","GET_HLS_STREAMING_SESSION_URL","GET_IMAGES","GET_MEDIA","GET_MEDIA_FOR_FRAGMENT_LIST","LIST_FRAGMENTS","PUT_MEDIA"
            break
        }

        # Amazon.KinesisVideo.ChannelRole
        "Get-KVSignalingChannelEndpoint/SingleMasterChannelEndpointConfiguration_Role"
        {
            $v = "MASTER","VIEWER"
            break
        }

        # Amazon.KinesisVideo.ChannelType
        "New-KVSignalingChannel/ChannelType"
        {
            $v = "FULL_MESH","SINGLE_MASTER"
            break
        }

        # Amazon.KinesisVideo.ComparisonOperator
        "Get-KVSignalingChannelList/ChannelNameCondition_ComparisonOperator"
        {
            $v = "BEGINS_WITH"
            break
        }

        # Amazon.KinesisVideo.ConfigurationStatus
        {
            ($_ -eq "Update-KVImageGenerationConfiguration/ImageGenerationConfiguration_Status") -Or
            ($_ -eq "Update-KVNotificationConfiguration/NotificationConfiguration_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.KinesisVideo.Format
        "Update-KVImageGenerationConfiguration/ImageGenerationConfiguration_Format"
        {
            $v = "JPEG","PNG"
            break
        }

        # Amazon.KinesisVideo.ImageSelectorType
        "Update-KVImageGenerationConfiguration/ImageGenerationConfiguration_ImageSelectorType"
        {
            $v = "PRODUCER_TIMESTAMP","SERVER_TIMESTAMP"
            break
        }

        # Amazon.KinesisVideo.UpdateDataRetentionOperation
        "Update-KVDataRetention/Operation"
        {
            $v = "DECREASE_DATA_RETENTION","INCREASE_DATA_RETENTION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KV_map = @{
    "APIName"=@("Get-KVDataEndpoint")
    "ChannelNameCondition_ComparisonOperator"=@("Get-KVSignalingChannelList")
    "ChannelType"=@("New-KVSignalingChannel")
    "ImageGenerationConfiguration_Format"=@("Update-KVImageGenerationConfiguration")
    "ImageGenerationConfiguration_ImageSelectorType"=@("Update-KVImageGenerationConfiguration")
    "ImageGenerationConfiguration_Status"=@("Update-KVImageGenerationConfiguration")
    "NotificationConfiguration_Status"=@("Update-KVNotificationConfiguration")
    "Operation"=@("Update-KVDataRetention")
    "SingleMasterChannelEndpointConfiguration_Role"=@("Get-KVSignalingChannelEndpoint")
}

_awsArgumentCompleterRegistration $KV_Completers $KV_map

$KV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KV_SelectMap = @{
    "Select"=@("New-KVSignalingChannel",
               "New-KVStream",
               "Remove-KVSignalingChannel",
               "Remove-KVStream",
               "Get-KVImageGenerationConfiguration",
               "Get-KVNotificationConfiguration",
               "Get-KVSignalingChannel",
               "Get-KVStream",
               "Get-KVDataEndpoint",
               "Get-KVSignalingChannelEndpoint",
               "Get-KVSignalingChannelList",
               "Get-KVStreamList",
               "Get-KVResourceTag",
               "Get-KVTagsForStreamList",
               "Add-KVResourceTag",
               "Add-KVStreamTag",
               "Remove-KVResourceTag",
               "Remove-KVStreamTag",
               "Update-KVDataRetention",
               "Update-KVImageGenerationConfiguration",
               "Update-KVNotificationConfiguration",
               "Update-KVSignalingChannel",
               "Update-KVStream")
}

_awsArgumentCompleterRegistration $KV_SelectCompleters $KV_SelectMap
# Argument completions for service Amazon Kinesis Video Streams Media


$KVM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KVM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVM_SelectMap = @{
    "Select"=@("Get-KVMMedia")
}

_awsArgumentCompleterRegistration $KVM_SelectCompleters $KVM_SelectMap
# Argument completions for service Amazon Kinesis Video Signaling Channels


$KVSC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisVideoSignalingChannels.Service
        "Get-KVSCIceServerConfig/Service"
        {
            $v = "TURN"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVSC_map = @{
    "Service"=@("Get-KVSCIceServerConfig")
}

_awsArgumentCompleterRegistration $KVSC_Completers $KVSC_map

$KVSC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KVSC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVSC_SelectMap = @{
    "Select"=@("Get-KVSCIceServerConfig",
               "Send-KVSCAlexaOfferToMaster")
}

_awsArgumentCompleterRegistration $KVSC_SelectCompleters $KVSC_SelectMap
# Argument completions for service AWS Key Management Service


$KMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KeyManagementService.AlgorithmSpec
        "Get-KMSParametersForImport/WrappingAlgorithm"
        {
            $v = "RSAES_OAEP_SHA_1","RSAES_OAEP_SHA_256","RSAES_PKCS1_V1_5"
            break
        }

        # Amazon.KeyManagementService.CustomerMasterKeySpec
        "New-KMSKey/CustomerMasterKeySpec"
        {
            $v = "ECC_NIST_P256","ECC_NIST_P384","ECC_NIST_P521","ECC_SECG_P256K1","HMAC_224","HMAC_256","HMAC_384","HMAC_512","RSA_2048","RSA_3072","RSA_4096","SM2","SYMMETRIC_DEFAULT"
            break
        }

        # Amazon.KeyManagementService.DataKeyPairSpec
        {
            ($_ -eq "New-KMSDataKeyPair/KeyPairSpec") -Or
            ($_ -eq "New-KMSDataKeyPairWithoutPlaintext/KeyPairSpec")
        }
        {
            $v = "ECC_NIST_P256","ECC_NIST_P384","ECC_NIST_P521","ECC_SECG_P256K1","RSA_2048","RSA_3072","RSA_4096","SM2"
            break
        }

        # Amazon.KeyManagementService.DataKeySpec
        {
            ($_ -eq "New-KMSDataKey/KeySpec") -Or
            ($_ -eq "New-KMSDataKeyWithoutPlaintext/KeySpec")
        }
        {
            $v = "AES_128","AES_256"
            break
        }

        # Amazon.KeyManagementService.EncryptionAlgorithmSpec
        {
            ($_ -eq "Invoke-KMSReEncrypt/DestinationEncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSDecrypt/EncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSEncrypt/EncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSReEncrypt/SourceEncryptionAlgorithm")
        }
        {
            $v = "RSAES_OAEP_SHA_1","RSAES_OAEP_SHA_256","SM2PKE","SYMMETRIC_DEFAULT"
            break
        }

        # Amazon.KeyManagementService.ExpirationModelType
        "Import-KMSKeyMaterial/ExpirationModel"
        {
            $v = "KEY_MATERIAL_DOES_NOT_EXPIRE","KEY_MATERIAL_EXPIRES"
            break
        }

        # Amazon.KeyManagementService.KeySpec
        "New-KMSKey/KeySpec"
        {
            $v = "ECC_NIST_P256","ECC_NIST_P384","ECC_NIST_P521","ECC_SECG_P256K1","HMAC_224","HMAC_256","HMAC_384","HMAC_512","RSA_2048","RSA_3072","RSA_4096","SM2","SYMMETRIC_DEFAULT"
            break
        }

        # Amazon.KeyManagementService.KeyUsageType
        "New-KMSKey/KeyUsage"
        {
            $v = "ENCRYPT_DECRYPT","GENERATE_VERIFY_MAC","SIGN_VERIFY"
            break
        }

        # Amazon.KeyManagementService.MacAlgorithmSpec
        {
            ($_ -eq "New-KMSMac/MacAlgorithm") -Or
            ($_ -eq "Test-KMSMac/MacAlgorithm")
        }
        {
            $v = "HMAC_SHA_224","HMAC_SHA_256","HMAC_SHA_384","HMAC_SHA_512"
            break
        }

        # Amazon.KeyManagementService.MessageType
        {
            ($_ -eq "Invoke-KMSSigning/MessageType") -Or
            ($_ -eq "Test-KMSSignature/MessageType")
        }
        {
            $v = "DIGEST","RAW"
            break
        }

        # Amazon.KeyManagementService.OriginType
        "New-KMSKey/Origin"
        {
            $v = "AWS_CLOUDHSM","AWS_KMS","EXTERNAL"
            break
        }

        # Amazon.KeyManagementService.SigningAlgorithmSpec
        {
            ($_ -eq "Invoke-KMSSigning/SigningAlgorithm") -Or
            ($_ -eq "Test-KMSSignature/SigningAlgorithm")
        }
        {
            $v = "ECDSA_SHA_256","ECDSA_SHA_384","ECDSA_SHA_512","RSASSA_PKCS1_V1_5_SHA_256","RSASSA_PKCS1_V1_5_SHA_384","RSASSA_PKCS1_V1_5_SHA_512","RSASSA_PSS_SHA_256","RSASSA_PSS_SHA_384","RSASSA_PSS_SHA_512","SM2DSA"
            break
        }

        # Amazon.KeyManagementService.WrappingKeySpec
        "Get-KMSParametersForImport/WrappingKeySpec"
        {
            $v = "RSA_2048"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KMS_map = @{
    "CustomerMasterKeySpec"=@("New-KMSKey")
    "DestinationEncryptionAlgorithm"=@("Invoke-KMSReEncrypt")
    "EncryptionAlgorithm"=@("Invoke-KMSDecrypt","Invoke-KMSEncrypt")
    "ExpirationModel"=@("Import-KMSKeyMaterial")
    "KeyPairSpec"=@("New-KMSDataKeyPair","New-KMSDataKeyPairWithoutPlaintext")
    "KeySpec"=@("New-KMSDataKey","New-KMSDataKeyWithoutPlaintext","New-KMSKey")
    "KeyUsage"=@("New-KMSKey")
    "MacAlgorithm"=@("New-KMSMac","Test-KMSMac")
    "MessageType"=@("Invoke-KMSSigning","Test-KMSSignature")
    "Origin"=@("New-KMSKey")
    "SigningAlgorithm"=@("Invoke-KMSSigning","Test-KMSSignature")
    "SourceEncryptionAlgorithm"=@("Invoke-KMSReEncrypt")
    "WrappingAlgorithm"=@("Get-KMSParametersForImport")
    "WrappingKeySpec"=@("Get-KMSParametersForImport")
}

_awsArgumentCompleterRegistration $KMS_Completers $KMS_map

$KMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KMS_SelectMap = @{
    "Select"=@("Stop-KMSKeyDeletion",
               "Connect-KMSCustomKeyStore",
               "New-KMSAlias",
               "New-KMSCustomKeyStore",
               "New-KMSGrant",
               "New-KMSKey",
               "Invoke-KMSDecrypt",
               "Remove-KMSAlias",
               "Remove-KMSCustomKeyStore",
               "Remove-KMSImportedKeyMaterial",
               "Get-KMSCustomKeyStore",
               "Get-KMSKey",
               "Disable-KMSKey",
               "Disable-KMSKeyRotation",
               "Disconnect-KMSCustomKeyStore",
               "Enable-KMSKey",
               "Enable-KMSKeyRotation",
               "Invoke-KMSEncrypt",
               "New-KMSDataKey",
               "New-KMSDataKeyPair",
               "New-KMSDataKeyPairWithoutPlaintext",
               "New-KMSDataKeyWithoutPlaintext",
               "New-KMSMac",
               "New-KMSRandom",
               "Get-KMSKeyPolicy",
               "Get-KMSKeyRotationStatus",
               "Get-KMSParametersForImport",
               "Get-KMSPublicKey",
               "Import-KMSKeyMaterial",
               "Get-KMSAliasList",
               "Get-KMSGrantList",
               "Get-KMSKeyPolicyList",
               "Get-KMSKeyList",
               "Get-KMSResourceTag",
               "Get-KMSRetirableGrant",
               "Write-KMSKeyPolicy",
               "Invoke-KMSReEncrypt",
               "New-KMSReplicaKey",
               "Disable-KMSGrant",
               "Revoke-KMSGrant",
               "Request-KMSKeyDeletion",
               "Invoke-KMSSigning",
               "Add-KMSResourceTag",
               "Remove-KMSResourceTag",
               "Update-KMSAlias",
               "Update-KMSCustomKeyStore",
               "Update-KMSKeyDescription",
               "Update-KMSPrimaryRegion",
               "Test-KMSSignature",
               "Test-KMSMac")
}

_awsArgumentCompleterRegistration $KMS_SelectCompleters $KMS_SelectMap
# Argument completions for service AWS Lake Formation


$LKF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LakeFormation.DataLakeResourceType
        "Get-LKFPermissionList/ResourceType"
        {
            $v = "CATALOG","DATABASE","DATA_LOCATION","LF_TAG","LF_TAG_POLICY","LF_TAG_POLICY_DATABASE","LF_TAG_POLICY_TABLE","TABLE"
            break
        }

        # Amazon.LakeFormation.OptimizerType
        "Get-LKFTableStorageOptimizerList/StorageOptimizerType"
        {
            $v = "ALL","COMPACTION","GARBAGE_COLLECTION"
            break
        }

        # Amazon.LakeFormation.ResourceShareType
        "Get-LKFLFTagList/ResourceShareType"
        {
            $v = "ALL","FOREIGN"
            break
        }

        # Amazon.LakeFormation.ResourceType
        {
            ($_ -eq "Add-LKFLFTagsToResource/Resource_LFTagPolicy_ResourceType") -Or
            ($_ -eq "Get-LKFPermissionList/Resource_LFTagPolicy_ResourceType") -Or
            ($_ -eq "Get-LKFResourceLFTag/Resource_LFTagPolicy_ResourceType") -Or
            ($_ -eq "Grant-LKFPermission/Resource_LFTagPolicy_ResourceType") -Or
            ($_ -eq "Remove-LKFLFTagsFromResource/Resource_LFTagPolicy_ResourceType") -Or
            ($_ -eq "Revoke-LKFPermission/Resource_LFTagPolicy_ResourceType")
        }
        {
            $v = "DATABASE","TABLE"
            break
        }

        # Amazon.LakeFormation.TransactionStatusFilter
        "Get-LKFTransactionList/StatusFilter"
        {
            $v = "ABORTED","ACTIVE","ALL","COMMITTED","COMPLETED"
            break
        }

        # Amazon.LakeFormation.TransactionType
        "Start-LKFTransaction/TransactionType"
        {
            $v = "READ_AND_WRITE","READ_ONLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LKF_map = @{
    "Resource_LFTagPolicy_ResourceType"=@("Add-LKFLFTagsToResource","Get-LKFPermissionList","Get-LKFResourceLFTag","Grant-LKFPermission","Remove-LKFLFTagsFromResource","Revoke-LKFPermission")
    "ResourceShareType"=@("Get-LKFLFTagList")
    "ResourceType"=@("Get-LKFPermissionList")
    "StatusFilter"=@("Get-LKFTransactionList")
    "StorageOptimizerType"=@("Get-LKFTableStorageOptimizerList")
    "TransactionType"=@("Start-LKFTransaction")
}

_awsArgumentCompleterRegistration $LKF_Completers $LKF_map

$LKF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LKF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LKF_SelectMap = @{
    "Select"=@("Add-LKFLFTagsToResource",
               "Grant-LKFPermissionBatch",
               "Revoke-LKFPermissionBatch",
               "Stop-LKFTransaction",
               "Write-LKFTransaction",
               "New-LKFDataCellsFilter",
               "New-LKFLFTag",
               "Remove-LKFDataCellsFilter",
               "Remove-LKFLFTag",
               "Remove-LKFObjectsOnCancel",
               "Unregister-LKFResource",
               "Get-LKFResource",
               "Get-LKFTransaction",
               "Invoke-LKFTransaction",
               "Get-LKFDataLakeSetting",
               "Get-LKFEffectivePermissionsForPath",
               "Get-LKFLFTag",
               "Get-LKFQueryState",
               "Get-LKFQueryStatistic",
               "Get-LKFResourceLFTag",
               "Get-LKFTableObject",
               "Get-LKFTemporaryGluePartitionCredential",
               "Get-LKFTemporaryGlueTableCredential",
               "Get-LKFWorkUnitResult",
               "Get-LKFWorkUnit",
               "Grant-LKFPermission",
               "Get-LKFDataCellsFilterList",
               "Get-LKFLFTagList",
               "Get-LKFPermissionList",
               "Get-LKFResourceList",
               "Get-LKFTableStorageOptimizerList",
               "Get-LKFTransactionList",
               "Write-LKFDataLakeSetting",
               "Register-LKFResource",
               "Remove-LKFLFTagsFromResource",
               "Revoke-LKFPermission",
               "Search-LKFDatabasesByLFTag",
               "Search-LKFTablesByLFTag",
               "Start-LKFQueryPlanning",
               "Start-LKFTransaction",
               "Update-LKFLFTag",
               "Update-LKFResource",
               "Update-LKFTableObject",
               "Update-LKFTableStorageOptimizer")
}

_awsArgumentCompleterRegistration $LKF_SelectCompleters $LKF_SelectMap
# Argument completions for service AWS Lambda


$LM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lambda.Architecture
        {
            ($_ -eq "Get-LMLayerList/CompatibleArchitecture") -Or
            ($_ -eq "Get-LMLayerVersionList/CompatibleArchitecture")
        }
        {
            $v = "arm64","x86_64"
            break
        }

        # Amazon.Lambda.CodeSigningPolicy
        {
            ($_ -eq "New-LMCodeSigningConfig/CodeSigningPolicies_UntrustedArtifactOnDeployment") -Or
            ($_ -eq "Update-LMCodeSigningConfig/CodeSigningPolicies_UntrustedArtifactOnDeployment")
        }
        {
            $v = "Enforce","Warn"
            break
        }

        # Amazon.Lambda.EventSourcePosition
        "New-LMEventSourceMapping/StartingPosition"
        {
            $v = "AT_TIMESTAMP","LATEST","TRIM_HORIZON"
            break
        }

        # Amazon.Lambda.FunctionUrlAuthType
        {
            ($_ -eq "New-LMFunctionUrlConfig/AuthType") -Or
            ($_ -eq "Update-LMFunctionUrlConfig/AuthType") -Or
            ($_ -eq "Add-LMPermission/FunctionUrlAuthType")
        }
        {
            $v = "AWS_IAM","NONE"
            break
        }

        # Amazon.Lambda.FunctionVersion
        "Get-LMFunctionList/FunctionVersion"
        {
            $v = "ALL"
            break
        }

        # Amazon.Lambda.InvocationType
        "Invoke-LMFunction/InvocationType"
        {
            $v = "DryRun","Event","RequestResponse"
            break
        }

        # Amazon.Lambda.LogType
        "Invoke-LMFunction/LogType"
        {
            $v = "None","Tail"
            break
        }

        # Amazon.Lambda.PackageType
        "Publish-LMFunction/PackageType"
        {
            $v = "Image","Zip"
            break
        }

        # Amazon.Lambda.Runtime
        {
            ($_ -eq "Get-LMLayerList/CompatibleRuntime") -Or
            ($_ -eq "Get-LMLayerVersionList/CompatibleRuntime") -Or
            ($_ -eq "Publish-LMFunction/Runtime") -Or
            ($_ -eq "Update-LMFunctionConfiguration/Runtime")
        }
        {
            $v = "dotnet6","dotnetcore1.0","dotnetcore2.0","dotnetcore2.1","dotnetcore3.1","go1.x","java11","java8","java8.al2","nodejs","nodejs10.x","nodejs12.x","nodejs14.x","nodejs16.x","nodejs4.3","nodejs4.3-edge","nodejs6.10","nodejs8.10","provided","provided.al2","python2.7","python3.6","python3.7","python3.8","python3.9","ruby2.5","ruby2.7"
            break
        }

        # Amazon.Lambda.TracingMode
        {
            ($_ -eq "Publish-LMFunction/TracingConfig_Mode") -Or
            ($_ -eq "Update-LMFunctionConfiguration/TracingConfig_Mode")
        }
        {
            $v = "Active","PassThrough"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LM_map = @{
    "AuthType"=@("New-LMFunctionUrlConfig","Update-LMFunctionUrlConfig")
    "CodeSigningPolicies_UntrustedArtifactOnDeployment"=@("New-LMCodeSigningConfig","Update-LMCodeSigningConfig")
    "CompatibleArchitecture"=@("Get-LMLayerList","Get-LMLayerVersionList")
    "CompatibleRuntime"=@("Get-LMLayerList","Get-LMLayerVersionList")
    "FunctionUrlAuthType"=@("Add-LMPermission")
    "FunctionVersion"=@("Get-LMFunctionList")
    "InvocationType"=@("Invoke-LMFunction")
    "LogType"=@("Invoke-LMFunction")
    "PackageType"=@("Publish-LMFunction")
    "Runtime"=@("Publish-LMFunction","Update-LMFunctionConfiguration")
    "StartingPosition"=@("New-LMEventSourceMapping")
    "TracingConfig_Mode"=@("Publish-LMFunction","Update-LMFunctionConfiguration")
}

_awsArgumentCompleterRegistration $LM_Completers $LM_map

$LM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LM_SelectMap = @{
    "Select"=@("Add-LMLayerVersionPermission",
               "Add-LMPermission",
               "New-LMAlias",
               "New-LMCodeSigningConfig",
               "New-LMEventSourceMapping",
               "Publish-LMFunction",
               "New-LMFunctionUrlConfig",
               "Remove-LMAlias",
               "Remove-LMCodeSigningConfig",
               "Remove-LMEventSourceMapping",
               "Remove-LMFunction",
               "Remove-LMFunctionCodeSigningConfig",
               "Remove-LMFunctionConcurrency",
               "Remove-LMFunctionEventInvokeConfig",
               "Remove-LMFunctionUrlConfig",
               "Remove-LMLayerVersion",
               "Remove-LMProvisionedConcurrencyConfig",
               "Get-LMAccountSetting",
               "Get-LMAlias",
               "Get-LMCodeSigningConfig",
               "Get-LMEventSourceMapping",
               "Get-LMFunction",
               "Get-LMFunctionCodeSigningConfig",
               "Get-LMFunctionConcurrency",
               "Get-LMFunctionConfiguration",
               "Get-LMFunctionEventInvokeConfig",
               "Get-LMFunctionUrlConfig",
               "Get-LMLayerVersion",
               "Get-LMLayerVersionByArn",
               "Get-LMLayerVersionPolicy",
               "Get-LMPolicy",
               "Get-LMProvisionedConcurrencyConfig",
               "Invoke-LMFunction",
               "Invoke-LMFunctionAsync",
               "Get-LMAliasList",
               "Get-LMCodeSigningConfigList",
               "Get-LMEventSourceMappingList",
               "Get-LMFunctionEventInvokeConfigList",
               "Get-LMFunctionList",
               "Get-LMFunctionsByCodeSigningConfigList",
               "Get-LMFunctionUrlConfigList",
               "Get-LMLayerList",
               "Get-LMLayerVersionList",
               "Get-LMProvisionedConcurrencyConfigList",
               "Get-LMResourceTag",
               "Get-LMVersionsByFunction",
               "Publish-LMLayerVersion",
               "Publish-LMVersion",
               "Write-LMFunctionCodeSigningConfig",
               "Write-LMFunctionConcurrency",
               "Write-LMFunctionEventInvokeConfig",
               "Write-LMProvisionedConcurrencyConfig",
               "Remove-LMLayerVersionPermission",
               "Remove-LMPermission",
               "Add-LMResourceTag",
               "Remove-LMResourceTag",
               "Update-LMAlias",
               "Update-LMCodeSigningConfig",
               "Update-LMEventSourceMapping",
               "Update-LMFunctionCode",
               "Update-LMFunctionConfiguration",
               "Update-LMFunctionEventInvokeConfig",
               "Update-LMFunctionUrlConfig")
}

_awsArgumentCompleterRegistration $LM_SelectCompleters $LM_SelectMap
# Argument completions for service Amazon Lex Model Building Service


$LMB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LexModelBuildingService.ExportType
        "Get-LMBExport/ExportType"
        {
            $v = "ALEXA_SKILLS_KIT","LEX"
            break
        }

        # Amazon.LexModelBuildingService.FulfillmentActivityType
        "Write-LMBIntent/FulfillmentActivity_Type"
        {
            $v = "CodeHook","ReturnIntent"
            break
        }

        # Amazon.LexModelBuildingService.Locale
        {
            ($_ -eq "Get-LMBBuiltinIntentList/Locale") -Or
            ($_ -eq "Get-LMBBuiltinSlotType/Locale") -Or
            ($_ -eq "Write-LMBBot/Locale")
        }
        {
            $v = "de-DE","en-AU","en-GB","en-IN","en-US","es-419","es-ES","es-US","fr-CA","fr-FR","it-IT","ja-JP","ko-KR"
            break
        }

        # Amazon.LexModelBuildingService.MergeStrategy
        "Start-LMBImport/MergeStrategy"
        {
            $v = "FAIL_ON_CONFLICT","OVERWRITE_LATEST"
            break
        }

        # Amazon.LexModelBuildingService.MigrationSortAttribute
        "Get-LMBMigrationSummaryList/SortByAttribute"
        {
            $v = "MIGRATION_DATE_TIME","V1_BOT_NAME"
            break
        }

        # Amazon.LexModelBuildingService.MigrationStatus
        "Get-LMBMigrationSummaryList/MigrationStatusEquals"
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.LexModelBuildingService.MigrationStrategy
        "Start-LMBMigration/MigrationStrategy"
        {
            $v = "CREATE_NEW","UPDATE_EXISTING"
            break
        }

        # Amazon.LexModelBuildingService.ProcessBehavior
        "Write-LMBBot/ProcessBehavior"
        {
            $v = "BUILD","SAVE"
            break
        }

        # Amazon.LexModelBuildingService.ResourceType
        {
            ($_ -eq "Get-LMBExport/ResourceType") -Or
            ($_ -eq "Start-LMBImport/ResourceType")
        }
        {
            $v = "BOT","INTENT","SLOT_TYPE"
            break
        }

        # Amazon.LexModelBuildingService.SlotValueSelectionStrategy
        "Write-LMBSlotType/ValueSelectionStrategy"
        {
            $v = "ORIGINAL_VALUE","TOP_RESOLUTION"
            break
        }

        # Amazon.LexModelBuildingService.SortOrder
        "Get-LMBMigrationSummaryList/SortByOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.LexModelBuildingService.StatusType
        "Get-LMBUtterancesView/StatusType"
        {
            $v = "Detected","Missed"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMB_map = @{
    "ExportType"=@("Get-LMBExport")
    "FulfillmentActivity_Type"=@("Write-LMBIntent")
    "Locale"=@("Get-LMBBuiltinIntentList","Get-LMBBuiltinSlotType","Write-LMBBot")
    "MergeStrategy"=@("Start-LMBImport")
    "MigrationStatusEquals"=@("Get-LMBMigrationSummaryList")
    "MigrationStrategy"=@("Start-LMBMigration")
    "ProcessBehavior"=@("Write-LMBBot")
    "ResourceType"=@("Get-LMBExport","Start-LMBImport")
    "SortByAttribute"=@("Get-LMBMigrationSummaryList")
    "SortByOrder"=@("Get-LMBMigrationSummaryList")
    "StatusType"=@("Get-LMBUtterancesView")
    "ValueSelectionStrategy"=@("Write-LMBSlotType")
}

_awsArgumentCompleterRegistration $LMB_Completers $LMB_map

$LMB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LMB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMB_SelectMap = @{
    "Select"=@("New-LMBBotVersion",
               "New-LMBIntentVersion",
               "New-LMBSlotTypeVersion",
               "Remove-LMBBot",
               "Remove-LMBBotAlias",
               "Remove-LMBBotChannelAssociation",
               "Remove-LMBBotVersion",
               "Remove-LMBIntent",
               "Remove-LMBIntentVersion",
               "Remove-LMBSlotType",
               "Remove-LMBSlotTypeVersion",
               "Remove-LMBUtterance",
               "Get-LMBBot",
               "Get-LMBBotAlias",
               "Get-LMBBotAliasList",
               "Get-LMBBotChannelAssociation",
               "Get-LMBBotChannelAssociationList",
               "Get-LMBBotList",
               "Get-LMBBotVersionList",
               "Get-LMBBuiltinIntent",
               "Get-LMBBuiltinIntentList",
               "Get-LMBBuiltinSlotType",
               "Get-LMBExport",
               "Get-LMBImport",
               "Get-LMBIntent",
               "Get-LMBIntentList",
               "Get-LMBIntentVersion",
               "Get-LMBMigration",
               "Get-LMBMigrationSummaryList",
               "Get-LMBSlotType",
               "Get-LMBSlotTypeList",
               "Get-LMBSlotTypeVersionList",
               "Get-LMBUtterancesView",
               "Get-LMBResourceTag",
               "Write-LMBBot",
               "Write-LMBBotAlias",
               "Write-LMBIntent",
               "Write-LMBSlotType",
               "Start-LMBImport",
               "Start-LMBMigration",
               "Add-LMBResourceTag",
               "Remove-LMBResourceTag")
}

_awsArgumentCompleterRegistration $LMB_SelectCompleters $LMB_SelectMap
# Argument completions for service AWS License Manager


$LICM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LicenseManager.CheckoutType
        "Invoke-LICMLicenseCheckout/CheckoutType"
        {
            $v = "PERPETUAL","PROVISIONAL"
            break
        }

        # Amazon.LicenseManager.DigitalSignatureMethod
        "Invoke-LICMLicenseCheckoutBorrow/DigitalSignatureMethod"
        {
            $v = "JWT_PS384"
            break
        }

        # Amazon.LicenseManager.GrantStatus
        "New-LICMGrantVersion/Status"
        {
            $v = "ACTIVE","DELETED","DISABLED","FAILED_WORKFLOW","PENDING_ACCEPT","PENDING_DELETE","PENDING_WORKFLOW","REJECTED","WORKFLOW_COMPLETED"
            break
        }

        # Amazon.LicenseManager.LicenseConfigurationStatus
        "Update-LICMLicenseConfiguration/LicenseConfigurationStatus"
        {
            $v = "AVAILABLE","DISABLED"
            break
        }

        # Amazon.LicenseManager.LicenseCountingType
        "New-LICMLicenseConfiguration/LicenseCountingType"
        {
            $v = "Core","Instance","Socket","vCPU"
            break
        }

        # Amazon.LicenseManager.LicenseStatus
        "New-LICMLicenseVersion/Status"
        {
            $v = "AVAILABLE","DEACTIVATED","DELETED","EXPIRED","PENDING_AVAILABLE","PENDING_DELETE","SUSPENDED"
            break
        }

        # Amazon.LicenseManager.RenewType
        {
            ($_ -eq "New-LICMLicense/ConsumptionConfiguration_RenewType") -Or
            ($_ -eq "New-LICMLicenseVersion/ConsumptionConfiguration_RenewType")
        }
        {
            $v = "Monthly","None","Weekly"
            break
        }

        # Amazon.LicenseManager.ReportFrequencyType
        {
            ($_ -eq "New-LICMLicenseManagerReportGenerator/ReportFrequency_Period") -Or
            ($_ -eq "Update-LICMLicenseManagerReportGenerator/ReportFrequency_Period")
        }
        {
            $v = "DAY","MONTH","WEEK"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LICM_map = @{
    "CheckoutType"=@("Invoke-LICMLicenseCheckout")
    "ConsumptionConfiguration_RenewType"=@("New-LICMLicense","New-LICMLicenseVersion")
    "DigitalSignatureMethod"=@("Invoke-LICMLicenseCheckoutBorrow")
    "LicenseConfigurationStatus"=@("Update-LICMLicenseConfiguration")
    "LicenseCountingType"=@("New-LICMLicenseConfiguration")
    "ReportFrequency_Period"=@("New-LICMLicenseManagerReportGenerator","Update-LICMLicenseManagerReportGenerator")
    "Status"=@("New-LICMGrantVersion","New-LICMLicenseVersion")
}

_awsArgumentCompleterRegistration $LICM_Completers $LICM_map

$LICM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LICM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LICM_SelectMap = @{
    "Select"=@("Approve-LICMGrant",
               "Invoke-LICMLicenseCheckIn",
               "Invoke-LICMLicenseCheckoutBorrow",
               "Invoke-LICMLicenseCheckout",
               "New-LICMGrant",
               "New-LICMGrantVersion",
               "New-LICMLicense",
               "New-LICMLicenseConfiguration",
               "New-LICMLicenseConversionTaskForResource",
               "New-LICMLicenseManagerReportGenerator",
               "New-LICMLicenseVersion",
               "New-LICMToken",
               "Remove-LICMGrant",
               "Remove-LICMLicense",
               "Remove-LICMLicenseConfiguration",
               "Remove-LICMLicenseManagerReportGenerator",
               "Remove-LICMToken",
               "Invoke-LICMExtendLicenseConsumption",
               "Get-LICMAccessToken",
               "Get-LICMGrant",
               "Get-LICMLicense",
               "Get-LICMLicenseConfiguration",
               "Get-LICMLicenseConversionTask",
               "Get-LICMLicenseManagerReportGenerator",
               "Get-LICMLicenseUsage",
               "Get-LICMServiceSetting",
               "Get-LICMAssociationsForLicenseConfigurationList",
               "Get-LICMDistributedGrantList",
               "Get-LICMFailuresForLicenseConfigurationOperationList",
               "Get-LICMLicenseConfigurationList",
               "Get-LICMLicenseConversionTaskList",
               "Get-LICMLicenseManagerReportGeneratorList",
               "Get-LICMLicenseList",
               "Get-LICMLicenseSpecificationsForResourceList",
               "Get-LICMLicenseVersionList",
               "Get-LICMReceivedGrantList",
               "Get-LICMReceivedGrantsForOrganizationList",
               "Get-LICMReceivedLicenseList",
               "Get-LICMReceivedLicensesForOrganizationList",
               "Get-LICMResourceInventoryList",
               "Get-LICMResourceTagList",
               "Get-LICMTokenList",
               "Get-LICMUsageForLicenseConfigurationList",
               "Deny-LICMGrant",
               "Add-LICMResourceTag",
               "Remove-LICMResourceTag",
               "Update-LICMLicenseConfiguration",
               "Update-LICMLicenseManagerReportGenerator",
               "Update-LICMLicenseSpecificationsForResource",
               "Update-LICMServiceSetting")
}

_awsArgumentCompleterRegistration $LICM_SelectCompleters $LICM_SelectMap
# Argument completions for service AWS License Manager User Subscription


$LMUS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LMUS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMUS_SelectMap = @{
    "Select"=@("Add-LMUSUser",
               "Unregister-LMUSIdentityProvider",
               "Remove-LMUSUser",
               "Get-LMUSIdentityProviderList",
               "Get-LMUSInstanceList",
               "Get-LMUSProductSubscriptionList",
               "Get-LMUSUserAssociationList",
               "Register-LMUSIdentityProvider",
               "Start-LMUSProductSubscription",
               "Stop-LMUSProductSubscription")
}

_awsArgumentCompleterRegistration $LMUS_SelectCompleters $LMUS_SelectMap
# Argument completions for service Amazon Lightsail


$LS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lightsail.AccessType
        "Update-LSBucket/AccessRules_GetObject"
        {
            $v = "private","public"
            break
        }

        # Amazon.Lightsail.AddOnType
        {
            ($_ -eq "Enable-LSAddOn/AddOnRequest_AddOnType") -Or
            ($_ -eq "Disable-LSAddOn/AddOnType")
        }
        {
            $v = "AutoSnapshot"
            break
        }

        # Amazon.Lightsail.AlarmState
        "Test-LSAlarm/State"
        {
            $v = "ALARM","INSUFFICIENT_DATA","OK"
            break
        }

        # Amazon.Lightsail.BehaviorEnum
        {
            ($_ -eq "New-LSDistribution/DefaultCacheBehavior_Behavior") -Or
            ($_ -eq "Update-LSDistribution/DefaultCacheBehavior_Behavior")
        }
        {
            $v = "cache","dont-cache"
            break
        }

        # Amazon.Lightsail.BucketMetricName
        "Get-LSBucketMetricData/MetricName"
        {
            $v = "BucketSizeBytes","NumberOfObjects"
            break
        }

        # Amazon.Lightsail.ComparisonOperator
        "Add-LSAlarm/ComparisonOperator"
        {
            $v = "GreaterThanOrEqualToThreshold","GreaterThanThreshold","LessThanOrEqualToThreshold","LessThanThreshold"
            break
        }

        # Amazon.Lightsail.ContactMethodVerificationProtocol
        "Send-LSContactMethodVerification/Protocol"
        {
            $v = "Email"
            break
        }

        # Amazon.Lightsail.ContactProtocol
        {
            ($_ -eq "New-LSContactMethod/Protocol") -Or
            ($_ -eq "Remove-LSContactMethod/Protocol")
        }
        {
            $v = "Email","SMS"
            break
        }

        # Amazon.Lightsail.ContainerServiceMetricName
        "Get-LSContainerServiceMetricData/MetricName"
        {
            $v = "CPUUtilization","MemoryUtilization"
            break
        }

        # Amazon.Lightsail.ContainerServicePowerName
        {
            ($_ -eq "New-LSContainerService/Power") -Or
            ($_ -eq "Update-LSContainerService/Power")
        }
        {
            $v = "large","medium","micro","nano","small","xlarge"
            break
        }

        # Amazon.Lightsail.DistributionMetricName
        "Get-LSDistributionMetricData/MetricName"
        {
            $v = "BytesDownloaded","BytesUploaded","Http4xxErrorRate","Http5xxErrorRate","Requests","TotalErrorRate"
            break
        }

        # Amazon.Lightsail.ForwardValues
        {
            ($_ -eq "New-LSDistribution/CacheBehaviorSettings_ForwardedCookies_Option") -Or
            ($_ -eq "Update-LSDistribution/CacheBehaviorSettings_ForwardedCookies_Option") -Or
            ($_ -eq "New-LSDistribution/CacheBehaviorSettings_ForwardedHeaders_Option") -Or
            ($_ -eq "Update-LSDistribution/CacheBehaviorSettings_ForwardedHeaders_Option")
        }
        {
            $v = "all","allow-list","none"
            break
        }

        # Amazon.Lightsail.HttpEndpoint
        "Update-LSInstanceMetadataOption/HttpEndpoint"
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.Lightsail.HttpProtocolIpv6
        "Update-LSInstanceMetadataOption/HttpProtocolIpv6"
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.Lightsail.HttpTokens
        "Update-LSInstanceMetadataOption/HttpTokens"
        {
            $v = "optional","required"
            break
        }

        # Amazon.Lightsail.InstanceAccessProtocol
        "Get-LSInstanceAccessDetail/Protocol"
        {
            $v = "rdp","ssh"
            break
        }

        # Amazon.Lightsail.InstanceMetricName
        "Get-LSInstanceMetricData/MetricName"
        {
            $v = "BurstCapacityPercentage","BurstCapacityTime","CPUUtilization","MetadataNoToken","NetworkIn","NetworkOut","StatusCheckFailed","StatusCheckFailed_Instance","StatusCheckFailed_System"
            break
        }

        # Amazon.Lightsail.IpAddressType
        {
            ($_ -eq "New-LSDistribution/IpAddressType") -Or
            ($_ -eq "New-LSInstance/IpAddressType") -Or
            ($_ -eq "New-LSInstancesFromSnapshot/IpAddressType") -Or
            ($_ -eq "New-LSLoadBalancer/IpAddressType") -Or
            ($_ -eq "Set-LSIpAddressType/IpAddressType")
        }
        {
            $v = "dualstack","ipv4"
            break
        }

        # Amazon.Lightsail.LoadBalancerAttributeName
        "Update-LSLoadBalancerAttribute/AttributeName"
        {
            $v = "HealthCheckPath","HttpsRedirectionEnabled","SessionStickinessEnabled","SessionStickiness_LB_CookieDurationSeconds","TlsPolicyName"
            break
        }

        # Amazon.Lightsail.LoadBalancerMetricName
        "Get-LSLoadBalancerMetricData/MetricName"
        {
            $v = "ClientTLSNegotiationErrorCount","HealthyHostCount","HTTPCode_Instance_2XX_Count","HTTPCode_Instance_3XX_Count","HTTPCode_Instance_4XX_Count","HTTPCode_Instance_5XX_Count","HTTPCode_LB_4XX_Count","HTTPCode_LB_5XX_Count","InstanceResponseTime","RejectedConnectionCount","RequestCount","UnhealthyHostCount"
            break
        }

        # Amazon.Lightsail.MetricName
        "Add-LSAlarm/MetricName"
        {
            $v = "BurstCapacityPercentage","BurstCapacityTime","ClientTLSNegotiationErrorCount","CPUUtilization","DatabaseConnections","DiskQueueDepth","FreeStorageSpace","HealthyHostCount","HTTPCode_Instance_2XX_Count","HTTPCode_Instance_3XX_Count","HTTPCode_Instance_4XX_Count","HTTPCode_Instance_5XX_Count","HTTPCode_LB_4XX_Count","HTTPCode_LB_5XX_Count","InstanceResponseTime","NetworkIn","NetworkOut","NetworkReceiveThroughput","NetworkTransmitThroughput","RejectedConnectionCount","RequestCount","StatusCheckFailed","StatusCheckFailed_Instance","StatusCheckFailed_System","UnhealthyHostCount"
            break
        }

        # Amazon.Lightsail.MetricUnit
        {
            ($_ -eq "Get-LSBucketMetricData/Unit") -Or
            ($_ -eq "Get-LSDistributionMetricData/Unit") -Or
            ($_ -eq "Get-LSInstanceMetricData/Unit") -Or
            ($_ -eq "Get-LSLoadBalancerMetricData/Unit") -Or
            ($_ -eq "Get-LSRelationalDatabaseMetricData/Unit")
        }
        {
            $v = "Bits","Bits/Second","Bytes","Bytes/Second","Count","Count/Second","Gigabits","Gigabits/Second","Gigabytes","Gigabytes/Second","Kilobits","Kilobits/Second","Kilobytes","Kilobytes/Second","Megabits","Megabits/Second","Megabytes","Megabytes/Second","Microseconds","Milliseconds","None","Percent","Seconds","Terabits","Terabits/Second","Terabytes","Terabytes/Second"
            break
        }

        # Amazon.Lightsail.NetworkProtocol
        {
            ($_ -eq "Close-LSInstancePublicPort/PortInfo_Protocol") -Or
            ($_ -eq "Open-LSInstancePublicPort/PortInfo_Protocol")
        }
        {
            $v = "all","icmp","tcp","udp"
            break
        }

        # Amazon.Lightsail.OriginProtocolPolicyEnum
        {
            ($_ -eq "New-LSDistribution/Origin_ProtocolPolicy") -Or
            ($_ -eq "Update-LSDistribution/Origin_ProtocolPolicy")
        }
        {
            $v = "http-only","https-only"
            break
        }

        # Amazon.Lightsail.RegionName
        {
            ($_ -eq "New-LSDistribution/Origin_RegionName") -Or
            ($_ -eq "Update-LSDistribution/Origin_RegionName") -Or
            ($_ -eq "Copy-LSSnapshot/SourceRegion")
        }
        {
            $v = "ap-northeast-1","ap-northeast-2","ap-south-1","ap-southeast-1","ap-southeast-2","ca-central-1","eu-central-1","eu-north-1","eu-west-1","eu-west-2","eu-west-3","us-east-1","us-east-2","us-west-1","us-west-2"
            break
        }

        # Amazon.Lightsail.RelationalDatabaseMetricName
        "Get-LSRelationalDatabaseMetricData/MetricName"
        {
            $v = "CPUUtilization","DatabaseConnections","DiskQueueDepth","FreeStorageSpace","NetworkReceiveThroughput","NetworkTransmitThroughput"
            break
        }

        # Amazon.Lightsail.RelationalDatabasePasswordVersion
        "Get-LSRelationalDatabaseMasterUserPassword/PasswordVersion"
        {
            $v = "CURRENT","PENDING","PREVIOUS"
            break
        }

        # Amazon.Lightsail.ResourceBucketAccess
        "Set-LSResourceAccessForBucket/Access"
        {
            $v = "allow","deny"
            break
        }

        # Amazon.Lightsail.ResourceType
        "Set-LSIpAddressType/ResourceType"
        {
            $v = "Alarm","Bucket","Certificate","CloudFormationStackRecord","ContactMethod","ContainerService","Disk","DiskSnapshot","Distribution","Domain","ExportSnapshotRecord","Instance","InstanceSnapshot","KeyPair","LoadBalancer","LoadBalancerTlsCertificate","PeeredVpc","RelationalDatabase","RelationalDatabaseSnapshot","StaticIp"
            break
        }

        # Amazon.Lightsail.TreatMissingData
        "Add-LSAlarm/TreatMissingData"
        {
            $v = "breaching","ignore","missing","notBreaching"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LS_map = @{
    "Access"=@("Set-LSResourceAccessForBucket")
    "AccessRules_GetObject"=@("Update-LSBucket")
    "AddOnRequest_AddOnType"=@("Enable-LSAddOn")
    "AddOnType"=@("Disable-LSAddOn")
    "AttributeName"=@("Update-LSLoadBalancerAttribute")
    "CacheBehaviorSettings_ForwardedCookies_Option"=@("New-LSDistribution","Update-LSDistribution")
    "CacheBehaviorSettings_ForwardedHeaders_Option"=@("New-LSDistribution","Update-LSDistribution")
    "ComparisonOperator"=@("Add-LSAlarm")
    "DefaultCacheBehavior_Behavior"=@("New-LSDistribution","Update-LSDistribution")
    "HttpEndpoint"=@("Update-LSInstanceMetadataOption")
    "HttpProtocolIpv6"=@("Update-LSInstanceMetadataOption")
    "HttpTokens"=@("Update-LSInstanceMetadataOption")
    "IpAddressType"=@("New-LSDistribution","New-LSInstance","New-LSInstancesFromSnapshot","New-LSLoadBalancer","Set-LSIpAddressType")
    "MetricName"=@("Add-LSAlarm","Get-LSBucketMetricData","Get-LSContainerServiceMetricData","Get-LSDistributionMetricData","Get-LSInstanceMetricData","Get-LSLoadBalancerMetricData","Get-LSRelationalDatabaseMetricData")
    "Origin_ProtocolPolicy"=@("New-LSDistribution","Update-LSDistribution")
    "Origin_RegionName"=@("New-LSDistribution","Update-LSDistribution")
    "PasswordVersion"=@("Get-LSRelationalDatabaseMasterUserPassword")
    "PortInfo_Protocol"=@("Close-LSInstancePublicPort","Open-LSInstancePublicPort")
    "Power"=@("New-LSContainerService","Update-LSContainerService")
    "Protocol"=@("Get-LSInstanceAccessDetail","New-LSContactMethod","Remove-LSContactMethod","Send-LSContactMethodVerification")
    "ResourceType"=@("Set-LSIpAddressType")
    "SourceRegion"=@("Copy-LSSnapshot")
    "State"=@("Test-LSAlarm")
    "TreatMissingData"=@("Add-LSAlarm")
    "Unit"=@("Get-LSBucketMetricData","Get-LSDistributionMetricData","Get-LSInstanceMetricData","Get-LSLoadBalancerMetricData","Get-LSRelationalDatabaseMetricData")
}

_awsArgumentCompleterRegistration $LS_Completers $LS_map

$LS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LS_SelectMap = @{
    "Select"=@("New-LSStaticIp",
               "Mount-LSCertificateToDistribution",
               "Add-LSDisk",
               "Add-LSInstancesToLoadBalancer",
               "Add-LSLoadBalancerTlsCertificate",
               "Mount-LSStaticIp",
               "Close-LSInstancePublicPort",
               "Copy-LSSnapshot",
               "New-LSBucket",
               "New-LSBucketAccessKey",
               "New-LSCertificate",
               "New-LSCloudFormationStack",
               "New-LSContactMethod",
               "New-LSContainerService",
               "New-LSContainerServiceDeployment",
               "New-LSContainerServiceRegistryLogin",
               "New-LSDisk",
               "New-LSDiskFromSnapshot",
               "New-LSDiskSnapshot",
               "New-LSDistribution",
               "New-LSDomain",
               "New-LSDomainEntry",
               "New-LSInstance",
               "New-LSInstancesFromSnapshot",
               "New-LSInstanceSnapshot",
               "New-LSKeyPair",
               "New-LSLoadBalancer",
               "New-LSLoadBalancerTlsCertificate",
               "New-LSRelationalDatabase",
               "New-LSRelationalDatabaseFromSnapshot",
               "New-LSRelationalDatabaseSnapshot",
               "Remove-LSAlarm",
               "Remove-LSAutoSnapshot",
               "Remove-LSBucket",
               "Remove-LSBucketAccessKey",
               "Remove-LSCertificate",
               "Remove-LSContactMethod",
               "Remove-LSContainerImage",
               "Remove-LSContainerService",
               "Remove-LSDisk",
               "Remove-LSDiskSnapshot",
               "Remove-LSDistribution",
               "Remove-LSDomain",
               "Remove-LSDomainEntry",
               "Remove-LSInstance",
               "Remove-LSInstanceSnapshot",
               "Remove-LSKeyPair",
               "Remove-LSKnownHostKey",
               "Remove-LSLoadBalancer",
               "Remove-LSLoadBalancerTlsCertificate",
               "Remove-LSRelationalDatabase",
               "Remove-LSRelationalDatabaseSnapshot",
               "Dismount-LSCertificateFromDistribution",
               "Dismount-LSDisk",
               "Dismount-LSInstancesFromLoadBalancer",
               "Dismount-LSStaticIp",
               "Disable-LSAddOn",
               "Read-LSDefaultKeyPair",
               "Enable-LSAddOn",
               "Export-LSSnapshot",
               "Get-LSActiveNameList",
               "Get-LSAlarm",
               "Get-LSAutoSnapshot",
               "Get-LSBlueprintList",
               "Get-LSBucketAccessKey",
               "Get-LSBucketBundle",
               "Get-LSBucketMetricData",
               "Get-LSBucket",
               "Get-LSBundleList",
               "Get-LSCertificate",
               "Get-LSCloudFormationStackRecord",
               "Get-LSContactMethod",
               "Get-LSContainerAPIMetadata",
               "Get-LSContainerImage",
               "Get-LSContainerLog",
               "Get-LSContainerServiceDeployment",
               "Get-LSContainerServiceMetricData",
               "Get-LSContainerServicePower",
               "Get-LSContainerService",
               "Get-LSDisk",
               "Get-LSDiskList",
               "Get-LSDiskSnapshot",
               "Get-LSDiskSnapshotList",
               "Get-LSDistributionBundle",
               "Get-LSDistributionLatestCacheReset",
               "Get-LSDistributionMetricData",
               "Get-LSDistribution",
               "Get-LSDomain",
               "Get-LSDomainList",
               "Get-LSExportSnapshotRecord",
               "Get-LSInstance",
               "Get-LSInstanceAccessDetail",
               "Get-LSInstanceMetricData",
               "Get-LSInstancePortStateList",
               "Get-LSInstanceList",
               "Get-LSInstanceSnapshot",
               "Get-LSInstanceSnapshotList",
               "Get-LSInstanceState",
               "Get-LSKeyPairInfo",
               "Get-LSKeypairList",
               "Get-LSLoadBalancer",
               "Get-LSLoadBalancerMetricData",
               "Get-LSLoadBalancerList",
               "Get-LSLoadBalancerTlsCertificate",
               "Get-LSLoadBalancerTlsPolicy",
               "Get-LSOperation",
               "Get-LSOperationList",
               "Get-LSOperationListForResource",
               "Get-LSRegionList",
               "Get-LSRelationalDatabase",
               "Get-LSRelationalDatabaseBlueprint",
               "Get-LSRelationalDatabaseBundle",
               "Get-LSRelationalDatabaseEvent",
               "Get-LSRelationalDatabaseLogEvent",
               "Get-LSRelationalDatabaseLogStream",
               "Get-LSRelationalDatabaseMasterUserPassword",
               "Get-LSRelationalDatabaseMetricData",
               "Get-LSRelationalDatabaseParameter",
               "Get-LSRelationalDatabaseList",
               "Get-LSRelationalDatabaseSnapshot",
               "Get-LSRelationalDatabaseSnapshotList",
               "Get-LSStaticIp",
               "Get-LSStaticIpList",
               "Import-LSKeyPair",
               "Test-LSVpcPeered",
               "Open-LSInstancePublicPort",
               "Add-LSPeerVpc",
               "Add-LSAlarm",
               "Set-LSInstancePublicPort",
               "Restart-LSInstance",
               "Restart-LSRelationalDatabase",
               "Register-LSContainerImage",
               "Remove-LSStaticIp",
               "Reset-LSDistributionCache",
               "Send-LSContactMethodVerification",
               "Set-LSIpAddressType",
               "Set-LSResourceAccessForBucket",
               "Start-LSInstance",
               "Start-LSRelationalDatabase",
               "Stop-LSInstance",
               "Stop-LSRelationalDatabase",
               "Add-LSResourceTag",
               "Test-LSAlarm",
               "Remove-LSPeerVpc",
               "Remove-LSResourceTag",
               "Update-LSBucket",
               "Update-LSBucketBundle",
               "Update-LSContainerService",
               "Update-LSDistribution",
               "Update-LSDistributionBundle",
               "Update-LSDomainEntry",
               "Update-LSInstanceMetadataOption",
               "Update-LSLoadBalancerAttribute",
               "Update-LSRelationalDatabase",
               "Update-LSRelationalDatabaseParameter")
}

_awsArgumentCompleterRegistration $LS_SelectCompleters $LS_SelectMap
# Argument completions for service Amazon Location Service


$LOC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LocationService.DimensionUnit
        {
            ($_ -eq "Get-LOCRoute/TruckModeOptions_Dimensions_Unit") -Or
            ($_ -eq "Get-LOCRouteMatrix/TruckModeOptions_Dimensions_Unit")
        }
        {
            $v = "Feet","Meters"
            break
        }

        # Amazon.LocationService.DistanceUnit
        {
            ($_ -eq "Get-LOCRoute/DistanceUnit") -Or
            ($_ -eq "Get-LOCRouteMatrix/DistanceUnit")
        }
        {
            $v = "Kilometers","Miles"
            break
        }

        # Amazon.LocationService.IntendedUse
        {
            ($_ -eq "Edit-LOCPlaceIndex/DataSourceConfiguration_IntendedUse") -Or
            ($_ -eq "New-LOCPlaceIndex/DataSourceConfiguration_IntendedUse")
        }
        {
            $v = "SingleUse","Storage"
            break
        }

        # Amazon.LocationService.PositionFiltering
        {
            ($_ -eq "Edit-LOCTracker/PositionFiltering") -Or
            ($_ -eq "New-LOCTracker/PositionFiltering")
        }
        {
            $v = "AccuracyBased","DistanceBased","TimeBased"
            break
        }

        # Amazon.LocationService.PricingPlan
        {
            ($_ -eq "Edit-LOCGeofenceCollection/PricingPlan") -Or
            ($_ -eq "Edit-LOCMap/PricingPlan") -Or
            ($_ -eq "Edit-LOCPlaceIndex/PricingPlan") -Or
            ($_ -eq "Edit-LOCRouteCalculator/PricingPlan") -Or
            ($_ -eq "Edit-LOCTracker/PricingPlan") -Or
            ($_ -eq "New-LOCGeofenceCollection/PricingPlan") -Or
            ($_ -eq "New-LOCMap/PricingPlan") -Or
            ($_ -eq "New-LOCPlaceIndex/PricingPlan") -Or
            ($_ -eq "New-LOCRouteCalculator/PricingPlan") -Or
            ($_ -eq "New-LOCTracker/PricingPlan")
        }
        {
            $v = "MobileAssetManagement","MobileAssetTracking","RequestBasedUsage"
            break
        }

        # Amazon.LocationService.TravelMode
        {
            ($_ -eq "Get-LOCRoute/TravelMode") -Or
            ($_ -eq "Get-LOCRouteMatrix/TravelMode")
        }
        {
            $v = "Car","Truck","Walking"
            break
        }

        # Amazon.LocationService.VehicleWeightUnit
        {
            ($_ -eq "Get-LOCRoute/TruckModeOptions_Weight_Unit") -Or
            ($_ -eq "Get-LOCRouteMatrix/TruckModeOptions_Weight_Unit")
        }
        {
            $v = "Kilograms","Pounds"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LOC_map = @{
    "DataSourceConfiguration_IntendedUse"=@("Edit-LOCPlaceIndex","New-LOCPlaceIndex")
    "DistanceUnit"=@("Get-LOCRoute","Get-LOCRouteMatrix")
    "PositionFiltering"=@("Edit-LOCTracker","New-LOCTracker")
    "PricingPlan"=@("Edit-LOCGeofenceCollection","Edit-LOCMap","Edit-LOCPlaceIndex","Edit-LOCRouteCalculator","Edit-LOCTracker","New-LOCGeofenceCollection","New-LOCMap","New-LOCPlaceIndex","New-LOCRouteCalculator","New-LOCTracker")
    "TravelMode"=@("Get-LOCRoute","Get-LOCRouteMatrix")
    "TruckModeOptions_Dimensions_Unit"=@("Get-LOCRoute","Get-LOCRouteMatrix")
    "TruckModeOptions_Weight_Unit"=@("Get-LOCRoute","Get-LOCRouteMatrix")
}

_awsArgumentCompleterRegistration $LOC_Completers $LOC_map

$LOC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LOC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LOC_SelectMap = @{
    "Select"=@("Register-LOCTrackerConsumer",
               "Remove-LOCDevicePositionHistoryBatch",
               "Remove-LOCGeofenceBatch",
               "Submit-LOCGeofenceEvaluationBatch",
               "Get-LOCDevicePositionBatch",
               "Set-LOCGeofenceBatch",
               "Set-LOCDevicePositionBatch",
               "Get-LOCRoute",
               "Get-LOCRouteMatrix",
               "New-LOCGeofenceCollection",
               "New-LOCMap",
               "New-LOCPlaceIndex",
               "New-LOCRouteCalculator",
               "New-LOCTracker",
               "Remove-LOCGeofenceCollection",
               "Remove-LOCMap",
               "Remove-LOCPlaceIndex",
               "Remove-LOCRouteCalculator",
               "Remove-LOCTracker",
               "Get-LOCGeofenceCollection",
               "Get-LOCMap",
               "Get-LOCPlaceIndex",
               "Get-LOCRouteCalculator",
               "Get-LOCTracker",
               "Unregister-LOCTrackerConsumer",
               "Get-LOCDevicePosition",
               "Get-LOCDevicePositionHistory",
               "Get-LOCGeofence",
               "Get-LOCMapGlyph",
               "Get-LOCMapSprite",
               "Get-LOCMapStyleDescriptor",
               "Get-LOCMapTile",
               "Get-LOCPlace",
               "Get-LOCDevicePositionList",
               "Get-LOCGeofenceCollectionList",
               "Get-LOCGeofenceList",
               "Get-LOCMapList",
               "Get-LOCPlaceIndexList",
               "Get-LOCRouteCalculatorList",
               "Get-LOCResourceTagSet",
               "Get-LOCTrackerConsumerList",
               "Get-LOCTrackerList",
               "Set-LOCGeofence",
               "Search-LOCPlaceIndexForPosition",
               "Search-LOCPlaceIndexForSuggestion",
               "Search-LOCPlaceIndexForText",
               "Add-LOCResourceTagSet",
               "Remove-LOCResourceTagSet",
               "Edit-LOCGeofenceCollection",
               "Edit-LOCMap",
               "Edit-LOCPlaceIndex",
               "Edit-LOCRouteCalculator",
               "Edit-LOCTracker")
}

_awsArgumentCompleterRegistration $LOC_SelectCompleters $LOC_SelectMap
# Argument completions for service Amazon CloudWatch Logs


$CWL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchLogs.Distribution
        "Write-CWLSubscriptionFilter/Distribution"
        {
            $v = "ByLogStream","Random"
            break
        }

        # Amazon.CloudWatchLogs.ExportTaskStatusCode
        "Get-CWLExportTask/StatusCode"
        {
            $v = "CANCELLED","COMPLETED","FAILED","PENDING","PENDING_CANCEL","RUNNING"
            break
        }

        # Amazon.CloudWatchLogs.OrderBy
        "Get-CWLLogStream/OrderBy"
        {
            $v = "LastEventTime","LogStreamName"
            break
        }

        # Amazon.CloudWatchLogs.QueryStatus
        "Get-CWLQuery/Status"
        {
            $v = "Cancelled","Complete","Failed","Running","Scheduled","Timeout","Unknown"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWL_map = @{
    "Distribution"=@("Write-CWLSubscriptionFilter")
    "OrderBy"=@("Get-CWLLogStream")
    "Status"=@("Get-CWLQuery")
    "StatusCode"=@("Get-CWLExportTask")
}

_awsArgumentCompleterRegistration $CWL_Completers $CWL_map

$CWL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWL_SelectMap = @{
    "Select"=@("Register-CWLKmsKey",
               "Stop-CWLExportTask",
               "New-CWLExportTask",
               "New-CWLLogGroup",
               "New-CWLLogStream",
               "Remove-CWLDestination",
               "Remove-CWLLogGroup",
               "Remove-CWLLogStream",
               "Remove-CWLMetricFilter",
               "Remove-CWLQueryDefinition",
               "Remove-CWLResourcePolicy",
               "Remove-CWLRetentionPolicy",
               "Remove-CWLSubscriptionFilter",
               "Get-CWLDestination",
               "Get-CWLExportTask",
               "Get-CWLLogGroup",
               "Get-CWLLogStream",
               "Get-CWLMetricFilter",
               "Get-CWLQuery",
               "Get-CWLQueryDefinition",
               "Get-CWLResourcePolicy",
               "Get-CWLSubscriptionFilter",
               "Unregister-CWLKmsKey",
               "Get-CWLFilteredLogEvent",
               "Get-CWLLogEvent",
               "Get-CWLLogGroupField",
               "Get-CWLLogRecord",
               "Get-CWLQueryResult",
               "Get-CWLResourceTag",
               "Get-CWLLogGroupTag",
               "Write-CWLDestination",
               "Write-CWLDestinationPolicy",
               "Write-CWLLogEvent",
               "Write-CWLMetricFilter",
               "Write-CWLQueryDefinition",
               "Write-CWLResourcePolicy",
               "Write-CWLRetentionPolicy",
               "Write-CWLSubscriptionFilter",
               "Start-CWLQuery",
               "Stop-CWLQuery",
               "Add-CWLLogGroupTag",
               "Add-CWLResourceTag",
               "Test-CWLMetricFilter",
               "Remove-CWLLogGroupTag",
               "Remove-CWLResourceTag")
}

_awsArgumentCompleterRegistration $CWL_SelectCompleters $CWL_SelectMap
# Argument completions for service Amazon Lookout for Equipment


$L4E_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LookoutEquipment.DataUploadFrequency
        {
            ($_ -eq "New-L4EInferenceScheduler/DataUploadFrequency") -Or
            ($_ -eq "Update-L4EInferenceScheduler/DataUploadFrequency")
        }
        {
            $v = "PT10M","PT15M","PT1H","PT30M","PT5M"
            break
        }

        # Amazon.LookoutEquipment.InferenceExecutionStatus
        "Get-L4EInferenceExecutionList/Status"
        {
            $v = "FAILED","IN_PROGRESS","SUCCESS"
            break
        }

        # Amazon.LookoutEquipment.IngestionJobStatus
        "Get-L4EDataIngestionJobList/Status"
        {
            $v = "FAILED","IN_PROGRESS","SUCCESS"
            break
        }

        # Amazon.LookoutEquipment.LabelRating
        "New-L4ELabel/Rating"
        {
            $v = "ANOMALY","NEUTRAL","NO_ANOMALY"
            break
        }

        # Amazon.LookoutEquipment.ModelStatus
        "Get-L4EModelList/Status"
        {
            $v = "FAILED","IN_PROGRESS","SUCCESS"
            break
        }

        # Amazon.LookoutEquipment.TargetSamplingRate
        "New-L4EModel/DataPreProcessingConfiguration_TargetSamplingRate"
        {
            $v = "PT10M","PT10S","PT15M","PT15S","PT1H","PT1M","PT1S","PT30M","PT30S","PT5M","PT5S"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$L4E_map = @{
    "DataPreProcessingConfiguration_TargetSamplingRate"=@("New-L4EModel")
    "DataUploadFrequency"=@("New-L4EInferenceScheduler","Update-L4EInferenceScheduler")
    "Rating"=@("New-L4ELabel")
    "Status"=@("Get-L4EDataIngestionJobList","Get-L4EInferenceExecutionList","Get-L4EModelList")
}

_awsArgumentCompleterRegistration $L4E_Completers $L4E_map

$L4E_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.L4E.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$L4E_SelectMap = @{
    "Select"=@("New-L4EDataset",
               "New-L4EInferenceScheduler",
               "New-L4ELabel",
               "New-L4ELabelGroup",
               "New-L4EModel",
               "Remove-L4EDataset",
               "Remove-L4EInferenceScheduler",
               "Remove-L4ELabel",
               "Remove-L4ELabelGroup",
               "Remove-L4EModel",
               "Get-L4EDataIngestionJob",
               "Get-L4EDataset",
               "Get-L4EInferenceScheduler",
               "Get-L4ELabel",
               "Get-L4ELabelGroup",
               "Get-L4EModel",
               "Get-L4EDataIngestionJobList",
               "Get-L4EDatasetList",
               "Get-L4EInferenceEventList",
               "Get-L4EInferenceExecutionList",
               "Get-L4EInferenceSchedulerList",
               "Get-L4ELabelGroupList",
               "Get-L4ELabelList",
               "Get-L4EModelList",
               "Get-L4ESensorStatisticList",
               "Get-L4EResourceTag",
               "Start-L4EDataIngestionJob",
               "Start-L4EInferenceScheduler",
               "Stop-L4EInferenceScheduler",
               "Add-L4EResourceTag",
               "Remove-L4EResourceTag",
               "Update-L4EInferenceScheduler",
               "Update-L4ELabelGroup")
}

_awsArgumentCompleterRegistration $L4E_SelectCompleters $L4E_SelectMap
# Argument completions for service Amazon Lookout for Metrics


$LOM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LookoutMetrics.CSVFileCompression
        {
            ($_ -eq "New-LOMMetricSet/MetricSource_S3SourceConfig_FileFormatDescriptor_CsvFormatDescriptor_FileCompression") -Or
            ($_ -eq "Update-LOMMetricSet/MetricSource_S3SourceConfig_FileFormatDescriptor_CsvFormatDescriptor_FileCompression") -Or
            ($_ -eq "Get-LOMSampleData/S3SourceConfig_FileFormatDescriptor_CsvFormatDescriptor_FileCompression")
        }
        {
            $v = "GZIP","NONE"
            break
        }

        # Amazon.LookoutMetrics.Frequency
        {
            ($_ -eq "New-LOMAnomalyDetector/AnomalyDetectorConfig_AnomalyDetectorFrequency") -Or
            ($_ -eq "Update-LOMAnomalyDetector/AnomalyDetectorConfig_AnomalyDetectorFrequency") -Or
            ($_ -eq "New-LOMMetricSet/MetricSetFrequency") -Or
            ($_ -eq "Update-LOMMetricSet/MetricSetFrequency")
        }
        {
            $v = "P1D","PT10M","PT1H","PT5M"
            break
        }

        # Amazon.LookoutMetrics.JsonFileCompression
        {
            ($_ -eq "New-LOMMetricSet/MetricSource_S3SourceConfig_FileFormatDescriptor_JsonFormatDescriptor_FileCompression") -Or
            ($_ -eq "Update-LOMMetricSet/MetricSource_S3SourceConfig_FileFormatDescriptor_JsonFormatDescriptor_FileCompression") -Or
            ($_ -eq "Get-LOMSampleData/S3SourceConfig_FileFormatDescriptor_JsonFormatDescriptor_FileCompression")
        }
        {
            $v = "GZIP","NONE"
            break
        }

        # Amazon.LookoutMetrics.RelationshipType
        "Get-LOMAnomalyGroupRelatedMetricList/RelationshipTypeFilter"
        {
            $v = "CAUSE_OF_INPUT_ANOMALY_GROUP","EFFECT_OF_INPUT_ANOMALY_GROUP"
            break
        }

        # Amazon.LookoutMetrics.SnsFormat
        {
            ($_ -eq "New-LOMAlert/Action_SNSConfiguration_SnsFormat") -Or
            ($_ -eq "Update-LOMAlert/Action_SNSConfiguration_SnsFormat")
        }
        {
            $v = "JSON","LONG_TEXT","SHORT_TEXT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LOM_map = @{
    "Action_SNSConfiguration_SnsFormat"=@("New-LOMAlert","Update-LOMAlert")
    "AnomalyDetectorConfig_AnomalyDetectorFrequency"=@("New-LOMAnomalyDetector","Update-LOMAnomalyDetector")
    "MetricSetFrequency"=@("New-LOMMetricSet","Update-LOMMetricSet")
    "MetricSource_S3SourceConfig_FileFormatDescriptor_CsvFormatDescriptor_FileCompression"=@("New-LOMMetricSet","Update-LOMMetricSet")
    "MetricSource_S3SourceConfig_FileFormatDescriptor_JsonFormatDescriptor_FileCompression"=@("New-LOMMetricSet","Update-LOMMetricSet")
    "RelationshipTypeFilter"=@("Get-LOMAnomalyGroupRelatedMetricList")
    "S3SourceConfig_FileFormatDescriptor_CsvFormatDescriptor_FileCompression"=@("Get-LOMSampleData")
    "S3SourceConfig_FileFormatDescriptor_JsonFormatDescriptor_FileCompression"=@("Get-LOMSampleData")
}

_awsArgumentCompleterRegistration $LOM_Completers $LOM_map

$LOM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LOM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LOM_SelectMap = @{
    "Select"=@("Enable-LOMAnomalyDetector",
               "Enable-LOMBackTestAnomalyDetector",
               "New-LOMAlert",
               "New-LOMAnomalyDetector",
               "New-LOMMetricSet",
               "Disable-LOMAnomalyDetector",
               "Remove-LOMAlert",
               "Remove-LOMAnomalyDetector",
               "Get-LOMAlert",
               "Get-LOMAnomalyDetectionExecution",
               "Get-LOMAnomalyDetector",
               "Get-LOMMetricSet",
               "Get-LOMMetricSetConfig",
               "Get-LOMAnomalyGroup",
               "Get-LOMDataQualityMetricList",
               "Get-LOMFeedback",
               "Get-LOMSampleData",
               "Get-LOMAlertList",
               "Get-LOMAnomalyDetectorList",
               "Get-LOMAnomalyGroupRelatedMetricList",
               "Get-LOMAnomalyGroupSummaryList",
               "Get-LOMAnomalyGroupTimeSeriesList",
               "Get-LOMMetricSetList",
               "Get-LOMResourceTag",
               "Write-LOMFeedback",
               "Add-LOMResourceTag",
               "Remove-LOMResourceTag",
               "Update-LOMAlert",
               "Update-LOMAnomalyDetector",
               "Update-LOMMetricSet")
}

_awsArgumentCompleterRegistration $LOM_SelectCompleters $LOM_SelectMap
# Argument completions for service Amazon Lookout for Vision


$LFV_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LookoutforVision.TargetDevice
        "Start-LFVModelPackagingJob/Configuration_Greengrass_TargetDevice"
        {
            $v = "jetson_xavier"
            break
        }

        # Amazon.LookoutforVision.TargetPlatformAccelerator
        "Start-LFVModelPackagingJob/Configuration_Greengrass_TargetPlatform_Accelerator"
        {
            $v = "NVIDIA"
            break
        }

        # Amazon.LookoutforVision.TargetPlatformArch
        "Start-LFVModelPackagingJob/Configuration_Greengrass_TargetPlatform_Arch"
        {
            $v = "ARM64","X86_64"
            break
        }

        # Amazon.LookoutforVision.TargetPlatformOs
        "Start-LFVModelPackagingJob/Configuration_Greengrass_TargetPlatform_Os"
        {
            $v = "LINUX"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LFV_map = @{
    "Configuration_Greengrass_TargetDevice"=@("Start-LFVModelPackagingJob")
    "Configuration_Greengrass_TargetPlatform_Accelerator"=@("Start-LFVModelPackagingJob")
    "Configuration_Greengrass_TargetPlatform_Arch"=@("Start-LFVModelPackagingJob")
    "Configuration_Greengrass_TargetPlatform_Os"=@("Start-LFVModelPackagingJob")
}

_awsArgumentCompleterRegistration $LFV_Completers $LFV_map

$LFV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LFV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LFV_SelectMap = @{
    "Select"=@("New-LFVDataset",
               "New-LFVModel",
               "New-LFVProject",
               "Remove-LFVDataset",
               "Remove-LFVModel",
               "Remove-LFVProject",
               "Get-LFVDataset",
               "Get-LFVModel",
               "Get-LFVModelPackagingJob",
               "Get-LFVProject",
               "Find-LFVAnomaly",
               "Get-LFVDatasetEntryList",
               "Get-LFVModelPackagingJobList",
               "Get-LFVModelList",
               "Get-LFVProjectList",
               "Get-LFVResourceTag",
               "Start-LFVModel",
               "Start-LFVModelPackagingJob",
               "Stop-LFVModel",
               "Add-LFVResourceTag",
               "Remove-LFVResourceTag",
               "Update-LFVDatasetEntry")
}

_awsArgumentCompleterRegistration $LFV_SelectCompleters $LFV_SelectMap
# Argument completions for service M2


$AMM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MainframeModernization.BatchJobExecutionStatus
        "Get-AMMBatchJobExecutionList/Status"
        {
            $v = "Cancelled","Cancelling","Dispatching","Failed","Holding","Running","Submitting","Succeeded","Succeeded With Warning"
            break
        }

        # Amazon.MainframeModernization.EngineType
        {
            ($_ -eq "Get-AMMEngineVersionList/EngineType") -Or
            ($_ -eq "Get-AMMEnvironmentList/EngineType") -Or
            ($_ -eq "New-AMMApplication/EngineType") -Or
            ($_ -eq "New-AMMEnvironment/EngineType")
        }
        {
            $v = "bluage","microfocus"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMM_map = @{
    "EngineType"=@("Get-AMMEngineVersionList","Get-AMMEnvironmentList","New-AMMApplication","New-AMMEnvironment")
    "Status"=@("Get-AMMBatchJobExecutionList")
}

_awsArgumentCompleterRegistration $AMM_Completers $AMM_map

$AMM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMM_SelectMap = @{
    "Select"=@("Stop-AMMBatchJobExecution",
               "New-AMMApplication",
               "New-AMMDataSetImportTask",
               "New-AMMDeployment",
               "New-AMMEnvironment",
               "Remove-AMMApplication",
               "Remove-AMMApplicationFromEnvironment",
               "Remove-AMMEnvironment",
               "Get-AMMApplication",
               "Get-AMMApplicationVersion",
               "Get-AMMBatchJobExecution",
               "Get-AMMDataSetDetail",
               "Get-AMMDataSetImportTask",
               "Get-AMMDeployment",
               "Get-AMMEnvironment",
               "Get-AMMApplicationList",
               "Get-AMMApplicationVersionList",
               "Get-AMMBatchJobDefinitionList",
               "Get-AMMBatchJobExecutionList",
               "Get-AMMDataSetImportHistoryList",
               "Get-AMMDataSetList",
               "Get-AMMDeploymentList",
               "Get-AMMEngineVersionList",
               "Get-AMMEnvironmentList",
               "Get-AMMResourceTag",
               "Start-AMMApplication",
               "Start-AMMBatchJob",
               "Stop-AMMApplication",
               "Add-AMMResourceTag",
               "Remove-AMMResourceTag",
               "Update-AMMApplication",
               "Update-AMMEnvironment")
}

_awsArgumentCompleterRegistration $AMM_SelectCompleters $AMM_SelectMap
# Argument completions for service Amazon Machine Learning


$ML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MachineLearning.BatchPredictionFilterVariable
        "Get-MLBatchPredictionList/FilterVariable"
        {
            $v = "CreatedAt","DataSourceId","DataURI","IAMUser","LastUpdatedAt","MLModelId","Name","Status"
            break
        }

        # Amazon.MachineLearning.DataSourceFilterVariable
        "Get-MLDataSourceList/FilterVariable"
        {
            $v = "CreatedAt","DataLocationS3","IAMUser","LastUpdatedAt","Name","Status"
            break
        }

        # Amazon.MachineLearning.EvaluationFilterVariable
        "Get-MLEvaluationList/FilterVariable"
        {
            $v = "CreatedAt","DataSourceId","DataURI","IAMUser","LastUpdatedAt","MLModelId","Name","Status"
            break
        }

        # Amazon.MachineLearning.MLModelFilterVariable
        "Get-MLModelList/FilterVariable"
        {
            $v = "Algorithm","CreatedAt","IAMUser","LastUpdatedAt","MLModelType","Name","RealtimeEndpointStatus","Status","TrainingDataSourceId","TrainingDataURI"
            break
        }

        # Amazon.MachineLearning.MLModelType
        "New-MLModel/MLModelType"
        {
            $v = "BINARY","MULTICLASS","REGRESSION"
            break
        }

        # Amazon.MachineLearning.SortOrder
        {
            ($_ -eq "Get-MLBatchPredictionList/SortOrder") -Or
            ($_ -eq "Get-MLDataSourceList/SortOrder") -Or
            ($_ -eq "Get-MLEvaluationList/SortOrder") -Or
            ($_ -eq "Get-MLModelList/SortOrder")
        }
        {
            $v = "asc","dsc"
            break
        }

        # Amazon.MachineLearning.TaggableResourceType
        {
            ($_ -eq "Add-MLResourceTag/ResourceType") -Or
            ($_ -eq "Get-MLResourceTag/ResourceType") -Or
            ($_ -eq "Remove-MLResourceTag/ResourceType")
        }
        {
            $v = "BatchPrediction","DataSource","Evaluation","MLModel"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ML_map = @{
    "FilterVariable"=@("Get-MLBatchPredictionList","Get-MLDataSourceList","Get-MLEvaluationList","Get-MLModelList")
    "MLModelType"=@("New-MLModel")
    "ResourceType"=@("Add-MLResourceTag","Get-MLResourceTag","Remove-MLResourceTag")
    "SortOrder"=@("Get-MLBatchPredictionList","Get-MLDataSourceList","Get-MLEvaluationList","Get-MLModelList")
}

_awsArgumentCompleterRegistration $ML_Completers $ML_map

$ML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ML_SelectMap = @{
    "Select"=@("Add-MLResourceTag",
               "New-MLBatchPrediction",
               "New-MLDataSourceFromRDS",
               "New-MLDataSourceFromRedshift",
               "New-MLDataSourceFromS3",
               "New-MLEvaluation",
               "New-MLModel",
               "New-MLRealtimeEndpoint",
               "Remove-MLBatchPrediction",
               "Remove-MLDataSource",
               "Remove-MLEvaluation",
               "Remove-MLModel",
               "Remove-MLRealtimeEndpoint",
               "Remove-MLResourceTag",
               "Get-MLBatchPredictionList",
               "Get-MLDataSourceList",
               "Get-MLEvaluationList",
               "Get-MLModelList",
               "Get-MLResourceTag",
               "Get-MLBatchPrediction",
               "Get-MLDataSource",
               "Get-MLEvaluation",
               "Get-MLModel",
               "Get-MLPrediction",
               "Update-MLBatchPrediction",
               "Update-MLDataSource",
               "Update-MLEvaluation",
               "Update-MLMLModel")
}

_awsArgumentCompleterRegistration $ML_SelectCompleters $ML_SelectMap
# Argument completions for service Amazon Macie


$MAC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MAC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MAC_SelectMap = @{
    "Select"=@("Add-MACMemberAccount",
               "Add-MACS3Resource",
               "Remove-MACMemberAccount",
               "Remove-MACS3Resource",
               "Get-MACMemberAccountList",
               "Get-MACS3ResourceList",
               "Update-MACS3Resource")
}

_awsArgumentCompleterRegistration $MAC_SelectCompleters $MAC_SelectMap
# Argument completions for service Amazon Macie 2


$MAC2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Macie2.DayOfWeek
        "New-MAC2ClassificationJob/ScheduleFrequency_WeeklySchedule_DayOfWeek"
        {
            $v = "FRIDAY","MONDAY","SATURDAY","SUNDAY","THURSDAY","TUESDAY","WEDNESDAY"
            break
        }

        # Amazon.Macie2.FindingPublishingFrequency
        {
            ($_ -eq "Enable-MAC2Macie/FindingPublishingFrequency") -Or
            ($_ -eq "Update-MAC2MacieSession/FindingPublishingFrequency")
        }
        {
            $v = "FIFTEEN_MINUTES","ONE_HOUR","SIX_HOURS"
            break
        }

        # Amazon.Macie2.FindingsFilterAction
        {
            ($_ -eq "New-MAC2FindingsFilter/Action") -Or
            ($_ -eq "Update-MAC2FindingsFilter/Action")
        }
        {
            $v = "ARCHIVE","NOOP"
            break
        }

        # Amazon.Macie2.FindingStatisticsSortAttributeName
        "Get-MAC2FindingStatistic/SortCriteria_AttributeName"
        {
            $v = "count","groupKey"
            break
        }

        # Amazon.Macie2.GroupBy
        "Get-MAC2FindingStatistic/GroupBy"
        {
            $v = "classificationDetails.jobId","resourcesAffected.s3Bucket.name","severity.description","type"
            break
        }

        # Amazon.Macie2.JobStatus
        "Update-MAC2ClassificationJob/JobStatus"
        {
            $v = "CANCELLED","COMPLETE","IDLE","PAUSED","RUNNING","USER_PAUSED"
            break
        }

        # Amazon.Macie2.JobType
        "New-MAC2ClassificationJob/JobType"
        {
            $v = "ONE_TIME","SCHEDULED"
            break
        }

        # Amazon.Macie2.ListJobsSortAttributeName
        "Get-MAC2ClassificationJobList/SortCriteria_AttributeName"
        {
            $v = "createdAt","jobStatus","jobType","name"
            break
        }

        # Amazon.Macie2.MacieStatus
        {
            ($_ -eq "Enable-MAC2Macie/Status") -Or
            ($_ -eq "Update-MAC2MacieSession/Status") -Or
            ($_ -eq "Update-MAC2MemberSession/Status")
        }
        {
            $v = "ENABLED","PAUSED"
            break
        }

        # Amazon.Macie2.ManagedDataIdentifierSelector
        "New-MAC2ClassificationJob/ManagedDataIdentifierSelector"
        {
            $v = "ALL","EXCLUDE","INCLUDE","NONE"
            break
        }

        # Amazon.Macie2.OrderBy
        {
            ($_ -eq "Get-MAC2UsageStatistic/SortBy_OrderBy") -Or
            ($_ -eq "Get-MAC2Bucket/SortCriteria_OrderBy") -Or
            ($_ -eq "Get-MAC2ClassificationJobList/SortCriteria_OrderBy") -Or
            ($_ -eq "Get-MAC2Finding/SortCriteria_OrderBy") -Or
            ($_ -eq "Get-MAC2FindingList/SortCriteria_OrderBy") -Or
            ($_ -eq "Get-MAC2FindingStatistic/SortCriteria_OrderBy") -Or
            ($_ -eq "Search-MAC2Resource/SortCriteria_OrderBy")
        }
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.Macie2.RevealStatus
        "Update-MAC2RevealConfiguration/Configuration_Status"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Macie2.SearchResourcesSortAttributeName
        "Search-MAC2Resource/SortCriteria_AttributeName"
        {
            $v = "ACCOUNT_ID","RESOURCE_NAME","S3_CLASSIFIABLE_OBJECT_COUNT","S3_CLASSIFIABLE_SIZE_IN_BYTES"
            break
        }

        # Amazon.Macie2.TimeRange
        "Get-MAC2UsageStatistic/TimeRange"
        {
            $v = "MONTH_TO_DATE","PAST_30_DAYS"
            break
        }

        # Amazon.Macie2.UsageStatisticsSortKey
        "Get-MAC2UsageStatistic/SortBy_Key"
        {
            $v = "accountId","freeTrialStartDate","serviceLimitValue","total"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MAC2_map = @{
    "Action"=@("New-MAC2FindingsFilter","Update-MAC2FindingsFilter")
    "Configuration_Status"=@("Update-MAC2RevealConfiguration")
    "FindingPublishingFrequency"=@("Enable-MAC2Macie","Update-MAC2MacieSession")
    "GroupBy"=@("Get-MAC2FindingStatistic")
    "JobStatus"=@("Update-MAC2ClassificationJob")
    "JobType"=@("New-MAC2ClassificationJob")
    "ManagedDataIdentifierSelector"=@("New-MAC2ClassificationJob")
    "ScheduleFrequency_WeeklySchedule_DayOfWeek"=@("New-MAC2ClassificationJob")
    "SortBy_Key"=@("Get-MAC2UsageStatistic")
    "SortBy_OrderBy"=@("Get-MAC2UsageStatistic")
    "SortCriteria_AttributeName"=@("Get-MAC2ClassificationJobList","Get-MAC2FindingStatistic","Search-MAC2Resource")
    "SortCriteria_OrderBy"=@("Get-MAC2Bucket","Get-MAC2ClassificationJobList","Get-MAC2Finding","Get-MAC2FindingList","Get-MAC2FindingStatistic","Search-MAC2Resource")
    "Status"=@("Enable-MAC2Macie","Update-MAC2MacieSession","Update-MAC2MemberSession")
    "TimeRange"=@("Get-MAC2UsageStatistic")
}

_awsArgumentCompleterRegistration $MAC2_Completers $MAC2_map

$MAC2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MAC2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MAC2_SelectMap = @{
    "Select"=@("Approve-MAC2Invitation",
               "Get-MAC2GetCustomDataIdentifier",
               "New-MAC2AllowList",
               "New-MAC2ClassificationJob",
               "New-MAC2CustomDataIdentifier",
               "New-MAC2FindingsFilter",
               "New-MAC2Invitation",
               "New-MAC2Member",
               "New-MAC2SampleFinding",
               "Deny-MAC2Invitation",
               "Remove-MAC2AllowList",
               "Remove-MAC2CustomDataIdentifier",
               "Remove-MAC2FindingsFilter",
               "Remove-MAC2Invitation",
               "Remove-MAC2Member",
               "Get-MAC2Bucket",
               "Get-MAC2ClassificationJob",
               "Get-MAC2OrganizationConfiguration",
               "Disable-MAC2Macie",
               "Disable-MAC2OrganizationAdminAccount",
               "Unregister-MAC2FromAdministratorAccount",
               "Unregister-MAC2FromMasterAccount",
               "Unregister-MAC2Member",
               "Enable-MAC2Macie",
               "Enable-MAC2OrganizationAdminAccount",
               "Get-MAC2AdministratorAccount",
               "Get-MAC2AllowList",
               "Get-MAC2BucketStatistic",
               "Get-MAC2ClassificationExportConfiguration",
               "Get-MAC2CustomDataIdentifier",
               "Get-MAC2Finding",
               "Get-MAC2FindingsFilter",
               "Get-MAC2FindingsPublicationConfiguration",
               "Get-MAC2FindingStatistic",
               "Get-MAC2InvitationsCount",
               "Get-MAC2MacieSession",
               "Get-MAC2MasterAccount",
               "Get-MAC2Member",
               "Get-MAC2RevealConfiguration",
               "Get-MAC2SensitiveDataOccurrence",
               "Get-MAC2SensitiveDataOccurrencesAvailability",
               "Get-MAC2UsageStatistic",
               "Get-MAC2UsageTotal",
               "Get-MAC2AllowListList",
               "Get-MAC2ClassificationJobList",
               "Get-MAC2CustomDataIdentifierList",
               "Get-MAC2FindingList",
               "Get-MAC2FindingsFilterList",
               "Get-MAC2InvitationList",
               "Get-MAC2ManagedDataIdentifierList",
               "Get-MAC2MemberList",
               "Get-MAC2OrganizationAdminAccountList",
               "Get-MAC2ResourceTag",
               "Write-MAC2ClassificationExportConfiguration",
               "Write-MAC2FindingsPublicationConfiguration",
               "Search-MAC2Resource",
               "Add-MAC2ResourceTag",
               "Test-MAC2CustomDataIdentifier",
               "Remove-MAC2ResourceTag",
               "Update-MAC2AllowList",
               "Update-MAC2ClassificationJob",
               "Update-MAC2FindingsFilter",
               "Update-MAC2MacieSession",
               "Update-MAC2MemberSession",
               "Update-MAC2OrganizationConfiguration",
               "Update-MAC2RevealConfiguration")
}

_awsArgumentCompleterRegistration $MAC2_SelectCompleters $MAC2_SelectMap
# Argument completions for service Amazon Managed Blockchain


$MBC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ManagedBlockchain.AccessorType
        "New-MBCAccessor/AccessorType"
        {
            $v = "BILLING_TOKEN"
            break
        }

        # Amazon.ManagedBlockchain.Edition
        "New-MBCNetwork/FrameworkConfiguration_Fabric_Edition"
        {
            $v = "STANDARD","STARTER"
            break
        }

        # Amazon.ManagedBlockchain.Framework
        {
            ($_ -eq "Get-MBCNetworkList/Framework") -Or
            ($_ -eq "New-MBCNetwork/Framework")
        }
        {
            $v = "ETHEREUM","HYPERLEDGER_FABRIC"
            break
        }

        # Amazon.ManagedBlockchain.MemberStatus
        "Get-MBCMemberList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING","INACCESSIBLE_ENCRYPTION_KEY","UPDATING"
            break
        }

        # Amazon.ManagedBlockchain.NetworkStatus
        "Get-MBCNetworkList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING"
            break
        }

        # Amazon.ManagedBlockchain.NodeStatus
        "Get-MBCNodeList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING","FAILED","INACCESSIBLE_ENCRYPTION_KEY","UNHEALTHY","UPDATING"
            break
        }

        # Amazon.ManagedBlockchain.StateDBType
        "New-MBCNode/NodeConfiguration_StateDB"
        {
            $v = "CouchDB","LevelDB"
            break
        }

        # Amazon.ManagedBlockchain.ThresholdComparator
        "New-MBCNetwork/VotingPolicy_ApprovalThresholdPolicy_ThresholdComparator"
        {
            $v = "GREATER_THAN","GREATER_THAN_OR_EQUAL_TO"
            break
        }

        # Amazon.ManagedBlockchain.VoteValue
        "Send-MBCProposalVote/Vote"
        {
            $v = "NO","YES"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MBC_map = @{
    "AccessorType"=@("New-MBCAccessor")
    "Framework"=@("Get-MBCNetworkList","New-MBCNetwork")
    "FrameworkConfiguration_Fabric_Edition"=@("New-MBCNetwork")
    "NodeConfiguration_StateDB"=@("New-MBCNode")
    "Status"=@("Get-MBCMemberList","Get-MBCNetworkList","Get-MBCNodeList")
    "Vote"=@("Send-MBCProposalVote")
    "VotingPolicy_ApprovalThresholdPolicy_ThresholdComparator"=@("New-MBCNetwork")
}

_awsArgumentCompleterRegistration $MBC_Completers $MBC_map

$MBC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MBC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MBC_SelectMap = @{
    "Select"=@("New-MBCAccessor",
               "New-MBCMember",
               "New-MBCNetwork",
               "New-MBCNode",
               "New-MBCProposal",
               "Remove-MBCAccessor",
               "Remove-MBCMember",
               "Remove-MBCNode",
               "Get-MBCAccessor",
               "Get-MBCMember",
               "Get-MBCNetwork",
               "Get-MBCNode",
               "Get-MBCProposal",
               "Get-MBCAccessorList",
               "Get-MBCInvitationList",
               "Get-MBCMemberList",
               "Get-MBCNetworkList",
               "Get-MBCNodeList",
               "Get-MBCProposalList",
               "Get-MBCProposalVoteList",
               "Get-MBCResourceTag",
               "Deny-MBCInvitation",
               "Add-MBCResourceTag",
               "Remove-MBCResourceTag",
               "Update-MBCMember",
               "Update-MBCNode",
               "Send-MBCProposalVote")
}

_awsArgumentCompleterRegistration $MBC_SelectCompleters $MBC_SelectMap
# Argument completions for service AWS Marketplace Catalog Service


$MCAT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MarketplaceCatalog.SortOrder
        {
            ($_ -eq "Get-MCATChangeSetList/Sort_SortOrder") -Or
            ($_ -eq "Get-MCATEntityList/Sort_SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCAT_map = @{
    "Sort_SortOrder"=@("Get-MCATChangeSetList","Get-MCATEntityList")
}

_awsArgumentCompleterRegistration $MCAT_Completers $MCAT_map

$MCAT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MCAT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCAT_SelectMap = @{
    "Select"=@("Stop-MCATChangeSet",
               "Get-MCATChangeSet",
               "Get-MCATEntity",
               "Get-MCATChangeSetList",
               "Get-MCATEntityList",
               "Get-MCATResourceTag",
               "Start-MCATChangeSet",
               "Add-MCATResourceTag",
               "Remove-MCATResourceTag")
}

_awsArgumentCompleterRegistration $MCAT_SelectCompleters $MCAT_SelectMap
# Argument completions for service AWS Marketplace Commerce Analytics


$MCA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AWSMarketplaceCommerceAnalytics.DataSetType
        "New-MCADataSet/DataSetType"
        {
            $v = "customer_profile_by_geography","customer_profile_by_industry","customer_profile_by_revenue","customer_subscriber_annual_subscriptions","customer_subscriber_hourly_monthly_subscriptions","daily_business_canceled_product_subscribers","daily_business_fees","daily_business_free_trial_conversions","daily_business_new_instances","daily_business_new_product_subscribers","daily_business_usage_by_instance_type","disbursed_amount_by_age_of_disbursed_funds","disbursed_amount_by_age_of_past_due_funds","disbursed_amount_by_age_of_uncollected_funds","disbursed_amount_by_customer_geo","disbursed_amount_by_instance_hours","disbursed_amount_by_product","disbursed_amount_by_product_with_uncollected_funds","disbursed_amount_by_uncollected_funds_breakdown","monthly_revenue_annual_subscriptions","monthly_revenue_billing_and_revenue_data","monthly_revenue_field_demonstration_usage","monthly_revenue_flexible_payment_schedule","sales_compensation_billed_revenue","us_sales_and_use_tax_records"
            break
        }

        # Amazon.AWSMarketplaceCommerceAnalytics.SupportDataSetType
        "Start-MCASupportDataExport/DataSetType"
        {
            $v = "customer_support_contacts_data","test_customer_support_contacts_data"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCA_map = @{
    "DataSetType"=@("New-MCADataSet","Start-MCASupportDataExport")
}

_awsArgumentCompleterRegistration $MCA_Completers $MCA_map

$MCA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MCA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCA_SelectMap = @{
    "Select"=@("New-MCADataSet",
               "Start-MCASupportDataExport")
}

_awsArgumentCompleterRegistration $MCA_SelectCompleters $MCA_SelectMap
# Argument completions for service AWS Elemental MediaConnect


$EMCN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaConnect.Colorimetry
        "Update-EMCNFlowMediaStream/Attributes_Fmtp_Colorimetry"
        {
            $v = "BT2020","BT2100","BT601","BT709","ST2065-1","ST2065-3","XYZ"
            break
        }

        # Amazon.MediaConnect.EntitlementStatus
        "Update-EMCNFlowEntitlement/EntitlementStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.MediaConnect.FailoverMode
        {
            ($_ -eq "New-EMCNFlow/SourceFailoverConfig_FailoverMode") -Or
            ($_ -eq "Update-EMCNFlow/SourceFailoverConfig_FailoverMode")
        }
        {
            $v = "FAILOVER","MERGE"
            break
        }

        # Amazon.MediaConnect.MaintenanceDay
        {
            ($_ -eq "New-EMCNFlow/Maintenance_MaintenanceDay") -Or
            ($_ -eq "Update-EMCNFlow/Maintenance_MaintenanceDay")
        }
        {
            $v = "Friday","Monday","Saturday","Sunday","Thursday","Tuesday","Wednesday"
            break
        }

        # Amazon.MediaConnect.MediaStreamType
        "Update-EMCNFlowMediaStream/MediaStreamType"
        {
            $v = "ancillary-data","audio","video"
            break
        }

        # Amazon.MediaConnect.Protocol
        {
            ($_ -eq "Update-EMCNFlowOutput/Protocol") -Or
            ($_ -eq "Update-EMCNFlowSource/Protocol")
        }
        {
            $v = "cdi","fujitsu-qos","rist","rtp","rtp-fec","srt-caller","srt-listener","st2110-jpegxs","zixi-pull","zixi-push"
            break
        }

        # Amazon.MediaConnect.Range
        "Update-EMCNFlowMediaStream/Attributes_Fmtp_Range"
        {
            $v = "FULL","FULLPROTECT","NARROW"
            break
        }

        # Amazon.MediaConnect.ScanMode
        "Update-EMCNFlowMediaStream/Attributes_Fmtp_ScanMode"
        {
            $v = "interlace","progressive","progressive-segmented-frame"
            break
        }

        # Amazon.MediaConnect.State
        {
            ($_ -eq "New-EMCNFlow/SourceFailoverConfig_State") -Or
            ($_ -eq "Update-EMCNFlow/SourceFailoverConfig_State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.MediaConnect.Tcs
        "Update-EMCNFlowMediaStream/Attributes_Fmtp_Tcs"
        {
            $v = "BT2100LINHLG","BT2100LINPQ","DENSITY","HLG","LINEAR","PQ","SDR","ST2065-1","ST428-1"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMCN_map = @{
    "Attributes_Fmtp_Colorimetry"=@("Update-EMCNFlowMediaStream")
    "Attributes_Fmtp_Range"=@("Update-EMCNFlowMediaStream")
    "Attributes_Fmtp_ScanMode"=@("Update-EMCNFlowMediaStream")
    "Attributes_Fmtp_Tcs"=@("Update-EMCNFlowMediaStream")
    "EntitlementStatus"=@("Update-EMCNFlowEntitlement")
    "Maintenance_MaintenanceDay"=@("New-EMCNFlow","Update-EMCNFlow")
    "MediaStreamType"=@("Update-EMCNFlowMediaStream")
    "Protocol"=@("Update-EMCNFlowOutput","Update-EMCNFlowSource")
    "SourceFailoverConfig_FailoverMode"=@("New-EMCNFlow","Update-EMCNFlow")
    "SourceFailoverConfig_State"=@("New-EMCNFlow","Update-EMCNFlow")
}

_awsArgumentCompleterRegistration $EMCN_Completers $EMCN_map

$EMCN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMCN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMCN_SelectMap = @{
    "Select"=@("Add-EMCNFlowMediaStream",
               "Add-EMCNFlowOutput",
               "Add-EMCNFlowSource",
               "Add-EMCNFlowVpcInterface",
               "New-EMCNFlow",
               "Remove-EMCNFlow",
               "Get-EMCNFlow",
               "Get-EMCNOffering",
               "Get-EMCNReservation",
               "Grant-EMCNFlowEntitlement",
               "Get-EMCNEntitlementList",
               "Get-EMCNFlowList",
               "Get-EMCNOfferingList",
               "Get-EMCNReservationList",
               "Get-EMCNResourceTag",
               "New-EMCNOffering",
               "Remove-EMCNFlowMediaStream",
               "Remove-EMCNFlowOutput",
               "Remove-EMCNFlowSource",
               "Remove-EMCNFlowVpcInterface",
               "Revoke-EMCNFlowEntitlement",
               "Start-EMCNFlow",
               "Stop-EMCNFlow",
               "Add-EMCNResourceTag",
               "Remove-EMCNResourceTag",
               "Update-EMCNFlow",
               "Update-EMCNFlowEntitlement",
               "Update-EMCNFlowMediaStream",
               "Update-EMCNFlowOutput",
               "Update-EMCNFlowSource")
}

_awsArgumentCompleterRegistration $EMCN_SelectCompleters $EMCN_SelectMap
# Argument completions for service AWS Elemental MediaConvert


$EMC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaConvert.AccelerationMode
        {
            ($_ -eq "New-EMCJob/AccelerationSettings_Mode") -Or
            ($_ -eq "New-EMCJobTemplate/AccelerationSettings_Mode") -Or
            ($_ -eq "Update-EMCJobTemplate/AccelerationSettings_Mode")
        }
        {
            $v = "DISABLED","ENABLED","PREFERRED"
            break
        }

        # Amazon.MediaConvert.BillingTagsSource
        "New-EMCJob/BillingTagsSource"
        {
            $v = "JOB","JOB_TEMPLATE","PRESET","QUEUE"
            break
        }

        # Amazon.MediaConvert.Commitment
        {
            ($_ -eq "New-EMCQueue/ReservationPlanSettings_Commitment") -Or
            ($_ -eq "Update-EMCQueue/ReservationPlanSettings_Commitment")
        }
        {
            $v = "ONE_YEAR"
            break
        }

        # Amazon.MediaConvert.DescribeEndpointsMode
        "Get-EMCEndpoint/Mode"
        {
            $v = "DEFAULT","GET_ONLY"
            break
        }

        # Amazon.MediaConvert.InputPolicy
        {
            ($_ -eq "Write-EMCPolicy/Policy_HttpInputs") -Or
            ($_ -eq "Write-EMCPolicy/Policy_HttpsInputs") -Or
            ($_ -eq "Write-EMCPolicy/Policy_S3Inputs")
        }
        {
            $v = "ALLOWED","DISALLOWED"
            break
        }

        # Amazon.MediaConvert.JobStatus
        "Get-EMCJobList/Status"
        {
            $v = "CANCELED","COMPLETE","ERROR","PROGRESSING","SUBMITTED"
            break
        }

        # Amazon.MediaConvert.JobTemplateListBy
        "Get-EMCJobTemplateList/ListBy"
        {
            $v = "CREATION_DATE","NAME","SYSTEM"
            break
        }

        # Amazon.MediaConvert.Order
        {
            ($_ -eq "Get-EMCJobList/Order") -Or
            ($_ -eq "Get-EMCJobTemplateList/Order") -Or
            ($_ -eq "Get-EMCPresetList/Order") -Or
            ($_ -eq "Get-EMCQueueList/Order")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.MediaConvert.PresetListBy
        "Get-EMCPresetList/ListBy"
        {
            $v = "CREATION_DATE","NAME","SYSTEM"
            break
        }

        # Amazon.MediaConvert.PricingPlan
        "New-EMCQueue/PricingPlan"
        {
            $v = "ON_DEMAND","RESERVED"
            break
        }

        # Amazon.MediaConvert.QueueListBy
        "Get-EMCQueueList/ListBy"
        {
            $v = "CREATION_DATE","NAME"
            break
        }

        # Amazon.MediaConvert.QueueStatus
        {
            ($_ -eq "New-EMCQueue/Status") -Or
            ($_ -eq "Update-EMCQueue/Status")
        }
        {
            $v = "ACTIVE","PAUSED"
            break
        }

        # Amazon.MediaConvert.RenewalType
        {
            ($_ -eq "New-EMCQueue/ReservationPlanSettings_RenewalType") -Or
            ($_ -eq "Update-EMCQueue/ReservationPlanSettings_RenewalType")
        }
        {
            $v = "AUTO_RENEW","EXPIRE"
            break
        }

        # Amazon.MediaConvert.SimulateReservedQueue
        "New-EMCJob/SimulateReservedQueue"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.MediaConvert.StatusUpdateInterval
        {
            ($_ -eq "New-EMCJob/StatusUpdateInterval") -Or
            ($_ -eq "New-EMCJobTemplate/StatusUpdateInterval") -Or
            ($_ -eq "Update-EMCJobTemplate/StatusUpdateInterval")
        }
        {
            $v = "SECONDS_10","SECONDS_12","SECONDS_120","SECONDS_15","SECONDS_180","SECONDS_20","SECONDS_240","SECONDS_30","SECONDS_300","SECONDS_360","SECONDS_420","SECONDS_480","SECONDS_540","SECONDS_60","SECONDS_600"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMC_map = @{
    "AccelerationSettings_Mode"=@("New-EMCJob","New-EMCJobTemplate","Update-EMCJobTemplate")
    "BillingTagsSource"=@("New-EMCJob")
    "ListBy"=@("Get-EMCJobTemplateList","Get-EMCPresetList","Get-EMCQueueList")
    "Mode"=@("Get-EMCEndpoint")
    "Order"=@("Get-EMCJobList","Get-EMCJobTemplateList","Get-EMCPresetList","Get-EMCQueueList")
    "Policy_HttpInputs"=@("Write-EMCPolicy")
    "Policy_HttpsInputs"=@("Write-EMCPolicy")
    "Policy_S3Inputs"=@("Write-EMCPolicy")
    "PricingPlan"=@("New-EMCQueue")
    "ReservationPlanSettings_Commitment"=@("New-EMCQueue","Update-EMCQueue")
    "ReservationPlanSettings_RenewalType"=@("New-EMCQueue","Update-EMCQueue")
    "SimulateReservedQueue"=@("New-EMCJob")
    "Status"=@("Get-EMCJobList","New-EMCQueue","Update-EMCQueue")
    "StatusUpdateInterval"=@("New-EMCJob","New-EMCJobTemplate","Update-EMCJobTemplate")
}

_awsArgumentCompleterRegistration $EMC_Completers $EMC_map

$EMC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMC_SelectMap = @{
    "Select"=@("Register-EMCCertificate",
               "Stop-EMCJob",
               "New-EMCJob",
               "New-EMCJobTemplate",
               "New-EMCPreset",
               "New-EMCQueue",
               "Remove-EMCJobTemplate",
               "Remove-EMCPolicy",
               "Remove-EMCPreset",
               "Remove-EMCQueue",
               "Get-EMCEndpoint",
               "Unregister-EMCCertificate",
               "Get-EMCJob",
               "Get-EMCJobTemplate",
               "Get-EMCPolicy",
               "Get-EMCPreset",
               "Get-EMCQueue",
               "Get-EMCJobList",
               "Get-EMCJobTemplateList",
               "Get-EMCPresetList",
               "Get-EMCQueueList",
               "Get-EMCResourceTag",
               "Write-EMCPolicy",
               "Add-EMCResourceTag",
               "Remove-EMCResourceTag",
               "Update-EMCJobTemplate",
               "Update-EMCPreset",
               "Update-EMCQueue")
}

_awsArgumentCompleterRegistration $EMC_SelectCompleters $EMC_SelectMap
# Argument completions for service AWS Elemental MediaLive


$EML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaLive.AcceptHeader
        "Get-EMLInputDeviceThumbnail/Accept"
        {
            $v = "image/jpeg"
            break
        }

        # Amazon.MediaLive.CdiInputResolution
        {
            ($_ -eq "New-EMLChannel/CdiInputSpecification_Resolution") -Or
            ($_ -eq "Update-EMLChannel/CdiInputSpecification_Resolution")
        }
        {
            $v = "FHD","HD","SD","UHD"
            break
        }

        # Amazon.MediaLive.ChannelClass
        {
            ($_ -eq "New-EMLChannel/ChannelClass") -Or
            ($_ -eq "Update-EMLChannelClass/ChannelClass")
        }
        {
            $v = "SINGLE_PIPELINE","STANDARD"
            break
        }

        # Amazon.MediaLive.InputCodec
        {
            ($_ -eq "New-EMLChannel/InputSpecification_Codec") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_Codec")
        }
        {
            $v = "AVC","HEVC","MPEG2"
            break
        }

        # Amazon.MediaLive.InputDeviceConfiguredInput
        {
            ($_ -eq "Update-EMLInputDevice/HdDeviceSettings_ConfiguredInput") -Or
            ($_ -eq "Update-EMLInputDevice/UhdDeviceSettings_ConfiguredInput")
        }
        {
            $v = "AUTO","HDMI","SDI"
            break
        }

        # Amazon.MediaLive.InputMaximumBitrate
        {
            ($_ -eq "New-EMLChannel/InputSpecification_MaximumBitrate") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_MaximumBitrate")
        }
        {
            $v = "MAX_10_MBPS","MAX_20_MBPS","MAX_50_MBPS"
            break
        }

        # Amazon.MediaLive.InputResolution
        {
            ($_ -eq "New-EMLChannel/InputSpecification_Resolution") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_Resolution")
        }
        {
            $v = "HD","SD","UHD"
            break
        }

        # Amazon.MediaLive.InputType
        "New-EMLInput/Type"
        {
            $v = "AWS_CDI","INPUT_DEVICE","MEDIACONNECT","MP4_FILE","RTMP_PULL","RTMP_PUSH","RTP_PUSH","TS_FILE","UDP_PUSH","URL_PULL"
            break
        }

        # Amazon.MediaLive.LogLevel
        {
            ($_ -eq "New-EMLChannel/LogLevel") -Or
            ($_ -eq "Update-EMLChannel/LogLevel")
        }
        {
            $v = "DEBUG","DISABLED","ERROR","INFO","WARNING"
            break
        }

        # Amazon.MediaLive.MaintenanceDay
        {
            ($_ -eq "New-EMLChannel/Maintenance_MaintenanceDay") -Or
            ($_ -eq "Update-EMLChannel/Maintenance_MaintenanceDay")
        }
        {
            $v = "FRIDAY","MONDAY","SATURDAY","SUNDAY","THURSDAY","TUESDAY","WEDNESDAY"
            break
        }

        # Amazon.MediaLive.PreferredChannelPipeline
        {
            ($_ -eq "New-EMLMultiplexProgram/MultiplexProgramSettings_PreferredChannelPipeline") -Or
            ($_ -eq "Update-EMLMultiplexProgram/MultiplexProgramSettings_PreferredChannelPipeline")
        }
        {
            $v = "CURRENTLY_ACTIVE","PIPELINE_0","PIPELINE_1"
            break
        }

        # Amazon.MediaLive.RebootInputDeviceForce
        "Restart-EMLInputDevice/Force"
        {
            $v = "NO","YES"
            break
        }

        # Amazon.MediaLive.ReservationAutomaticRenewal
        {
            ($_ -eq "New-EMLOfferingPurchase/RenewalSettings_AutomaticRenewal") -Or
            ($_ -eq "Update-EMLReservation/RenewalSettings_AutomaticRenewal")
        }
        {
            $v = "DISABLED","ENABLED","UNAVAILABLE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EML_map = @{
    "Accept"=@("Get-EMLInputDeviceThumbnail")
    "CdiInputSpecification_Resolution"=@("New-EMLChannel","Update-EMLChannel")
    "ChannelClass"=@("New-EMLChannel","Update-EMLChannelClass")
    "Force"=@("Restart-EMLInputDevice")
    "HdDeviceSettings_ConfiguredInput"=@("Update-EMLInputDevice")
    "InputSpecification_Codec"=@("New-EMLChannel","Update-EMLChannel")
    "InputSpecification_MaximumBitrate"=@("New-EMLChannel","Update-EMLChannel")
    "InputSpecification_Resolution"=@("New-EMLChannel","Update-EMLChannel")
    "LogLevel"=@("New-EMLChannel","Update-EMLChannel")
    "Maintenance_MaintenanceDay"=@("New-EMLChannel","Update-EMLChannel")
    "MultiplexProgramSettings_PreferredChannelPipeline"=@("New-EMLMultiplexProgram","Update-EMLMultiplexProgram")
    "RenewalSettings_AutomaticRenewal"=@("New-EMLOfferingPurchase","Update-EMLReservation")
    "Type"=@("New-EMLInput")
    "UhdDeviceSettings_ConfiguredInput"=@("Update-EMLInputDevice")
}

_awsArgumentCompleterRegistration $EML_Completers $EML_map

$EML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EML_SelectMap = @{
    "Select"=@("Receive-EMLInputDeviceTransfer",
               "Remove-EMLResourceBatch",
               "Start-EMLResourceBatch",
               "Stop-EMLResourceBatch",
               "Update-EMLScheduleBatch",
               "Stop-EMLInputDeviceTransfer",
               "Request-EMLDevice",
               "New-EMLChannel",
               "New-EMLInput",
               "New-EMLInputSecurityGroup",
               "New-EMLMultiplex",
               "New-EMLMultiplexProgram",
               "New-EMLPartnerInput",
               "Add-EMLResourceTag",
               "Remove-EMLChannel",
               "Remove-EMLInput",
               "Remove-EMLInputSecurityGroup",
               "Remove-EMLMultiplex",
               "Remove-EMLMultiplexProgram",
               "Remove-EMLReservation",
               "Remove-EMLSchedule",
               "Remove-EMLResourceTag",
               "Get-EMLChannel",
               "Get-EMLInput",
               "Get-EMLInputDevice",
               "Get-EMLInputDeviceThumbnail",
               "Get-EMLInputSecurityGroup",
               "Get-EMLMultiplex",
               "Get-EMLMultiplexProgram",
               "Get-EMLOffering",
               "Get-EMLReservation",
               "Get-EMLSchedule",
               "Get-EMLChannelList",
               "Get-EMLInputDeviceList",
               "Get-EMLInputDeviceTransferList",
               "Get-EMLInputList",
               "Get-EMLInputSecurityGroupList",
               "Get-EMLMultiplexList",
               "Get-EMLMultiplexProgramList",
               "Get-EMLOfferingList",
               "Get-EMLReservationList",
               "Get-EMLResourceTag",
               "New-EMLOfferingPurchase",
               "Restart-EMLInputDevice",
               "Deny-EMLInputDeviceTransfer",
               "Start-EMLChannel",
               "Start-EMLInputDeviceMaintenanceWindow",
               "Start-EMLMultiplex",
               "Stop-EMLChannel",
               "Stop-EMLMultiplex",
               "Move-EMLInputDevice",
               "Update-EMLChannel",
               "Update-EMLChannelClass",
               "Update-EMLInput",
               "Update-EMLInputDevice",
               "Update-EMLInputSecurityGroup",
               "Update-EMLMultiplex",
               "Update-EMLMultiplexProgram",
               "Update-EMLReservation")
}

_awsArgumentCompleterRegistration $EML_SelectCompleters $EML_SelectMap
# Argument completions for service AWS Elemental MediaPackage


$EMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaPackage.CmafEncryptionMethod
        {
            ($_ -eq "New-EMPOriginEndpoint/CmafPackage_Encryption_EncryptionMethod") -Or
            ($_ -eq "Update-EMPOriginEndpoint/CmafPackage_Encryption_EncryptionMethod")
        }
        {
            $v = "AES_CTR","SAMPLE_AES"
            break
        }

        # Amazon.MediaPackage.Origination
        {
            ($_ -eq "New-EMPOriginEndpoint/Origination") -Or
            ($_ -eq "Update-EMPOriginEndpoint/Origination")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.MediaPackage.PresetSpeke20Audio
        {
            ($_ -eq "New-EMPOriginEndpoint/CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Audio") -Or
            ($_ -eq "Update-EMPOriginEndpoint/CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Audio")
        }
        {
            $v = "PRESET-AUDIO-1","PRESET-AUDIO-2","PRESET-AUDIO-3","SHARED","UNENCRYPTED"
            break
        }

        # Amazon.MediaPackage.PresetSpeke20Video
        {
            ($_ -eq "New-EMPOriginEndpoint/CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Video") -Or
            ($_ -eq "Update-EMPOriginEndpoint/CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Video")
        }
        {
            $v = "PRESET-VIDEO-1","PRESET-VIDEO-2","PRESET-VIDEO-3","PRESET-VIDEO-4","PRESET-VIDEO-5","PRESET-VIDEO-6","PRESET-VIDEO-7","PRESET-VIDEO-8","SHARED","UNENCRYPTED"
            break
        }

        # Amazon.MediaPackage.StreamOrder
        {
            ($_ -eq "New-EMPOriginEndpoint/CmafPackage_StreamSelection_StreamOrder") -Or
            ($_ -eq "Update-EMPOriginEndpoint/CmafPackage_StreamSelection_StreamOrder")
        }
        {
            $v = "ORIGINAL","VIDEO_BITRATE_ASCENDING","VIDEO_BITRATE_DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMP_map = @{
    "CmafPackage_Encryption_EncryptionMethod"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
    "CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Audio"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
    "CmafPackage_Encryption_SpekeKeyProvider_EncryptionContractConfiguration_PresetSpeke20Video"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
    "CmafPackage_StreamSelection_StreamOrder"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
    "Origination"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
}

_awsArgumentCompleterRegistration $EMP_Completers $EMP_map

$EMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMP_SelectMap = @{
    "Select"=@("Update-EMPLogConfiguration",
               "New-EMPChannel",
               "New-EMPHarvestJob",
               "New-EMPOriginEndpoint",
               "Remove-EMPChannel",
               "Remove-EMPOriginEndpoint",
               "Get-EMPChannel",
               "Get-EMPHarvestJob",
               "Get-EMPOriginEndpoint",
               "Get-EMPChannelList",
               "Get-EMPHarvestJobList",
               "Get-EMPOriginEndpointList",
               "Get-EMPResourceTag",
               "Invoke-EMPChannelCredentialRotation",
               "Invoke-EMPIngestEndpointCredentialRotation",
               "Add-EMPResourceTag",
               "Remove-EMPResourceTag",
               "Update-EMPChannel",
               "Update-EMPOriginEndpoint")
}

_awsArgumentCompleterRegistration $EMP_SelectCompleters $EMP_SelectMap
# Argument completions for service AWS Elemental MediaPackage VOD


$EMPV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMPV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMPV_SelectMap = @{
    "Select"=@("Update-EMPVLog",
               "New-EMPVAsset",
               "New-EMPVPackagingConfiguration",
               "New-EMPVPackagingGroup",
               "Remove-EMPVAsset",
               "Remove-EMPVPackagingConfiguration",
               "Remove-EMPVPackagingGroup",
               "Get-EMPVAsset",
               "Get-EMPVPackagingConfiguration",
               "Get-EMPVPackagingGroup",
               "Get-EMPVAssetList",
               "Get-EMPVPackagingConfigurationList",
               "Get-EMPVPackagingGroupList",
               "Get-EMPVResourceTag",
               "Add-EMPVResourceTag",
               "Remove-EMPVResourceTag",
               "Update-EMPVPackagingGroup")
}

_awsArgumentCompleterRegistration $EMPV_SelectCompleters $EMPV_SelectMap
# Argument completions for service AWS Elemental MediaStore


$EMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaStore.ContainerLevelMetrics
        "Write-EMSMetricPolicy/MetricPolicy_ContainerLevelMetrics"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMS_map = @{
    "MetricPolicy_ContainerLevelMetrics"=@("Write-EMSMetricPolicy")
}

_awsArgumentCompleterRegistration $EMS_Completers $EMS_map

$EMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMS_SelectMap = @{
    "Select"=@("New-EMSContainer",
               "Remove-EMSContainer",
               "Remove-EMSContainerPolicy",
               "Remove-EMSCorsPolicy",
               "Remove-EMSLifecyclePolicy",
               "Remove-EMSMetricPolicy",
               "Get-EMSContainer",
               "Get-EMSContainerPolicy",
               "Get-EMSCorsPolicy",
               "Get-EMSLifecyclePolicy",
               "Get-EMSMetricPolicy",
               "Get-EMSContainerList",
               "Get-EMSResourceTag",
               "Write-EMSContainerPolicy",
               "Write-EMSCorsPolicy",
               "Write-EMSLifecyclePolicy",
               "Write-EMSMetricPolicy",
               "Start-EMSAccessLogging",
               "Stop-EMSAccessLogging",
               "Add-EMSResourceTag",
               "Remove-EMSResourceTag")
}

_awsArgumentCompleterRegistration $EMS_SelectCompleters $EMS_SelectMap
# Argument completions for service AWS Elemental MediaStore Data Plane


$EMSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaStoreData.StorageClass
        "Write-EMSDObject/StorageClass"
        {
            $v = "TEMPORAL"
            break
        }

        # Amazon.MediaStoreData.UploadAvailability
        "Write-EMSDObject/UploadAvailability"
        {
            $v = "STANDARD","STREAMING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMSD_map = @{
    "StorageClass"=@("Write-EMSDObject")
    "UploadAvailability"=@("Write-EMSDObject")
}

_awsArgumentCompleterRegistration $EMSD_Completers $EMSD_map

$EMSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMSD_SelectMap = @{
    "Select"=@("Remove-EMSDObject",
               "Get-EMSDObjectMetadata",
               "Get-EMSDObject",
               "Get-EMSDItemList",
               "Write-EMSDObject")
}

_awsArgumentCompleterRegistration $EMSD_SelectCompleters $EMSD_SelectMap
# Argument completions for service AWS Elemental MediaTailor


$EMT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaTailor.AccessType
        {
            ($_ -eq "New-EMTSourceLocation/AccessConfiguration_AccessType") -Or
            ($_ -eq "Update-EMTSourceLocation/AccessConfiguration_AccessType")
        }
        {
            $v = "S3_SIGV4","SECRETS_MANAGER_ACCESS_TOKEN"
            break
        }

        # Amazon.MediaTailor.Mode
        "Set-EMTPlaybackConfiguration/AvailSuppression_Mode"
        {
            $v = "BEHIND_LIVE_EDGE","OFF"
            break
        }

        # Amazon.MediaTailor.PlaybackMode
        "New-EMTChannel/PlaybackMode"
        {
            $v = "LINEAR","LOOP"
            break
        }

        # Amazon.MediaTailor.RelativePosition
        "New-EMTProgram/ScheduleConfiguration_Transition_RelativePosition"
        {
            $v = "AFTER_PROGRAM","BEFORE_PROGRAM"
            break
        }

        # Amazon.MediaTailor.Tier
        "New-EMTChannel/Tier"
        {
            $v = "BASIC","STANDARD"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMT_map = @{
    "AccessConfiguration_AccessType"=@("New-EMTSourceLocation","Update-EMTSourceLocation")
    "AvailSuppression_Mode"=@("Set-EMTPlaybackConfiguration")
    "PlaybackMode"=@("New-EMTChannel")
    "ScheduleConfiguration_Transition_RelativePosition"=@("New-EMTProgram")
    "Tier"=@("New-EMTChannel")
}

_awsArgumentCompleterRegistration $EMT_Completers $EMT_map

$EMT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMT_SelectMap = @{
    "Select"=@("Add-EMTLogsForPlaybackConfiguration",
               "New-EMTChannel",
               "New-EMTLiveSource",
               "New-EMTPrefetchSchedule",
               "New-EMTProgram",
               "New-EMTSourceLocation",
               "New-EMTVodSource",
               "Remove-EMTChannel",
               "Remove-EMTChannelPolicy",
               "Remove-EMTLiveSource",
               "Remove-EMTPlaybackConfiguration",
               "Remove-EMTPrefetchSchedule",
               "Remove-EMTProgram",
               "Remove-EMTSourceLocation",
               "Remove-EMTVodSource",
               "Get-EMTChannel",
               "Get-EMTLiveSource",
               "Get-EMTProgram",
               "Get-EMTSourceLocation",
               "Get-EMTVodSource",
               "Get-EMTChannelPolicy",
               "Get-EMTChannelSchedule",
               "Get-EMTPlaybackConfiguration",
               "Get-EMTPrefetchSchedule",
               "Get-EMTAlertList",
               "Get-EMTChannelList",
               "Get-EMTLiveSourceList",
               "Get-EMTPlaybackConfigurationList",
               "Get-EMTPrefetchScheduleList",
               "Get-EMTSourceLocationList",
               "Get-EMTResourceTag",
               "Get-EMTVodSourceList",
               "Write-EMTChannelPolicy",
               "Set-EMTPlaybackConfiguration",
               "Start-EMTChannel",
               "Stop-EMTChannel",
               "Add-EMTResourceTag",
               "Remove-EMTResourceTag",
               "Update-EMTChannel",
               "Update-EMTLiveSource",
               "Update-EMTSourceLocation",
               "Update-EMTVodSource")
}

_awsArgumentCompleterRegistration $EMT_SelectCompleters $EMT_SelectMap
# Argument completions for service Amazon MemoryDB


$MDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MemoryDB.InputAuthenticationType
        {
            ($_ -eq "New-MDBUser/AuthenticationMode_Type") -Or
            ($_ -eq "Update-MDBUser/AuthenticationMode_Type")
        }
        {
            $v = "password"
            break
        }

        # Amazon.MemoryDB.SourceType
        "Get-MDBEvent/SourceType"
        {
            $v = "acl","cluster","node","parameter-group","subnet-group","user"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MDB_map = @{
    "AuthenticationMode_Type"=@("New-MDBUser","Update-MDBUser")
    "SourceType"=@("Get-MDBEvent")
}

_awsArgumentCompleterRegistration $MDB_Completers $MDB_map

$MDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MDB_SelectMap = @{
    "Select"=@("Update-MDBUpdateClusterBatch",
               "Copy-MDBSnapshot",
               "New-MDBACL",
               "New-MDBCluster",
               "New-MDBParameterGroup",
               "New-MDBSnapshot",
               "New-MDBSubnetGroup",
               "New-MDBUser",
               "Remove-MDBACL",
               "Remove-MDBCluster",
               "Remove-MDBParameterGroup",
               "Remove-MDBSnapshot",
               "Remove-MDBSubnetGroup",
               "Remove-MDBUser",
               "Get-MDBACLs",
               "Get-MDBCluster",
               "Get-MDBEngineVersion",
               "Get-MDBEvent",
               "Get-MDBParameterGroup",
               "Get-MDBParameter",
               "Get-MDBServiceUpdate",
               "Get-MDBSnapshot",
               "Get-MDBSubnetGroup",
               "Get-MDBUser",
               "Start-MDBFailoverShard",
               "Get-MDBAllowedNodeTypeUpdateList",
               "Get-MDBTag",
               "Reset-MDBParameterGroup",
               "Add-MDBResourceTag",
               "Remove-MDBResourceTag",
               "Update-MDBACL",
               "Update-MDBCluster",
               "Update-MDBParameterGroup",
               "Update-MDBSubnetGroup",
               "Update-MDBUser")
}

_awsArgumentCompleterRegistration $MDB_SelectCompleters $MDB_SelectMap
# Argument completions for service AWS Marketplace Metering


$MM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MM_SelectMap = @{
    "Select"=@("Send-MMMeteringDataBatch",
               "Send-MMMeteringData",
               "Register-MMUsage",
               "Get-MMCustomerMetadata")
}

_awsArgumentCompleterRegistration $MM_SelectCompleters $MM_SelectMap
# Argument completions for service Application Migration Service


$MGN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Mgn.BootMode
        "Update-MGNLaunchConfiguration/BootMode"
        {
            $v = "LEGACY_BIOS","UEFI"
            break
        }

        # Amazon.Mgn.ChangeServerLifeCycleStateSourceServerLifecycleState
        "Set-MGNServerLifeCycleState/LifeCycle_State"
        {
            $v = "CUTOVER","READY_FOR_CUTOVER","READY_FOR_TEST"
            break
        }

        # Amazon.Mgn.LaunchDisposition
        "Update-MGNLaunchConfiguration/LaunchDisposition"
        {
            $v = "STARTED","STOPPED"
            break
        }

        # Amazon.Mgn.PostLaunchActionsDeploymentType
        {
            ($_ -eq "New-MGNLaunchConfigurationTemplate/PostLaunchActions_Deployment") -Or
            ($_ -eq "Update-MGNLaunchConfiguration/PostLaunchActions_Deployment") -Or
            ($_ -eq "Update-MGNLaunchConfigurationTemplate/PostLaunchActions_Deployment")
        }
        {
            $v = "CUTOVER_ONLY","TEST_AND_CUTOVER"
            break
        }

        # Amazon.Mgn.ReplicationConfigurationDataPlaneRouting
        {
            ($_ -eq "New-MGNReplicationConfigurationTemplate/DataPlaneRouting") -Or
            ($_ -eq "Update-MGNReplicationConfiguration/DataPlaneRouting") -Or
            ($_ -eq "Update-MGNReplicationConfigurationTemplate/DataPlaneRouting")
        }
        {
            $v = "PRIVATE_IP","PUBLIC_IP"
            break
        }

        # Amazon.Mgn.ReplicationConfigurationDefaultLargeStagingDiskType
        {
            ($_ -eq "New-MGNReplicationConfigurationTemplate/DefaultLargeStagingDiskType") -Or
            ($_ -eq "Update-MGNReplicationConfiguration/DefaultLargeStagingDiskType") -Or
            ($_ -eq "Update-MGNReplicationConfigurationTemplate/DefaultLargeStagingDiskType")
        }
        {
            $v = "GP2","GP3","ST1"
            break
        }

        # Amazon.Mgn.ReplicationConfigurationEbsEncryption
        {
            ($_ -eq "New-MGNReplicationConfigurationTemplate/EbsEncryption") -Or
            ($_ -eq "Update-MGNReplicationConfiguration/EbsEncryption") -Or
            ($_ -eq "Update-MGNReplicationConfigurationTemplate/EbsEncryption")
        }
        {
            $v = "CUSTOM","DEFAULT"
            break
        }

        # Amazon.Mgn.ReplicationType
        "Update-MGNSourceServerReplicationType/ReplicationType"
        {
            $v = "AGENT_BASED","SNAPSHOT_SHIPPING"
            break
        }

        # Amazon.Mgn.TargetInstanceTypeRightSizingMethod
        "Update-MGNLaunchConfiguration/TargetInstanceTypeRightSizingMethod"
        {
            $v = "BASIC","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MGN_map = @{
    "BootMode"=@("Update-MGNLaunchConfiguration")
    "DataPlaneRouting"=@("New-MGNReplicationConfigurationTemplate","Update-MGNReplicationConfiguration","Update-MGNReplicationConfigurationTemplate")
    "DefaultLargeStagingDiskType"=@("New-MGNReplicationConfigurationTemplate","Update-MGNReplicationConfiguration","Update-MGNReplicationConfigurationTemplate")
    "EbsEncryption"=@("New-MGNReplicationConfigurationTemplate","Update-MGNReplicationConfiguration","Update-MGNReplicationConfigurationTemplate")
    "LaunchDisposition"=@("Update-MGNLaunchConfiguration")
    "LifeCycle_State"=@("Set-MGNServerLifeCycleState")
    "PostLaunchActions_Deployment"=@("New-MGNLaunchConfigurationTemplate","Update-MGNLaunchConfiguration","Update-MGNLaunchConfigurationTemplate")
    "ReplicationType"=@("Update-MGNSourceServerReplicationType")
    "TargetInstanceTypeRightSizingMethod"=@("Update-MGNLaunchConfiguration")
}

_awsArgumentCompleterRegistration $MGN_Completers $MGN_map

$MGN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MGN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MGN_SelectMap = @{
    "Select"=@("Set-MGNServerLifeCycleState",
               "New-MGNLaunchConfigurationTemplate",
               "New-MGNReplicationConfigurationTemplate",
               "Remove-MGNJob",
               "Remove-MGNLaunchConfigurationTemplate",
               "Remove-MGNReplicationConfigurationTemplate",
               "Remove-MGNSourceServer",
               "Remove-MGNVcenterClient",
               "Get-MGNJobLogItem",
               "Get-MGNJob",
               "Get-MGNLaunchConfigurationTemplate",
               "Get-MGNReplicationConfigurationTemplate",
               "Get-MGNSourceServer",
               "Get-MGNVcenterClient",
               "Disconnect-MGNFromService",
               "Complete-MGNCutover",
               "Get-MGNLaunchConfiguration",
               "Get-MGNReplicationConfiguration",
               "Initialize-MGNService",
               "Get-MGNResourceTag",
               "Set-MGNAsArchived",
               "Resume-MGNDataReplication",
               "Start-MGNCutover",
               "Start-MGNReplication",
               "Start-MGNTest",
               "Add-MGNResourceTag",
               "Remove-MGNTargetInstance",
               "Remove-MGNResourceTag",
               "Update-MGNLaunchConfiguration",
               "Update-MGNLaunchConfigurationTemplate",
               "Update-MGNReplicationConfiguration",
               "Update-MGNReplicationConfigurationTemplate",
               "Update-MGNSourceServerReplicationType")
}

_awsArgumentCompleterRegistration $MGN_SelectCompleters $MGN_SelectMap
# Argument completions for service AWS Migration Hub Config


$MHC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHubConfig.TargetType
        {
            ($_ -eq "Get-MHCHomeRegionControl/Target_Type") -Or
            ($_ -eq "New-MHCHomeRegionControl/Target_Type")
        }
        {
            $v = "ACCOUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHC_map = @{
    "Target_Type"=@("Get-MHCHomeRegionControl","New-MHCHomeRegionControl")
}

_awsArgumentCompleterRegistration $MHC_Completers $MHC_map

$MHC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MHC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHC_SelectMap = @{
    "Select"=@("New-MHCHomeRegionControl",
               "Get-MHCHomeRegionControl",
               "Get-MHCHomeRegion")
}

_awsArgumentCompleterRegistration $MHC_SelectCompleters $MHC_SelectMap
# Argument completions for service AWS Migration Hub Orchestrator


$MHO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHubOrchestrator.MigrationWorkflowStatusEnum
        "Get-MHOWorkflowList/Status"
        {
            $v = "COMPLETED","CREATING","CREATION_FAILED","DELETED","DELETING","DELETION_FAILED","IN_PROGRESS","NOT_STARTED","PAUSED","PAUSING","PAUSING_FAILED","STARTING","USER_ATTENTION_REQUIRED","WORKFLOW_FAILED"
            break
        }

        # Amazon.MigrationHubOrchestrator.RunEnvironment
        {
            ($_ -eq "New-MHOWorkflowStep/WorkflowStepAutomationConfiguration_RunEnvironment") -Or
            ($_ -eq "Update-MHOWorkflowStep/WorkflowStepAutomationConfiguration_RunEnvironment")
        }
        {
            $v = "AWS","ONPREMISE"
            break
        }

        # Amazon.MigrationHubOrchestrator.StepActionType
        {
            ($_ -eq "New-MHOWorkflowStep/StepActionType") -Or
            ($_ -eq "Update-MHOWorkflowStep/StepActionType")
        }
        {
            $v = "AUTOMATED","MANUAL"
            break
        }

        # Amazon.MigrationHubOrchestrator.StepStatus
        "Update-MHOWorkflowStep/Status"
        {
            $v = "AWAITING_DEPENDENCIES","COMPLETED","FAILED","IN_PROGRESS","PAUSED","READY","USER_ATTENTION_REQUIRED"
            break
        }

        # Amazon.MigrationHubOrchestrator.TargetType
        {
            ($_ -eq "New-MHOWorkflowStep/WorkflowStepAutomationConfiguration_TargetType") -Or
            ($_ -eq "Update-MHOWorkflowStep/WorkflowStepAutomationConfiguration_TargetType")
        }
        {
            $v = "ALL","NONE","SINGLE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHO_map = @{
    "Status"=@("Get-MHOWorkflowList","Update-MHOWorkflowStep")
    "StepActionType"=@("New-MHOWorkflowStep","Update-MHOWorkflowStep")
    "WorkflowStepAutomationConfiguration_RunEnvironment"=@("New-MHOWorkflowStep","Update-MHOWorkflowStep")
    "WorkflowStepAutomationConfiguration_TargetType"=@("New-MHOWorkflowStep","Update-MHOWorkflowStep")
}

_awsArgumentCompleterRegistration $MHO_Completers $MHO_map

$MHO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MHO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHO_SelectMap = @{
    "Select"=@("New-MHOWorkflow",
               "New-MHOWorkflowStep",
               "New-MHOWorkflowStepGroup",
               "Remove-MHOWorkflow",
               "Remove-MHOWorkflowStep",
               "Remove-MHOWorkflowStepGroup",
               "Get-MHOTemplate",
               "Get-MHOTemplateStep",
               "Get-MHOTemplateStepGroup",
               "Get-MHOWorkflow",
               "Get-MHOWorkflowStep",
               "Get-MHOWorkflowStepGroup",
               "Get-MHOPluginList",
               "Get-MHOResourceTag",
               "Get-MHOTemplateList",
               "Get-MHOTemplateStepGroupList",
               "Get-MHOTemplateStepList",
               "Get-MHOWorkflowList",
               "Get-MHOWorkflowStepGroupList",
               "Get-MHOWorkflowStepList",
               "Start-MHOWorkflowStep",
               "Start-MHOWorkflow",
               "Stop-MHOWorkflow",
               "Add-MHOResourceTag",
               "Remove-MHOResourceTag",
               "Update-MHOWorkflow",
               "Update-MHOWorkflowStep",
               "Update-MHOWorkflowStepGroup")
}

_awsArgumentCompleterRegistration $MHO_SelectCompleters $MHO_SelectMap
# Argument completions for service AWS Migration Hub Refactor Spaces


$MHRS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHubRefactorSpaces.ApiGatewayEndpointType
        "New-MHRSApplication/ApiGatewayProxy_EndpointType"
        {
            $v = "PRIVATE","REGIONAL"
            break
        }

        # Amazon.MigrationHubRefactorSpaces.NetworkFabricType
        "New-MHRSEnvironment/NetworkFabricType"
        {
            $v = "TRANSIT_GATEWAY"
            break
        }

        # Amazon.MigrationHubRefactorSpaces.ProxyType
        "New-MHRSApplication/ProxyType"
        {
            $v = "API_GATEWAY"
            break
        }

        # Amazon.MigrationHubRefactorSpaces.RouteActivationState
        {
            ($_ -eq "Update-MHRSRoute/ActivationState") -Or
            ($_ -eq "New-MHRSRoute/DefaultRoute_ActivationState") -Or
            ($_ -eq "New-MHRSRoute/UriPathRoute_ActivationState")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.MigrationHubRefactorSpaces.RouteType
        "New-MHRSRoute/RouteType"
        {
            $v = "DEFAULT","URI_PATH"
            break
        }

        # Amazon.MigrationHubRefactorSpaces.ServiceEndpointType
        "New-MHRSService/EndpointType"
        {
            $v = "LAMBDA","URL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHRS_map = @{
    "ActivationState"=@("Update-MHRSRoute")
    "ApiGatewayProxy_EndpointType"=@("New-MHRSApplication")
    "DefaultRoute_ActivationState"=@("New-MHRSRoute")
    "EndpointType"=@("New-MHRSService")
    "NetworkFabricType"=@("New-MHRSEnvironment")
    "ProxyType"=@("New-MHRSApplication")
    "RouteType"=@("New-MHRSRoute")
    "UriPathRoute_ActivationState"=@("New-MHRSRoute")
}

_awsArgumentCompleterRegistration $MHRS_Completers $MHRS_map

$MHRS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MHRS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHRS_SelectMap = @{
    "Select"=@("New-MHRSApplication",
               "New-MHRSEnvironment",
               "New-MHRSRoute",
               "New-MHRSService",
               "Remove-MHRSApplication",
               "Remove-MHRSEnvironment",
               "Remove-MHRSResourcePolicy",
               "Remove-MHRSRoute",
               "Remove-MHRSService",
               "Get-MHRSApplication",
               "Get-MHRSEnvironment",
               "Get-MHRSResourcePolicy",
               "Get-MHRSRoute",
               "Get-MHRSService",
               "Get-MHRSApplicationList",
               "Get-MHRSEnvironmentList",
               "Get-MHRSEnvironmentVpcList",
               "Get-MHRSRouteList",
               "Get-MHRSServiceList",
               "Get-MHRSResourceTag",
               "Write-MHRSResourcePolicy",
               "Add-MHRSResourceTag",
               "Remove-MHRSResourceTag",
               "Update-MHRSRoute")
}

_awsArgumentCompleterRegistration $MHRS_SelectCompleters $MHRS_SelectMap
# Argument completions for service Migration Hub Strategy Recommendations


$MHS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHubStrategyRecommendations.ApplicationComponentCriteria
        "Get-MHSApplicationComponentList/ApplicationComponentCriteria"
        {
            $v = "APP_NAME","APP_TYPE","DESTINATION","NOT_DEFINED","SERVER_ID","STRATEGY"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.DatabaseManagementPreference
        "Write-MHSPortfolioPreference/DatabasePreferences_DatabaseManagementPreference"
        {
            $v = "AWS-managed","No preference","Self-manage"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.DataSourceType
        "Start-MHSImportFileTask/DataSourceType"
        {
            $v = "ApplicationDiscoveryService","MPA"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.InclusionStatus
        "Update-MHSApplicationComponentConfig/InclusionStatus"
        {
            $v = "excludeFromAssessment","includeInAssessment"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.OutputFormat
        "Start-MHSRecommendationReportGeneration/OutputFormat"
        {
            $v = "Excel","Json"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.ServerCriteria
        "Get-MHSServerList/ServerCriteria"
        {
            $v = "DESTINATION","NOT_DEFINED","OS_NAME","SERVER_ID","STRATEGY"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.SortOrder
        {
            ($_ -eq "Get-MHSApplicationComponentList/Sort") -Or
            ($_ -eq "Get-MHSServerList/Sort")
        }
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.Strategy
        {
            ($_ -eq "Update-MHSApplicationComponentConfig/StrategyOption_Strategy") -Or
            ($_ -eq "Update-MHSServerConfig/StrategyOption_Strategy")
        }
        {
            $v = "Refactor","Rehost","Relocate","Replatform","Repurchase","Retain","Retirement"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.TargetDestination
        {
            ($_ -eq "Update-MHSApplicationComponentConfig/StrategyOption_TargetDestination") -Or
            ($_ -eq "Update-MHSServerConfig/StrategyOption_TargetDestination")
        }
        {
            $v = "Amazon DocumentDB","Amazon DynamoDB","Amazon Elastic Cloud Compute (EC2)","Amazon Elastic Container Service (ECS)","Amazon Elastic Kubernetes Service (EKS)","Amazon Relational Database Service","Amazon Relational Database Service on MySQL","Amazon Relational Database Service on PostgreSQL","Aurora MySQL","Aurora PostgreSQL","AWS Elastic BeanStalk","AWS Fargate","None specified"
            break
        }

        # Amazon.MigrationHubStrategyRecommendations.TransformationToolName
        {
            ($_ -eq "Update-MHSApplicationComponentConfig/StrategyOption_ToolName") -Or
            ($_ -eq "Update-MHSServerConfig/StrategyOption_ToolName")
        }
        {
            $v = "App2Container","Application Migration Service","Database Migration Service","End of Support Migration","In Place Operating System Upgrade","Native SQL Server Backup/Restore","Porting Assistant For .NET","Schema Conversion Tool","Strategy Recommendation Support","Windows Web Application Migration Assistant"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHS_map = @{
    "ApplicationComponentCriteria"=@("Get-MHSApplicationComponentList")
    "DatabasePreferences_DatabaseManagementPreference"=@("Write-MHSPortfolioPreference")
    "DataSourceType"=@("Start-MHSImportFileTask")
    "InclusionStatus"=@("Update-MHSApplicationComponentConfig")
    "OutputFormat"=@("Start-MHSRecommendationReportGeneration")
    "ServerCriteria"=@("Get-MHSServerList")
    "Sort"=@("Get-MHSApplicationComponentList","Get-MHSServerList")
    "StrategyOption_Strategy"=@("Update-MHSApplicationComponentConfig","Update-MHSServerConfig")
    "StrategyOption_TargetDestination"=@("Update-MHSApplicationComponentConfig","Update-MHSServerConfig")
    "StrategyOption_ToolName"=@("Update-MHSApplicationComponentConfig","Update-MHSServerConfig")
}

_awsArgumentCompleterRegistration $MHS_Completers $MHS_map

$MHS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MHS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHS_SelectMap = @{
    "Select"=@("Get-MHSApplicationComponentDetail",
               "Get-MHSApplicationComponentStrategy",
               "Get-MHSAssessment",
               "Get-MHSImportFileTask",
               "Get-MHSPortfolioPreference",
               "Get-MHSPortfolioSummary",
               "Get-MHSRecommendationReportDetail",
               "Get-MHSServerDetail",
               "Get-MHSServerStrategy",
               "Get-MHSApplicationComponentList",
               "Get-MHSCollectorList",
               "Get-MHSImportFileTaskList",
               "Get-MHSServerList",
               "Write-MHSPortfolioPreference",
               "Start-MHSAssessment",
               "Start-MHSImportFileTask",
               "Start-MHSRecommendationReportGeneration",
               "Stop-MHSAssessment",
               "Update-MHSApplicationComponentConfig",
               "Update-MHSServerConfig")
}

_awsArgumentCompleterRegistration $MHS_SelectCompleters $MHS_SelectMap
# Argument completions for service AWS Mobile


$MOBL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Mobile.Platform
        "Export-MOBLBundle/Platform"
        {
            $v = "ANDROID","JAVASCRIPT","LINUX","OBJC","OSX","SWIFT","WINDOWS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MOBL_map = @{
    "Platform"=@("Export-MOBLBundle")
}

_awsArgumentCompleterRegistration $MOBL_Completers $MOBL_map

$MOBL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MOBL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MOBL_SelectMap = @{
    "Select"=@("New-MOBLProject",
               "Remove-MOBLProject",
               "Get-MOBLBundle",
               "Get-MOBLProject",
               "Export-MOBLBundle",
               "Export-MOBLProject",
               "Get-MOBLBundleList",
               "Get-MOBLProjectList",
               "Update-MOBLProject")
}

_awsArgumentCompleterRegistration $MOBL_SelectCompleters $MOBL_SelectMap
# Argument completions for service Amazon Lex Model Building V2


$LMBV2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LexModelsV2.AggregatedUtterancesSortAttribute
        "Get-LMBV2AggregatedUtteranceList/SortBy_Attribute"
        {
            $v = "HitCount","MissedCount"
            break
        }

        # Amazon.LexModelsV2.AudioRecognitionStrategy
        {
            ($_ -eq "New-LMBV2SlotType/ValueSelectionSetting_AdvancedRecognitionSetting_AudioRecognitionStrategy") -Or
            ($_ -eq "Update-LMBV2SlotType/ValueSelectionSetting_AdvancedRecognitionSetting_AudioRecognitionStrategy")
        }
        {
            $v = "UseSlotValuesAsCustomVocabulary"
            break
        }

        # Amazon.LexModelsV2.BotLocaleSortAttribute
        "Get-LMBV2BotLocaleList/SortBy_Attribute"
        {
            $v = "BotLocaleName"
            break
        }

        # Amazon.LexModelsV2.BotSortAttribute
        "Get-LMBV2BotList/SortBy_Attribute"
        {
            $v = "BotName"
            break
        }

        # Amazon.LexModelsV2.BotVersionSortAttribute
        "Get-LMBV2BotVersionList/SortBy_Attribute"
        {
            $v = "BotVersion"
            break
        }

        # Amazon.LexModelsV2.BuiltInIntentSortAttribute
        "Get-LMBV2BuiltInIntentList/SortBy_Attribute"
        {
            $v = "IntentSignature"
            break
        }

        # Amazon.LexModelsV2.BuiltInSlotTypeSortAttribute
        "Get-LMBV2BuiltInSlotTypeList/SortBy_Attribute"
        {
            $v = "SlotTypeSignature"
            break
        }

        # Amazon.LexModelsV2.DialogActionType
        {
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/InitialResponseSetting_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/InitialResponseSetting_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentClosingSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentClosingSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentClosingSetting_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentClosingSetting_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_ConfirmationConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_ConfirmationConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_ConfirmationNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_ConfirmationNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_DeclinationConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_DeclinationConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_DeclinationNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_DeclinationNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CaptureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CaptureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CaptureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CaptureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_FailureNextStep_DialogAction_Type") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotCaptureSetting_FailureNextStep_DialogAction_Type")
        }
        {
            $v = "CloseIntent","ConfirmIntent","ElicitIntent","ElicitSlot","EndConversation","EvaluateConditional","FulfillIntent","InvokeDialogCodeHook","StartIntent"
            break
        }

        # Amazon.LexModelsV2.Effect
        "New-LMBV2ResourcePolicyStatement/Effect"
        {
            $v = "Allow","Deny"
            break
        }

        # Amazon.LexModelsV2.ExportSortAttribute
        "Get-LMBV2ExportList/SortBy_Attribute"
        {
            $v = "LastUpdatedDateTime"
            break
        }

        # Amazon.LexModelsV2.ImportExportFileFormat
        "New-LMBV2Export/FileFormat"
        {
            $v = "LexJson","TSV"
            break
        }

        # Amazon.LexModelsV2.ImportSortAttribute
        "Get-LMBV2ImportList/SortBy_Attribute"
        {
            $v = "LastUpdatedDateTime"
            break
        }

        # Amazon.LexModelsV2.IntentSortAttribute
        "Get-LMBV2IntentList/SortBy_Attribute"
        {
            $v = "IntentName","LastUpdatedDateTime"
            break
        }

        # Amazon.LexModelsV2.MergeStrategy
        "Start-LMBV2Import/MergeStrategy"
        {
            $v = "Append","FailOnConflict","Overwrite"
            break
        }

        # Amazon.LexModelsV2.MessageSelectionStrategy
        {
            ($_ -eq "New-LMBV2Intent/IntentConfirmationSetting_PromptSpecification_MessageSelectionStrategy") -Or
            ($_ -eq "Update-LMBV2Intent/IntentConfirmationSetting_PromptSpecification_MessageSelectionStrategy") -Or
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_PromptSpecification_MessageSelectionStrategy") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_PromptSpecification_MessageSelectionStrategy")
        }
        {
            $v = "Ordered","Random"
            break
        }

        # Amazon.LexModelsV2.ObfuscationSettingType
        {
            ($_ -eq "New-LMBV2Slot/ObfuscationSetting_ObfuscationSettingType") -Or
            ($_ -eq "Update-LMBV2Slot/ObfuscationSetting_ObfuscationSettingType")
        }
        {
            $v = "DefaultObfuscation","None"
            break
        }

        # Amazon.LexModelsV2.SearchOrder
        "Search-LMBV2AssociatedTranscript/SearchOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.LexModelsV2.SlotConstraint
        {
            ($_ -eq "New-LMBV2Slot/ValueElicitationSetting_SlotConstraint") -Or
            ($_ -eq "Update-LMBV2Slot/ValueElicitationSetting_SlotConstraint")
        }
        {
            $v = "Optional","Required"
            break
        }

        # Amazon.LexModelsV2.SlotSortAttribute
        "Get-LMBV2SlotList/SortBy_Attribute"
        {
            $v = "LastUpdatedDateTime","SlotName"
            break
        }

        # Amazon.LexModelsV2.SlotTypeSortAttribute
        "Get-LMBV2SlotTypeList/SortBy_Attribute"
        {
            $v = "LastUpdatedDateTime","SlotTypeName"
            break
        }

        # Amazon.LexModelsV2.SlotValueResolutionStrategy
        {
            ($_ -eq "New-LMBV2SlotType/ValueSelectionSetting_ResolutionStrategy") -Or
            ($_ -eq "Update-LMBV2SlotType/ValueSelectionSetting_ResolutionStrategy")
        }
        {
            $v = "Concatenation","OriginalValue","TopResolution"
            break
        }

        # Amazon.LexModelsV2.SortOrder
        {
            ($_ -eq "Get-LMBV2AggregatedUtteranceList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2BotList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2BotLocaleList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2BotVersionList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2BuiltInIntentList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2BuiltInSlotTypeList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2ExportList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2ImportList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2IntentList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2SlotList/SortBy_Order") -Or
            ($_ -eq "Get-LMBV2SlotTypeList/SortBy_Order")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.LexModelsV2.TimeDimension
        "Get-LMBV2AggregatedUtteranceList/AggregationDuration_RelativeAggregationDuration_TimeDimension"
        {
            $v = "Days","Hours","Weeks"
            break
        }

        # Amazon.LexModelsV2.TranscriptFormat
        "Start-LMBV2BotRecommendation/TranscriptSourceSetting_S3BucketTranscriptSource_TranscriptFormat"
        {
            $v = "Lex"
            break
        }

        # Amazon.LexModelsV2.VoiceEngine
        {
            ($_ -eq "Start-LMBV2Import/ResourceSpecification_BotLocaleImportSpecification_VoiceSettings_Engine") -Or
            ($_ -eq "New-LMBV2BotLocale/VoiceSettings_Engine") -Or
            ($_ -eq "Update-LMBV2BotLocale/VoiceSettings_Engine")
        }
        {
            $v = "neural","standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMBV2_map = @{
    "AggregationDuration_RelativeAggregationDuration_TimeDimension"=@("Get-LMBV2AggregatedUtteranceList")
    "Effect"=@("New-LMBV2ResourcePolicyStatement")
    "FileFormat"=@("New-LMBV2Export")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_FailureNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_SuccessNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "FulfillmentCodeHook_PostFulfillmentStatusSpecification_TimeoutNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "InitialResponseSetting_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentClosingSetting_Conditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentClosingSetting_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_ConfirmationConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_ConfirmationNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_DeclinationConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_DeclinationNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_FailureNextStep_DialogAction_Type"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "IntentConfirmationSetting_PromptSpecification_MessageSelectionStrategy"=@("New-LMBV2Intent","Update-LMBV2Intent")
    "MergeStrategy"=@("Start-LMBV2Import")
    "ObfuscationSetting_ObfuscationSettingType"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ResourceSpecification_BotLocaleImportSpecification_VoiceSettings_Engine"=@("Start-LMBV2Import")
    "SearchOrder"=@("Search-LMBV2AssociatedTranscript")
    "SortBy_Attribute"=@("Get-LMBV2AggregatedUtteranceList","Get-LMBV2BotList","Get-LMBV2BotLocaleList","Get-LMBV2BotVersionList","Get-LMBV2BuiltInIntentList","Get-LMBV2BuiltInSlotTypeList","Get-LMBV2ExportList","Get-LMBV2ImportList","Get-LMBV2IntentList","Get-LMBV2SlotList","Get-LMBV2SlotTypeList")
    "SortBy_Order"=@("Get-LMBV2AggregatedUtteranceList","Get-LMBV2BotList","Get-LMBV2BotLocaleList","Get-LMBV2BotVersionList","Get-LMBV2BuiltInIntentList","Get-LMBV2BuiltInSlotTypeList","Get-LMBV2ExportList","Get-LMBV2ImportList","Get-LMBV2IntentList","Get-LMBV2SlotList","Get-LMBV2SlotTypeList")
    "TranscriptSourceSetting_S3BucketTranscriptSource_TranscriptFormat"=@("Start-LMBV2BotRecommendation")
    "ValueElicitationSetting_PromptSpecification_MessageSelectionStrategy"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CaptureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CaptureNextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_FailureNextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_SuccessNextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_CodeHook_PostCodeHookSpecification_TimeoutNextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_FailureConditional_DefaultBranch_NextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotCaptureSetting_FailureNextStep_DialogAction_Type"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueElicitationSetting_SlotConstraint"=@("New-LMBV2Slot","Update-LMBV2Slot")
    "ValueSelectionSetting_AdvancedRecognitionSetting_AudioRecognitionStrategy"=@("New-LMBV2SlotType","Update-LMBV2SlotType")
    "ValueSelectionSetting_ResolutionStrategy"=@("New-LMBV2SlotType","Update-LMBV2SlotType")
    "VoiceSettings_Engine"=@("New-LMBV2BotLocale","Update-LMBV2BotLocale")
}

_awsArgumentCompleterRegistration $LMBV2_Completers $LMBV2_map

$LMBV2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LMBV2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMBV2_SelectMap = @{
    "Select"=@("New-LMBV2CustomVocabularyItem",
               "Remove-LMBV2CustomVocabularyItem",
               "Edit-LMBV2CustomVocabularyItem",
               "Invoke-LMBV2BuildBotLocale",
               "New-LMBV2Bot",
               "New-LMBV2BotAlias",
               "New-LMBV2BotLocale",
               "New-LMBV2BotVersion",
               "New-LMBV2Export",
               "New-LMBV2Intent",
               "New-LMBV2ResourcePolicy",
               "New-LMBV2ResourcePolicyStatement",
               "New-LMBV2Slot",
               "New-LMBV2SlotType",
               "New-LMBV2UploadUrl",
               "Remove-LMBV2Bot",
               "Remove-LMBV2BotAlias",
               "Remove-LMBV2BotLocale",
               "Remove-LMBV2BotVersion",
               "Remove-LMBV2CustomVocabulary",
               "Remove-LMBV2Export",
               "Remove-LMBV2Import",
               "Remove-LMBV2Intent",
               "Remove-LMBV2ResourcePolicy",
               "Remove-LMBV2ResourcePolicyStatement",
               "Remove-LMBV2Slot",
               "Remove-LMBV2SlotType",
               "Remove-LMBV2Utterance",
               "Get-LMBV2Bot",
               "Get-LMBV2BotAlias",
               "Get-LMBV2BotLocale",
               "Get-LMBV2BotRecommendation",
               "Get-LMBV2BotVersion",
               "Get-LMBV2CustomVocabularyMetadata",
               "Get-LMBV2Export",
               "Get-LMBV2Import",
               "Get-LMBV2Intent",
               "Get-LMBV2ResourcePolicy",
               "Get-LMBV2Slot",
               "Get-LMBV2SlotType",
               "Get-LMBV2AggregatedUtteranceList",
               "Get-LMBV2BotAliasList",
               "Get-LMBV2BotLocaleList",
               "Get-LMBV2BotRecommendationList",
               "Get-LMBV2BotList",
               "Get-LMBV2BotVersionList",
               "Get-LMBV2BuiltInIntentList",
               "Get-LMBV2BuiltInSlotTypeList",
               "Get-LMBV2CustomVocabularyItemList",
               "Get-LMBV2ExportList",
               "Get-LMBV2ImportList",
               "Get-LMBV2IntentList",
               "Get-LMBV2RecommendedIntentList",
               "Get-LMBV2SlotList",
               "Get-LMBV2SlotTypeList",
               "Get-LMBV2ResourceTag",
               "Search-LMBV2AssociatedTranscript",
               "Start-LMBV2BotRecommendation",
               "Start-LMBV2Import",
               "Stop-LMBV2BotRecommendation",
               "Add-LMBV2ResourceTag",
               "Remove-LMBV2ResourceTag",
               "Update-LMBV2Bot",
               "Update-LMBV2BotAlias",
               "Update-LMBV2BotLocale",
               "Update-LMBV2BotRecommendation",
               "Update-LMBV2Export",
               "Update-LMBV2Intent",
               "Update-LMBV2ResourcePolicy",
               "Update-LMBV2Slot",
               "Update-LMBV2SlotType")
}

_awsArgumentCompleterRegistration $LMBV2_SelectCompleters $LMBV2_SelectMap
# Argument completions for service Amazon CloudWatch


$CW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatch.ComparisonOperator
        "Write-CWMetricAlarm/ComparisonOperator"
        {
            $v = "GreaterThanOrEqualToThreshold","GreaterThanThreshold","GreaterThanUpperThreshold","LessThanLowerOrGreaterThanUpperThreshold","LessThanLowerThreshold","LessThanOrEqualToThreshold","LessThanThreshold"
            break
        }

        # Amazon.CloudWatch.HistoryItemType
        "Get-CWAlarmHistory/HistoryItemType"
        {
            $v = "Action","ConfigurationUpdate","StateUpdate"
            break
        }

        # Amazon.CloudWatch.MetricStreamOutputFormat
        "Write-CWMetricStream/OutputFormat"
        {
            $v = "json","opentelemetry0.7"
            break
        }

        # Amazon.CloudWatch.RecentlyActive
        "Get-CWMetricList/RecentlyActive"
        {
            $v = "PT3H"
            break
        }

        # Amazon.CloudWatch.ScanBy
        {
            ($_ -eq "Get-CWAlarmHistory/ScanBy") -Or
            ($_ -eq "Get-CWMetricData/ScanBy")
        }
        {
            $v = "TimestampAscending","TimestampDescending"
            break
        }

        # Amazon.CloudWatch.StandardUnit
        {
            ($_ -eq "Get-CWAlarmForMetric/Unit") -Or
            ($_ -eq "Get-CWMetricStatistic/Unit") -Or
            ($_ -eq "Write-CWMetricAlarm/Unit")
        }
        {
            $v = "Bits","Bits/Second","Bytes","Bytes/Second","Count","Count/Second","Gigabits","Gigabits/Second","Gigabytes","Gigabytes/Second","Kilobits","Kilobits/Second","Kilobytes","Kilobytes/Second","Megabits","Megabits/Second","Megabytes","Megabytes/Second","Microseconds","Milliseconds","None","Percent","Seconds","Terabits","Terabits/Second","Terabytes","Terabytes/Second"
            break
        }

        # Amazon.CloudWatch.StateValue
        {
            ($_ -eq "Get-CWAlarm/StateValue") -Or
            ($_ -eq "Set-CWAlarmState/StateValue")
        }
        {
            $v = "ALARM","INSUFFICIENT_DATA","OK"
            break
        }

        # Amazon.CloudWatch.Statistic
        {
            ($_ -eq "Get-CWAlarmForMetric/Statistic") -Or
            ($_ -eq "Write-CWMetricAlarm/Statistic")
        }
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CW_map = @{
    "ComparisonOperator"=@("Write-CWMetricAlarm")
    "HistoryItemType"=@("Get-CWAlarmHistory")
    "OutputFormat"=@("Write-CWMetricStream")
    "RecentlyActive"=@("Get-CWMetricList")
    "ScanBy"=@("Get-CWAlarmHistory","Get-CWMetricData")
    "StateValue"=@("Get-CWAlarm","Set-CWAlarmState")
    "Statistic"=@("Get-CWAlarmForMetric","Write-CWMetricAlarm")
    "Unit"=@("Get-CWAlarmForMetric","Get-CWMetricStatistic","Write-CWMetricAlarm")
}

_awsArgumentCompleterRegistration $CW_Completers $CW_map

$CW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CW_SelectMap = @{
    "Select"=@("Remove-CWAlarm",
               "Remove-CWAnomalyDetector",
               "Remove-CWDashboard",
               "Remove-CWInsightRule",
               "Remove-CWMetricStream",
               "Get-CWAlarmHistory",
               "Get-CWAlarm",
               "Get-CWAlarmForMetric",
               "Get-CWAnomalyDetector",
               "Get-CWInsightRule",
               "Disable-CWAlarmAction",
               "Disable-CWInsightRule",
               "Enable-CWAlarmAction",
               "Enable-CWInsightRule",
               "Get-CWDashboard",
               "Get-CWInsightRuleReport",
               "Get-CWMetricData",
               "Get-CWMetricStatistic",
               "Get-CWMetricStream",
               "Get-CWMetricWidgetImage",
               "Get-CWDashboardList",
               "Get-CWManagedInsightRule",
               "Get-CWMetricList",
               "Get-CWMetricStreamList",
               "Get-CWResourceTag",
               "Write-CWAnomalyDetector",
               "Write-CWCompositeAlarm",
               "Write-CWDashboard",
               "Write-CWInsightRule",
               "Write-CWManagedInsightRule",
               "Write-CWMetricAlarm",
               "Write-CWMetricData",
               "Write-CWMetricStream",
               "Set-CWAlarmState",
               "Start-CWMetricStream",
               "Stop-CWMetricStream",
               "Add-CWResourceTag",
               "Remove-CWResourceTag")
}

_awsArgumentCompleterRegistration $CW_SelectCompleters $CW_SelectMap
# Argument completions for service Amazon MQ


$MQ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MQ.AuthenticationStrategy
        {
            ($_ -eq "New-MQBroker/AuthenticationStrategy") -Or
            ($_ -eq "New-MQConfiguration/AuthenticationStrategy") -Or
            ($_ -eq "Update-MQBroker/AuthenticationStrategy")
        }
        {
            $v = "LDAP","SIMPLE"
            break
        }

        # Amazon.MQ.BrokerStorageType
        "New-MQBroker/StorageType"
        {
            $v = "EBS","EFS"
            break
        }

        # Amazon.MQ.DeploymentMode
        "New-MQBroker/DeploymentMode"
        {
            $v = "ACTIVE_STANDBY_MULTI_AZ","CLUSTER_MULTI_AZ","SINGLE_INSTANCE"
            break
        }

        # Amazon.MQ.EngineType
        {
            ($_ -eq "New-MQBroker/EngineType") -Or
            ($_ -eq "New-MQConfiguration/EngineType")
        }
        {
            $v = "ACTIVEMQ","RABBITMQ"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MQ_map = @{
    "AuthenticationStrategy"=@("New-MQBroker","New-MQConfiguration","Update-MQBroker")
    "DeploymentMode"=@("New-MQBroker")
    "EngineType"=@("New-MQBroker","New-MQConfiguration")
    "StorageType"=@("New-MQBroker")
}

_awsArgumentCompleterRegistration $MQ_Completers $MQ_map

$MQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MQ_SelectMap = @{
    "Select"=@("New-MQBroker",
               "New-MQConfiguration",
               "New-MQTag",
               "New-MQUser",
               "Remove-MQBroker",
               "Remove-MQTag",
               "Remove-MQUser",
               "Get-MQBroker",
               "Get-MQBrokerEngineType",
               "Get-MQBrokerInstanceOption",
               "Get-MQConfiguration",
               "Get-MQConfigurationRevision",
               "Get-MQUser",
               "Get-MQBrokerList",
               "Get-MQConfigurationRevisionList",
               "Get-MQConfigurationList",
               "Get-MQTagList",
               "Get-MQUserList",
               "Restart-MQBroker",
               "Update-MQBroker",
               "Update-MQConfiguration",
               "Update-MQUser")
}

_awsArgumentCompleterRegistration $MQ_SelectCompleters $MQ_SelectMap
# Argument completions for service Amazon MTurk Service


$MTR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MTurk.EventType
        "Send-MTRTestEventNotification/TestEventType"
        {
            $v = "AssignmentAbandoned","AssignmentAccepted","AssignmentApproved","AssignmentRejected","AssignmentReturned","AssignmentSubmitted","HITCreated","HITDisposed","HITExpired","HITExtended","HITReviewable","Ping"
            break
        }

        # Amazon.MTurk.NotificationTransport
        {
            ($_ -eq "Send-MTRTestEventNotification/Notification_Transport") -Or
            ($_ -eq "Update-MTRNotificationSetting/Notification_Transport")
        }
        {
            $v = "Email","SNS","SQS"
            break
        }

        # Amazon.MTurk.QualificationStatus
        "Get-MTRWorkersWithQualificationType/Status"
        {
            $v = "Granted","Revoked"
            break
        }

        # Amazon.MTurk.QualificationTypeStatus
        {
            ($_ -eq "New-MTRQualificationType/QualificationTypeStatus") -Or
            ($_ -eq "Update-MTRQualificationType/QualificationTypeStatus")
        }
        {
            $v = "Active","Inactive"
            break
        }

        # Amazon.MTurk.ReviewableHITStatus
        "Get-MTRReviewableHITList/Status"
        {
            $v = "Reviewable","Reviewing"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MTR_map = @{
    "Notification_Transport"=@("Send-MTRTestEventNotification","Update-MTRNotificationSetting")
    "QualificationTypeStatus"=@("New-MTRQualificationType","Update-MTRQualificationType")
    "Status"=@("Get-MTRReviewableHITList","Get-MTRWorkersWithQualificationType")
    "TestEventType"=@("Send-MTRTestEventNotification")
}

_awsArgumentCompleterRegistration $MTR_Completers $MTR_map

$MTR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MTR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MTR_SelectMap = @{
    "Select"=@("Grant-MTRQualificationRequest",
               "Approve-MTRAssignment",
               "Add-MTRQualificationToWorker",
               "New-MTRAdditionalAssignmentsForHIT",
               "New-MTRHIT",
               "New-MTRHITType",
               "New-MTRHITWithHITType",
               "New-MTRQualificationType",
               "New-MTRWorkerBlock",
               "Remove-MTRHIT",
               "Remove-MTRQualificationType",
               "Remove-MTRWorkerBlock",
               "Remove-MTRQualificationFromWorker",
               "Get-MTRAccountBalance",
               "Get-MTRAssignment",
               "Get-MTRFileUploadURL",
               "Get-MTRHIT",
               "Get-MTRQualificationScore",
               "Get-MTRQualificationType",
               "Get-MTRHITAssignmentList",
               "Get-MTRBonusPaymentList",
               "Get-MTRHITList",
               "Get-MTRHITListForQualificationType",
               "Get-MTRQualificationRequestList",
               "Get-MTRQualificationTypeList",
               "Get-MTRReviewableHITList",
               "Get-MTRReviewPolicyResultList",
               "Get-MTRWorkerBlockList",
               "Get-MTRWorkersWithQualificationType",
               "Send-MTRWorkerNotification",
               "Deny-MTRAssignment",
               "Deny-MTRQualificationRequest",
               "Send-MTRBonus",
               "Send-MTRTestEventNotification",
               "Update-MTRExpirationForHIT",
               "Update-MTRHITReviewStatus",
               "Update-MTRHITTypeOfHIT",
               "Update-MTRNotificationSetting",
               "Update-MTRQualificationType")
}

_awsArgumentCompleterRegistration $MTR_SelectCompleters $MTR_SelectMap
# Argument completions for service AmazonMWAA


$MWAA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MWAA.LoggingLevel
        {
            ($_ -eq "New-MWAAEnvironment/LoggingConfiguration_DagProcessingLogs_LogLevel") -Or
            ($_ -eq "Update-MWAAEnvironment/LoggingConfiguration_DagProcessingLogs_LogLevel") -Or
            ($_ -eq "New-MWAAEnvironment/LoggingConfiguration_SchedulerLogs_LogLevel") -Or
            ($_ -eq "Update-MWAAEnvironment/LoggingConfiguration_SchedulerLogs_LogLevel") -Or
            ($_ -eq "New-MWAAEnvironment/LoggingConfiguration_TaskLogs_LogLevel") -Or
            ($_ -eq "Update-MWAAEnvironment/LoggingConfiguration_TaskLogs_LogLevel") -Or
            ($_ -eq "New-MWAAEnvironment/LoggingConfiguration_WebserverLogs_LogLevel") -Or
            ($_ -eq "Update-MWAAEnvironment/LoggingConfiguration_WebserverLogs_LogLevel") -Or
            ($_ -eq "New-MWAAEnvironment/LoggingConfiguration_WorkerLogs_LogLevel") -Or
            ($_ -eq "Update-MWAAEnvironment/LoggingConfiguration_WorkerLogs_LogLevel")
        }
        {
            $v = "CRITICAL","DEBUG","ERROR","INFO","WARNING"
            break
        }

        # Amazon.MWAA.WebserverAccessMode
        {
            ($_ -eq "New-MWAAEnvironment/WebserverAccessMode") -Or
            ($_ -eq "Update-MWAAEnvironment/WebserverAccessMode")
        }
        {
            $v = "PRIVATE_ONLY","PUBLIC_ONLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MWAA_map = @{
    "LoggingConfiguration_DagProcessingLogs_LogLevel"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
    "LoggingConfiguration_SchedulerLogs_LogLevel"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
    "LoggingConfiguration_TaskLogs_LogLevel"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
    "LoggingConfiguration_WebserverLogs_LogLevel"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
    "LoggingConfiguration_WorkerLogs_LogLevel"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
    "WebserverAccessMode"=@("New-MWAAEnvironment","Update-MWAAEnvironment")
}

_awsArgumentCompleterRegistration $MWAA_Completers $MWAA_map

$MWAA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MWAA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MWAA_SelectMap = @{
    "Select"=@("New-MWAACliToken",
               "New-MWAAEnvironment",
               "New-MWAAWebLoginToken",
               "Remove-MWAAEnvironment",
               "Get-MWAAEnvironment",
               "Get-MWAAEnvironmentList",
               "Get-MWAAResourceTag",
               "Publish-MWAAMetric",
               "Add-MWAAResourceTag",
               "Remove-MWAAResourceTag",
               "Update-MWAAEnvironment")
}

_awsArgumentCompleterRegistration $MWAA_SelectCompleters $MWAA_SelectMap
# Argument completions for service Amazon Neptune


$NPT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Neptune.SourceType
        "Get-NPTEvent/SourceType"
        {
            $v = "db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NPT_map = @{
    "SourceType"=@("Get-NPTEvent")
}

_awsArgumentCompleterRegistration $NPT_Completers $NPT_map

$NPT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NPT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NPT_SelectMap = @{
    "Select"=@("Add-NPTRoleToDBCluster",
               "Add-NPTSourceIdentifierToSubscription",
               "Add-NPTResourceTag",
               "Submit-NPTPendingMaintenanceAction",
               "Copy-NPTDBClusterParameterGroup",
               "Copy-NPTDBClusterSnapshot",
               "Copy-NPTDBParameterGroup",
               "New-NPTDBCluster",
               "New-NPTDBClusterEndpoint",
               "New-NPTDBClusterParameterGroup",
               "New-NPTDBClusterSnapshot",
               "New-NPTDBInstance",
               "New-NPTDBParameterGroup",
               "New-NPTDBSubnetGroup",
               "New-NPTEventSubscription",
               "New-NPTGlobalCluster",
               "Remove-NPTDBCluster",
               "Remove-NPTDBClusterEndpoint",
               "Remove-NPTDBClusterParameterGroup",
               "Remove-NPTDBClusterSnapshot",
               "Remove-NPTDBInstance",
               "Remove-NPTDBParameterGroup",
               "Remove-NPTDBSubnetGroup",
               "Remove-NPTEventSubscription",
               "Remove-NPTGlobalCluster",
               "Get-NPTDBClusterEndpoint",
               "Get-NPTDBClusterParameterGroup",
               "Get-NPTDBClusterParameter",
               "Get-NPTDBCluster",
               "Get-NPTDBClusterSnapshotAttribute",
               "Get-NPTDBClusterSnapshot",
               "Get-NPTDBEngineVersion",
               "Get-NPTDBInstance",
               "Get-NPTDBParameterGroup",
               "Get-NPTDBParameter",
               "Get-NPTDBSubnetGroup",
               "Get-NPTEngineDefaultClusterParameter",
               "Get-NPTEngineDefaultParameter",
               "Get-NPTEventCategory",
               "Get-NPTEvent",
               "Get-NPTEventSubscription",
               "Get-NPTGlobalCluster",
               "Get-NPTOrderableDBInstanceOption",
               "Get-NPTPendingMaintenanceAction",
               "Get-NPTValidDBInstanceModification",
               "Start-NPTDBClusterFailover",
               "Edit-NPTGlobalClusterPrimary",
               "Get-NPTResourceTagList",
               "Edit-NPTDBCluster",
               "Edit-NPTDBClusterEndpoint",
               "Edit-NPTDBClusterParameterGroup",
               "Edit-NPTDBClusterSnapshotAttribute",
               "Edit-NPTDBInstance",
               "Edit-NPTDBParameterGroup",
               "Edit-NPTDBSubnetGroup",
               "Edit-NPTEventSubscription",
               "Edit-NPTGlobalCluster",
               "Convert-NPTReadReplicaDBCluster",
               "Restart-NPTDBInstance",
               "Remove-NPTFromGlobalCluster",
               "Remove-NPTRoleFromDBCluster",
               "Remove-NPTSourceIdentifierFromSubscription",
               "Remove-NPTResourceTag",
               "Reset-NPTDBClusterParameterGroup",
               "Reset-NPTDBParameterGroup",
               "Restore-NPTDBClusterFromSnapshot",
               "Restore-NPTDBClusterToPointInTime",
               "Start-NPTDBCluster",
               "Stop-NPTDBCluster")
}

_awsArgumentCompleterRegistration $NPT_SelectCompleters $NPT_SelectMap
# Argument completions for service AWS Network Firewall


$NWFW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.NetworkFirewall.EncryptionType
        {
            ($_ -eq "New-NWFWFirewall/EncryptionConfiguration_Type") -Or
            ($_ -eq "New-NWFWFirewallPolicy/EncryptionConfiguration_Type") -Or
            ($_ -eq "New-NWFWRuleGroup/EncryptionConfiguration_Type") -Or
            ($_ -eq "Update-NWFWFirewallEncryptionConfiguration/EncryptionConfiguration_Type") -Or
            ($_ -eq "Update-NWFWFirewallPolicy/EncryptionConfiguration_Type") -Or
            ($_ -eq "Update-NWFWRuleGroup/EncryptionConfiguration_Type")
        }
        {
            $v = "AWS_OWNED_KMS_KEY","CUSTOMER_KMS"
            break
        }

        # Amazon.NetworkFirewall.GeneratedRulesType
        {
            ($_ -eq "New-NWFWRuleGroup/RuleGroup_RulesSource_RulesSourceList_GeneratedRulesType") -Or
            ($_ -eq "Update-NWFWRuleGroup/RuleGroup_RulesSource_RulesSourceList_GeneratedRulesType")
        }
        {
            $v = "ALLOWLIST","DENYLIST"
            break
        }

        # Amazon.NetworkFirewall.ResourceManagedStatus
        "Get-NWFWRuleGroupList/Scope"
        {
            $v = "ACCOUNT","MANAGED"
            break
        }

        # Amazon.NetworkFirewall.ResourceManagedType
        "Get-NWFWRuleGroupList/ManagedType"
        {
            $v = "AWS_MANAGED_DOMAIN_LISTS","AWS_MANAGED_THREAT_SIGNATURES"
            break
        }

        # Amazon.NetworkFirewall.RuleGroupType
        {
            ($_ -eq "Get-NWFWRuleGroup/Type") -Or
            ($_ -eq "Get-NWFWRuleGroupList/Type") -Or
            ($_ -eq "Get-NWFWRuleGroupMetadata/Type") -Or
            ($_ -eq "New-NWFWRuleGroup/Type") -Or
            ($_ -eq "Remove-NWFWRuleGroup/Type") -Or
            ($_ -eq "Update-NWFWRuleGroup/Type")
        }
        {
            $v = "STATEFUL","STATELESS"
            break
        }

        # Amazon.NetworkFirewall.RuleOrder
        {
            ($_ -eq "New-NWFWFirewallPolicy/FirewallPolicy_StatefulEngineOptions_RuleOrder") -Or
            ($_ -eq "Update-NWFWFirewallPolicy/FirewallPolicy_StatefulEngineOptions_RuleOrder") -Or
            ($_ -eq "New-NWFWRuleGroup/RuleGroup_StatefulRuleOptions_RuleOrder") -Or
            ($_ -eq "Update-NWFWRuleGroup/RuleGroup_StatefulRuleOptions_RuleOrder")
        }
        {
            $v = "DEFAULT_ACTION_ORDER","STRICT_ORDER"
            break
        }

        # Amazon.NetworkFirewall.StreamExceptionPolicy
        {
            ($_ -eq "New-NWFWFirewallPolicy/FirewallPolicy_StatefulEngineOptions_StreamExceptionPolicy") -Or
            ($_ -eq "Update-NWFWFirewallPolicy/FirewallPolicy_StatefulEngineOptions_StreamExceptionPolicy")
        }
        {
            $v = "CONTINUE","DROP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NWFW_map = @{
    "EncryptionConfiguration_Type"=@("New-NWFWFirewall","New-NWFWFirewallPolicy","New-NWFWRuleGroup","Update-NWFWFirewallEncryptionConfiguration","Update-NWFWFirewallPolicy","Update-NWFWRuleGroup")
    "FirewallPolicy_StatefulEngineOptions_RuleOrder"=@("New-NWFWFirewallPolicy","Update-NWFWFirewallPolicy")
    "FirewallPolicy_StatefulEngineOptions_StreamExceptionPolicy"=@("New-NWFWFirewallPolicy","Update-NWFWFirewallPolicy")
    "ManagedType"=@("Get-NWFWRuleGroupList")
    "RuleGroup_RulesSource_RulesSourceList_GeneratedRulesType"=@("New-NWFWRuleGroup","Update-NWFWRuleGroup")
    "RuleGroup_StatefulRuleOptions_RuleOrder"=@("New-NWFWRuleGroup","Update-NWFWRuleGroup")
    "Scope"=@("Get-NWFWRuleGroupList")
    "Type"=@("Get-NWFWRuleGroup","Get-NWFWRuleGroupList","Get-NWFWRuleGroupMetadata","New-NWFWRuleGroup","Remove-NWFWRuleGroup","Update-NWFWRuleGroup")
}

_awsArgumentCompleterRegistration $NWFW_Completers $NWFW_map

$NWFW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NWFW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NWFW_SelectMap = @{
    "Select"=@("Register-NWFWFirewallPolicy",
               "Register-NWFWSubnet",
               "New-NWFWFirewall",
               "New-NWFWFirewallPolicy",
               "New-NWFWRuleGroup",
               "Remove-NWFWFirewall",
               "Remove-NWFWFirewallPolicy",
               "Remove-NWFWResourcePolicy",
               "Remove-NWFWRuleGroup",
               "Get-NWFWFirewall",
               "Get-NWFWFirewallPolicy",
               "Get-NWFWLoggingConfiguration",
               "Get-NWFWResourcePolicy",
               "Get-NWFWRuleGroup",
               "Get-NWFWRuleGroupMetadata",
               "Unregister-NWFWSubnet",
               "Get-NWFWFirewallPolicyList",
               "Get-NWFWFirewallList",
               "Get-NWFWRuleGroupList",
               "Get-NWFWResourceTag",
               "Write-NWFWResourcePolicy",
               "Add-NWFWResourceTag",
               "Remove-NWFWResourceTag",
               "Update-NWFWFirewallDeleteProtection",
               "Update-NWFWFirewallDescription",
               "Update-NWFWFirewallEncryptionConfiguration",
               "Update-NWFWFirewallPolicy",
               "Update-NWFWFirewallPolicyChangeProtection",
               "Update-NWFWLoggingConfiguration",
               "Update-NWFWRuleGroup",
               "Update-NWFWSubnetChangeProtection")
}

_awsArgumentCompleterRegistration $NWFW_SelectCompleters $NWFW_SelectMap
# Argument completions for service AWS Network Manager


$NMGR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.NetworkManager.AttachmentState
        "Get-NMGRAttachmentList/State"
        {
            $v = "AVAILABLE","CREATING","DELETING","FAILED","PENDING_ATTACHMENT_ACCEPTANCE","PENDING_NETWORK_UPDATE","PENDING_TAG_ACCEPTANCE","REJECTED","UPDATING"
            break
        }

        # Amazon.NetworkManager.AttachmentType
        "Get-NMGRAttachmentList/AttachmentType"
        {
            $v = "CONNECT","SITE_TO_SITE_VPN","TRANSIT_GATEWAY_ROUTE_TABLE","VPC"
            break
        }

        # Amazon.NetworkManager.CoreNetworkPolicyAlias
        "Get-NMGRCoreNetworkPolicy/Alias"
        {
            $v = "LATEST","LIVE"
            break
        }

        # Amazon.NetworkManager.PeeringState
        "Get-NMGRPeeringList/State"
        {
            $v = "AVAILABLE","CREATING","DELETING","FAILED"
            break
        }

        # Amazon.NetworkManager.PeeringType
        "Get-NMGRPeeringList/PeeringType"
        {
            $v = "TRANSIT_GATEWAY"
            break
        }

        # Amazon.NetworkManager.TunnelProtocol
        "New-NMGRConnectAttachment/Options_Protocol"
        {
            $v = "GRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NMGR_map = @{
    "Alias"=@("Get-NMGRCoreNetworkPolicy")
    "AttachmentType"=@("Get-NMGRAttachmentList")
    "Options_Protocol"=@("New-NMGRConnectAttachment")
    "PeeringType"=@("Get-NMGRPeeringList")
    "State"=@("Get-NMGRAttachmentList","Get-NMGRPeeringList")
}

_awsArgumentCompleterRegistration $NMGR_Completers $NMGR_map

$NMGR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NMGR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NMGR_SelectMap = @{
    "Select"=@("Confirm-NMGRAttachment",
               "Add-NMGRConnectPeerAssociation",
               "Register-NMGRCustomerGateway",
               "Register-NMGRLink",
               "Register-NMGRTransitGatewayConnectPeer",
               "New-NMGRConnectAttachment",
               "New-NMGRConnection",
               "New-NMGRConnectPeer",
               "New-NMGRCoreNetwork",
               "New-NMGRDevice",
               "New-NMGRGlobalNetwork",
               "New-NMGRLink",
               "New-NMGRSite",
               "New-NMGRSiteToSiteVpnAttachment",
               "New-NMGRTransitGatewayPeering",
               "New-NMGRTransitGatewayRouteTableAttachment",
               "New-NMGRVpcAttachment",
               "Remove-NMGRAttachment",
               "Remove-NMGRConnection",
               "Remove-NMGRConnectPeer",
               "Remove-NMGRCoreNetwork",
               "Remove-NMGRCoreNetworkPolicyVersion",
               "Remove-NMGRDevice",
               "Remove-NMGRGlobalNetwork",
               "Remove-NMGRLink",
               "Remove-NMGRPeering",
               "Remove-NMGRResourcePolicy",
               "Remove-NMGRSite",
               "Unregister-NMGRTransitGateway",
               "Get-NMGRGlobalNetwork",
               "Remove-NMGRConnectPeerAssociation",
               "Unregister-NMGRCustomerGateway",
               "Unregister-NMGRLink",
               "Unregister-NMGRTransitGatewayConnectPeer",
               "Enable-NMGRCoreNetworkChangeSet",
               "Get-NMGRConnectAttachment",
               "Get-NMGRConnection",
               "Get-NMGRConnectPeer",
               "Get-NMGRConnectPeerAssociation",
               "Get-NMGRCoreNetwork",
               "Get-NMGRCoreNetworkChangeEvent",
               "Get-NMGRCoreNetworkChangeSet",
               "Get-NMGRCoreNetworkPolicy",
               "Get-NMGRCustomerGatewayAssociation",
               "Get-NMGRDevice",
               "Get-NMGRLinkAssociation",
               "Get-NMGRLink",
               "Get-NMGRNetworkResourceCount",
               "Get-NMGRNetworkResourceRelationship",
               "Get-NMGRNetworkResource",
               "Get-NMGRNetworkRoute",
               "Get-NMGRNetworkTelemetry",
               "Get-NMGRResourcePolicy",
               "Get-NMGRRouteAnalysis",
               "Get-NMGRSite",
               "Get-NMGRSiteToSiteVpnAttachment",
               "Get-NMGRTransitGatewayConnectPeerAssociation",
               "Get-NMGRTransitGatewayPeering",
               "Get-NMGRTransitGatewayRegistration",
               "Get-NMGRTransitGatewayRouteTableAttachment",
               "Get-NMGRVpcAttachment",
               "Get-NMGRAttachmentList",
               "Get-NMGRConnectPeerList",
               "Get-NMGRCoreNetworkPolicyVersionList",
               "Get-NMGRCoreNetworkList",
               "Get-NMGROrganizationServiceAccessStatusList",
               "Get-NMGRPeeringList",
               "Get-NMGRResourceTag",
               "Write-NMGRCoreNetworkPolicy",
               "Write-NMGRResourcePolicy",
               "Register-NMGRTransitGateway",
               "Deny-NMGRAttachment",
               "Restore-NMGRCoreNetworkPolicyVersion",
               "Start-NMGROrganizationServiceAccessUpdate",
               "Start-NMGRRouteAnalysis",
               "Add-NMGRResourceTag",
               "Remove-NMGRResourceTag",
               "Update-NMGRConnection",
               "Update-NMGRCoreNetwork",
               "Update-NMGRDevice",
               "Update-NMGRGlobalNetwork",
               "Update-NMGRLink",
               "Update-NMGRNetworkResourceMetadata",
               "Update-NMGRSite",
               "Update-NMGRVpcAttachment")
}

_awsArgumentCompleterRegistration $NMGR_SelectCompleters $NMGR_SelectMap
# Argument completions for service Amazon Nimble Studio


$NS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.NimbleStudio.LaunchProfilePersona
        "Update-NSLaunchProfileMember/Persona"
        {
            $v = "USER"
            break
        }

        # Amazon.NimbleStudio.StreamingClipboardMode
        {
            ($_ -eq "New-NSLaunchProfile/StreamConfiguration_ClipboardMode") -Or
            ($_ -eq "Update-NSLaunchProfile/StreamConfiguration_ClipboardMode")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.NimbleStudio.StreamingInstanceType
        "New-NSStreamingSession/Ec2InstanceType"
        {
            $v = "g3.4xlarge","g3s.xlarge","g4dn.12xlarge","g4dn.16xlarge","g4dn.2xlarge","g4dn.4xlarge","g4dn.8xlarge","g4dn.xlarge","g5.16xlarge","g5.2xlarge","g5.4xlarge","g5.8xlarge","g5.xlarge"
            break
        }

        # Amazon.NimbleStudio.StudioComponentSubtype
        {
            ($_ -eq "New-NSStudioComponent/Subtype") -Or
            ($_ -eq "Update-NSStudioComponent/Subtype")
        }
        {
            $v = "AMAZON_FSX_FOR_LUSTRE","AMAZON_FSX_FOR_WINDOWS","AWS_MANAGED_MICROSOFT_AD","CUSTOM"
            break
        }

        # Amazon.NimbleStudio.StudioComponentType
        {
            ($_ -eq "New-NSStudioComponent/Type") -Or
            ($_ -eq "Update-NSStudioComponent/Type")
        }
        {
            $v = "ACTIVE_DIRECTORY","COMPUTE_FARM","CUSTOM","LICENSE_SERVICE","SHARED_FILE_SYSTEM"
            break
        }

        # Amazon.NimbleStudio.StudioEncryptionConfigurationKeyType
        "New-NSStudio/StudioEncryptionConfiguration_KeyType"
        {
            $v = "AWS_OWNED_KEY","CUSTOMER_MANAGED_KEY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NS_map = @{
    "Ec2InstanceType"=@("New-NSStreamingSession")
    "Persona"=@("Update-NSLaunchProfileMember")
    "StreamConfiguration_ClipboardMode"=@("New-NSLaunchProfile","Update-NSLaunchProfile")
    "StudioEncryptionConfiguration_KeyType"=@("New-NSStudio")
    "Subtype"=@("New-NSStudioComponent","Update-NSStudioComponent")
    "Type"=@("New-NSStudioComponent","Update-NSStudioComponent")
}

_awsArgumentCompleterRegistration $NS_Completers $NS_map

$NS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NS_SelectMap = @{
    "Select"=@("Approve-NSEula",
               "New-NSLaunchProfile",
               "New-NSStreamingImage",
               "New-NSStreamingSession",
               "New-NSStreamingSessionStream",
               "New-NSStudio",
               "New-NSStudioComponent",
               "Remove-NSLaunchProfile",
               "Remove-NSLaunchProfileMember",
               "Remove-NSStreamingImage",
               "Remove-NSStreamingSession",
               "Remove-NSStudio",
               "Remove-NSStudioComponent",
               "Remove-NSStudioMember",
               "Get-NSEula",
               "Get-NSLaunchProfile",
               "Get-NSLaunchProfileDetail",
               "Get-NSLaunchProfileInitialization",
               "Get-NSLaunchProfileMember",
               "Get-NSStreamingImage",
               "Get-NSStreamingSession",
               "Get-NSStreamingSessionStream",
               "Get-NSStudio",
               "Get-NSStudioComponent",
               "Get-NSStudioMember",
               "Get-NSEulaAcceptanceList",
               "Get-NSEulaList",
               "Get-NSLaunchProfileMemberList",
               "Get-NSLaunchProfileList",
               "Get-NSStreamingImageList",
               "Get-NSStreamingSessionList",
               "Get-NSStudioComponentList",
               "Get-NSStudioMemberList",
               "Get-NSStudioList",
               "Get-NSResourceTag",
               "Write-NSLaunchProfileMember",
               "Write-NSStudioMember",
               "Start-NSStreamingSession",
               "Start-NSStudioSSOConfigurationRepair",
               "Stop-NSStreamingSession",
               "Add-NSResourceTag",
               "Remove-NSResourceTag",
               "Update-NSLaunchProfile",
               "Update-NSLaunchProfileMember",
               "Update-NSStreamingImage",
               "Update-NSStudio",
               "Update-NSStudioComponent")
}

_awsArgumentCompleterRegistration $NS_SelectCompleters $NS_SelectMap
# Argument completions for service Amazon OpenSearch Service


$OS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.OpenSearchService.AutoTuneDesiredState
        {
            ($_ -eq "New-OSDomain/AutoTuneOptions_DesiredState") -Or
            ($_ -eq "Update-OSDomainConfig/AutoTuneOptions_DesiredState")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.OpenSearchService.EngineType
        "Get-OSDomainNameList/EngineType"
        {
            $v = "Elasticsearch","OpenSearch"
            break
        }

        # Amazon.OpenSearchService.OpenSearchPartitionInstanceType
        {
            ($_ -eq "New-OSDomain/ClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "Update-OSDomainConfig/ClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "New-OSDomain/ClusterConfig_InstanceType") -Or
            ($_ -eq "Update-OSDomainConfig/ClusterConfig_InstanceType") -Or
            ($_ -eq "Get-OSInstanceTypeLimit/InstanceType")
        }
        {
            $v = "c4.2xlarge.search","c4.4xlarge.search","c4.8xlarge.search","c4.large.search","c4.xlarge.search","c5.18xlarge.search","c5.2xlarge.search","c5.4xlarge.search","c5.9xlarge.search","c5.large.search","c5.xlarge.search","c6g.12xlarge.search","c6g.2xlarge.search","c6g.4xlarge.search","c6g.8xlarge.search","c6g.large.search","c6g.xlarge.search","d2.2xlarge.search","d2.4xlarge.search","d2.8xlarge.search","d2.xlarge.search","i2.2xlarge.search","i2.xlarge.search","i3.16xlarge.search","i3.2xlarge.search","i3.4xlarge.search","i3.8xlarge.search","i3.large.search","i3.xlarge.search","m3.2xlarge.search","m3.large.search","m3.medium.search","m3.xlarge.search","m4.10xlarge.search","m4.2xlarge.search","m4.4xlarge.search","m4.large.search","m4.xlarge.search","m5.12xlarge.search","m5.24xlarge.search","m5.2xlarge.search","m5.4xlarge.search","m5.large.search","m5.xlarge.search","m6g.12xlarge.search","m6g.2xlarge.search","m6g.4xlarge.search","m6g.8xlarge.search","m6g.large.search","m6g.xlarge.search","r3.2xlarge.search","r3.4xlarge.search","r3.8xlarge.search","r3.large.search","r3.xlarge.search","r4.16xlarge.search","r4.2xlarge.search","r4.4xlarge.search","r4.8xlarge.search","r4.large.search","r4.xlarge.search","r5.12xlarge.search","r5.24xlarge.search","r5.2xlarge.search","r5.4xlarge.search","r5.large.search","r5.xlarge.search","r6g.12xlarge.search","r6g.2xlarge.search","r6g.4xlarge.search","r6g.8xlarge.search","r6g.large.search","r6g.xlarge.search","r6gd.12xlarge.search","r6gd.16xlarge.search","r6gd.2xlarge.search","r6gd.4xlarge.search","r6gd.8xlarge.search","r6gd.large.search","r6gd.xlarge.search","t2.medium.search","t2.micro.search","t2.small.search","t3.2xlarge.search","t3.large.search","t3.medium.search","t3.micro.search","t3.nano.search","t3.small.search","t3.xlarge.search","t4g.medium.search","t4g.small.search","ultrawarm1.large.search","ultrawarm1.medium.search","ultrawarm1.xlarge.search"
            break
        }

        # Amazon.OpenSearchService.OpenSearchWarmPartitionInstanceType
        {
            ($_ -eq "New-OSDomain/ClusterConfig_WarmType") -Or
            ($_ -eq "Update-OSDomainConfig/ClusterConfig_WarmType")
        }
        {
            $v = "ultrawarm1.large.search","ultrawarm1.medium.search","ultrawarm1.xlarge.search"
            break
        }

        # Amazon.OpenSearchService.PackageType
        "New-OSPackage/PackageType"
        {
            $v = "TXT-DICTIONARY"
            break
        }

        # Amazon.OpenSearchService.RollbackOnDisable
        "Update-OSDomainConfig/AutoTuneOptions_RollbackOnDisable"
        {
            $v = "DEFAULT_ROLLBACK","NO_ROLLBACK"
            break
        }

        # Amazon.OpenSearchService.TLSSecurityPolicy
        {
            ($_ -eq "New-OSDomain/DomainEndpointOptions_TLSSecurityPolicy") -Or
            ($_ -eq "Update-OSDomainConfig/DomainEndpointOptions_TLSSecurityPolicy")
        }
        {
            $v = "Policy-Min-TLS-1-0-2019-07","Policy-Min-TLS-1-2-2019-07"
            break
        }

        # Amazon.OpenSearchService.VolumeType
        {
            ($_ -eq "New-OSDomain/EBSOptions_VolumeType") -Or
            ($_ -eq "Update-OSDomainConfig/EBSOptions_VolumeType")
        }
        {
            $v = "gp2","gp3","io1","standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OS_map = @{
    "AutoTuneOptions_DesiredState"=@("New-OSDomain","Update-OSDomainConfig")
    "AutoTuneOptions_RollbackOnDisable"=@("Update-OSDomainConfig")
    "ClusterConfig_DedicatedMasterType"=@("New-OSDomain","Update-OSDomainConfig")
    "ClusterConfig_InstanceType"=@("New-OSDomain","Update-OSDomainConfig")
    "ClusterConfig_WarmType"=@("New-OSDomain","Update-OSDomainConfig")
    "DomainEndpointOptions_TLSSecurityPolicy"=@("New-OSDomain","Update-OSDomainConfig")
    "EBSOptions_VolumeType"=@("New-OSDomain","Update-OSDomainConfig")
    "EngineType"=@("Get-OSDomainNameList")
    "InstanceType"=@("Get-OSInstanceTypeLimit")
    "PackageType"=@("New-OSPackage")
}

_awsArgumentCompleterRegistration $OS_Completers $OS_map

$OS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OS_SelectMap = @{
    "Select"=@("Approve-OSInboundConnection",
               "Add-OSResourceTag",
               "Start-OSAssociatePackage",
               "Approve-OSVpcEndpointAccess",
               "Stop-OSServiceSoftwareUpdate",
               "New-OSDomain",
               "New-OSOutboundConnection",
               "New-OSPackage",
               "New-OSVpcEndpoint",
               "Remove-OSDomain",
               "Remove-OSInboundConnection",
               "Remove-OSOutboundConnection",
               "Remove-OSPackage",
               "Remove-OSVpcEndpoint",
               "Get-OSDomain",
               "Get-OSDomainAutoTune",
               "Get-OSDomainChangeProgress",
               "Get-OSDomainConfig",
               "Get-OSDomainList",
               "Get-OSInboundConnection",
               "Get-OSInstanceTypeLimit",
               "Get-OSOutboundConnection",
               "Get-OSPackage",
               "Get-OSReservedInstanceOfferingList",
               "Get-OSReservedInstanceList",
               "Get-OSVpcEndpoint",
               "Start-OSDissociatePackage",
               "Get-OSCompatibleVersion",
               "Get-OSPackageVersionHistory",
               "Get-OSUpgradeHistory",
               "Get-OSUpgradeStatus",
               "Get-OSDomainNameList",
               "Get-OSDomainsForPackageList",
               "Get-OSInstanceTypeDetailList",
               "Get-OSPackagesForDomainList",
               "Get-OSResourceTag",
               "Get-OSVersionList",
               "Get-OSVpcEndpointAccessList",
               "Get-OSVpcEndpointList",
               "Get-OSVpcEndpointsForDomainList",
               "New-OSReservedInstanceOffering",
               "Deny-OSInboundConnection",
               "Remove-OSResourceTag",
               "Revoke-OSVpcEndpointAccess",
               "Start-OSServiceSoftwareUpdate",
               "Update-OSDomainConfig",
               "Update-OSPackage",
               "Update-OSVpcEndpoint",
               "Update-OSDomain")
}

_awsArgumentCompleterRegistration $OS_SelectCompleters $OS_SelectMap
# Argument completions for service AWS OpsWorks


$OPS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.OpsWorks.AppType
        {
            ($_ -eq "New-OPSApp/Type") -Or
            ($_ -eq "Update-OPSApp/Type")
        }
        {
            $v = "aws-flow-ruby","java","nodejs","other","php","rails","static"
            break
        }

        # Amazon.OpsWorks.Architecture
        {
            ($_ -eq "New-OPSInstance/Architecture") -Or
            ($_ -eq "Update-OPSInstance/Architecture")
        }
        {
            $v = "i386","x86_64"
            break
        }

        # Amazon.OpsWorks.AutoScalingType
        {
            ($_ -eq "New-OPSInstance/AutoScalingType") -Or
            ($_ -eq "Update-OPSInstance/AutoScalingType")
        }
        {
            $v = "load","timer"
            break
        }

        # Amazon.OpsWorks.DeploymentCommandName
        "New-OPSDeployment/Command_Name"
        {
            $v = "configure","deploy","execute_recipes","install_dependencies","restart","rollback","setup","start","stop","undeploy","update_custom_cookbooks","update_dependencies"
            break
        }

        # Amazon.OpsWorks.LayerType
        "New-OPSLayer/Type"
        {
            $v = "aws-flow-ruby","custom","db-master","ecs-cluster","java-app","lb","memcached","monitoring-master","nodejs-app","php-app","rails-app","web"
            break
        }

        # Amazon.OpsWorks.RootDeviceType
        {
            ($_ -eq "Copy-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "New-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "Update-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "New-OPSInstance/RootDeviceType")
        }
        {
            $v = "ebs","instance-store"
            break
        }

        # Amazon.OpsWorks.SourceType
        {
            ($_ -eq "New-OPSApp/AppSource_Type") -Or
            ($_ -eq "Update-OPSApp/AppSource_Type") -Or
            ($_ -eq "Copy-OPSStack/CustomCookbooksSource_Type") -Or
            ($_ -eq "New-OPSStack/CustomCookbooksSource_Type") -Or
            ($_ -eq "Update-OPSStack/CustomCookbooksSource_Type")
        }
        {
            $v = "archive","git","s3","svn"
            break
        }

        # Amazon.OpsWorks.VirtualizationType
        "New-OPSInstance/VirtualizationType"
        {
            $v = "hvm","paravirtual"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OPS_map = @{
    "AppSource_Type"=@("New-OPSApp","Update-OPSApp")
    "Architecture"=@("New-OPSInstance","Update-OPSInstance")
    "AutoScalingType"=@("New-OPSInstance","Update-OPSInstance")
    "Command_Name"=@("New-OPSDeployment")
    "CustomCookbooksSource_Type"=@("Copy-OPSStack","New-OPSStack","Update-OPSStack")
    "DefaultRootDeviceType"=@("Copy-OPSStack","New-OPSStack","Update-OPSStack")
    "RootDeviceType"=@("New-OPSInstance")
    "Type"=@("New-OPSApp","New-OPSLayer","Update-OPSApp")
    "VirtualizationType"=@("New-OPSInstance")
}

_awsArgumentCompleterRegistration $OPS_Completers $OPS_map

$OPS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OPS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OPS_SelectMap = @{
    "Select"=@("Register-OPSInstanceAssignment",
               "Add-OPSVolume",
               "Add-OPSElasticIp",
               "Add-OPSElasticLoadBalancer",
               "Copy-OPSStack",
               "New-OPSApp",
               "New-OPSDeployment",
               "New-OPSInstance",
               "New-OPSLayer",
               "New-OPSStack",
               "New-OPSUserProfile",
               "Remove-OPSApp",
               "Remove-OPSInstance",
               "Remove-OPSLayer",
               "Remove-OPSStack",
               "Remove-OPSUserProfile",
               "Unregister-OPSEcsCluster",
               "Unregister-OPSElasticIp",
               "Unregister-OPSInstance",
               "Unregister-OPSRdsDbInstance",
               "Unregister-OPSVolume",
               "Get-OPSAgentVersion",
               "Get-OPSApp",
               "Get-OPSCommand",
               "Get-OPSDeployment",
               "Get-OPSEcsCluster",
               "Get-OPSElasticIp",
               "Get-OPSElasticLoadBalancer",
               "Get-OPSInstance",
               "Get-OPSLayer",
               "Get-OPSLoadBasedAutoScaling",
               "Get-OPSMyUserProfile",
               "Get-OPSOperatingSystem",
               "Get-OPSPermission",
               "Get-OPSRaidArray",
               "Get-OPSRdsDbInstance",
               "Get-OPSServiceError",
               "Get-OPSStackProvisioningParameter",
               "Get-OPSStack",
               "Get-OPSStackSummary",
               "Get-OPSTimeBasedAutoScaling",
               "Get-OPSUserProfile",
               "Get-OPSVolume",
               "Dismount-OPSElasticLoadBalancer",
               "Remove-OPSElasticIp",
               "Get-OPSHostnameSuggestion",
               "Grant-OPSAccess",
               "Get-OPSResourceTag",
               "Restart-OPSInstance",
               "Register-OPSEcsCluster",
               "Register-OPSElasticIp",
               "Register-OPSInstance",
               "Register-OPSRdsDbInstance",
               "Register-OPSVolume",
               "Set-OPSLoadBasedAutoScaling",
               "Set-OPSPermission",
               "Set-OPSTimeBasedAutoScaling",
               "Start-OPSInstance",
               "Start-OPSStack",
               "Stop-OPSInstance",
               "Stop-OPSStack",
               "Add-OPSResourceTag",
               "Unregister-OPSInstanceAssignment",
               "Remove-OPSVolume",
               "Remove-OPSResourceTag",
               "Update-OPSApp",
               "Update-OPSElasticIp",
               "Update-OPSInstance",
               "Update-OPSLayer",
               "Update-OPSMyUserProfile",
               "Update-OPSRdsDbInstance",
               "Update-OPSStack",
               "Update-OPSUserProfile",
               "Update-OPSVolume")
}

_awsArgumentCompleterRegistration $OPS_SelectCompleters $OPS_SelectMap
# Argument completions for service AWS OpsWorksCM


$OWCM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OWCM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OWCM_SelectMap = @{
    "Select"=@("Add-OWCMNode",
               "New-OWCMBackup",
               "New-OWCMServer",
               "Remove-OWCMBackup",
               "Remove-OWCMServer",
               "Get-OWCMAccountAttribute",
               "Get-OWCMBackupList",
               "Get-OWCMEventList",
               "Get-OWCMNodeAssociationStatus",
               "Get-OWCMServerList",
               "Remove-OWCMNode",
               "Export-OWCMServerEngineAttribute",
               "Get-OWCMResourceTag",
               "Restore-OWCMServer",
               "Start-OWCMMaintenance",
               "Add-OWCMResourceTag",
               "Remove-OWCMResourceTag",
               "Update-OWCMServer",
               "Update-OWCMServerEngineAttribute")
}

_awsArgumentCompleterRegistration $OWCM_SelectCompleters $OWCM_SelectMap
# Argument completions for service AWS Organizations


$ORG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Organizations.ActionType
        {
            ($_ -eq "Get-ORGAccountHandshakeList/Filter_ActionType") -Or
            ($_ -eq "Get-ORGOrganizationHandshakeList/Filter_ActionType")
        }
        {
            $v = "ADD_ORGANIZATIONS_SERVICE_LINKED_ROLE","APPROVE_ALL_FEATURES","ENABLE_ALL_FEATURES","INVITE"
            break
        }

        # Amazon.Organizations.ChildType
        "Get-ORGChild/ChildType"
        {
            $v = "ACCOUNT","ORGANIZATIONAL_UNIT"
            break
        }

        # Amazon.Organizations.EffectivePolicyType
        "Get-ORGEffectivePolicy/PolicyType"
        {
            $v = "AISERVICES_OPT_OUT_POLICY","BACKUP_POLICY","TAG_POLICY"
            break
        }

        # Amazon.Organizations.HandshakePartyType
        "New-ORGAccountInvitation/Target_Type"
        {
            $v = "ACCOUNT","EMAIL","ORGANIZATION"
            break
        }

        # Amazon.Organizations.IAMUserAccessToBilling
        {
            ($_ -eq "New-ORGAccount/IamUserAccessToBilling") -Or
            ($_ -eq "New-ORGGovCloudAccount/IamUserAccessToBilling")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.Organizations.OrganizationFeatureSet
        "New-ORGOrganization/FeatureSet"
        {
            $v = "ALL","CONSOLIDATED_BILLING"
            break
        }

        # Amazon.Organizations.PolicyType
        {
            ($_ -eq "Get-ORGPolicyForTarget/Filter") -Or
            ($_ -eq "Get-ORGPolicyList/Filter") -Or
            ($_ -eq "Disable-ORGPolicyType/PolicyType") -Or
            ($_ -eq "Enable-ORGPolicyType/PolicyType") -Or
            ($_ -eq "New-ORGPolicy/Type")
        }
        {
            $v = "AISERVICES_OPT_OUT_POLICY","BACKUP_POLICY","SERVICE_CONTROL_POLICY","TAG_POLICY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ORG_map = @{
    "ChildType"=@("Get-ORGChild")
    "FeatureSet"=@("New-ORGOrganization")
    "Filter"=@("Get-ORGPolicyForTarget","Get-ORGPolicyList")
    "Filter_ActionType"=@("Get-ORGAccountHandshakeList","Get-ORGOrganizationHandshakeList")
    "IamUserAccessToBilling"=@("New-ORGAccount","New-ORGGovCloudAccount")
    "PolicyType"=@("Disable-ORGPolicyType","Enable-ORGPolicyType","Get-ORGEffectivePolicy")
    "Target_Type"=@("New-ORGAccountInvitation")
    "Type"=@("New-ORGPolicy")
}

_awsArgumentCompleterRegistration $ORG_Completers $ORG_map

$ORG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ORG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ORG_SelectMap = @{
    "Select"=@("Confirm-ORGHandshake",
               "Add-ORGPolicy",
               "Stop-ORGHandshake",
               "Close-ORGAccount",
               "New-ORGAccount",
               "New-ORGGovCloudAccount",
               "New-ORGOrganization",
               "New-ORGOrganizationalUnit",
               "New-ORGPolicy",
               "Deny-ORGHandshake",
               "Remove-ORGOrganization",
               "Remove-ORGOrganizationalUnit",
               "Remove-ORGPolicy",
               "Unregister-ORGDelegatedAdministrator",
               "Get-ORGAccount",
               "Get-ORGAccountCreationStatus",
               "Get-ORGEffectivePolicy",
               "Get-ORGHandshake",
               "Get-ORGOrganization",
               "Get-ORGOrganizationalUnit",
               "Get-ORGPolicy",
               "Dismount-ORGPolicy",
               "Disable-ORGAWSServiceAccess",
               "Disable-ORGPolicyType",
               "Enable-ORGAllFeature",
               "Enable-ORGAWSServiceAccess",
               "Enable-ORGPolicyType",
               "New-ORGAccountInvitation",
               "Remove-ORGOrganizationAssociation",
               "Get-ORGAccountList",
               "Get-ORGAccountForParent",
               "Get-ORGAWSServiceAccessForOrganization",
               "Get-ORGChild",
               "Get-ORGAccountCreationStatusList",
               "Get-ORGDelegatedAdministratorList",
               "Get-ORGDelegatedServicesForAccountList",
               "Get-ORGAccountHandshakeList",
               "Get-ORGOrganizationHandshakeList",
               "Get-ORGOrganizationalUnitList",
               "Get-ORGParent",
               "Get-ORGPolicyList",
               "Get-ORGPolicyForTarget",
               "Get-ORGRoot",
               "Get-ORGResourceTag",
               "Get-ORGTargetForPolicy",
               "Move-ORGAccount",
               "Register-ORGDelegatedAdministrator",
               "Remove-ORGAccountFromOrganization",
               "Add-ORGResourceTag",
               "Remove-ORGResourceTag",
               "Update-ORGOrganizationalUnit",
               "Update-ORGPolicy")
}

_awsArgumentCompleterRegistration $ORG_SelectCompleters $ORG_SelectMap
# Argument completions for service AWS Outposts


$OUTP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Outposts.AddressType
        {
            ($_ -eq "Get-OUTPSiteAddress/AddressType") -Or
            ($_ -eq "Update-OUTPSiteAddress/AddressType")
        }
        {
            $v = "OPERATING_ADDRESS","SHIPPING_ADDRESS"
            break
        }

        # Amazon.Outposts.FiberOpticCableType
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/FiberOpticCableType") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_FiberOpticCableType")
        }
        {
            $v = "MULTI_MODE","SINGLE_MODE"
            break
        }

        # Amazon.Outposts.MaximumSupportedWeightLbs
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/MaximumSupportedWeightLbs") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_MaximumSupportedWeightLbs")
        }
        {
            $v = "MAX_1400_LBS","MAX_1600_LBS","MAX_1800_LBS","MAX_2000_LBS","NO_LIMIT"
            break
        }

        # Amazon.Outposts.OpticalStandard
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/OpticalStandard") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_OpticalStandard")
        }
        {
            $v = "OPTIC_1000BASE_LX","OPTIC_1000BASE_SX","OPTIC_100GBASE_CWDM4","OPTIC_100GBASE_LR4","OPTIC_100GBASE_SR4","OPTIC_100G_PSM4_MSA","OPTIC_10GBASE_IR","OPTIC_10GBASE_LR","OPTIC_10GBASE_SR","OPTIC_40GBASE_ESR","OPTIC_40GBASE_IR4_LR4L","OPTIC_40GBASE_LR4","OPTIC_40GBASE_SR"
            break
        }

        # Amazon.Outposts.PaymentOption
        "New-OUTPOrder/PaymentOption"
        {
            $v = "ALL_UPFRONT","NO_UPFRONT","PARTIAL_UPFRONT"
            break
        }

        # Amazon.Outposts.PaymentTerm
        "New-OUTPOrder/PaymentTerm"
        {
            $v = "ONE_YEAR","THREE_YEARS"
            break
        }

        # Amazon.Outposts.PowerConnector
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/PowerConnector") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_PowerConnector")
        }
        {
            $v = "AH530P7W","AH532P6W","IEC309","L6_30P"
            break
        }

        # Amazon.Outposts.PowerDrawKva
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/PowerDrawKva") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_PowerDrawKva")
        }
        {
            $v = "POWER_10_KVA","POWER_15_KVA","POWER_5_KVA"
            break
        }

        # Amazon.Outposts.PowerFeedDrop
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/PowerFeedDrop") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_PowerFeedDrop")
        }
        {
            $v = "ABOVE_RACK","BELOW_RACK"
            break
        }

        # Amazon.Outposts.PowerPhase
        {
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/PowerPhase") -Or
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_PowerPhase")
        }
        {
            $v = "SINGLE_PHASE","THREE_PHASE"
            break
        }

        # Amazon.Outposts.SupportedHardwareType
        {
            ($_ -eq "New-OUTPOutpost/SupportedHardwareType") -Or
            ($_ -eq "Update-OUTPOutpost/SupportedHardwareType")
        }
        {
            $v = "RACK","SERVER"
            break
        }

        # Amazon.Outposts.UplinkCount
        {
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_UplinkCount") -Or
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/UplinkCount")
        }
        {
            $v = "UPLINK_COUNT_1","UPLINK_COUNT_12","UPLINK_COUNT_16","UPLINK_COUNT_2","UPLINK_COUNT_3","UPLINK_COUNT_4","UPLINK_COUNT_5","UPLINK_COUNT_6","UPLINK_COUNT_7","UPLINK_COUNT_8"
            break
        }

        # Amazon.Outposts.UplinkGbps
        {
            ($_ -eq "New-OUTPSite/RackPhysicalProperties_UplinkGbps") -Or
            ($_ -eq "Update-OUTPSiteRackPhysicalProperty/UplinkGbps")
        }
        {
            $v = "UPLINK_100G","UPLINK_10G","UPLINK_1G","UPLINK_40G"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OUTP_map = @{
    "AddressType"=@("Get-OUTPSiteAddress","Update-OUTPSiteAddress")
    "FiberOpticCableType"=@("Update-OUTPSiteRackPhysicalProperty")
    "MaximumSupportedWeightLbs"=@("Update-OUTPSiteRackPhysicalProperty")
    "OpticalStandard"=@("Update-OUTPSiteRackPhysicalProperty")
    "PaymentOption"=@("New-OUTPOrder")
    "PaymentTerm"=@("New-OUTPOrder")
    "PowerConnector"=@("Update-OUTPSiteRackPhysicalProperty")
    "PowerDrawKva"=@("Update-OUTPSiteRackPhysicalProperty")
    "PowerFeedDrop"=@("Update-OUTPSiteRackPhysicalProperty")
    "PowerPhase"=@("Update-OUTPSiteRackPhysicalProperty")
    "RackPhysicalProperties_FiberOpticCableType"=@("New-OUTPSite")
    "RackPhysicalProperties_MaximumSupportedWeightLbs"=@("New-OUTPSite")
    "RackPhysicalProperties_OpticalStandard"=@("New-OUTPSite")
    "RackPhysicalProperties_PowerConnector"=@("New-OUTPSite")
    "RackPhysicalProperties_PowerDrawKva"=@("New-OUTPSite")
    "RackPhysicalProperties_PowerFeedDrop"=@("New-OUTPSite")
    "RackPhysicalProperties_PowerPhase"=@("New-OUTPSite")
    "RackPhysicalProperties_UplinkCount"=@("New-OUTPSite")
    "RackPhysicalProperties_UplinkGbps"=@("New-OUTPSite")
    "SupportedHardwareType"=@("New-OUTPOutpost","Update-OUTPOutpost")
    "UplinkCount"=@("Update-OUTPSiteRackPhysicalProperty")
    "UplinkGbps"=@("Update-OUTPSiteRackPhysicalProperty")
}

_awsArgumentCompleterRegistration $OUTP_Completers $OUTP_map

$OUTP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OUTP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OUTP_SelectMap = @{
    "Select"=@("Stop-OUTPOrder",
               "New-OUTPOrder",
               "New-OUTPOutpost",
               "New-OUTPSite",
               "Remove-OUTPOutpost",
               "Remove-OUTPSite",
               "Get-OUTPCatalogItem",
               "Get-OUTPConnection",
               "Get-OUTPOrder",
               "Get-OUTPOutpost",
               "Get-OUTPOutpostInstanceType",
               "Get-OUTPSite",
               "Get-OUTPSiteAddress",
               "Get-OUTPAssetList",
               "Get-OUTPCatalogItemList",
               "Get-OUTPOrderList",
               "Get-OUTPOutpostList",
               "Get-OUTPSiteList",
               "Get-OUTPResourceTag",
               "Start-OUTPConnection",
               "Add-OUTPResourceTag",
               "Remove-OUTPResourceTag",
               "Update-OUTPOutpost",
               "Update-OUTPSite",
               "Update-OUTPSiteAddress",
               "Update-OUTPSiteRackPhysicalProperty")
}

_awsArgumentCompleterRegistration $OUTP_SelectCompleters $OUTP_SelectMap
# Argument completions for service AWS Panorama


$PAN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Panorama.ConnectionType
        {
            ($_ -eq "Register-PANDevice/NetworkingConfiguration_Ethernet0_ConnectionType") -Or
            ($_ -eq "Register-PANDevice/NetworkingConfiguration_Ethernet1_ConnectionType")
        }
        {
            $v = "DHCP","STATIC_IP"
            break
        }

        # Amazon.Panorama.DeviceAggregatedStatus
        "Get-PANDeviceList/DeviceAggregatedStatusFilter"
        {
            $v = "AWAITING_PROVISIONING","DELETING","ERROR","FAILED","LEASE_EXPIRED","OFFLINE","ONLINE","PENDING","REBOOTING","UPDATE_NEEDED"
            break
        }

        # Amazon.Panorama.JobType
        "New-PANJobForDevice/JobType"
        {
            $v = "OTA","REBOOT"
            break
        }

        # Amazon.Panorama.ListDevicesSortBy
        "Get-PANDeviceList/SortBy"
        {
            $v = "CREATED_TIME","DEVICE_AGGREGATED_STATUS","DEVICE_ID","NAME"
            break
        }

        # Amazon.Panorama.NodeCategory
        "Get-PANNodeList/Category"
        {
            $v = "BUSINESS_LOGIC","MEDIA_SINK","MEDIA_SOURCE","ML_MODEL"
            break
        }

        # Amazon.Panorama.PackageImportJobType
        "New-PANPackageImportJob/JobType"
        {
            $v = "MARKETPLACE_NODE_PACKAGE_VERSION","NODE_PACKAGE_VERSION"
            break
        }

        # Amazon.Panorama.SortOrder
        "Get-PANDeviceList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Panorama.StatusFilter
        "Get-PANApplicationInstanceList/StatusFilter"
        {
            $v = "DEPLOYMENT_ERROR","DEPLOYMENT_FAILED","DEPLOYMENT_SUCCEEDED","PROCESSING_DEPLOYMENT","PROCESSING_REMOVAL","REMOVAL_FAILED","REMOVAL_SUCCEEDED"
            break
        }

        # Amazon.Panorama.TemplateType
        "New-PANNodeFromTemplateJob/TemplateType"
        {
            $v = "RTSP_CAMERA_STREAM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PAN_map = @{
    "Category"=@("Get-PANNodeList")
    "DeviceAggregatedStatusFilter"=@("Get-PANDeviceList")
    "JobType"=@("New-PANJobForDevice","New-PANPackageImportJob")
    "NetworkingConfiguration_Ethernet0_ConnectionType"=@("Register-PANDevice")
    "NetworkingConfiguration_Ethernet1_ConnectionType"=@("Register-PANDevice")
    "SortBy"=@("Get-PANDeviceList")
    "SortOrder"=@("Get-PANDeviceList")
    "StatusFilter"=@("Get-PANApplicationInstanceList")
    "TemplateType"=@("New-PANNodeFromTemplateJob")
}

_awsArgumentCompleterRegistration $PAN_Completers $PAN_map

$PAN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PAN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PAN_SelectMap = @{
    "Select"=@("New-PANApplicationInstance",
               "New-PANJobForDevice",
               "New-PANNodeFromTemplateJob",
               "New-PANPackage",
               "New-PANPackageImportJob",
               "Remove-PANDevice",
               "Remove-PANPackage",
               "Unregister-PANPackageVersion",
               "Get-PANApplicationInstance",
               "Get-PANApplicationInstanceDetail",
               "Get-PANDevice",
               "Get-PANDeviceJob",
               "Get-PANNode",
               "Get-PANNodeFromTemplateJob",
               "Get-PANPackage",
               "Get-PANPackageImportJob",
               "Get-PANPackageVersion",
               "Get-PANApplicationInstanceDependencyList",
               "Get-PANApplicationInstanceNodeInstanceList",
               "Get-PANApplicationInstanceList",
               "Get-PANDeviceList",
               "Get-PANDevicesJobList",
               "Get-PANNodeFromTemplateJobList",
               "Get-PANNodeList",
               "Get-PANPackageImportJobList",
               "Get-PANPackageList",
               "Get-PANResourceTag",
               "Register-PANDevice",
               "Register-PANPackageVersion",
               "Remove-PANApplicationInstance",
               "Send-PANApplicationInstanceNodeInstance",
               "Add-PANResourceTag",
               "Remove-PANResourceTag",
               "Update-PANDeviceMetadata")
}

_awsArgumentCompleterRegistration $PAN_SelectCompleters $PAN_SelectMap
# Argument completions for service AWS Personalize


$PERS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Personalize.Domain
        {
            ($_ -eq "Get-PERSRecipeList/Domain") -Or
            ($_ -eq "New-PERSDatasetGroup/Domain") -Or
            ($_ -eq "New-PERSSchema/Domain")
        }
        {
            $v = "ECOMMERCE","VIDEO_ON_DEMAND"
            break
        }

        # Amazon.Personalize.ImportMode
        "New-PERSDatasetImportJob/ImportMode"
        {
            $v = "FULL","INCREMENTAL"
            break
        }

        # Amazon.Personalize.IngestionMode
        "New-PERSDatasetExportJob/IngestionMode"
        {
            $v = "ALL","BULK","PUT"
            break
        }

        # Amazon.Personalize.ObjectiveSensitivity
        "New-PERSSolution/SolutionConfig_OptimizationObjective_ObjectiveSensitivity"
        {
            $v = "HIGH","LOW","MEDIUM","OFF"
            break
        }

        # Amazon.Personalize.RecipeProvider
        "Get-PERSRecipeList/RecipeProvider"
        {
            $v = "SERVICE"
            break
        }

        # Amazon.Personalize.TrainingMode
        "New-PERSSolutionVersion/TrainingMode"
        {
            $v = "FULL","UPDATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERS_map = @{
    "Domain"=@("Get-PERSRecipeList","New-PERSDatasetGroup","New-PERSSchema")
    "ImportMode"=@("New-PERSDatasetImportJob")
    "IngestionMode"=@("New-PERSDatasetExportJob")
    "RecipeProvider"=@("Get-PERSRecipeList")
    "SolutionConfig_OptimizationObjective_ObjectiveSensitivity"=@("New-PERSSolution")
    "TrainingMode"=@("New-PERSSolutionVersion")
}

_awsArgumentCompleterRegistration $PERS_Completers $PERS_map

$PERS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERS_SelectMap = @{
    "Select"=@("New-PERSBatchInferenceJob",
               "New-PERSBatchSegmentJob",
               "New-PERSCampaign",
               "New-PERSDataset",
               "New-PERSDatasetExportJob",
               "New-PERSDatasetGroup",
               "New-PERSDatasetImportJob",
               "New-PERSEventTracker",
               "New-PERSFilter",
               "New-PERSRecommender",
               "New-PERSSchema",
               "New-PERSSolution",
               "New-PERSSolutionVersion",
               "Remove-PERSCampaign",
               "Remove-PERSDataset",
               "Remove-PERSDatasetGroup",
               "Remove-PERSEventTracker",
               "Remove-PERSFilter",
               "Remove-PERSRecommender",
               "Remove-PERSSchema",
               "Remove-PERSSolution",
               "Get-PERSAlgorithm",
               "Get-PERSBatchInferenceJob",
               "Get-PERSBatchSegmentJob",
               "Get-PERSCampaign",
               "Get-PERSDataset",
               "Get-PERSDatasetExportJob",
               "Get-PERSDatasetGroup",
               "Get-PERSDatasetImportJob",
               "Get-PERSEventTracker",
               "Get-PERSFeatureTransformation",
               "Get-PERSFilter",
               "Get-PERSRecipe",
               "Get-PERSRecommender",
               "Get-PERSSchema",
               "Get-PERSSolution",
               "Get-PERSSolutionVersion",
               "Get-PERSSolutionMetric",
               "Get-PERSBatchInferenceJobList",
               "Get-PERSBatchSegmentJobList",
               "Get-PERSCampaignList",
               "Get-PERSDatasetExportJobList",
               "Get-PERSDatasetGroupList",
               "Get-PERSDatasetImportJobList",
               "Get-PERSDatasetList",
               "Get-PERSEventTrackerList",
               "Get-PERSFilterList",
               "Get-PERSRecipeList",
               "Get-PERSRecommenderList",
               "Get-PERSSchemaList",
               "Get-PERSSolutionList",
               "Get-PERSSolutionVersionList",
               "Get-PERSResourceTag",
               "Start-PERSRecommender",
               "Stop-PERSRecommender",
               "Stop-PERSSolutionVersionCreation",
               "Add-PERSResourceTag",
               "Remove-PERSResourceTag",
               "Update-PERSCampaign",
               "Update-PERSRecommender")
}

_awsArgumentCompleterRegistration $PERS_SelectCompleters $PERS_SelectMap
# Argument completions for service Amazon Personalize Events


$PERSE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERSE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERSE_SelectMap = @{
    "Select"=@("Write-PERSEEvent",
               "Write-PERSEItem",
               "Write-PERSEUser")
}

_awsArgumentCompleterRegistration $PERSE_SelectCompleters $PERSE_SelectMap
# Argument completions for service Amazon Personalize Runtime


$PERSR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERSR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERSR_SelectMap = @{
    "Select"=@("Get-PERSRPersonalizedRanking",
               "Get-PERSRRecommendation")
}

_awsArgumentCompleterRegistration $PERSR_SelectCompleters $PERSR_SelectMap
# Argument completions for service AWS Performance Insights


$PI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.PI.ServiceType
        {
            ($_ -eq "Get-PIAvailableResourceDimensionList/ServiceType") -Or
            ($_ -eq "Get-PIAvailableResourceMetricList/ServiceType") -Or
            ($_ -eq "Get-PIDimensionKey/ServiceType") -Or
            ($_ -eq "Get-PIDimensionKeyDetail/ServiceType") -Or
            ($_ -eq "Get-PIResourceMetadata/ServiceType") -Or
            ($_ -eq "Get-PIResourceMetric/ServiceType")
        }
        {
            $v = "DOCDB","RDS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PI_map = @{
    "ServiceType"=@("Get-PIAvailableResourceDimensionList","Get-PIAvailableResourceMetricList","Get-PIDimensionKey","Get-PIDimensionKeyDetail","Get-PIResourceMetadata","Get-PIResourceMetric")
}

_awsArgumentCompleterRegistration $PI_Completers $PI_map

$PI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PI_SelectMap = @{
    "Select"=@("Get-PIDimensionKey",
               "Get-PIDimensionKeyDetail",
               "Get-PIResourceMetadata",
               "Get-PIResourceMetric",
               "Get-PIAvailableResourceDimensionList",
               "Get-PIAvailableResourceMetricList")
}

_awsArgumentCompleterRegistration $PI_SelectCompleters $PI_SelectMap
# Argument completions for service Amazon Pinpoint


$PIN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Pinpoint.Action
        {
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_ADM_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_ADM_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_APNS_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_APNS_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_Baidu_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_Baidu_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_Default_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_Default_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_GCM_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_GCM_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_GCMMessage_Action")
        }
        {
            $v = "DEEP_LINK","OPEN_APP","URL"
            break
        }

        # Amazon.Pinpoint.ChannelType
        "Update-PINEndpoint/EndpointRequest_ChannelType"
        {
            $v = "ADM","APNS","APNS_SANDBOX","APNS_VOIP","APNS_VOIP_SANDBOX","BAIDU","CUSTOM","EMAIL","GCM","IN_APP","PUSH","SMS","VOICE"
            break
        }

        # Amazon.Pinpoint.DimensionType
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "New-PINJourney/WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "Update-PINJourney/WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Location_Country_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Location_Country_DimensionType")
        }
        {
            $v = "EXCLUSIVE","INCLUSIVE"
            break
        }

        # Amazon.Pinpoint.Duration
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_Duration") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_Duration")
        }
        {
            $v = "DAY_14","DAY_30","DAY_7","HR_24"
            break
        }

        # Amazon.Pinpoint.FilterType
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_FilterType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_FilterType") -Or
            ($_ -eq "New-PINJourney/WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_FilterType") -Or
            ($_ -eq "Update-PINJourney/WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_FilterType")
        }
        {
            $v = "ENDPOINT","SYSTEM"
            break
        }

        # Amazon.Pinpoint.Format
        "New-PINImportJob/ImportJobRequest_Format"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.Pinpoint.Frequency
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_Frequency") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_Frequency")
        }
        {
            $v = "DAILY","EVENT","HOURLY","IN_APP_EVENT","MONTHLY","ONCE","WEEKLY"
            break
        }

        # Amazon.Pinpoint.Include
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_SegmentGroups_Include") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_SegmentGroups_Include")
        }
        {
            $v = "ALL","ANY","NONE"
            break
        }

        # Amazon.Pinpoint.Layout
        {
            ($_ -eq "New-PINInAppTemplate/InAppTemplateRequest_Layout") -Or
            ($_ -eq "Update-PINInAppTemplate/InAppTemplateRequest_Layout") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_InAppMessage_Layout") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_InAppMessage_Layout")
        }
        {
            $v = "BOTTOM_BANNER","CAROUSEL","MIDDLE_BANNER","MOBILE_FEED","OVERLAYS","TOP_BANNER"
            break
        }

        # Amazon.Pinpoint.MessageType
        {
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType")
        }
        {
            $v = "PROMOTIONAL","TRANSACTIONAL"
            break
        }

        # Amazon.Pinpoint.Mode
        {
            ($_ -eq "Update-PINApplicationSettingList/WriteApplicationSettingsRequest_CampaignHook_Mode") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Hook_Mode") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Hook_Mode")
        }
        {
            $v = "DELIVERY","FILTER"
            break
        }

        # Amazon.Pinpoint.RecencyType
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.Pinpoint.State
        {
            ($_ -eq "Update-PINJourneyState/JourneyStateRequest_State") -Or
            ($_ -eq "New-PINJourney/WriteJourneyRequest_State") -Or
            ($_ -eq "Update-PINJourney/WriteJourneyRequest_State")
        }
        {
            $v = "ACTIVE","CANCELLED","CLOSED","COMPLETED","DRAFT","PAUSED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PIN_map = @{
    "EndpointRequest_ChannelType"=@("Update-PINEndpoint")
    "ImportJobRequest_Format"=@("New-PINImportJob")
    "InAppTemplateRequest_Layout"=@("New-PINInAppTemplate","Update-PINInAppTemplate")
    "JourneyStateRequest_State"=@("Update-PINJourneyState")
    "MessageRequest_MessageConfiguration_ADMMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_APNSMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_BaiduMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_GCMMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_SMSMessage_MessageType"=@("Send-PINMessage")
    "PushNotificationTemplateRequest_ADM_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_APNS_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_Baidu_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_Default_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_GCM_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "SendUsersMessageRequest_MessageConfiguration_ADMMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_APNSMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_BaiduMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_GCMMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_SMSMessage_MessageType"=@("Send-PINUserMessageBatch")
    "WriteApplicationSettingsRequest_CampaignHook_Mode"=@("Update-PINApplicationSettingList")
    "WriteCampaignRequest_Hook_Mode"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_ADMMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_APNSMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_GCMMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_InAppMessage_Layout"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_EventFilter_FilterType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_Frequency"=@("New-PINCampaign","Update-PINCampaign")
    "WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_Dimensions_EventType_DimensionType"=@("New-PINJourney","Update-PINJourney")
    "WriteJourneyRequest_StartCondition_EventStartCondition_EventFilter_FilterType"=@("New-PINJourney","Update-PINJourney")
    "WriteJourneyRequest_State"=@("New-PINJourney","Update-PINJourney")
    "WriteSegmentRequest_Dimensions_Behavior_Recency_Duration"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Location_Country_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_SegmentGroups_Include"=@("New-PINSegment","Update-PINSegment")
}

_awsArgumentCompleterRegistration $PIN_Completers $PIN_map

$PIN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PIN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PIN_SelectMap = @{
    "Select"=@("New-PINApp",
               "New-PINCampaign",
               "New-PINEmailTemplate",
               "New-PINExportJob",
               "New-PINImportJob",
               "New-PINInAppTemplate",
               "New-PINJourney",
               "New-PINPushTemplate",
               "New-PINRecommenderConfiguration",
               "New-PINSegment",
               "New-PINSmsTemplate",
               "New-PINVoiceTemplate",
               "Remove-PINAdmChannel",
               "Remove-PINApnsChannel",
               "Remove-PINApnsSandboxChannel",
               "Remove-PINApnsVoipChannel",
               "Remove-PINApnsVoipSandboxChannel",
               "Remove-PINApp",
               "Remove-PINBaiduChannel",
               "Remove-PINCampaign",
               "Remove-PINEmailChannel",
               "Remove-PINEmailTemplate",
               "Remove-PINEndpoint",
               "Remove-PINEventStream",
               "Remove-PINGcmChannel",
               "Remove-PINInAppTemplate",
               "Remove-PINJourney",
               "Remove-PINPushTemplate",
               "Remove-PINRecommenderConfiguration",
               "Remove-PINSegment",
               "Remove-PINSmsChannel",
               "Remove-PINSmsTemplate",
               "Remove-PINUserEndpoint",
               "Remove-PINVoiceChannel",
               "Remove-PINVoiceTemplate",
               "Get-PINAdmChannel",
               "Get-PINApnsChannel",
               "Get-PINApnsSandboxChannel",
               "Get-PINApnsVoipChannel",
               "Get-PINApnsVoipSandboxChannel",
               "Get-PINApp",
               "Get-PINApplicationDateRangeKpi",
               "Get-PINApplicationSettingList",
               "Get-PINAppList",
               "Get-PINBaiduChannel",
               "Get-PINCampaign",
               "Get-PINCampaignActivityList",
               "Get-PINCampaignDateRangeKpi",
               "Get-PINCampaignList",
               "Get-PINCampaignVersion",
               "Get-PINCampaignVersionList",
               "Get-PINChannel",
               "Get-PINEmailChannel",
               "Get-PINEmailTemplate",
               "Get-PINEndpoint",
               "Get-PINEventStream",
               "Get-PINExportJob",
               "Get-PINExportJobList",
               "Get-PINGcmChannel",
               "Get-PINImportJob",
               "Get-PINImportJobList",
               "Get-PINInAppMessage",
               "Get-PINInAppTemplate",
               "Get-PINJourney",
               "Get-PINJourneyDateRangeKpi",
               "Get-PINJourneyExecutionActivityMetric",
               "Get-PINJourneyExecutionMetric",
               "Get-PINPushTemplate",
               "Get-PINRecommenderConfiguration",
               "Get-PINRecommenderConfigurationList",
               "Get-PINSegment",
               "Get-PINSegmentExportJobList",
               "Get-PINSegmentImportJobList",
               "Get-PINSegmentList",
               "Get-PINSegmentVersion",
               "Get-PINSegmentVersionList",
               "Get-PINSmsChannel",
               "Get-PINSmsTemplate",
               "Get-PINUserEndpoint",
               "Get-PINVoiceChannel",
               "Get-PINVoiceTemplate",
               "Get-PINJourneyList",
               "Get-PINResourceTag",
               "Get-PINTemplateList",
               "Get-PINTemplateVersionList",
               "Confirm-PINPhoneNumber",
               "Write-PINEvent",
               "Write-PINEventStream",
               "Remove-PINAttribute",
               "Send-PINMessage",
               "Send-PINOTPMessage",
               "Send-PINUserMessageBatch",
               "Add-PINResourceTag",
               "Remove-PINResourceTag",
               "Update-PINAdmChannel",
               "Update-PINApnsChannel",
               "Update-PINApnsSandboxChannel",
               "Update-PINApnsVoipChannel",
               "Update-PINApnsVoipSandboxChannel",
               "Update-PINApplicationSettingList",
               "Update-PINBaiduChannel",
               "Update-PINCampaign",
               "Update-PINEmailChannel",
               "Update-PINEmailTemplate",
               "Update-PINEndpoint",
               "Update-PINEndpointsBatch",
               "Update-PINGcmChannel",
               "Update-PINInAppTemplate",
               "Update-PINJourney",
               "Update-PINJourneyState",
               "Update-PINPushTemplate",
               "Update-PINRecommenderConfiguration",
               "Update-PINSegment",
               "Update-PINSmsChannel",
               "Update-PINSmsTemplate",
               "Update-PINTemplateActiveVersion",
               "Update-PINVoiceChannel",
               "Update-PINVoiceTemplate",
               "Confirm-PINOTPMessage")
}

_awsArgumentCompleterRegistration $PIN_SelectCompleters $PIN_SelectMap
# Argument completions for service Amazon Pinpoint Email


$PINE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.PinpointEmail.BehaviorOnMxFailure
        "Write-PINEEmailIdentityMailFromAttribute/BehaviorOnMxFailure"
        {
            $v = "REJECT_MESSAGE","USE_DEFAULT_VALUE"
            break
        }

        # Amazon.PinpointEmail.TlsPolicy
        {
            ($_ -eq "New-PINEConfigurationSet/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "Write-PINEConfigurationSetDeliveryOption/TlsPolicy")
        }
        {
            $v = "OPTIONAL","REQUIRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PINE_map = @{
    "BehaviorOnMxFailure"=@("Write-PINEEmailIdentityMailFromAttribute")
    "DeliveryOptions_TlsPolicy"=@("New-PINEConfigurationSet")
    "TlsPolicy"=@("Write-PINEConfigurationSetDeliveryOption")
}

_awsArgumentCompleterRegistration $PINE_Completers $PINE_map

$PINE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PINE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PINE_SelectMap = @{
    "Select"=@("New-PINEConfigurationSet",
               "New-PINEConfigurationSetEventDestination",
               "New-PINEDedicatedIpPool",
               "New-PINEDeliverabilityTestReport",
               "New-PINEEmailIdentity",
               "Remove-PINEConfigurationSet",
               "Remove-PINEConfigurationSetEventDestination",
               "Remove-PINEDedicatedIpPool",
               "Remove-PINEEmailIdentity",
               "Get-PINEAccount",
               "Get-PINEBlacklistReport",
               "Get-PINEConfigurationSet",
               "Get-PINEConfigurationSetEventDestination",
               "Get-PINEDedicatedIp",
               "Get-PINEDedicatedIpList",
               "Get-PINEDeliverabilityDashboardOption",
               "Get-PINEDeliverabilityTestReport",
               "Get-PINEDomainDeliverabilityCampaign",
               "Get-PINEDomainStatisticsReport",
               "Get-PINEEmailIdentity",
               "Get-PINEConfigurationSetList",
               "Get-PINEDedicatedIpPoolList",
               "Get-PINEDeliverabilityTestReportList",
               "Get-PINEDomainDeliverabilityCampaignList",
               "Get-PINEEmailIdentityList",
               "Get-PINEResourceTag",
               "Write-PINEAccountDedicatedIpWarmupAttribute",
               "Write-PINEAccountSendingAttribute",
               "Write-PINEConfigurationSetDeliveryOption",
               "Write-PINEConfigurationSetReputationOption",
               "Write-PINEConfigurationSetSendingOption",
               "Write-PINEConfigurationSetTrackingOption",
               "Write-PINEDedicatedIpInPool",
               "Write-PINEDedicatedIpWarmupAttribute",
               "Write-PINEDeliverabilityDashboardOption",
               "Write-PINEEmailIdentityDkimAttribute",
               "Write-PINEEmailIdentityFeedbackAttribute",
               "Write-PINEEmailIdentityMailFromAttribute",
               "Send-PINEEmail",
               "Add-PINEResourceTag",
               "Remove-PINEResourceTag",
               "Update-PINEConfigurationSetEventDestination")
}

_awsArgumentCompleterRegistration $PINE_SelectCompleters $PINE_SelectMap
# Argument completions for service Amazon Pinpoint SMS Voice V2


$SMSV_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.PinpointSMSVoiceV2.KeywordAction
        "Set-SMSVKeyword/KeywordAction"
        {
            $v = "AUTOMATIC_RESPONSE","OPT_IN","OPT_OUT"
            break
        }

        # Amazon.PinpointSMSVoiceV2.MessageType
        {
            ($_ -eq "New-SMSVPhoneNumber/MessageType") -Or
            ($_ -eq "New-SMSVPool/MessageType") -Or
            ($_ -eq "Send-SMSVTextMessage/MessageType") -Or
            ($_ -eq "Set-SMSVDefaultMessageType/MessageType")
        }
        {
            $v = "PROMOTIONAL","TRANSACTIONAL"
            break
        }

        # Amazon.PinpointSMSVoiceV2.RequestableNumberType
        "New-SMSVPhoneNumber/NumberType"
        {
            $v = "LONG_CODE","TEN_DLC","TOLL_FREE"
            break
        }

        # Amazon.PinpointSMSVoiceV2.VoiceId
        "Send-SMSVVoiceMessage/VoiceId"
        {
            $v = "AMY","ASTRID","BIANCA","BRIAN","CAMILA","CARLA","CARMEN","CELINE","CHANTAL","CONCHITA","CRISTIANO","DORA","EMMA","ENRIQUE","EWA","FILIZ","GERAINT","GIORGIO","GWYNETH","HANS","INES","IVY","JACEK","JAN","JOANNA","JOEY","JUSTIN","KARL","KENDRA","KIMBERLY","LEA","LIV","LOTTE","LUCIA","LUPE","MADS","MAJA","MARLENE","MATHIEU","MATTHEW","MAXIM","MIA","MIGUEL","MIZUKI","NAJA","NICOLE","PENELOPE","RAVEENA","RICARDO","RUBEN","RUSSELL","SALLI","SEOYEON","TAKUMI","TATYANA","VICKI","VITORIA","ZEINA","ZHIYU"
            break
        }

        # Amazon.PinpointSMSVoiceV2.VoiceMessageBodyTextType
        "Send-SMSVVoiceMessage/MessageBodyTextType"
        {
            $v = "SSML","TEXT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMSV_map = @{
    "KeywordAction"=@("Set-SMSVKeyword")
    "MessageBodyTextType"=@("Send-SMSVVoiceMessage")
    "MessageType"=@("New-SMSVPhoneNumber","New-SMSVPool","Send-SMSVTextMessage","Set-SMSVDefaultMessageType")
    "NumberType"=@("New-SMSVPhoneNumber")
    "VoiceId"=@("Send-SMSVVoiceMessage")
}

_awsArgumentCompleterRegistration $SMSV_Completers $SMSV_map

$SMSV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMSV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMSV_SelectMap = @{
    "Select"=@("Register-SMSVOriginationIdentity",
               "New-SMSVConfigurationSet",
               "New-SMSVEventDestination",
               "New-SMSVOptOutList",
               "New-SMSVPool",
               "Remove-SMSVConfigurationSet",
               "Remove-SMSVDefaultMessageType",
               "Remove-SMSVDefaultSenderId",
               "Remove-SMSVEventDestination",
               "Remove-SMSVKeyword",
               "Remove-SMSVOptedOutNumber",
               "Remove-SMSVOptOutList",
               "Remove-SMSVPool",
               "Remove-SMSVTextMessageSpendLimitOverride",
               "Remove-SMSVVoiceMessageSpendLimitOverride",
               "Get-SMSVAccountAttribute",
               "Get-SMSVAccountLimit",
               "Get-SMSVConfigurationSet",
               "Get-SMSVKeyword",
               "Get-SMSVOptedOutNumber",
               "Get-SMSVOptOutList",
               "Get-SMSVPhoneNumber",
               "Get-SMSVPool",
               "Get-SMSVSenderId",
               "Get-SMSVSpendLimit",
               "Unregister-SMSVOriginationIdentity",
               "Get-SMSVPoolOriginationIdentityList",
               "Get-SMSVResourceTagList",
               "Set-SMSVKeyword",
               "Set-SMSVOptedOutNumber",
               "Remove-SMSVPhoneNumber",
               "New-SMSVPhoneNumber",
               "Send-SMSVTextMessage",
               "Send-SMSVVoiceMessage",
               "Set-SMSVDefaultMessageType",
               "Set-SMSVDefaultSenderId",
               "Set-SMSVTextMessageSpendLimitOverride",
               "Set-SMSVVoiceMessageSpendLimitOverride",
               "Add-SMSVResourceTag",
               "Remove-SMSVResourceTag",
               "Update-SMSVEventDestination",
               "Update-SMSVPhoneNumber",
               "Update-SMSVPool")
}

_awsArgumentCompleterRegistration $SMSV_SelectCompleters $SMSV_SelectMap
# Argument completions for service Amazon Polly


$POL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Polly.Engine
        {
            ($_ -eq "Get-POLSpeech/Engine") -Or
            ($_ -eq "Get-POLVoice/Engine") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/Engine")
        }
        {
            $v = "neural","standard"
            break
        }

        # Amazon.Polly.LanguageCode
        {
            ($_ -eq "Get-POLSpeech/LanguageCode") -Or
            ($_ -eq "Get-POLVoice/LanguageCode") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/LanguageCode")
        }
        {
            $v = "arb","ca-ES","cmn-CN","cy-GB","da-DK","de-AT","de-DE","en-AU","en-GB","en-GB-WLS","en-IN","en-NZ","en-US","en-ZA","es-ES","es-MX","es-US","fr-CA","fr-FR","hi-IN","is-IS","it-IT","ja-JP","ko-KR","nb-NO","nl-NL","pl-PL","pt-BR","pt-PT","ro-RO","ru-RU","sv-SE","tr-TR","yue-CN"
            break
        }

        # Amazon.Polly.OutputFormat
        {
            ($_ -eq "Get-POLSpeech/OutputFormat") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/OutputFormat")
        }
        {
            $v = "json","mp3","ogg_vorbis","pcm"
            break
        }

        # Amazon.Polly.TaskStatus
        "Get-POLSpeechSynthesisTaskList/Status"
        {
            $v = "completed","failed","inProgress","scheduled"
            break
        }

        # Amazon.Polly.TextType
        {
            ($_ -eq "Get-POLSpeech/TextType") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/TextType")
        }
        {
            $v = "ssml","text"
            break
        }

        # Amazon.Polly.VoiceId
        {
            ($_ -eq "Get-POLSpeech/VoiceId") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/VoiceId")
        }
        {
            $v = "Aditi","Amy","Aria","Arlet","Arthur","Astrid","Ayanda","Bianca","Brian","Camila","Carla","Carmen","Celine","Chantal","Conchita","Cristiano","Daniel","Dora","Elin","Emma","Enrique","Ewa","Filiz","Gabrielle","Geraint","Giorgio","Gwyneth","Hannah","Hans","Hiujin","Ida","Ines","Ivy","Jacek","Jan","Joanna","Joey","Justin","Kajal","Karl","Kendra","Kevin","Kimberly","Laura","Lea","Liam","Liv","Lotte","Lucia","Lupe","Mads","Maja","Marlene","Mathieu","Matthew","Maxim","Mia","Miguel","Mizuki","Naja","Nicole","Olivia","Pedro","Penelope","Raveena","Ricardo","Ruben","Russell","Salli","Seoyeon","Suvi","Takumi","Tatyana","Vicki","Vitoria","Zeina","Zhiyu"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$POL_map = @{
    "Engine"=@("Get-POLSpeech","Get-POLVoice","Start-POLSpeechSynthesisTask")
    "LanguageCode"=@("Get-POLSpeech","Get-POLVoice","Start-POLSpeechSynthesisTask")
    "OutputFormat"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
    "Status"=@("Get-POLSpeechSynthesisTaskList")
    "TextType"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
    "VoiceId"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
}

_awsArgumentCompleterRegistration $POL_Completers $POL_map

$POL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.POL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$POL_SelectMap = @{
    "Select"=@("Remove-POLLexicon",
               "Get-POLVoice",
               "Get-POLLexicon",
               "Get-POLSpeechSynthesisTask",
               "Get-POLLexiconList",
               "Get-POLSpeechSynthesisTaskList",
               "Write-POLLexicon",
               "Start-POLSpeechSynthesisTask",
               "Get-POLSpeech")
}

_awsArgumentCompleterRegistration $POL_SelectCompleters $POL_SelectMap
# Argument completions for service AWS Price List Service


$PLS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PLS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PLS_SelectMap = @{
    "Select"=@("Get-PLSService",
               "Get-PLSAttributeValue",
               "Get-PLSProduct")
}

_awsArgumentCompleterRegistration $PLS_SelectCompleters $PLS_SelectMap
# Argument completions for service AWS Route53 Recovery Readiness


$PD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PD_SelectMap = @{
    "Select"=@("New-PDCell",
               "New-PDCrossAccountAuthorization",
               "New-PDReadinessCheck",
               "New-PDRecoveryGroup",
               "New-PDResourceSet",
               "Remove-PDCell",
               "Remove-PDCrossAccountAuthorization",
               "Remove-PDReadinessCheck",
               "Remove-PDRecoveryGroup",
               "Remove-PDResourceSet",
               "Get-PDArchitectureRecommendation",
               "Get-PDCell",
               "Get-PDCellReadinessSummary",
               "Get-PDReadinessCheck",
               "Get-PDReadinessCheckResourceStatus",
               "Get-PDReadinessCheckStatus",
               "Get-PDRecoveryGroup",
               "Get-PDRecoveryGroupReadinessSummary",
               "Get-PDResourceSet",
               "Get-PDCellList",
               "Get-PDCrossAccountAuthorizationList",
               "Get-PDReadinessCheckList",
               "Get-PDRecoveryGroupList",
               "Get-PDResourceSetList",
               "Get-PDRuleList",
               "Get-PDTagsForResourceList",
               "Add-PDResourceTag",
               "Remove-PDResourceTag",
               "Update-PDCell",
               "Update-PDReadinessCheck",
               "Update-PDRecoveryGroup",
               "Update-PDResourceSet")
}

_awsArgumentCompleterRegistration $PD_SelectCompleters $PD_SelectMap
# Argument completions for service AWS Private 5G


$PV5G_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Private5G.ElevationReference
        "Set-PV5GAccessPoint/Position_ElevationReference"
        {
            $v = "AGL","AMSL"
            break
        }

        # Amazon.Private5G.ElevationUnit
        "Set-PV5GAccessPoint/Position_ElevationUnit"
        {
            $v = "FEET"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PV5G_map = @{
    "Position_ElevationReference"=@("Set-PV5GAccessPoint")
    "Position_ElevationUnit"=@("Set-PV5GAccessPoint")
}

_awsArgumentCompleterRegistration $PV5G_Completers $PV5G_map

$PV5G_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PV5G.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PV5G_SelectMap = @{
    "Select"=@("Confirm-PV5GOrderReceipt",
               "Enable-PV5GDeviceIdentifier",
               "Enable-PV5GNetworkSite",
               "Set-PV5GAccessPoint",
               "New-PV5GNetwork",
               "New-PV5GNetworkSite",
               "Disable-PV5GDeviceIdentifier",
               "Remove-PV5GNetwork",
               "Remove-PV5GNetworkSite",
               "Get-PV5GDeviceIdentifier",
               "Get-PV5GNetwork",
               "Get-PV5GNetworkResource",
               "Get-PV5GNetworkSite",
               "Get-PV5GOrder",
               "Get-PV5GDeviceIdentifierList",
               "Get-PV5GNetworkResourceList",
               "Get-PV5GNetworkList",
               "Get-PV5GNetworkSiteList",
               "Get-PV5GOrderList",
               "Get-PV5GResourceTag",
               "Ping-PV5GPing",
               "Add-PV5GResourceTag",
               "Remove-PV5GResourceTag",
               "Update-PV5GNetworkSite",
               "Update-PV5GNetworkSitePlan")
}

_awsArgumentCompleterRegistration $PV5G_SelectCompleters $PV5G_SelectMap
# Argument completions for service AWS Proton


$PRO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Proton.ComponentDeploymentUpdateType
        "Update-PROComponent/DeploymentType"
        {
            $v = "CURRENT_VERSION","NONE"
            break
        }

        # Amazon.Proton.DeploymentUpdateType
        {
            ($_ -eq "Update-PROEnvironment/DeploymentType") -Or
            ($_ -eq "Update-PROServiceInstance/DeploymentType") -Or
            ($_ -eq "Update-PROServicePipeline/DeploymentType")
        }
        {
            $v = "CURRENT_VERSION","MAJOR_VERSION","MINOR_VERSION","NONE"
            break
        }

        # Amazon.Proton.EnvironmentAccountConnectionRequesterAccountType
        "Get-PROEnvironmentAccountConnectionList/RequestedBy"
        {
            $v = "ENVIRONMENT_ACCOUNT","MANAGEMENT_ACCOUNT"
            break
        }

        # Amazon.Proton.ListServiceInstancesSortBy
        "Get-PROServiceInstanceList/SortBy"
        {
            $v = "createdAt","deploymentStatus","environmentName","lastDeploymentAttemptedAt","name","serviceName","templateName"
            break
        }

        # Amazon.Proton.Provisioning
        {
            ($_ -eq "New-PROServiceTemplate/PipelineProvisioning") -Or
            ($_ -eq "New-PROEnvironmentTemplate/Provisioning")
        }
        {
            $v = "CUSTOMER_MANAGED"
            break
        }

        # Amazon.Proton.RepositoryProvider
        {
            ($_ -eq "Update-PROAccountSetting/PipelineProvisioningRepository_Provider") -Or
            ($_ -eq "Get-PRORepository/Provider") -Or
            ($_ -eq "New-PRORepository/Provider") -Or
            ($_ -eq "Remove-PRORepository/Provider") -Or
            ($_ -eq "New-PROEnvironment/ProvisioningRepository_Provider") -Or
            ($_ -eq "Update-PROEnvironment/ProvisioningRepository_Provider") -Or
            ($_ -eq "Get-PRORepositorySyncDefinitionList/RepositoryProvider") -Or
            ($_ -eq "Get-PRORepositorySyncStatus/RepositoryProvider") -Or
            ($_ -eq "New-PROTemplateSyncConfig/RepositoryProvider") -Or
            ($_ -eq "Update-PROTemplateSyncConfig/RepositoryProvider")
        }
        {
            $v = "BITBUCKET","GITHUB","GITHUB_ENTERPRISE"
            break
        }

        # Amazon.Proton.ResourceDeploymentStatus
        "Edit-PROResourceDeploymentStatusChange/Status"
        {
            $v = "FAILED","IN_PROGRESS","SUCCEEDED"
            break
        }

        # Amazon.Proton.SortOrder
        "Get-PROServiceInstanceList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Proton.SyncType
        {
            ($_ -eq "Get-PRORepositorySyncDefinitionList/SyncType") -Or
            ($_ -eq "Get-PRORepositorySyncStatus/SyncType")
        }
        {
            $v = "TEMPLATE_SYNC"
            break
        }

        # Amazon.Proton.TemplateType
        {
            ($_ -eq "Get-PROTemplateSyncConfig/TemplateType") -Or
            ($_ -eq "Get-PROTemplateSyncStatus/TemplateType") -Or
            ($_ -eq "New-PROTemplateSyncConfig/TemplateType") -Or
            ($_ -eq "Remove-PROTemplateSyncConfig/TemplateType") -Or
            ($_ -eq "Update-PROTemplateSyncConfig/TemplateType")
        }
        {
            $v = "ENVIRONMENT","SERVICE"
            break
        }

        # Amazon.Proton.TemplateVersionStatus
        {
            ($_ -eq "Update-PROEnvironmentTemplateVersion/Status") -Or
            ($_ -eq "Update-PROServiceTemplateVersion/Status")
        }
        {
            $v = "DRAFT","PUBLISHED","REGISTRATION_FAILED","REGISTRATION_IN_PROGRESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PRO_map = @{
    "DeploymentType"=@("Update-PROComponent","Update-PROEnvironment","Update-PROServiceInstance","Update-PROServicePipeline")
    "PipelineProvisioning"=@("New-PROServiceTemplate")
    "PipelineProvisioningRepository_Provider"=@("Update-PROAccountSetting")
    "Provider"=@("Get-PRORepository","New-PRORepository","Remove-PRORepository")
    "Provisioning"=@("New-PROEnvironmentTemplate")
    "ProvisioningRepository_Provider"=@("New-PROEnvironment","Update-PROEnvironment")
    "RepositoryProvider"=@("Get-PRORepositorySyncDefinitionList","Get-PRORepositorySyncStatus","New-PROTemplateSyncConfig","Update-PROTemplateSyncConfig")
    "RequestedBy"=@("Get-PROEnvironmentAccountConnectionList")
    "SortBy"=@("Get-PROServiceInstanceList")
    "SortOrder"=@("Get-PROServiceInstanceList")
    "Status"=@("Edit-PROResourceDeploymentStatusChange","Update-PROEnvironmentTemplateVersion","Update-PROServiceTemplateVersion")
    "SyncType"=@("Get-PRORepositorySyncDefinitionList","Get-PRORepositorySyncStatus")
    "TemplateType"=@("Get-PROTemplateSyncConfig","Get-PROTemplateSyncStatus","New-PROTemplateSyncConfig","Remove-PROTemplateSyncConfig","Update-PROTemplateSyncConfig")
}

_awsArgumentCompleterRegistration $PRO_Completers $PRO_map

$PRO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PRO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PRO_SelectMap = @{
    "Select"=@("Approve-PROEnvironmentAccountConnection",
               "Stop-PROComponentDeployment",
               "Stop-PROEnvironmentDeployment",
               "Stop-PROServiceInstanceDeployment",
               "Stop-PROServicePipelineDeployment",
               "New-PROComponent",
               "New-PROEnvironment",
               "New-PROEnvironmentAccountConnection",
               "New-PROEnvironmentTemplate",
               "New-PROEnvironmentTemplateVersion",
               "New-PRORepository",
               "New-PROService",
               "New-PROServiceTemplate",
               "New-PROServiceTemplateVersion",
               "New-PROTemplateSyncConfig",
               "Remove-PROComponent",
               "Remove-PROEnvironment",
               "Remove-PROEnvironmentAccountConnection",
               "Remove-PROEnvironmentTemplate",
               "Remove-PROEnvironmentTemplateVersion",
               "Remove-PRORepository",
               "Remove-PROService",
               "Remove-PROServiceTemplate",
               "Remove-PROServiceTemplateVersion",
               "Remove-PROTemplateSyncConfig",
               "Get-PROAccountSetting",
               "Get-PROComponent",
               "Get-PROEnvironment",
               "Get-PROEnvironmentAccountConnection",
               "Get-PROEnvironmentTemplate",
               "Get-PROEnvironmentTemplateVersion",
               "Get-PRORepository",
               "Get-PRORepositorySyncStatus",
               "Get-PROService",
               "Get-PROServiceInstance",
               "Get-PROServiceTemplate",
               "Get-PROServiceTemplateVersion",
               "Get-PROTemplateSyncConfig",
               "Get-PROTemplateSyncStatus",
               "Get-PROComponentOutputList",
               "Get-PROComponentProvisionedResourceList",
               "Get-PROComponentList",
               "Get-PROEnvironmentAccountConnectionList",
               "Get-PROEnvironmentOutputList",
               "Get-PROEnvironmentProvisionedResourceList",
               "Get-PROEnvironmentList",
               "Get-PROEnvironmentTemplateList",
               "Get-PROEnvironmentTemplateVersionList",
               "Get-PRORepositoryList",
               "Get-PRORepositorySyncDefinitionList",
               "Get-PROServiceInstanceOutputList",
               "Get-PROServiceInstanceProvisionedResourceList",
               "Get-PROServiceInstanceList",
               "Get-PROServicePipelineOutputList",
               "Get-PROServicePipelineProvisionedResourceList",
               "Get-PROServiceList",
               "Get-PROServiceTemplateList",
               "Get-PROServiceTemplateVersionList",
               "Get-PROResourceTag",
               "Edit-PROResourceDeploymentStatusChange",
               "Deny-PROEnvironmentAccountConnection",
               "Add-PROResourceTag",
               "Remove-PROResourceTag",
               "Update-PROAccountSetting",
               "Update-PROComponent",
               "Update-PROEnvironment",
               "Update-PROEnvironmentAccountConnection",
               "Update-PROEnvironmentTemplate",
               "Update-PROEnvironmentTemplateVersion",
               "Update-PROService",
               "Update-PROServiceInstance",
               "Update-PROServicePipeline",
               "Update-PROServiceTemplate",
               "Update-PROServiceTemplateVersion",
               "Update-PROTemplateSyncConfig")
}

_awsArgumentCompleterRegistration $PRO_SelectCompleters $PRO_SelectMap
# Argument completions for service Amazon QLDB


$QLDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.QLDB.OutputFormat
        "Export-QLDBJournalToS3/OutputFormat"
        {
            $v = "ION_BINARY","ION_TEXT","JSON"
            break
        }

        # Amazon.QLDB.PermissionsMode
        {
            ($_ -eq "New-QLDBLedger/PermissionsMode") -Or
            ($_ -eq "Update-QLDBLedgerPermissionsMode/PermissionsMode")
        }
        {
            $v = "ALLOW_ALL","STANDARD"
            break
        }

        # Amazon.QLDB.S3ObjectEncryptionType
        "Export-QLDBJournalToS3/S3ExportConfiguration_EncryptionConfiguration_ObjectEncryptionType"
        {
            $v = "NO_ENCRYPTION","SSE_KMS","SSE_S3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDB_map = @{
    "OutputFormat"=@("Export-QLDBJournalToS3")
    "PermissionsMode"=@("New-QLDBLedger","Update-QLDBLedgerPermissionsMode")
    "S3ExportConfiguration_EncryptionConfiguration_ObjectEncryptionType"=@("Export-QLDBJournalToS3")
}

_awsArgumentCompleterRegistration $QLDB_Completers $QLDB_map

$QLDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QLDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDB_SelectMap = @{
    "Select"=@("Stop-QLDBJournalKinesisStream",
               "New-QLDBLedger",
               "Remove-QLDBLedger",
               "Get-QLDBJournalKinesisStream",
               "Get-QLDBJournalS3Export",
               "Get-QLDBLedger",
               "Export-QLDBJournalToS3",
               "Get-QLDBBlock",
               "Get-QLDBDigest",
               "Get-QLDBRevision",
               "Get-QLDBJournalKinesisStreamsForLedgerList",
               "Get-QLDBJournalS3ExportList",
               "Get-QLDBJournalS3ExportsForLedgerList",
               "Get-QLDBLedgerList",
               "Get-QLDBResourceTag",
               "Start-QLDBStreamJournalToKinesi",
               "Add-QLDBResourceTag",
               "Remove-QLDBResourceTag",
               "Update-QLDBLedger",
               "Update-QLDBLedgerPermissionsMode")
}

_awsArgumentCompleterRegistration $QLDB_SelectCompleters $QLDB_SelectMap
# Argument completions for service Amazon QLDB Session


$QLDBS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QLDBS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDBS_SelectMap = @{
    "Select"=@("Send-QLDBSCommand")
}

_awsArgumentCompleterRegistration $QLDBS_SelectCompleters $QLDBS_SelectMap
# Argument completions for service Amazon QuickSight


$QS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.QuickSight.AssignmentStatus
        {
            ($_ -eq "Get-QSIAMPolicyAssignmentList/AssignmentStatus") -Or
            ($_ -eq "New-QSIAMPolicyAssignment/AssignmentStatus") -Or
            ($_ -eq "Update-QSIAMPolicyAssignment/AssignmentStatus")
        }
        {
            $v = "DISABLED","DRAFT","ENABLED"
            break
        }

        # Amazon.QuickSight.AuthenticationMethodOption
        "New-QSAccountSubscription/AuthenticationMethod"
        {
            $v = "ACTIVE_DIRECTORY","IAM_AND_QUICKSIGHT","IAM_ONLY"
            break
        }

        # Amazon.QuickSight.DashboardBehavior
        {
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus") -Or
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.QuickSight.DashboardUIState
        {
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_SheetControlsOption_VisibilityState") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_SheetControlsOption_VisibilityState")
        }
        {
            $v = "COLLAPSED","EXPANDED"
            break
        }

        # Amazon.QuickSight.DataSetImportMode
        {
            ($_ -eq "New-QSDataSet/ImportMode") -Or
            ($_ -eq "Update-QSDataSet/ImportMode")
        }
        {
            $v = "DIRECT_QUERY","SPICE"
            break
        }

        # Amazon.QuickSight.DataSourceType
        "New-QSDataSource/Type"
        {
            $v = "ADOBE_ANALYTICS","AMAZON_ELASTICSEARCH","AMAZON_OPENSEARCH","ATHENA","AURORA","AURORA_POSTGRESQL","AWS_IOT_ANALYTICS","EXASOL","GITHUB","JIRA","MARIADB","MYSQL","ORACLE","POSTGRESQL","PRESTO","REDSHIFT","S3","SALESFORCE","SERVICENOW","SNOWFLAKE","SPARK","SQLSERVER","TERADATA","TIMESTREAM","TWITTER"
            break
        }

        # Amazon.QuickSight.Edition
        "New-QSAccountSubscription/Edition"
        {
            $v = "ENTERPRISE","ENTERPRISE_AND_Q","STANDARD"
            break
        }

        # Amazon.QuickSight.EmbeddingIdentityType
        "Get-QSDashboardEmbedUrl/IdentityType"
        {
            $v = "ANONYMOUS","IAM","QUICKSIGHT"
            break
        }

        # Amazon.QuickSight.FolderType
        "New-QSFolder/FolderType"
        {
            $v = "SHARED"
            break
        }

        # Amazon.QuickSight.IdentityStore
        "New-QSNamespace/IdentityStore"
        {
            $v = "QUICKSIGHT"
            break
        }

        # Amazon.QuickSight.IdentityType
        "Register-QSUser/IdentityType"
        {
            $v = "IAM","QUICKSIGHT"
            break
        }

        # Amazon.QuickSight.IngestionType
        "New-QSIngestion/IngestionType"
        {
            $v = "FULL_REFRESH","INCREMENTAL_REFRESH"
            break
        }

        # Amazon.QuickSight.MemberType
        {
            ($_ -eq "New-QSFolderMembership/MemberType") -Or
            ($_ -eq "Remove-QSFolderMembership/MemberType")
        }
        {
            $v = "ANALYSIS","DASHBOARD","DATASET"
            break
        }

        # Amazon.QuickSight.RowLevelPermissionFormatVersion
        {
            ($_ -eq "New-QSDataSet/RowLevelPermissionDataSet_FormatVersion") -Or
            ($_ -eq "Update-QSDataSet/RowLevelPermissionDataSet_FormatVersion")
        }
        {
            $v = "VERSION_1","VERSION_2"
            break
        }

        # Amazon.QuickSight.RowLevelPermissionPolicy
        {
            ($_ -eq "New-QSDataSet/RowLevelPermissionDataSet_PermissionPolicy") -Or
            ($_ -eq "Update-QSDataSet/RowLevelPermissionDataSet_PermissionPolicy")
        }
        {
            $v = "DENY_ACCESS","GRANT_ACCESS"
            break
        }

        # Amazon.QuickSight.Status
        {
            ($_ -eq "New-QSDataSet/RowLevelPermissionDataSet_Status") -Or
            ($_ -eq "Update-QSDataSet/RowLevelPermissionDataSet_Status") -Or
            ($_ -eq "New-QSDataSet/RowLevelPermissionTagConfiguration_Status") -Or
            ($_ -eq "Update-QSDataSet/RowLevelPermissionTagConfiguration_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.QuickSight.ThemeType
        "Get-QSThemeList/Type"
        {
            $v = "ALL","CUSTOM","QUICKSIGHT"
            break
        }

        # Amazon.QuickSight.UserRole
        {
            ($_ -eq "Update-QSUser/Role") -Or
            ($_ -eq "Register-QSUser/UserRole")
        }
        {
            $v = "ADMIN","AUTHOR","READER","RESTRICTED_AUTHOR","RESTRICTED_READER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QS_map = @{
    "AssignmentStatus"=@("Get-QSIAMPolicyAssignmentList","New-QSIAMPolicyAssignment","Update-QSIAMPolicyAssignment")
    "AuthenticationMethod"=@("New-QSAccountSubscription")
    "DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus"=@("New-QSDashboard","Update-QSDashboard")
    "DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus"=@("New-QSDashboard","Update-QSDashboard")
    "DashboardPublishOptions_SheetControlsOption_VisibilityState"=@("New-QSDashboard","Update-QSDashboard")
    "Edition"=@("New-QSAccountSubscription")
    "FolderType"=@("New-QSFolder")
    "IdentityStore"=@("New-QSNamespace")
    "IdentityType"=@("Get-QSDashboardEmbedUrl","Register-QSUser")
    "ImportMode"=@("New-QSDataSet","Update-QSDataSet")
    "IngestionType"=@("New-QSIngestion")
    "MemberType"=@("New-QSFolderMembership","Remove-QSFolderMembership")
    "Role"=@("Update-QSUser")
    "RowLevelPermissionDataSet_FormatVersion"=@("New-QSDataSet","Update-QSDataSet")
    "RowLevelPermissionDataSet_PermissionPolicy"=@("New-QSDataSet","Update-QSDataSet")
    "RowLevelPermissionDataSet_Status"=@("New-QSDataSet","Update-QSDataSet")
    "RowLevelPermissionTagConfiguration_Status"=@("New-QSDataSet","Update-QSDataSet")
    "Type"=@("Get-QSThemeList","New-QSDataSource")
    "UserRole"=@("Register-QSUser")
}

_awsArgumentCompleterRegistration $QS_Completers $QS_map

$QS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QS_SelectMap = @{
    "Select"=@("Stop-QSIngestion",
               "New-QSAccountCustomization",
               "New-QSAccountSubscription",
               "New-QSAnalysis",
               "New-QSDashboard",
               "New-QSDataSet",
               "New-QSDataSource",
               "New-QSFolder",
               "New-QSFolderMembership",
               "New-QSGroup",
               "New-QSGroupMembership",
               "New-QSIAMPolicyAssignment",
               "New-QSIngestion",
               "New-QSNamespace",
               "New-QSTemplate",
               "New-QSTemplateAlias",
               "New-QSTheme",
               "New-QSThemeAlias",
               "Remove-QSAccountCustomization",
               "Remove-QSAnalysis",
               "Remove-QSDashboard",
               "Remove-QSDataSet",
               "Remove-QSDataSource",
               "Remove-QSFolder",
               "Remove-QSFolderMembership",
               "Remove-QSGroup",
               "Remove-QSGroupMembership",
               "Remove-QSIAMPolicyAssignment",
               "Remove-QSNamespace",
               "Remove-QSTemplate",
               "Remove-QSTemplateAlias",
               "Remove-QSTheme",
               "Remove-QSThemeAlias",
               "Remove-QSUser",
               "Remove-QSUserByPrincipalId",
               "Get-QSAccountCustomization",
               "Get-QSAccountSetting",
               "Get-QSAccountSubscription",
               "Get-QSAnalysis",
               "Get-QSAnalysisPermission",
               "Get-QSDashboard",
               "Get-QSDashboardPermission",
               "Get-QSDataSet",
               "Get-QSDataSetPermission",
               "Get-QSDataSource",
               "Get-QSDataSourcePermission",
               "Get-QSFolder",
               "Get-QSFolderPermission",
               "Get-QSFolderResolvedPermission",
               "Get-QSGroup",
               "Get-QSGroupMembership",
               "Get-QSIAMPolicyAssignment",
               "Get-QSIngestion",
               "Get-QSIpRestriction",
               "Get-QSNamespace",
               "Get-QSTemplate",
               "Get-QSTemplateAlias",
               "Get-QSTemplatePermission",
               "Get-QSTheme",
               "Get-QSThemeAlias",
               "Get-QSThemePermission",
               "Get-QSUser",
               "New-QSEmbedUrlForAnonymousUser",
               "New-QSEmbedUrlForRegisteredUser",
               "Get-QSDashboardEmbedUrl",
               "Get-QSSessionEmbedUrl",
               "Get-QSAnalysisList",
               "Get-QSDashboardList",
               "Get-QSDashboardVersionList",
               "Get-QSDataSetList",
               "Get-QSDataSourceList",
               "Get-QSFolderMemberList",
               "Get-QSFolderList",
               "Get-QSGroupMembershipList",
               "Get-QSGroupList",
               "Get-QSIAMPolicyAssignmentList",
               "Get-QSIAMPolicyAssignmentsForUserList",
               "Get-QSIngestionList",
               "Get-QSNamespaceList",
               "Get-QSResourceTag",
               "Get-QSTemplateAliasList",
               "Get-QSTemplateList",
               "Get-QSTemplateVersionList",
               "Get-QSThemeAliasList",
               "Get-QSThemeList",
               "Get-QSThemeVersionList",
               "Get-QSUserGroupList",
               "Get-QSUserList",
               "Register-QSUser",
               "Restore-QSAnalysis",
               "Search-QSAnalysis",
               "Search-QSDashboard",
               "Search-QSFolder",
               "Find-QSGroup",
               "Add-QSResourceTag",
               "Remove-QSResourceTag",
               "Update-QSAccountCustomization",
               "Update-QSAccountSetting",
               "Update-QSAnalysis",
               "Update-QSAnalysisPermission",
               "Update-QSDashboard",
               "Update-QSDashboardPermission",
               "Update-QSDashboardPublishedVersion",
               "Update-QSDataSet",
               "Update-QSDataSetPermission",
               "Update-QSDataSource",
               "Update-QSDataSourcePermission",
               "Update-QSFolder",
               "Update-QSFolderPermission",
               "Update-QSGroup",
               "Update-QSIAMPolicyAssignment",
               "Update-QSIpRestriction",
               "Update-QSPublicSharingSetting",
               "Update-QSTemplate",
               "Update-QSTemplateAlias",
               "Update-QSTemplatePermission",
               "Update-QSTheme",
               "Update-QSThemeAlias",
               "Update-QSThemePermission",
               "Update-QSUser")
}

_awsArgumentCompleterRegistration $QS_SelectCompleters $QS_SelectMap
# Argument completions for service AWS Resource Access Manager (RAM)


$RAM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RAM.ResourceOwner
        {
            ($_ -eq "Get-RAMPrincipalList/ResourceOwner") -Or
            ($_ -eq "Get-RAMResourceList/ResourceOwner") -Or
            ($_ -eq "Get-RAMResourceShare/ResourceOwner")
        }
        {
            $v = "OTHER-ACCOUNTS","SELF"
            break
        }

        # Amazon.RAM.ResourceRegionScopeFilter
        {
            ($_ -eq "Get-RAMPendingInvitationResourceList/ResourceRegionScope") -Or
            ($_ -eq "Get-RAMResourceList/ResourceRegionScope") -Or
            ($_ -eq "Get-RAMResourceTypeList/ResourceRegionScope")
        }
        {
            $v = "ALL","GLOBAL","REGIONAL"
            break
        }

        # Amazon.RAM.ResourceShareAssociationStatus
        "Get-RAMResourceShareAssociation/AssociationStatus"
        {
            $v = "ASSOCIATED","ASSOCIATING","DISASSOCIATED","DISASSOCIATING","FAILED"
            break
        }

        # Amazon.RAM.ResourceShareAssociationType
        "Get-RAMResourceShareAssociation/AssociationType"
        {
            $v = "PRINCIPAL","RESOURCE"
            break
        }

        # Amazon.RAM.ResourceShareStatus
        "Get-RAMResourceShare/ResourceShareStatus"
        {
            $v = "ACTIVE","DELETED","DELETING","FAILED","PENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RAM_map = @{
    "AssociationStatus"=@("Get-RAMResourceShareAssociation")
    "AssociationType"=@("Get-RAMResourceShareAssociation")
    "ResourceOwner"=@("Get-RAMPrincipalList","Get-RAMResourceList","Get-RAMResourceShare")
    "ResourceRegionScope"=@("Get-RAMPendingInvitationResourceList","Get-RAMResourceList","Get-RAMResourceTypeList")
    "ResourceShareStatus"=@("Get-RAMResourceShare")
}

_awsArgumentCompleterRegistration $RAM_Completers $RAM_map

$RAM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RAM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RAM_SelectMap = @{
    "Select"=@("Confirm-RAMResourceShareInvitation",
               "Connect-RAMResourceShare",
               "Add-RAMPermissionToResourceShare",
               "New-RAMResourceShare",
               "Remove-RAMResourceShare",
               "Disconnect-RAMResourceShare",
               "Remove-RAMPermissionFromResourceShare",
               "Enable-RAMSharingWithAwsOrganization",
               "Get-RAMPermission",
               "Get-RAMResourcePolicy",
               "Get-RAMResourceShareAssociation",
               "Get-RAMResourceShareInvitation",
               "Get-RAMResourceShare",
               "Get-RAMPendingInvitationResourceList",
               "Get-RAMPermissionList",
               "Get-RAMPermissionVersionList",
               "Get-RAMPrincipalList",
               "Get-RAMResourceList",
               "Get-RAMResourceSharePermissionList",
               "Get-RAMResourceTypeList",
               "Convert-RAMPolicyBasedResourceShareToPromoted",
               "Deny-RAMResourceShareInvitation",
               "Add-RAMResourceTag",
               "Remove-RAMResourceTag",
               "Update-RAMResourceShare")
}

_awsArgumentCompleterRegistration $RAM_SelectCompleters $RAM_SelectMap
# Argument completions for service Amazon Recycle Bin


$RBIN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RecycleBin.ResourceType
        {
            ($_ -eq "Get-RBINRuleList/ResourceType") -Or
            ($_ -eq "New-RBINRule/ResourceType") -Or
            ($_ -eq "Update-RBINRule/ResourceType")
        }
        {
            $v = "EBS_SNAPSHOT","EC2_IMAGE"
            break
        }

        # Amazon.RecycleBin.RetentionPeriodUnit
        {
            ($_ -eq "New-RBINRule/RetentionPeriod_RetentionPeriodUnit") -Or
            ($_ -eq "Update-RBINRule/RetentionPeriod_RetentionPeriodUnit")
        }
        {
            $v = "DAYS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RBIN_map = @{
    "ResourceType"=@("Get-RBINRuleList","New-RBINRule","Update-RBINRule")
    "RetentionPeriod_RetentionPeriodUnit"=@("New-RBINRule","Update-RBINRule")
}

_awsArgumentCompleterRegistration $RBIN_Completers $RBIN_map

$RBIN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RBIN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RBIN_SelectMap = @{
    "Select"=@("New-RBINRule",
               "Remove-RBINRule",
               "Get-RBINRule",
               "Get-RBINRuleList",
               "Get-RBINResourceTag",
               "Add-RBINResourceTag",
               "Remove-RBINResourceTag",
               "Update-RBINRule")
}

_awsArgumentCompleterRegistration $RBIN_SelectCompleters $RBIN_SelectMap
# Argument completions for service Amazon Relational Database Service


$RDS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RDS.ActivityStreamMode
        "Start-RDSActivityStream/Mode"
        {
            $v = "async","sync"
            break
        }

        # Amazon.RDS.AuditPolicyState
        "Edit-RDSActivityStream/AuditPolicyState"
        {
            $v = "locked","unlocked"
            break
        }

        # Amazon.RDS.AutomationMode
        "Edit-RDSDBInstance/AutomationMode"
        {
            $v = "all-paused","full"
            break
        }

        # Amazon.RDS.CustomEngineVersionStatus
        "Edit-RDSCustomDBEngineVersion/Status"
        {
            $v = "available","inactive","inactive-except-restore"
            break
        }

        # Amazon.RDS.DBProxyEndpointTargetRole
        "New-RDSDBProxyEndpoint/TargetRole"
        {
            $v = "READ_ONLY","READ_WRITE"
            break
        }

        # Amazon.RDS.EngineFamily
        "New-RDSDBProxy/EngineFamily"
        {
            $v = "MYSQL","POSTGRESQL","SQLSERVER"
            break
        }

        # Amazon.RDS.ExportSourceType
        "Get-RDSExportTask/SourceType"
        {
            $v = "CLUSTER","SNAPSHOT"
            break
        }

        # Amazon.RDS.ReplicaMode
        {
            ($_ -eq "Edit-RDSDBInstance/ReplicaMode") -Or
            ($_ -eq "New-RDSDBInstanceReadReplica/ReplicaMode")
        }
        {
            $v = "mounted","open-read-only"
            break
        }

        # Amazon.RDS.SourceType
        "Get-RDSEvent/SourceType"
        {
            $v = "custom-engine-version","db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-proxy","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDS_map = @{
    "AuditPolicyState"=@("Edit-RDSActivityStream")
    "AutomationMode"=@("Edit-RDSDBInstance")
    "EngineFamily"=@("New-RDSDBProxy")
    "Mode"=@("Start-RDSActivityStream")
    "ReplicaMode"=@("Edit-RDSDBInstance","New-RDSDBInstanceReadReplica")
    "SourceType"=@("Get-RDSEvent","Get-RDSExportTask")
    "Status"=@("Edit-RDSCustomDBEngineVersion")
    "TargetRole"=@("New-RDSDBProxyEndpoint")
}

_awsArgumentCompleterRegistration $RDS_Completers $RDS_map

$RDS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RDS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDS_SelectMap = @{
    "Select"=@("Add-RDSRoleToDBCluster",
               "Add-RDSRoleToDBInstance",
               "Add-RDSSourceIdentifierToSubscription",
               "Add-RDSTagsToResource",
               "Submit-RDSPendingMaintenanceAction",
               "Enable-RDSDBSecurityGroupIngress",
               "Reset-RDSDBCluster",
               "Stop-RDSExportTask",
               "Copy-RDSDBClusterParameterGroup",
               "Copy-RDSDBClusterSnapshot",
               "Copy-RDSDBParameterGroup",
               "Copy-RDSDBSnapshot",
               "Copy-RDSOptionGroup",
               "New-RDSCustomDBEngineVersion",
               "New-RDSDBCluster",
               "New-RDSDBClusterEndpoint",
               "New-RDSDBClusterParameterGroup",
               "New-RDSDBClusterSnapshot",
               "New-RDSDBInstance",
               "New-RDSDBInstanceReadReplica",
               "New-RDSDBParameterGroup",
               "New-RDSDBProxy",
               "New-RDSDBProxyEndpoint",
               "New-RDSDBSecurityGroup",
               "New-RDSDBSnapshot",
               "New-RDSDBSubnetGroup",
               "New-RDSEventSubscription",
               "New-RDSGlobalCluster",
               "New-RDSOptionGroup",
               "Remove-RDSCustomDBEngineVersion",
               "Remove-RDSDBCluster",
               "Remove-RDSDBClusterEndpoint",
               "Remove-RDSDBClusterParameterGroup",
               "Remove-RDSDBClusterSnapshot",
               "Remove-RDSDBInstance",
               "Remove-RDSDBInstanceAutomatedBackup",
               "Remove-RDSDBParameterGroup",
               "Remove-RDSDBProxy",
               "Remove-RDSDBProxyEndpoint",
               "Remove-RDSDBSecurityGroup",
               "Remove-RDSDBSnapshot",
               "Remove-RDSDBSubnetGroup",
               "Remove-RDSEventSubscription",
               "Remove-RDSGlobalCluster",
               "Remove-RDSOptionGroup",
               "Unregister-RDSDBProxyTarget",
               "Get-RDSAccountAttribute",
               "Get-RDSCertificate",
               "Get-RDSDBClusterBacktrackList",
               "Get-RDSDBClusterEndpoint",
               "Get-RDSDBClusterParameterGroup",
               "Get-RDSDBClusterParameter",
               "Get-RDSDBCluster",
               "Get-RDSDBClusterSnapshotAttribute",
               "Get-RDSDBClusterSnapshot",
               "Get-RDSDBEngineVersion",
               "Get-RDSDBInstanceAutomatedBackup",
               "Get-RDSDBInstance",
               "Get-RDSDBLogFile",
               "Get-RDSDBParameterGroup",
               "Get-RDSDBParameter",
               "Get-RDSDBProxy",
               "Get-RDSDBProxyEndpoint",
               "Get-RDSDBProxyTargetGroup",
               "Get-RDSDBProxyTarget",
               "Get-RDSDBSecurityGroup",
               "Get-RDSDBSnapshotAttribute",
               "Get-RDSDBSnapshot",
               "Get-RDSDBSubnetGroup",
               "Get-RDSEngineDefaultClusterParameter",
               "Get-RDSEngineDefaultParameter",
               "Get-RDSEventCategory",
               "Get-RDSEvent",
               "Get-RDSEventSubscription",
               "Get-RDSExportTask",
               "Get-RDSGlobalCluster",
               "Get-RDSOptionGroupOption",
               "Get-RDSOptionGroup",
               "Get-RDSOrderableDBInstanceOption",
               "Get-RDSPendingMaintenanceAction",
               "Get-RDSReservedDBInstance",
               "Get-RDSReservedDBInstancesOfferingList",
               "Get-RDSSourceRegion",
               "Get-RDSValidDBInstanceModification",
               "Get-RDSDBLogFilePortion",
               "Start-RDSDBClusterFailover",
               "Start-RDSFailoverGlobalCluster",
               "Get-RDSTagForResource",
               "Edit-RDSActivityStream",
               "Edit-RDSCertificate",
               "Edit-RDSCurrentDBClusterCapacity",
               "Edit-RDSCustomDBEngineVersion",
               "Edit-RDSDBCluster",
               "Edit-RDSDBClusterEndpoint",
               "Edit-RDSDBClusterParameterGroup",
               "Edit-RDSDBClusterSnapshotAttribute",
               "Edit-RDSDBInstance",
               "Edit-RDSDBParameterGroup",
               "Edit-RDSDBProxy",
               "Edit-RDSDBProxyEndpoint",
               "Edit-RDSDBProxyTargetGroup",
               "Edit-RDSDBSnapshot",
               "Edit-RDSDBSnapshotAttribute",
               "Edit-RDSDBSubnetGroup",
               "Edit-RDSEventSubscription",
               "Edit-RDSGlobalCluster",
               "Edit-RDSOptionGroup",
               "Convert-RDSReadReplicaToStandalone",
               "Convert-RDSReadReplicaDBCluster",
               "New-RDSReservedDBInstancesOfferingPurchase",
               "Restart-RDSDBCluster",
               "Restart-RDSDBInstance",
               "Register-RDSDBProxyTarget",
               "Remove-RDSFromGlobalCluster",
               "Remove-RDSRoleFromDBCluster",
               "Remove-RDSRoleFromDBInstance",
               "Remove-RDSSourceIdentifierFromSubscription",
               "Remove-RDSTagFromResource",
               "Reset-RDSDBClusterParameterGroup",
               "Reset-RDSDBParameterGroup",
               "Restore-RDSDBClusterFromS3",
               "Restore-RDSDBClusterFromSnapshot",
               "Restore-RDSDBClusterToPointInTime",
               "Restore-RDSDBInstanceFromDBSnapshot",
               "Restore-RDSDBInstanceFromS3",
               "Restore-RDSDBInstanceToPointInTime",
               "Revoke-RDSDBSecurityGroupIngress",
               "Start-RDSActivityStream",
               "Start-RDSDBCluster",
               "Start-RDSDBInstance",
               "Start-RDSDBInstanceAutomatedBackupsReplication",
               "Start-RDSExportTask",
               "Stop-RDSActivityStream",
               "Stop-RDSDBCluster",
               "Stop-RDSDBInstance",
               "Stop-RDSDBInstanceAutomatedBackupsReplication",
               "Convert-RDSReadReplicaToNewPrimary")
}

_awsArgumentCompleterRegistration $RDS_SelectCompleters $RDS_SelectMap
# Argument completions for service AWS RDS DataService


$RDSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RDSDataService.DecimalReturnType
        "Invoke-RDSDStatement/ResultSetOptions_DecimalReturnType"
        {
            $v = "DOUBLE_OR_LONG","STRING"
            break
        }

        # Amazon.RDSDataService.LongReturnType
        "Invoke-RDSDStatement/ResultSetOptions_LongReturnType"
        {
            $v = "LONG","STRING"
            break
        }

        # Amazon.RDSDataService.RecordsFormatType
        "Invoke-RDSDStatement/FormatRecordsAs"
        {
            $v = "JSON","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDSD_map = @{
    "FormatRecordsAs"=@("Invoke-RDSDStatement")
    "ResultSetOptions_DecimalReturnType"=@("Invoke-RDSDStatement")
    "ResultSetOptions_LongReturnType"=@("Invoke-RDSDStatement")
}

_awsArgumentCompleterRegistration $RDSD_Completers $RDSD_map

$RDSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RDSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDSD_SelectMap = @{
    "Select"=@("Invoke-RDSDStatementBatch",
               "Start-RDSDTransaction",
               "Confirm-RDSDTransaction",
               "Invoke-RDSDSqlStatement",
               "Invoke-RDSDStatement",
               "Reset-RDSDTransaction")
}

_awsArgumentCompleterRegistration $RDSD_SelectCompleters $RDSD_SelectMap
# Argument completions for service Amazon Redshift


$RS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Redshift.ActionType
        "Get-RSNodeConfigurationOption/ActionType"
        {
            $v = "recommend-node-config","resize-cluster","restore-cluster"
            break
        }

        # Amazon.Redshift.AquaConfigurationStatus
        {
            ($_ -eq "Edit-RSAquaConfiguration/AquaConfigurationStatus") -Or
            ($_ -eq "New-RSCluster/AquaConfigurationStatus") -Or
            ($_ -eq "Restore-RSFromClusterSnapshot/AquaConfigurationStatus")
        }
        {
            $v = "auto","disabled","enabled"
            break
        }

        # Amazon.Redshift.DataShareStatusForConsumer
        "Get-RSDataSharesForConsumer/Status"
        {
            $v = "ACTIVE","AVAILABLE"
            break
        }

        # Amazon.Redshift.DataShareStatusForProducer
        "Get-RSDataSharesForProducer/Status"
        {
            $v = "ACTIVE","AUTHORIZED","DEAUTHORIZED","PENDING_AUTHORIZATION","REJECTED"
            break
        }

        # Amazon.Redshift.LogDestinationType
        "Enable-RSLogging/LogDestinationType"
        {
            $v = "cloudwatch","s3"
            break
        }

        # Amazon.Redshift.PartnerIntegrationStatus
        "Update-RSPartnerStatus/Status"
        {
            $v = "Active","ConnectionFailure","Inactive","RuntimeFailure"
            break
        }

        # Amazon.Redshift.ReservedNodeExchangeActionType
        "Get-RSReservedNodeExchangeConfigurationOption/ActionType"
        {
            $v = "resize-cluster","restore-cluster"
            break
        }

        # Amazon.Redshift.ScheduledActionTypeValues
        "Get-RSScheduledAction/TargetActionType"
        {
            $v = "PauseCluster","ResizeCluster","ResumeCluster"
            break
        }

        # Amazon.Redshift.SourceType
        "Get-RSEvent/SourceType"
        {
            $v = "cluster","cluster-parameter-group","cluster-security-group","cluster-snapshot","scheduled-action"
            break
        }

        # Amazon.Redshift.UsageLimitBreachAction
        {
            ($_ -eq "Edit-RSUsageLimit/BreachAction") -Or
            ($_ -eq "New-RSUsageLimit/BreachAction")
        }
        {
            $v = "disable","emit-metric","log"
            break
        }

        # Amazon.Redshift.UsageLimitFeatureType
        {
            ($_ -eq "Get-RSUsageLimit/FeatureType") -Or
            ($_ -eq "New-RSUsageLimit/FeatureType")
        }
        {
            $v = "concurrency-scaling","cross-region-datasharing","spectrum"
            break
        }

        # Amazon.Redshift.UsageLimitLimitType
        "New-RSUsageLimit/LimitType"
        {
            $v = "data-scanned","time"
            break
        }

        # Amazon.Redshift.UsageLimitPeriod
        "New-RSUsageLimit/Period"
        {
            $v = "daily","monthly","weekly"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RS_map = @{
    "ActionType"=@("Get-RSNodeConfigurationOption","Get-RSReservedNodeExchangeConfigurationOption")
    "AquaConfigurationStatus"=@("Edit-RSAquaConfiguration","New-RSCluster","Restore-RSFromClusterSnapshot")
    "BreachAction"=@("Edit-RSUsageLimit","New-RSUsageLimit")
    "FeatureType"=@("Get-RSUsageLimit","New-RSUsageLimit")
    "LimitType"=@("New-RSUsageLimit")
    "LogDestinationType"=@("Enable-RSLogging")
    "Period"=@("New-RSUsageLimit")
    "SourceType"=@("Get-RSEvent")
    "Status"=@("Get-RSDataSharesForConsumer","Get-RSDataSharesForProducer","Update-RSPartnerStatus")
    "TargetActionType"=@("Get-RSScheduledAction")
}

_awsArgumentCompleterRegistration $RS_Completers $RS_map

$RS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RS_SelectMap = @{
    "Select"=@("Switch-RSReservedNode",
               "Add-RSPartner",
               "Add-RSDataShareConsumer",
               "Approve-RSClusterSecurityGroupIngress",
               "Approve-RSDataShare",
               "Approve-RSEndpointAccess",
               "Approve-RSSnapshotAccess",
               "Remove-RSClusterSnapshotBatch",
               "Edit-RSClusterSnapshotBatch",
               "Stop-RSResize",
               "Copy-RSClusterSnapshot",
               "New-RSAuthenticationProfile",
               "New-RSCluster",
               "New-RSClusterParameterGroup",
               "New-RSClusterSecurityGroup",
               "New-RSClusterSnapshot",
               "New-RSClusterSubnetGroup",
               "New-RSEndpointAccess",
               "New-RSEventSubscription",
               "New-RSHsmClientCertificate",
               "New-RSHsmConfiguration",
               "New-RSScheduledAction",
               "New-RSSnapshotCopyGrant",
               "New-RSSnapshotSchedule",
               "New-RSResourceTag",
               "New-RSUsageLimit",
               "Revoke-RSDataShare",
               "Remove-RSAuthenticationProfile",
               "Remove-RSCluster",
               "Remove-RSClusterParameterGroup",
               "Remove-RSClusterSecurityGroup",
               "Remove-RSClusterSnapshot",
               "Remove-RSClusterSubnetGroup",
               "Remove-RSEndpointAccess",
               "Remove-RSEventSubscription",
               "Remove-RSHsmClientCertificate",
               "Remove-RSHsmConfiguration",
               "Remove-RSPartner",
               "Remove-RSScheduledAction",
               "Remove-RSSnapshotCopyGrant",
               "Remove-RSSnapshotSchedule",
               "Remove-RSResourceTag",
               "Remove-RSUsageLimit",
               "Get-RSAccountAttribute",
               "Get-RSAuthenticationProfile",
               "Get-RSClusterDbRevision",
               "Get-RSClusterParameterGroup",
               "Get-RSClusterParameter",
               "Get-RSCluster",
               "Get-RSClusterSecurityGroup",
               "Get-RSClusterSnapshot",
               "Get-RSClusterSubnetGroup",
               "Get-RSClusterTrack",
               "Get-RSClusterVersion",
               "Get-RSDataShare",
               "Get-RSDataSharesForConsumer",
               "Get-RSDataSharesForProducer",
               "Get-RSDefaultClusterParameter",
               "Get-RSEndpointAccess",
               "Get-RSEndpointAuthorization",
               "Get-RSEventCategory",
               "Get-RSEvent",
               "Get-RSEventSubscription",
               "Get-RSHsmClientCertificate",
               "Get-RSHsmConfiguration",
               "Get-RSLoggingStatus",
               "Get-RSNodeConfigurationOption",
               "Get-RSOrderableClusterOption",
               "Get-RSPartner",
               "Get-RSReservedNodeExchangeStatus",
               "Get-RSReservedNodeOffering",
               "Get-RSReservedNode",
               "Get-RSResize",
               "Get-RSScheduledAction",
               "Get-RSSnapshotCopyGrant",
               "Get-RSSnapshotSchedule",
               "Get-RSStorage",
               "Get-RSTableRestoreStatus",
               "Get-RSResourceTag",
               "Get-RSUsageLimit",
               "Disable-RSLogging",
               "Disable-RSSnapshotCopy",
               "Remove-RSDataShareConsumer",
               "Enable-RSLogging",
               "Enable-RSSnapshotCopy",
               "Get-RSClusterCredential",
               "Get-RSClusterCredentialsWithIAM",
               "Get-RSReservedNodeExchangeConfigurationOption",
               "Get-RSReservedNodeExchangeOffering",
               "Edit-RSAquaConfiguration",
               "Edit-RSAuthenticationProfile",
               "Edit-RSCluster",
               "Edit-RSClusterDbRevision",
               "Edit-RSClusterIamRole",
               "Edit-RSClusterMaintenance",
               "Edit-RSClusterParameterGroup",
               "Edit-RSClusterSnapshot",
               "Edit-RSClusterSnapshotSchedule",
               "Edit-RSClusterSubnetGroup",
               "Edit-RSEndpointAccess",
               "Edit-RSEventSubscription",
               "Edit-RSScheduledAction",
               "Edit-RSSnapshotCopyRetentionPeriod",
               "Edit-RSSnapshotSchedule",
               "Edit-RSUsageLimit",
               "Stop-RSCluster",
               "Request-RSReservedNodeOffering",
               "Restart-RSCluster",
               "Deny-RSDataShare",
               "Reset-RSClusterParameterGroup",
               "Set-RSClusterSize",
               "Restore-RSFromClusterSnapshot",
               "Restore-RSTableFromClusterSnapshot",
               "Start-RSCluster",
               "Revoke-RSClusterSecurityGroupIngress",
               "Revoke-RSEndpointAccess",
               "Revoke-RSSnapshotAccess",
               "Switch-RSEncryptionKey",
               "Update-RSPartnerStatus")
}

_awsArgumentCompleterRegistration $RS_SelectCompleters $RS_SelectMap
# Argument completions for service Redshift Data API Service


$RSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RedshiftDataAPIService.StatusString
        "Get-RSDStatementList/Status"
        {
            $v = "ABORTED","ALL","FAILED","FINISHED","PICKED","STARTED","SUBMITTED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RSD_map = @{
    "Status"=@("Get-RSDStatementList")
}

_awsArgumentCompleterRegistration $RSD_Completers $RSD_map

$RSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RSD_SelectMap = @{
    "Select"=@("Push-RSDBatchStatement",
               "Stop-RSDStatement",
               "Get-RSDStatement",
               "Get-RSDTable",
               "Send-RSDStatement",
               "Get-RSDStatementResult",
               "Get-RSDDatabasisList",
               "Get-RSDSchemaList",
               "Get-RSDStatementList",
               "Get-RSDTableList")
}

_awsArgumentCompleterRegistration $RSD_SelectCompleters $RSD_SelectMap
# Argument completions for service Redshift Serverless


$RSS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RedshiftServerless.UsageLimitBreachAction
        {
            ($_ -eq "New-RSSUsageLimit/BreachAction") -Or
            ($_ -eq "Update-RSSUsageLimit/BreachAction")
        }
        {
            $v = "deactivate","emit-metric","log"
            break
        }

        # Amazon.RedshiftServerless.UsageLimitPeriod
        "New-RSSUsageLimit/Period"
        {
            $v = "daily","monthly","weekly"
            break
        }

        # Amazon.RedshiftServerless.UsageLimitUsageType
        {
            ($_ -eq "Get-RSSUsageLimitList/UsageType") -Or
            ($_ -eq "New-RSSUsageLimit/UsageType")
        }
        {
            $v = "cross-region-datasharing","serverless-compute"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RSS_map = @{
    "BreachAction"=@("New-RSSUsageLimit","Update-RSSUsageLimit")
    "Period"=@("New-RSSUsageLimit")
    "UsageType"=@("Get-RSSUsageLimitList","New-RSSUsageLimit")
}

_awsArgumentCompleterRegistration $RSS_Completers $RSS_map

$RSS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RSS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RSS_SelectMap = @{
    "Select"=@("Convert-RSSRecoveryPointToSnapshot",
               "New-RSSEndpointAccess",
               "New-RSSNamespace",
               "New-RSSSnapshot",
               "New-RSSUsageLimit",
               "New-RSSWorkgroup",
               "Remove-RSSEndpointAccess",
               "Remove-RSSNamespace",
               "Remove-RSSResourcePolicy",
               "Remove-RSSSnapshot",
               "Remove-RSSUsageLimit",
               "Remove-RSSWorkgroup",
               "Get-RSSCredential",
               "Get-RSSEndpointAccess",
               "Get-RSSNamespace",
               "Get-RSSRecoveryPoint",
               "Get-RSSResourcePolicy",
               "Get-RSSSnapshot",
               "Get-RSSUsageLimit",
               "Get-RSSWorkgroup",
               "Get-RSSEndpointAccessList",
               "Get-RSSNamespaceList",
               "Get-RSSRecoveryPointList",
               "Get-RSSSnapshotList",
               "Get-RSSResourceTag",
               "Get-RSSUsageLimitList",
               "Get-RSSWorkgroupList",
               "Write-RSSResourcePolicy",
               "Restore-RSSFromRecoveryPoint",
               "Restore-RSSFromSnapshot",
               "Add-RSSResourceTag",
               "Remove-RSSResourceTag",
               "Update-RSSEndpointAccess",
               "Update-RSSNamespace",
               "Update-RSSSnapshot",
               "Update-RSSUsageLimit",
               "Update-RSSWorkgroup")
}

_awsArgumentCompleterRegistration $RSS_SelectCompleters $RSS_SelectMap
# Argument completions for service Amazon Rekognition


$REK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Rekognition.CelebrityRecognitionSortBy
        "Get-REKCelebrityRecognition/SortBy"
        {
            $v = "ID","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.ContentModerationSortBy
        "Get-REKContentModeration/SortBy"
        {
            $v = "NAME","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.DatasetType
        "New-REKDataset/DatasetType"
        {
            $v = "TEST","TRAIN"
            break
        }

        # Amazon.Rekognition.FaceAttributes
        "Start-REKFaceDetection/FaceAttributes"
        {
            $v = "ALL","DEFAULT"
            break
        }

        # Amazon.Rekognition.FaceSearchSortBy
        "Get-REKFaceSearch/SortBy"
        {
            $v = "INDEX","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.LabelDetectionSortBy
        "Get-REKLabelDetection/SortBy"
        {
            $v = "NAME","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.PersonTrackingSortBy
        "Get-REKPersonTracking/SortBy"
        {
            $v = "INDEX","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.QualityFilter
        {
            ($_ -eq "Add-REKDetectedFacesToCollection/QualityFilter") -Or
            ($_ -eq "Compare-REKFace/QualityFilter") -Or
            ($_ -eq "Search-REKFacesByImage/QualityFilter")
        }
        {
            $v = "AUTO","HIGH","LOW","MEDIUM","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$REK_map = @{
    "DatasetType"=@("New-REKDataset")
    "FaceAttributes"=@("Start-REKFaceDetection")
    "QualityFilter"=@("Add-REKDetectedFacesToCollection","Compare-REKFace","Search-REKFacesByImage")
    "SortBy"=@("Get-REKCelebrityRecognition","Get-REKContentModeration","Get-REKFaceSearch","Get-REKLabelDetection","Get-REKPersonTracking")
}

_awsArgumentCompleterRegistration $REK_Completers $REK_map

$REK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.REK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$REK_SelectMap = @{
    "Select"=@("Compare-REKFace",
               "Copy-REKProjectVersion",
               "New-REKCollection",
               "New-REKDataset",
               "New-REKProject",
               "New-REKProjectVersion",
               "New-REKStreamProcessor",
               "Remove-REKCollection",
               "Remove-REKDataset",
               "Remove-REKFace",
               "Remove-REKProject",
               "Remove-REKProjectPolicy",
               "Remove-REKProjectVersion",
               "Remove-REKStreamProcessor",
               "Get-REKCollection",
               "Get-REKDataset",
               "Get-REKProject",
               "Get-REKProjectVersion",
               "Get-REKStreamProcessor",
               "Find-REKCustomLabel",
               "Find-REKFace",
               "Find-REKLabel",
               "Find-REKModerationLabel",
               "Find-REKProtectiveEquipment",
               "Find-REKText",
               "Invoke-REKDistributeDatasetEntry",
               "Get-REKCelebrityInfo",
               "Get-REKCelebrityRecognition",
               "Get-REKContentModeration",
               "Get-REKFaceDetection",
               "Get-REKFaceSearch",
               "Get-REKLabelDetection",
               "Get-REKPersonTracking",
               "Get-REKSegmentDetection",
               "Get-REKTextDetection",
               "Add-REKDetectedFacesToCollection",
               "Get-REKCollectionIdList",
               "Get-REKDatasetEntryList",
               "Get-REKDatasetLabelList",
               "Get-REKFaceList",
               "Get-REKProjectPolicyList",
               "Get-REKStreamProcessorList",
               "Get-REKResourceTag",
               "Write-REKProjectPolicy",
               "Find-REKCelebrity",
               "Search-REKFace",
               "Search-REKFacesByImage",
               "Start-REKCelebrityRecognition",
               "Start-REKContentModeration",
               "Start-REKFaceDetection",
               "Start-REKFaceSearch",
               "Start-REKLabelDetection",
               "Start-REKPersonTracking",
               "Start-REKProjectVersion",
               "Start-REKSegmentDetection",
               "Start-REKStreamProcessor",
               "Start-REKTextDetection",
               "Stop-REKProjectVersion",
               "Stop-REKStreamProcessor",
               "Add-REKResourceTag",
               "Remove-REKResourceTag",
               "Update-REKDatasetEntry",
               "Update-REKStreamProcessor")
}

_awsArgumentCompleterRegistration $REK_SelectCompleters $REK_SelectMap
# Argument completions for service AWS Resilience Hub


$RESH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ResilienceHub.AppAssessmentScheduleType
        {
            ($_ -eq "New-RESHApp/AssessmentSchedule") -Or
            ($_ -eq "Update-RESHApp/AssessmentSchedule")
        }
        {
            $v = "Daily","Disabled"
            break
        }

        # Amazon.ResilienceHub.AssessmentInvoker
        "Get-RESHAppAssessmentList/Invoker"
        {
            $v = "System","User"
            break
        }

        # Amazon.ResilienceHub.ComplianceStatus
        "Get-RESHAppAssessmentList/ComplianceStatus"
        {
            $v = "PolicyBreached","PolicyMet"
            break
        }

        # Amazon.ResilienceHub.DataLocationConstraint
        {
            ($_ -eq "New-RESHResiliencyPolicy/DataLocationConstraint") -Or
            ($_ -eq "Update-RESHResiliencyPolicy/DataLocationConstraint")
        }
        {
            $v = "AnyLocation","SameContinent","SameCountry"
            break
        }

        # Amazon.ResilienceHub.ResiliencyPolicyTier
        {
            ($_ -eq "New-RESHResiliencyPolicy/Tier") -Or
            ($_ -eq "Update-RESHResiliencyPolicy/Tier")
        }
        {
            $v = "CoreServices","Critical","Important","MissionCritical","NonCritical"
            break
        }

        # Amazon.ResilienceHub.TemplateFormat
        "New-RESHRecommendationTemplate/Format"
        {
            $v = "CfnJson","CfnYaml"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RESH_map = @{
    "AssessmentSchedule"=@("New-RESHApp","Update-RESHApp")
    "ComplianceStatus"=@("Get-RESHAppAssessmentList")
    "DataLocationConstraint"=@("New-RESHResiliencyPolicy","Update-RESHResiliencyPolicy")
    "Format"=@("New-RESHRecommendationTemplate")
    "Invoker"=@("Get-RESHAppAssessmentList")
    "Tier"=@("New-RESHResiliencyPolicy","Update-RESHResiliencyPolicy")
}

_awsArgumentCompleterRegistration $RESH_Completers $RESH_map

$RESH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RESH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RESH_SelectMap = @{
    "Select"=@("Add-RESHDraftAppVersionResourceMapping",
               "New-RESHApp",
               "New-RESHRecommendationTemplate",
               "New-RESHResiliencyPolicy",
               "Remove-RESHApp",
               "Remove-RESHAppAssessment",
               "Remove-RESHRecommendationTemplate",
               "Remove-RESHResiliencyPolicy",
               "Get-RESHApp",
               "Get-RESHAppAssessment",
               "Get-RESHAppVersionResourcesResolutionStatus",
               "Get-RESHAppVersionTemplate",
               "Get-RESHDraftAppVersionResourcesImportStatus",
               "Get-RESHResiliencyPolicy",
               "Import-RESHResourcesToDraftAppVersion",
               "Get-RESHAlarmRecommendationList",
               "Get-RESHAppAssessmentList",
               "Get-RESHAppComponentComplianceList",
               "Get-RESHAppComponentRecommendationList",
               "Get-RESHAppList",
               "Get-RESHAppVersionResourceMappingList",
               "Get-RESHAppVersionResourceList",
               "Get-RESHAppVersionList",
               "Get-RESHRecommendationTemplateList",
               "Get-RESHResiliencyPolicyList",
               "Get-RESHSopRecommendationList",
               "Get-RESHSuggestedResiliencyPolicyList",
               "Get-RESHResourceTag",
               "Get-RESHTestRecommendationList",
               "Get-RESHUnsupportedAppVersionResourceList",
               "Publish-RESHAppVersion",
               "Write-RESHDraftAppVersionTemplate",
               "Remove-RESHDraftAppVersionResourceMapping",
               "Resolve-RESHAppVersionResource",
               "Start-RESHAppAssessment",
               "Add-RESHResourceTag",
               "Remove-RESHResourceTag",
               "Update-RESHApp",
               "Update-RESHResiliencyPolicy")
}

_awsArgumentCompleterRegistration $RESH_SelectCompleters $RESH_SelectMap
# Argument completions for service AWS Resource Explorer


$AREX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ResourceExplorer2.IndexType
        {
            ($_ -eq "Get-AREXIndexList/Type") -Or
            ($_ -eq "Update-AREXIndexType/Type")
        }
        {
            $v = "AGGREGATOR","LOCAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AREX_map = @{
    "Type"=@("Get-AREXIndexList","Update-AREXIndexType")
}

_awsArgumentCompleterRegistration $AREX_Completers $AREX_map

$AREX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AREX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AREX_SelectMap = @{
    "Select"=@("Register-AREXDefaultView",
               "Get-AREXViewBatch",
               "New-AREXIndex",
               "New-AREXView",
               "Remove-AREXIndex",
               "Remove-AREXView",
               "Unregister-AREXDefaultView",
               "Get-AREXDefaultView",
               "Get-AREXIndex",
               "Get-AREXView",
               "Get-AREXIndexList",
               "Get-AREXSupportedResourceTypeList",
               "Get-AREXResourceTag",
               "Get-AREXViewArnList",
               "Search-AREXResource",
               "Add-AREXResourceTag",
               "Remove-AREXResourceTag",
               "Update-AREXIndexType",
               "Update-AREXView")
}

_awsArgumentCompleterRegistration $AREX_SelectCompleters $AREX_SelectMap
# Argument completions for service AWS Resource Groups


$RG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RG_SelectMap = @{
    "Select"=@("New-RGGroup",
               "Remove-RGGroup",
               "Get-RGGroup",
               "Get-RGGroupConfiguration",
               "Get-RGGroupQuery",
               "Get-RGResourceTag",
               "Add-RGResource",
               "Get-RGGroupResourceList",
               "Get-RGGroupList",
               "Write-RGGroupConfiguration",
               "Find-RGResource",
               "Add-RGResourceTag",
               "Remove-RGResource",
               "Remove-RGResourceTag",
               "Update-RGGroup",
               "Update-RGGroupQuery")
}

_awsArgumentCompleterRegistration $RG_SelectCompleters $RG_SelectMap
# Argument completions for service AWS Resource Groups Tagging API


$RGT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RGT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RGT_SelectMap = @{
    "Select"=@("Get-RGTReportCreation",
               "Get-RGTComplianceSummary",
               "Get-RGTResource",
               "Get-RGTTagKey",
               "Get-RGTTagValue",
               "Start-RGTReportCreation",
               "Add-RGTResourceTag",
               "Remove-RGTResourceTag")
}

_awsArgumentCompleterRegistration $RGT_SelectCompleters $RGT_SelectMap
# Argument completions for service AWS RoboMaker


$ROBO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RoboMaker.Architecture
        "New-ROBORobot/Architecture"
        {
            $v = "ARM64","ARMHF","X86_64"
            break
        }

        # Amazon.RoboMaker.ComputeType
        "New-ROBOSimulationJob/Compute_ComputeType"
        {
            $v = "CPU","GPU_AND_CPU"
            break
        }

        # Amazon.RoboMaker.FailureBehavior
        "New-ROBOSimulationJob/FailureBehavior"
        {
            $v = "Continue","Fail"
            break
        }

        # Amazon.RoboMaker.RenderingEngineType
        {
            ($_ -eq "New-ROBOSimulationApplication/RenderingEngine_Name") -Or
            ($_ -eq "Update-ROBOSimulationApplication/RenderingEngine_Name")
        }
        {
            $v = "OGRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ROBO_map = @{
    "Architecture"=@("New-ROBORobot")
    "Compute_ComputeType"=@("New-ROBOSimulationJob")
    "FailureBehavior"=@("New-ROBOSimulationJob")
    "RenderingEngine_Name"=@("New-ROBOSimulationApplication","Update-ROBOSimulationApplication")
}

_awsArgumentCompleterRegistration $ROBO_Completers $ROBO_map

$ROBO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ROBO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ROBO_SelectMap = @{
    "Select"=@("Remove-ROBODeleteWorld",
               "Get-ROBOSimulationJobList",
               "Stop-ROBODeploymentJob",
               "Stop-ROBOSimulationJob",
               "Stop-ROBOSimulationJobBatch",
               "Stop-ROBOWorldExportJob",
               "Stop-ROBOWorldGenerationJob",
               "New-ROBODeploymentJob",
               "New-ROBOFleet",
               "New-ROBORobot",
               "New-ROBORobotApplication",
               "New-ROBORobotApplicationVersion",
               "New-ROBOSimulationApplication",
               "New-ROBOSimulationApplicationVersion",
               "New-ROBOSimulationJob",
               "New-ROBOWorldExportJob",
               "New-ROBOWorldGenerationJob",
               "New-ROBOWorldTemplate",
               "Remove-ROBOFleet",
               "Remove-ROBORobot",
               "Remove-ROBORobotApplication",
               "Remove-ROBOSimulationApplication",
               "Remove-ROBOWorldTemplate",
               "Unregister-ROBORobot",
               "Get-ROBODeploymentJob",
               "Get-ROBOFleet",
               "Get-ROBORobot",
               "Get-ROBORobotApplication",
               "Get-ROBOSimulationApplication",
               "Get-ROBOSimulationJob",
               "Get-ROBOSimulationJobBatch",
               "Get-ROBOWorld",
               "Get-ROBOWorldExportJob",
               "Get-ROBOWorldGenerationJob",
               "Get-ROBOWorldTemplate",
               "Get-ROBOWorldTemplateBody",
               "Get-ROBODeploymentJobList",
               "Get-ROBOFleetList",
               "Get-ROBORobotApplicationList",
               "Get-ROBORobotList",
               "Get-ROBOSimulationApplicationList",
               "Get-ROBOSimulationJobBatchList",
               "Get-ROBOSimulationJobSummary",
               "Get-ROBOResourceTag",
               "Get-ROBOWorldExportJobList",
               "Get-ROBOWorldGenerationJobList",
               "Get-ROBOWorldList",
               "Get-ROBOWorldTemplateList",
               "Register-ROBORobot",
               "Restart-ROBOSimulationJob",
               "Start-ROBOSimulationJobBatch",
               "Sync-ROBODeploymentJob",
               "Add-ROBOResourceTag",
               "Remove-ROBOResourceTag",
               "Update-ROBORobotApplication",
               "Update-ROBOSimulationApplication",
               "Update-ROBOWorldTemplate")
}

_awsArgumentCompleterRegistration $ROBO_SelectCompleters $ROBO_SelectMap
# Argument completions for service IAM Roles Anywhere


$IAMRA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IAMRolesAnywhere.TrustAnchorType
        {
            ($_ -eq "New-IAMRATrustAnchor/Source_SourceType") -Or
            ($_ -eq "Update-IAMRATrustAnchor/Source_SourceType")
        }
        {
            $v = "AWS_ACM_PCA","CERTIFICATE_BUNDLE","SELF_SIGNED_REPOSITORY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMRA_map = @{
    "Source_SourceType"=@("New-IAMRATrustAnchor","Update-IAMRATrustAnchor")
}

_awsArgumentCompleterRegistration $IAMRA_Completers $IAMRA_map

$IAMRA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IAMRA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMRA_SelectMap = @{
    "Select"=@("New-IAMRAProfile",
               "New-IAMRATrustAnchor",
               "Remove-IAMRACrl",
               "Remove-IAMRAProfile",
               "Remove-IAMRATrustAnchor",
               "Disable-IAMRACrl",
               "Disable-IAMRAProfile",
               "Disable-IAMRATrustAnchor",
               "Enable-IAMRACrl",
               "Enable-IAMRAProfile",
               "Enable-IAMRATrustAnchor",
               "Get-IAMRACrl",
               "Get-IAMRAProfile",
               "Get-IAMRASubject",
               "Get-IAMRATrustAnchor",
               "Import-IAMRACrl",
               "Get-IAMRACrlList",
               "Get-IAMRAProfileList",
               "Get-IAMRASubjectList",
               "Get-IAMRAResourceTag",
               "Get-IAMRATrustAnchorList",
               "Add-IAMRAResourceTag",
               "Remove-IAMRAResourceTag",
               "Update-IAMRACrl",
               "Update-IAMRAProfile",
               "Update-IAMRATrustAnchor")
}

_awsArgumentCompleterRegistration $IAMRA_SelectCompleters $IAMRA_SelectMap
# Argument completions for service Amazon Route 53


$R53_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53.AccountLimitType
        "Get-R53AccountLimit/Type"
        {
            $v = "MAX_HEALTH_CHECKS_BY_OWNER","MAX_HOSTED_ZONES_BY_OWNER","MAX_REUSABLE_DELEGATION_SETS_BY_OWNER","MAX_TRAFFIC_POLICIES_BY_OWNER","MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER"
            break
        }

        # Amazon.Route53.CloudWatchRegion
        {
            ($_ -eq "Update-R53HealthCheck/AlarmIdentifier_Region") -Or
            ($_ -eq "New-R53HealthCheck/HealthCheckConfig_AlarmIdentifier_Region")
        }
        {
            $v = "af-south-1","ap-east-1","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ap-southeast-3","ca-central-1","cn-north-1","cn-northwest-1","eu-central-1","eu-central-2","eu-north-1","eu-south-1","eu-south-2","eu-west-1","eu-west-2","eu-west-3","me-central-1","me-south-1","sa-east-1","us-east-1","us-east-2","us-gov-east-1","us-gov-west-1","us-iso-east-1","us-iso-west-1","us-isob-east-1","us-west-1","us-west-2"
            break
        }

        # Amazon.Route53.HealthCheckType
        "New-R53HealthCheck/HealthCheckConfig_Type"
        {
            $v = "CALCULATED","CLOUDWATCH_METRIC","HTTP","HTTPS","HTTPS_STR_MATCH","HTTP_STR_MATCH","RECOVERY_CONTROL","TCP"
            break
        }

        # Amazon.Route53.HostedZoneLimitType
        "Get-R53HostedZoneLimit/Type"
        {
            $v = "MAX_RRSETS_BY_ZONE","MAX_VPCS_ASSOCIATED_BY_ZONE"
            break
        }

        # Amazon.Route53.InsufficientDataHealthStatus
        {
            ($_ -eq "New-R53HealthCheck/HealthCheckConfig_InsufficientDataHealthStatus") -Or
            ($_ -eq "Update-R53HealthCheck/InsufficientDataHealthStatus")
        }
        {
            $v = "Healthy","LastKnownStatus","Unhealthy"
            break
        }

        # Amazon.Route53.ReusableDelegationSetLimitType
        "Get-R53ReusableDelegationSetLimit/Type"
        {
            $v = "MAX_ZONES_BY_REUSABLE_DELEGATION_SET"
            break
        }

        # Amazon.Route53.RRType
        {
            ($_ -eq "Test-R53DNSAnswer/RecordType") -Or
            ($_ -eq "Get-R53ResourceRecordSet/StartRecordType") -Or
            ($_ -eq "Get-R53TrafficPolicyInstanceList/TrafficPolicyInstanceTypeMarker") -Or
            ($_ -eq "Get-R53TrafficPolicyInstancesByHostedZone/TrafficPolicyInstanceTypeMarker") -Or
            ($_ -eq "Get-R53TrafficPolicyInstancesByPolicy/TrafficPolicyInstanceTypeMarker")
        }
        {
            $v = "A","AAAA","CAA","CNAME","DS","MX","NAPTR","NS","PTR","SOA","SPF","SRV","TXT"
            break
        }

        # Amazon.Route53.TagResourceType
        {
            ($_ -eq "Edit-R53TagsForResource/ResourceType") -Or
            ($_ -eq "Get-R53TagsForResource/ResourceType") -Or
            ($_ -eq "Get-R53TagsForResourceList/ResourceType")
        }
        {
            $v = "healthcheck","hostedzone"
            break
        }

        # Amazon.Route53.VPCRegion
        {
            ($_ -eq "New-R53HostedZone/VPC_VPCRegion") -Or
            ($_ -eq "New-R53VPCAssociationAuthorization/VPC_VPCRegion") -Or
            ($_ -eq "Register-R53VPCWithHostedZone/VPC_VPCRegion") -Or
            ($_ -eq "Remove-R53VPCAssociationAuthorization/VPC_VPCRegion") -Or
            ($_ -eq "Unregister-R53VPCFromHostedZone/VPC_VPCRegion") -Or
            ($_ -eq "Get-R53HostedZonesByVPC/VPCRegion")
        }
        {
            $v = "af-south-1","ap-east-1","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ap-southeast-3","ca-central-1","cn-north-1","eu-central-1","eu-central-2","eu-north-1","eu-south-1","eu-south-2","eu-west-1","eu-west-2","eu-west-3","me-central-1","me-south-1","sa-east-1","us-east-1","us-east-2","us-gov-east-1","us-gov-west-1","us-iso-east-1","us-iso-west-1","us-isob-east-1","us-west-1","us-west-2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53_map = @{
    "AlarmIdentifier_Region"=@("Update-R53HealthCheck")
    "HealthCheckConfig_AlarmIdentifier_Region"=@("New-R53HealthCheck")
    "HealthCheckConfig_InsufficientDataHealthStatus"=@("New-R53HealthCheck")
    "HealthCheckConfig_Type"=@("New-R53HealthCheck")
    "InsufficientDataHealthStatus"=@("Update-R53HealthCheck")
    "RecordType"=@("Test-R53DNSAnswer")
    "ResourceType"=@("Edit-R53TagsForResource","Get-R53TagsForResource","Get-R53TagsForResourceList")
    "StartRecordType"=@("Get-R53ResourceRecordSet")
    "TrafficPolicyInstanceTypeMarker"=@("Get-R53TrafficPolicyInstanceList","Get-R53TrafficPolicyInstancesByHostedZone","Get-R53TrafficPolicyInstancesByPolicy")
    "Type"=@("Get-R53AccountLimit","Get-R53HostedZoneLimit","Get-R53ReusableDelegationSetLimit")
    "VPC_VPCRegion"=@("New-R53HostedZone","New-R53VPCAssociationAuthorization","Register-R53VPCWithHostedZone","Remove-R53VPCAssociationAuthorization","Unregister-R53VPCFromHostedZone")
    "VPCRegion"=@("Get-R53HostedZonesByVPC")
}

_awsArgumentCompleterRegistration $R53_Completers $R53_map

$R53_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53_SelectMap = @{
    "Select"=@("Enable-R53KeySigningKey",
               "Register-R53VPCWithHostedZone",
               "Edit-R53CidrCollection",
               "Edit-R53ResourceRecordSet",
               "Edit-R53TagsForResource",
               "New-R53CidrCollection",
               "New-R53HealthCheck",
               "New-R53HostedZone",
               "New-R53KeySigningKey",
               "New-R53QueryLoggingConfig",
               "New-R53ReusableDelegationSet",
               "New-R53TrafficPolicy",
               "New-R53TrafficPolicyInstance",
               "New-R53TrafficPolicyVersion",
               "New-R53VPCAssociationAuthorization",
               "Disable-R53KeySigningKey",
               "Remove-R53CidrCollection",
               "Remove-R53HealthCheck",
               "Remove-R53HostedZone",
               "Remove-R53KeySigningKey",
               "Remove-R53QueryLoggingConfig",
               "Remove-R53ReusableDelegationSet",
               "Remove-R53TrafficPolicy",
               "Remove-R53TrafficPolicyInstance",
               "Remove-R53VPCAssociationAuthorization",
               "Disable-R53HostedZoneDNSSEC",
               "Unregister-R53VPCFromHostedZone",
               "Enable-R53HostedZoneDNSSEC",
               "Get-R53AccountLimit",
               "Get-R53Change",
               "Get-R53CheckerIpRange",
               "Get-R53DNSSEC",
               "Get-R53GeoLocation",
               "Get-R53HealthCheck",
               "Get-R53HealthCheckCount",
               "Get-R53HealthCheckLastFailureReason",
               "Get-R53HealthCheckStatus",
               "Get-R53HostedZone",
               "Get-R53HostedZoneCount",
               "Get-R53HostedZoneLimit",
               "Get-R53QueryLoggingConfig",
               "Get-R53ReusableDelegationSet",
               "Get-R53ReusableDelegationSetLimit",
               "Get-R53TrafficPolicy",
               "Get-R53TrafficPolicyInstance",
               "Get-R53TrafficPolicyInstanceCount",
               "Get-R53CidrBlockList",
               "Get-R53CidrCollectionList",
               "Get-R53CidrLocationList",
               "Get-R53GeoLocationList",
               "Get-R53HealthCheckList",
               "Get-R53HostedZoneList",
               "Get-R53HostedZonesByVPC",
               "Get-R53QueryLoggingConfigList",
               "Get-R53ResourceRecordSet",
               "Get-R53ReusableDelegationSetList",
               "Get-R53TagsForResource",
               "Get-R53TagsForResourceList",
               "Get-R53TrafficPolicyList",
               "Get-R53TrafficPolicyInstanceList",
               "Get-R53TrafficPolicyInstancesByHostedZone",
               "Get-R53TrafficPolicyInstancesByPolicy",
               "Get-R53TrafficPolicyVersionList",
               "Get-R53VPCAssociationAuthorizationList",
               "Test-R53DNSAnswer",
               "Update-R53HealthCheck",
               "Update-R53HostedZoneComment",
               "Update-R53TrafficPolicyComment",
               "Update-R53TrafficPolicyInstance",
               "Get-R53HostedZonesByName")
}

_awsArgumentCompleterRegistration $R53_SelectCompleters $R53_SelectMap
# Argument completions for service Amazon Route 53 Domains


$R53D_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53Domains.ContactType
        {
            ($_ -eq "Invoke-R53DDomainTransfer/AdminContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/AdminContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/AdminContact_ContactType") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/RegistrantContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/RegistrantContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/RegistrantContact_ContactType") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/TechContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/TechContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/TechContact_ContactType")
        }
        {
            $v = "ASSOCIATION","COMPANY","PERSON","PUBLIC_BODY","RESELLER"
            break
        }

        # Amazon.Route53Domains.CountryCode
        {
            ($_ -eq "Invoke-R53DDomainTransfer/AdminContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/AdminContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/AdminContact_CountryCode") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/RegistrantContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/RegistrantContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/RegistrantContact_CountryCode") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/TechContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/TechContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/TechContact_CountryCode")
        }
        {
            $v = "AC","AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AX","AZ","BA","BB","BD","BE","BF","BG","BH","BI","BJ","BL","BM","BN","BO","BQ","BR","BS","BT","BV","BW","BY","BZ","CA","CC","CD","CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CW","CX","CY","CZ","DE","DJ","DK","DM","DO","DZ","EC","EE","EG","EH","ER","ES","ET","FI","FJ","FK","FM","FO","FR","GA","GB","GD","GE","GF","GG","GH","GI","GL","GM","GN","GP","GQ","GR","GS","GT","GU","GW","GY","HK","HM","HN","HR","HT","HU","ID","IE","IL","IM","IN","IO","IQ","IR","IS","IT","JE","JM","JO","JP","KE","KG","KH","KI","KM","KN","KP","KR","KW","KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT","LU","LV","LY","MA","MC","MD","ME","MF","MG","MH","MK","ML","MM","MN","MO","MP","MQ","MR","MS","MT","MU","MV","MW","MX","MY","MZ","NA","NC","NE","NF","NG","NI","NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF","PG","PH","PK","PL","PM","PN","PR","PS","PT","PW","PY","QA","RE","RO","RS","RU","RW","SA","SB","SC","SD","SE","SG","SH","SI","SJ","SK","SL","SM","SN","SO","SR","SS","ST","SV","SX","SY","SZ","TC","TD","TF","TG","TH","TJ","TK","TL","TM","TN","TO","TP","TR","TT","TV","TW","TZ","UA","UG","US","UY","UZ","VA","VC","VE","VG","VI","VN","VU","WF","WS","YE","YT","ZA","ZM","ZW"
            break
        }

        # Amazon.Route53Domains.ListDomainsAttributeName
        "Get-R53DDomainList/SortCondition_Name"
        {
            $v = "DomainName","Expiry"
            break
        }

        # Amazon.Route53Domains.SortOrder
        "Get-R53DDomainList/SortCondition_SortOrder"
        {
            $v = "ASC","DESC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53D_map = @{
    "AdminContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "AdminContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "RegistrantContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "RegistrantContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "SortCondition_Name"=@("Get-R53DDomainList")
    "SortCondition_SortOrder"=@("Get-R53DDomainList")
    "TechContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "TechContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
}

_awsArgumentCompleterRegistration $R53D_Completers $R53D_map

$R53D_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53D.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53D_SelectMap = @{
    "Select"=@("Approve-R53DDomainTransferFromAnotherAwsAccount",
               "Stop-R53DDomainTransferToAnotherAwsAccount",
               "Test-R53DDomainAvailability",
               "Test-R53DDomainTransferability",
               "Remove-R53DDomain",
               "Remove-R53DTagsForDomain",
               "Disable-R53DDomainAutoRenew",
               "Disable-R53DDomainTransferLock",
               "Enable-R53DDomainAutoRenew",
               "Enable-R53DDomainTransferLock",
               "Get-R53DContactReachabilityStatus",
               "Get-R53DDomainDetail",
               "Get-R53DDomainSuggestion",
               "Get-R53DOperationDetail",
               "Get-R53DDomainList",
               "Get-R53DOperationList",
               "Get-R53DPriceList",
               "Get-R53DTagsForDomain",
               "Register-R53DDomain",
               "Deny-R53DDomainTransferFromAnotherAwsAccount",
               "Update-R53DDomainRenewal",
               "Send-R53DContactReachabilityEmail",
               "Get-R53DDomainAuthCode",
               "Invoke-R53DDomainTransfer",
               "Move-R53DDomainToAnotherAwsAccount",
               "Update-R53DDomainContact",
               "Update-R53DDomainContactPrivacy",
               "Update-R53DDomainNameserver",
               "Update-R53DTagsForDomain",
               "Get-R53DBillingRecord")
}

_awsArgumentCompleterRegistration $R53D_SelectCompleters $R53D_SelectMap
# Argument completions for service Route53 Recovery Cluster


$RRC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53RecoveryCluster.RoutingControlState
        "Update-RRCRoutingControlState/RoutingControlState"
        {
            $v = "Off","On"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RRC_map = @{
    "RoutingControlState"=@("Update-RRCRoutingControlState")
}

_awsArgumentCompleterRegistration $RRC_Completers $RRC_map

$RRC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RRC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RRC_SelectMap = @{
    "Select"=@("Get-RRCRoutingControlState",
               "Get-RRCRoutingControlList",
               "Update-RRCRoutingControlState",
               "Update-RRCRoutingControlStateBatch")
}

_awsArgumentCompleterRegistration $RRC_SelectCompleters $RRC_SelectMap
# Argument completions for service AWS Route53 Recovery Control Config


$R53RC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53RecoveryControlConfig.RuleType
        {
            ($_ -eq "New-R53RCSafetyRule/AssertionRule_RuleConfig_Type") -Or
            ($_ -eq "New-R53RCSafetyRule/GatingRule_RuleConfig_Type")
        }
        {
            $v = "AND","ATLEAST","OR"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53RC_map = @{
    "AssertionRule_RuleConfig_Type"=@("New-R53RCSafetyRule")
    "GatingRule_RuleConfig_Type"=@("New-R53RCSafetyRule")
}

_awsArgumentCompleterRegistration $R53RC_Completers $R53RC_map

$R53RC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53RC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53RC_SelectMap = @{
    "Select"=@("New-R53RCCluster",
               "New-R53RCControlPanel",
               "New-R53RCRoutingControl",
               "New-R53RCSafetyRule",
               "Remove-R53RCCluster",
               "Remove-R53RCControlPanel",
               "Remove-R53RCRoutingControl",
               "Remove-R53RCSafetyRule",
               "Get-R53RCCluster",
               "Get-R53RCControlPanel",
               "Get-R53RCRoutingControl",
               "Get-R53RCSafetyRule",
               "Get-R53RCAssociatedRoute53HealthCheckList",
               "Get-R53RCClusterList",
               "Get-R53RCControlPanelList",
               "Get-R53RCRoutingControlList",
               "Get-R53RCSafetyRuleList",
               "Get-R53RCResourceTag",
               "Add-R53RCResourceTag",
               "Remove-R53RCResourceTag",
               "Update-R53RCControlPanel",
               "Update-R53RCRoutingControl",
               "Update-R53RCSafetyRule")
}

_awsArgumentCompleterRegistration $R53RC_SelectCompleters $R53RC_SelectMap
# Argument completions for service Amazon Route 53 Resolver


$R53R_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53Resolver.Action
        {
            ($_ -eq "Edit-R53RFirewallRule/Action") -Or
            ($_ -eq "Get-R53RFirewallRuleList/Action") -Or
            ($_ -eq "New-R53RFirewallRule/Action")
        }
        {
            $v = "ALERT","ALLOW","BLOCK"
            break
        }

        # Amazon.Route53Resolver.AutodefinedReverseFlag
        "Update-R53RResolverConfig/AutodefinedReverseFlag"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.Route53Resolver.BlockOverrideDnsType
        {
            ($_ -eq "Edit-R53RFirewallRule/BlockOverrideDnsType") -Or
            ($_ -eq "New-R53RFirewallRule/BlockOverrideDnsType")
        }
        {
            $v = "CNAME"
            break
        }

        # Amazon.Route53Resolver.BlockResponse
        {
            ($_ -eq "Edit-R53RFirewallRule/BlockResponse") -Or
            ($_ -eq "New-R53RFirewallRule/BlockResponse")
        }
        {
            $v = "NODATA","NXDOMAIN","OVERRIDE"
            break
        }

        # Amazon.Route53Resolver.FirewallDomainImportOperation
        "Import-R53RFirewallDomainList/Operation"
        {
            $v = "REPLACE"
            break
        }

        # Amazon.Route53Resolver.FirewallDomainUpdateOperation
        "Edit-R53RFirewallDomain/Operation"
        {
            $v = "ADD","REMOVE","REPLACE"
            break
        }

        # Amazon.Route53Resolver.FirewallFailOpenStatus
        "Edit-R53RFirewallConfig/FirewallFailOpen"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Route53Resolver.FirewallRuleGroupAssociationStatus
        "Get-R53RFirewallRuleGroupAssociationList/Status"
        {
            $v = "COMPLETE","DELETING","UPDATING"
            break
        }

        # Amazon.Route53Resolver.MutationProtectionStatus
        {
            ($_ -eq "Edit-R53RFirewallRuleGroupAssociation/MutationProtection") -Or
            ($_ -eq "New-R53RFirewallRuleGroupAssociation/MutationProtection")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Route53Resolver.ResolverEndpointDirection
        "New-R53RResolverEndpoint/Direction"
        {
            $v = "INBOUND","OUTBOUND"
            break
        }

        # Amazon.Route53Resolver.RuleTypeOption
        "New-R53RResolverRule/RuleType"
        {
            $v = "FORWARD","RECURSIVE","SYSTEM"
            break
        }

        # Amazon.Route53Resolver.SortOrder
        {
            ($_ -eq "Get-R53RResolverQueryLogConfigAssociationList/SortOrder") -Or
            ($_ -eq "Get-R53RResolverQueryLogConfigList/SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Route53Resolver.Validation
        "Update-R53RResolverDnssecConfig/Validation"
        {
            $v = "DISABLE","ENABLE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53R_map = @{
    "Action"=@("Edit-R53RFirewallRule","Get-R53RFirewallRuleList","New-R53RFirewallRule")
    "AutodefinedReverseFlag"=@("Update-R53RResolverConfig")
    "BlockOverrideDnsType"=@("Edit-R53RFirewallRule","New-R53RFirewallRule")
    "BlockResponse"=@("Edit-R53RFirewallRule","New-R53RFirewallRule")
    "Direction"=@("New-R53RResolverEndpoint")
    "FirewallFailOpen"=@("Edit-R53RFirewallConfig")
    "MutationProtection"=@("Edit-R53RFirewallRuleGroupAssociation","New-R53RFirewallRuleGroupAssociation")
    "Operation"=@("Edit-R53RFirewallDomain","Import-R53RFirewallDomainList")
    "RuleType"=@("New-R53RResolverRule")
    "SortOrder"=@("Get-R53RResolverQueryLogConfigAssociationList","Get-R53RResolverQueryLogConfigList")
    "Status"=@("Get-R53RFirewallRuleGroupAssociationList")
    "Validation"=@("Update-R53RResolverDnssecConfig")
}

_awsArgumentCompleterRegistration $R53R_Completers $R53R_map

$R53R_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53R.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53R_SelectMap = @{
    "Select"=@("New-R53RFirewallRuleGroupAssociation",
               "Add-R53RResolverEndpointIpAddressAssociation",
               "Add-R53RResolverQueryLogConfigAssociation",
               "Add-R53RResolverRuleAssociation",
               "New-R53RFirewallDomainList",
               "New-R53RFirewallRule",
               "New-R53RFirewallRuleGroup",
               "New-R53RResolverEndpoint",
               "New-R53RResolverQueryLogConfig",
               "New-R53RResolverRule",
               "Remove-R53RFirewallDomainList",
               "Remove-R53RFirewallRule",
               "Remove-R53RFirewallRuleGroup",
               "Remove-R53RResolverEndpoint",
               "Remove-R53RResolverQueryLogConfig",
               "Remove-R53RResolverRule",
               "Remove-R53RFirewallRuleGroupAssociation",
               "Remove-R53RResolverEndpointIpAddressAssociation",
               "Remove-R53RResolverQueryLogConfigAssociation",
               "Remove-R53RResolverRuleAssociation",
               "Get-R53RFirewallConfig",
               "Get-R53RFirewallDomainList",
               "Get-R53RFirewallRuleGroup",
               "Get-R53RFirewallRuleGroupAssociation",
               "Get-R53RFirewallRuleGroupPolicy",
               "Get-R53RResolverConfig",
               "Get-R53RResolverDnssecConfig",
               "Get-R53RResolverEndpoint",
               "Get-R53RResolverQueryLogConfig",
               "Get-R53RResolverQueryLogConfigAssociation",
               "Get-R53RResolverQueryLogConfigPolicy",
               "Get-R53RResolverRule",
               "Get-R53RResolverRuleAssociation",
               "Get-R53RResolverRulePolicy",
               "Import-R53RFirewallDomainList",
               "Get-R53RFirewallConfigList",
               "Get-R53RFirewallDomainListList",
               "Get-R53RFirewallDomain",
               "Get-R53RFirewallRuleGroupAssociationList",
               "Get-R53RFirewallRuleGroupList",
               "Get-R53RFirewallRuleList",
               "Get-R53RResolverConfigList",
               "Get-R53RResolverDnssecConfigList",
               "Get-R53RResolverEndpointIpAddressList",
               "Get-R53RResolverEndpointList",
               "Get-R53RResolverQueryLogConfigAssociationList",
               "Get-R53RResolverQueryLogConfigList",
               "Get-R53RResolverRuleAssociationList",
               "Get-R53RResolverRuleList",
               "Get-R53RResourceTagList",
               "Edit-R53RFirewallRuleGroupPolicy",
               "Write-R53RResolverQueryLogConfigPolicy",
               "Set-R53RResolverRulePolicy",
               "Add-R53RResourceTag",
               "Remove-R53RResourceTag",
               "Edit-R53RFirewallConfig",
               "Edit-R53RFirewallDomain",
               "Edit-R53RFirewallRule",
               "Edit-R53RFirewallRuleGroupAssociation",
               "Update-R53RResolverConfig",
               "Update-R53RResolverDnssecConfig",
               "Update-R53RResolverEndpoint",
               "Update-R53RResolverRule")
}

_awsArgumentCompleterRegistration $R53R_SelectCompleters $R53R_SelectMap
# Argument completions for service CloudWatch RUM


$CWRUM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchRUM.MetricDestination
        {
            ($_ -eq "Add-CWRUMCreateRumMetricDefinition/Destination") -Or
            ($_ -eq "Get-CWRUMGetRumMetricDefinition/Destination") -Or
            ($_ -eq "Remove-CWRUMDeleteRumMetricDefinition/Destination") -Or
            ($_ -eq "Remove-CWRUMRumMetricsDestination/Destination") -Or
            ($_ -eq "Update-CWRUMRumMetricDefinition/Destination") -Or
            ($_ -eq "Write-CWRUMRumMetricsDestination/Destination")
        }
        {
            $v = "CloudWatch","Evidently"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWRUM_map = @{
    "Destination"=@("Add-CWRUMCreateRumMetricDefinition","Get-CWRUMGetRumMetricDefinition","Remove-CWRUMDeleteRumMetricDefinition","Remove-CWRUMRumMetricsDestination","Update-CWRUMRumMetricDefinition","Write-CWRUMRumMetricsDestination")
}

_awsArgumentCompleterRegistration $CWRUM_Completers $CWRUM_map

$CWRUM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWRUM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWRUM_SelectMap = @{
    "Select"=@("Add-CWRUMCreateRumMetricDefinition",
               "Remove-CWRUMDeleteRumMetricDefinition",
               "Get-CWRUMGetRumMetricDefinition",
               "New-CWRUMAppMonitor",
               "Remove-CWRUMAppMonitor",
               "Remove-CWRUMRumMetricsDestination",
               "Get-CWRUMAppMonitor",
               "Get-CWRUMAppMonitorData",
               "Get-CWRUMAppMonitorList",
               "Get-CWRUMRumMetricsDestinationList",
               "Get-CWRUMResourceTag",
               "Write-CWRUMRumEvent",
               "Write-CWRUMRumMetricsDestination",
               "Add-CWRUMResourceTag",
               "Remove-CWRUMResourceTag",
               "Update-CWRUMAppMonitor",
               "Update-CWRUMRumMetricDefinition")
}

_awsArgumentCompleterRegistration $CWRUM_SelectCompleters $CWRUM_SelectMap
# Argument completions for service Amazon Lex Runtime V2


$LRSV2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LexRuntimeV2.ConfirmationState
        {
            ($_ -eq "Send-LRSV2Text/SessionStateValue_Intent_ConfirmationState") -Or
            ($_ -eq "Write-LRSV2Session/SessionStateValue_Intent_ConfirmationState")
        }
        {
            $v = "Confirmed","Denied","None"
            break
        }

        # Amazon.LexRuntimeV2.DialogActionType
        {
            ($_ -eq "Send-LRSV2Text/SessionStateValue_DialogAction_Type") -Or
            ($_ -eq "Write-LRSV2Session/SessionStateValue_DialogAction_Type")
        }
        {
            $v = "Close","ConfirmIntent","Delegate","ElicitIntent","ElicitSlot","None"
            break
        }

        # Amazon.LexRuntimeV2.IntentState
        {
            ($_ -eq "Send-LRSV2Text/SessionStateValue_Intent_State") -Or
            ($_ -eq "Write-LRSV2Session/SessionStateValue_Intent_State")
        }
        {
            $v = "Failed","Fulfilled","FulfillmentInProgress","InProgress","ReadyForFulfillment","Waiting"
            break
        }

        # Amazon.LexRuntimeV2.StyleType
        {
            ($_ -eq "Send-LRSV2Text/SessionStateValue_DialogAction_SlotElicitationStyle") -Or
            ($_ -eq "Write-LRSV2Session/SessionStateValue_DialogAction_SlotElicitationStyle")
        }
        {
            $v = "Default","SpellByLetter","SpellByWord"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LRSV2_map = @{
    "SessionStateValue_DialogAction_SlotElicitationStyle"=@("Send-LRSV2Text","Write-LRSV2Session")
    "SessionStateValue_DialogAction_Type"=@("Send-LRSV2Text","Write-LRSV2Session")
    "SessionStateValue_Intent_ConfirmationState"=@("Send-LRSV2Text","Write-LRSV2Session")
    "SessionStateValue_Intent_State"=@("Send-LRSV2Text","Write-LRSV2Session")
}

_awsArgumentCompleterRegistration $LRSV2_Completers $LRSV2_map

$LRSV2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LRSV2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LRSV2_SelectMap = @{
    "Select"=@("Remove-LRSV2Session",
               "Get-LRSV2Session",
               "Write-LRSV2Session",
               "Send-LRSV2Text",
               "Send-LRSV2Utterance")
}

_awsArgumentCompleterRegistration $LRSV2_SelectCompleters $LRSV2_SelectMap
# Argument completions for service Amazon Lex


$LEX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lex.DialogActionType
        "Write-LEXSession/DialogAction_Type"
        {
            $v = "Close","ConfirmIntent","Delegate","ElicitIntent","ElicitSlot"
            break
        }

        # Amazon.Lex.FulfillmentState
        "Write-LEXSession/DialogAction_FulfillmentState"
        {
            $v = "Failed","Fulfilled","ReadyForFulfillment"
            break
        }

        # Amazon.Lex.MessageFormatType
        "Write-LEXSession/DialogAction_MessageFormat"
        {
            $v = "Composite","CustomPayload","PlainText","SSML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LEX_map = @{
    "DialogAction_FulfillmentState"=@("Write-LEXSession")
    "DialogAction_MessageFormat"=@("Write-LEXSession")
    "DialogAction_Type"=@("Write-LEXSession")
}

_awsArgumentCompleterRegistration $LEX_Completers $LEX_map

$LEX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LEX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LEX_SelectMap = @{
    "Select"=@("Remove-LEXSession",
               "Get-LEXSession",
               "Send-LEXContent",
               "Send-LEXText",
               "Write-LEXSession")
}

_awsArgumentCompleterRegistration $LEX_SelectCompleters $LEX_SelectMap
# Argument completions for service Amazon SageMaker Runtime


$SMR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMR_SelectMap = @{
    "Select"=@("Invoke-SMREndpoint",
               "Invoke-SMREndpointAsync")
}

_awsArgumentCompleterRegistration $SMR_SelectCompleters $SMR_SelectMap
# Argument completions for service Amazon Simple Storage Service (S3)


$S3_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.S3.BucketAccelerateStatus
        "Write-S3BucketAccelerateConfiguration/AccelerateConfiguration_Status"
        {
            $v = "Enabled","Suspended"
            break
        }

        # Amazon.S3.ChecksumAlgorithm
        {
            ($_ -eq "Add-S3PublicAccessBlock/ChecksumAlgorithm") -Or
            ($_ -eq "Copy-S3Object/ChecksumAlgorithm") -Or
            ($_ -eq "Remove-S3Object/ChecksumAlgorithm") -Or
            ($_ -eq "Restore-S3Object/ChecksumAlgorithm") -Or
            ($_ -eq "Set-S3ACL/ChecksumAlgorithm") -Or
            ($_ -eq "Set-S3BucketEncryption/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketAccelerateConfiguration/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketLogging/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketNotification/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketPolicy/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketReplication/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketRequestPayment/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketTagging/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketVersioning/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3BucketWebsite/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3CORSConfiguration/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3LifecycleConfiguration/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3Object/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3ObjectLegalHold/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3ObjectLockConfiguration/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3ObjectRetention/ChecksumAlgorithm") -Or
            ($_ -eq "Write-S3ObjectTagSet/ChecksumAlgorithm")
        }
        {
            $v = "CRC32","CRC32C","SHA1","SHA256"
            break
        }

        # Amazon.S3.ChecksumMode
        {
            ($_ -eq "Copy-S3Object/ChecksumMode") -Or
            ($_ -eq "Get-S3ObjectMetadata/ChecksumMode") -Or
            ($_ -eq "Read-S3Object/ChecksumMode")
        }
        {
            $v = "ENABLED"
            break
        }

        # Amazon.S3.EncodingType
        {
            ($_ -eq "Get-S3MultipartUpload/Encoding") -Or
            ($_ -eq "Get-S3Object/Encoding") -Or
            ($_ -eq "Get-S3ObjectV2/Encoding") -Or
            ($_ -eq "Get-S3Version/Encoding")
        }
        {
            $v = "Url"
            break
        }

        # Amazon.S3.ExpressionType
        "Select-S3ObjectContent/ExpressionType"
        {
            $v = "SQL"
            break
        }

        # Amazon.S3.GlacierJobTier
        {
            ($_ -eq "Restore-S3Object/RetrievalTier") -Or
            ($_ -eq "Restore-S3Object/Tier")
        }
        {
            $v = "Bulk","Expedited","Standard"
            break
        }

        # Amazon.S3.IntelligentTieringStatus
        "Write-S3BucketIntelligentTieringConfiguration/IntelligentTieringConfiguration_Status"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.S3.InventoryFormat
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_Destination_S3BucketDestination_InventoryFormat"
        {
            $v = "CSV","ORC","Parquet"
            break
        }

        # Amazon.S3.InventoryFrequency
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_Schedule_Frequency"
        {
            $v = "Daily","Weekly"
            break
        }

        # Amazon.S3.InventoryIncludedObjectVersions
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_IncludedObjectVersions"
        {
            $v = "All","Current"
            break
        }

        # Amazon.S3.ObjectLockEnabled
        "Write-S3ObjectLockConfiguration/ObjectLockConfiguration_ObjectLockEnabled"
        {
            $v = "Enabled"
            break
        }

        # Amazon.S3.ObjectLockLegalHoldStatus
        {
            ($_ -eq "Write-S3ObjectLegalHold/LegalHold_Status") -Or
            ($_ -eq "Write-S3GetObjectResponse/ObjectLockLegalHoldStatus")
        }
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.S3.ObjectLockMode
        "Write-S3GetObjectResponse/ObjectLockMode"
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3.ObjectLockRetentionMode
        {
            ($_ -eq "Write-S3ObjectLockConfiguration/ObjectLockConfiguration_Rule_DefaultRetention_Mode") -Or
            ($_ -eq "Write-S3ObjectRetention/Retention_Mode")
        }
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3.ReplicationStatus
        "Write-S3GetObjectResponse/ReplicationStatus"
        {
            $v = "COMPLETED","FAILED","PENDING","REPLICA"
            break
        }

        # Amazon.S3.RequestCharged
        "Write-S3GetObjectResponse/RequestCharged"
        {
            $v = "requester"
            break
        }

        # Amazon.S3.RequestPayer
        {
            ($_ -eq "Get-S3Object/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectAttribute/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectLegalHold/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectMetadata/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectRetention/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectTagSet/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectV2/RequestPayer") -Or
            ($_ -eq "Restore-S3Object/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectLegalHold/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectLockConfiguration/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectRetention/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectTagSet/RequestPayer")
        }
        {
            $v = "requester"
            break
        }

        # Amazon.S3.RestoreRequestType
        "Restore-S3Object/RestoreRequestType"
        {
            $v = "SELECT"
            break
        }

        # Amazon.S3.S3CannedACL
        {
            ($_ -eq "Set-S3ACL/CannedACL") -Or
            ($_ -eq "Copy-S3Object/CannedACLName") -Or
            ($_ -eq "New-S3Bucket/CannedACLName") -Or
            ($_ -eq "Write-S3Object/CannedACLName") -Or
            ($_ -eq "Restore-S3Object/OutputLocation_S3_CannedACL")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","log-delivery-write","NoACL","private","public-read","public-read-write"
            break
        }

        # Amazon.S3.S3StorageClass
        {
            ($_ -eq "Restore-S3Object/OutputLocation_S3_StorageClass") -Or
            ($_ -eq "Write-S3GetObjectResponse/StorageClass")
        }
        {
            $v = "DEEP_ARCHIVE","GLACIER","GLACIER_IR","INTELLIGENT_TIERING","ONEZONE_IA","OUTPOSTS","REDUCED_REDUNDANCY","STANDARD","STANDARD_IA"
            break
        }

        # Amazon.S3.ServerSideEncryptionCustomerMethod
        {
            ($_ -eq "Copy-S3Object/CopySourceServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Select-S3ObjectContent/ServerSideCustomerEncryptionMethod") -Or
            ($_ -eq "Copy-S3Object/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Get-S3ObjectMetadata/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Get-S3PreSignedURL/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Read-S3Object/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Write-S3Object/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Write-S3GetObjectResponse/SSECustomerAlgorithm")
        }
        {
            $v = "","AES256"
            break
        }

        # Amazon.S3.ServerSideEncryptionMethod
        {
            ($_ -eq "Restore-S3Object/OutputLocation_S3_Encryption_EncryptionType") -Or
            ($_ -eq "Copy-S3Object/ServerSideEncryption") -Or
            ($_ -eq "Write-S3Object/ServerSideEncryption") -Or
            ($_ -eq "Get-S3PreSignedURL/ServerSideEncryptionMethod") -Or
            ($_ -eq "Write-S3GetObjectResponse/ServerSideEncryptionMethod")
        }
        {
            $v = "","AES256","aws:kms"
            break
        }

        # Amazon.S3.StorageClassAnalysisSchemaVersion
        "Write-S3BucketAnalyticsConfiguration/AnalyticsConfiguration_StorageClassAnalysis_DataExport_OutputSchemaVersion"
        {
            $v = "V_1"
            break
        }

        # Amazon.S3.VersionStatus
        "Write-S3BucketVersioning/VersioningConfig_Status"
        {
            $v = "Enabled","Off","Suspended"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3_map = @{
    "AccelerateConfiguration_Status"=@("Write-S3BucketAccelerateConfiguration")
    "AnalyticsConfiguration_StorageClassAnalysis_DataExport_OutputSchemaVersion"=@("Write-S3BucketAnalyticsConfiguration")
    "CannedACL"=@("Set-S3ACL")
    "CannedACLName"=@("Copy-S3Object","New-S3Bucket","Write-S3Object")
    "ChecksumAlgorithm"=@("Add-S3PublicAccessBlock","Copy-S3Object","Remove-S3Object","Restore-S3Object","Set-S3ACL","Set-S3BucketEncryption","Write-S3BucketAccelerateConfiguration","Write-S3BucketLogging","Write-S3BucketNotification","Write-S3BucketPolicy","Write-S3BucketReplication","Write-S3BucketRequestPayment","Write-S3BucketTagging","Write-S3BucketVersioning","Write-S3BucketWebsite","Write-S3CORSConfiguration","Write-S3LifecycleConfiguration","Write-S3Object","Write-S3ObjectLegalHold","Write-S3ObjectLockConfiguration","Write-S3ObjectRetention","Write-S3ObjectTagSet")
    "ChecksumMode"=@("Copy-S3Object","Get-S3ObjectMetadata","Read-S3Object")
    "CopySourceServerSideEncryptionCustomerMethod"=@("Copy-S3Object")
    "Encoding"=@("Get-S3MultipartUpload","Get-S3Object","Get-S3ObjectV2","Get-S3Version")
    "ExpressionType"=@("Select-S3ObjectContent")
    "IntelligentTieringConfiguration_Status"=@("Write-S3BucketIntelligentTieringConfiguration")
    "InventoryConfiguration_Destination_S3BucketDestination_InventoryFormat"=@("Write-S3BucketInventoryConfiguration")
    "InventoryConfiguration_IncludedObjectVersions"=@("Write-S3BucketInventoryConfiguration")
    "InventoryConfiguration_Schedule_Frequency"=@("Write-S3BucketInventoryConfiguration")
    "LegalHold_Status"=@("Write-S3ObjectLegalHold")
    "ObjectLockConfiguration_ObjectLockEnabled"=@("Write-S3ObjectLockConfiguration")
    "ObjectLockConfiguration_Rule_DefaultRetention_Mode"=@("Write-S3ObjectLockConfiguration")
    "ObjectLockLegalHoldStatus"=@("Write-S3GetObjectResponse")
    "ObjectLockMode"=@("Write-S3GetObjectResponse")
    "OutputLocation_S3_CannedACL"=@("Restore-S3Object")
    "OutputLocation_S3_Encryption_EncryptionType"=@("Restore-S3Object")
    "OutputLocation_S3_StorageClass"=@("Restore-S3Object")
    "ReplicationStatus"=@("Write-S3GetObjectResponse")
    "RequestCharged"=@("Write-S3GetObjectResponse")
    "RequestPayer"=@("Get-S3Object","Get-S3ObjectAttribute","Get-S3ObjectLegalHold","Get-S3ObjectMetadata","Get-S3ObjectRetention","Get-S3ObjectTagSet","Get-S3ObjectV2","Restore-S3Object","Write-S3ObjectLegalHold","Write-S3ObjectLockConfiguration","Write-S3ObjectRetention","Write-S3ObjectTagSet")
    "RestoreRequestType"=@("Restore-S3Object")
    "Retention_Mode"=@("Write-S3ObjectRetention")
    "RetrievalTier"=@("Restore-S3Object")
    "ServerSideCustomerEncryptionMethod"=@("Select-S3ObjectContent")
    "ServerSideEncryption"=@("Copy-S3Object","Write-S3Object")
    "ServerSideEncryptionCustomerMethod"=@("Copy-S3Object","Get-S3ObjectMetadata","Get-S3PreSignedURL","Read-S3Object","Write-S3Object")
    "ServerSideEncryptionMethod"=@("Get-S3PreSignedURL","Write-S3GetObjectResponse")
    "SSECustomerAlgorithm"=@("Write-S3GetObjectResponse")
    "StorageClass"=@("Write-S3GetObjectResponse")
    "Tier"=@("Restore-S3Object")
    "VersioningConfig_Status"=@("Write-S3BucketVersioning")
}

_awsArgumentCompleterRegistration $S3_Completers $S3_map

$S3_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.S3.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3_SelectMap = @{
    "Select"=@("Remove-S3BucketAnalyticsConfiguration",
               "Remove-S3BucketEncryption",
               "Remove-S3BucketIntelligentTieringConfiguration",
               "Remove-S3BucketInventoryConfiguration",
               "Remove-S3BucketMetricsConfiguration",
               "Remove-S3BucketOwnershipControl",
               "Remove-S3BucketPolicy",
               "Remove-S3BucketReplication",
               "Remove-S3BucketTagging",
               "Remove-S3BucketWebsite",
               "Remove-S3CORSConfiguration",
               "Remove-S3LifecycleConfiguration",
               "Remove-S3ObjectTagSet",
               "Remove-S3PublicAccessBlock",
               "Get-S3ACL",
               "Get-S3BucketAccelerateConfiguration",
               "Get-S3BucketAnalyticsConfiguration",
               "Get-S3BucketEncryption",
               "Get-S3BucketIntelligentTieringConfiguration",
               "Get-S3BucketInventoryConfiguration",
               "Get-S3BucketLocation",
               "Get-S3BucketLogging",
               "Get-S3BucketMetricsConfiguration",
               "Get-S3BucketNotification",
               "Get-S3BucketOwnershipControl",
               "Get-S3BucketPolicy",
               "Get-S3BucketPolicyStatus",
               "Get-S3BucketReplication",
               "Get-S3BucketRequestPayment",
               "Get-S3BucketTagging",
               "Get-S3BucketVersioning",
               "Get-S3BucketWebsite",
               "Get-S3CORSConfiguration",
               "Get-S3LifecycleConfiguration",
               "Get-S3ObjectAttribute",
               "Get-S3ObjectLegalHold",
               "Get-S3ObjectLockConfiguration",
               "Get-S3ObjectMetadata",
               "Get-S3ObjectRetention",
               "Get-S3ObjectTagSet",
               "Get-S3PublicAccessBlock",
               "Get-S3BucketAnalyticsConfigurationList",
               "Get-S3BucketIntelligentTieringConfigurationList",
               "Get-S3BucketInventoryConfigurationList",
               "Get-S3BucketMetricsConfigurationList",
               "Get-S3Bucket",
               "Get-S3Object",
               "Get-S3ObjectV2",
               "Get-S3Version",
               "Set-S3ACL",
               "Write-S3BucketAccelerateConfiguration",
               "Write-S3BucketAnalyticsConfiguration",
               "Set-S3BucketEncryption",
               "Write-S3BucketIntelligentTieringConfiguration",
               "Write-S3BucketInventoryConfiguration",
               "Write-S3BucketLogging",
               "Write-S3BucketMetricsConfiguration",
               "Write-S3BucketNotification",
               "Write-S3BucketOwnershipControl",
               "Write-S3BucketPolicy",
               "Write-S3BucketReplication",
               "Write-S3BucketRequestPayment",
               "Write-S3BucketTagging",
               "Write-S3BucketVersioning",
               "Write-S3BucketWebsite",
               "Write-S3CORSConfiguration",
               "Write-S3LifecycleConfiguration",
               "Write-S3ObjectLegalHold",
               "Write-S3ObjectLockConfiguration",
               "Write-S3ObjectRetention",
               "Write-S3ObjectTagSet",
               "Add-S3PublicAccessBlock",
               "Restore-S3Object",
               "Select-S3ObjectContent",
               "Write-S3GetObjectResponse",
               "Copy-S3Object",
               "Get-S3MultipartUpload",
               "Get-S3PreSignedURL",
               "New-S3Bucket",
               "Read-S3Object",
               "Remove-S3Bucket",
               "Remove-S3MultipartUpload",
               "Remove-S3Object",
               "Test-S3Bucket",
               "Write-S3Object")
}

_awsArgumentCompleterRegistration $S3_SelectCompleters $S3_SelectMap
# Argument completions for service Amazon S3 Control


$S3C_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.S3Control.BucketCannedACL
        "New-S3CBucket/ACL"
        {
            $v = "authenticated-read","private","public-read","public-read-write"
            break
        }

        # Amazon.S3Control.BucketLocationConstraint
        "New-S3CBucket/CreateBucketConfiguration_LocationConstraint"
        {
            $v = "ap-northeast-1","ap-south-1","ap-southeast-1","ap-southeast-2","cn-north-1","EU","eu-central-1","eu-west-1","sa-east-1","us-west-1","us-west-2"
            break
        }

        # Amazon.S3Control.BucketVersioningStatus
        "Write-S3CBucketVersioning/VersioningConfiguration_Status"
        {
            $v = "Enabled","Suspended"
            break
        }

        # Amazon.S3Control.Format
        "Write-S3CStorageLensConfiguration/StorageLensConfiguration_DataExport_S3BucketDestination_Format"
        {
            $v = "CSV","Parquet"
            break
        }

        # Amazon.S3Control.GeneratedManifestFormat
        "New-S3CJob/ManifestGenerator_S3JobManifestGenerator_ManifestOutputLocation_ManifestFormat"
        {
            $v = "S3InventoryReport_CSV_20211130"
            break
        }

        # Amazon.S3Control.JobManifestFormat
        "New-S3CJob/Manifest_Spec_Format"
        {
            $v = "S3BatchOperations_CSV_20180820","S3InventoryReport_CSV_20161130"
            break
        }

        # Amazon.S3Control.JobReportFormat
        "New-S3CJob/Report_Format"
        {
            $v = "Report_CSV_20180820"
            break
        }

        # Amazon.S3Control.JobReportScope
        "New-S3CJob/Report_ReportScope"
        {
            $v = "AllTasks","FailedTasksOnly"
            break
        }

        # Amazon.S3Control.MFADelete
        "Write-S3CBucketVersioning/VersioningConfiguration_MFADelete"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.S3Control.OutputSchemaVersion
        "Write-S3CStorageLensConfiguration/StorageLensConfiguration_DataExport_S3BucketDestination_OutputSchemaVersion"
        {
            $v = "V_1"
            break
        }

        # Amazon.S3Control.RequestedJobStatus
        "Update-S3CJobStatus/RequestedJobStatus"
        {
            $v = "Cancelled","Ready"
            break
        }

        # Amazon.S3Control.S3CannedAccessControlList
        {
            ($_ -eq "New-S3CJob/Operation_S3PutObjectAcl_AccessControlPolicy_CannedAccessControlList") -Or
            ($_ -eq "New-S3CJob/Operation_S3PutObjectCopy_CannedAccessControlList")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","private","public-read","public-read-write"
            break
        }

        # Amazon.S3Control.S3ChecksumAlgorithm
        "New-S3CJob/Operation_S3PutObjectCopy_ChecksumAlgorithm"
        {
            $v = "CRC32","CRC32C","SHA1","SHA256"
            break
        }

        # Amazon.S3Control.S3GlacierJobTier
        "New-S3CJob/Operation_S3InitiateRestoreObject_GlacierJobTier"
        {
            $v = "BULK","STANDARD"
            break
        }

        # Amazon.S3Control.S3MetadataDirective
        "New-S3CJob/Operation_S3PutObjectCopy_MetadataDirective"
        {
            $v = "COPY","REPLACE"
            break
        }

        # Amazon.S3Control.S3ObjectLockLegalHoldStatus
        {
            ($_ -eq "New-S3CJob/Operation_S3PutObjectCopy_ObjectLockLegalHoldStatus") -Or
            ($_ -eq "New-S3CJob/Operation_S3PutObjectLegalHold_LegalHold_Status")
        }
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.S3Control.S3ObjectLockMode
        "New-S3CJob/Operation_S3PutObjectCopy_ObjectLockMode"
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3Control.S3ObjectLockRetentionMode
        "New-S3CJob/Operation_S3PutObjectRetention_Retention_Mode"
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3Control.S3SSEAlgorithm
        "New-S3CJob/Operation_S3PutObjectCopy_NewObjectMetadata_SSEAlgorithm"
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.S3Control.S3StorageClass
        "New-S3CJob/Operation_S3PutObjectCopy_StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER","GLACIER_IR","INTELLIGENT_TIERING","ONEZONE_IA","STANDARD","STANDARD_IA"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3C_map = @{
    "ACL"=@("New-S3CBucket")
    "CreateBucketConfiguration_LocationConstraint"=@("New-S3CBucket")
    "Manifest_Spec_Format"=@("New-S3CJob")
    "ManifestGenerator_S3JobManifestGenerator_ManifestOutputLocation_ManifestFormat"=@("New-S3CJob")
    "Operation_S3InitiateRestoreObject_GlacierJobTier"=@("New-S3CJob")
    "Operation_S3PutObjectAcl_AccessControlPolicy_CannedAccessControlList"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_CannedAccessControlList"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_ChecksumAlgorithm"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_MetadataDirective"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_NewObjectMetadata_SSEAlgorithm"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_ObjectLockLegalHoldStatus"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_ObjectLockMode"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_StorageClass"=@("New-S3CJob")
    "Operation_S3PutObjectLegalHold_LegalHold_Status"=@("New-S3CJob")
    "Operation_S3PutObjectRetention_Retention_Mode"=@("New-S3CJob")
    "Report_Format"=@("New-S3CJob")
    "Report_ReportScope"=@("New-S3CJob")
    "RequestedJobStatus"=@("Update-S3CJobStatus")
    "StorageLensConfiguration_DataExport_S3BucketDestination_Format"=@("Write-S3CStorageLensConfiguration")
    "StorageLensConfiguration_DataExport_S3BucketDestination_OutputSchemaVersion"=@("Write-S3CStorageLensConfiguration")
    "VersioningConfiguration_MFADelete"=@("Write-S3CBucketVersioning")
    "VersioningConfiguration_Status"=@("Write-S3CBucketVersioning")
}

_awsArgumentCompleterRegistration $S3C_Completers $S3C_map

$S3C_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.S3C.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3C_SelectMap = @{
    "Select"=@("New-S3CAccessPoint",
               "New-S3CAccessPointForObjectLambda",
               "New-S3CBucket",
               "New-S3CJob",
               "New-S3CMultiRegionAccessPoint",
               "Remove-S3CAccessPoint",
               "Remove-S3CAccessPointForObjectLambda",
               "Remove-S3CAccessPointPolicy",
               "Remove-S3CAccessPointPolicyForObjectLambda",
               "Remove-S3CBucket",
               "Remove-S3CBucketLifecycleConfiguration",
               "Remove-S3CBucketPolicy",
               "Remove-S3CBucketTagging",
               "Remove-S3CJobTagging",
               "Remove-S3CMultiRegionAccessPoint",
               "Remove-S3CPublicAccessBlock",
               "Remove-S3CStorageLensConfiguration",
               "Remove-S3CStorageLensConfigurationTagging",
               "Get-S3CJob",
               "Get-S3CMultiRegionAccessPointOperation",
               "Get-S3CAccessPoint",
               "Get-S3CAccessPointConfigurationForObjectLambda",
               "Get-S3CAccessPointForObjectLambda",
               "Get-S3CAccessPointPolicy",
               "Get-S3CAccessPointPolicyForObjectLambda",
               "Get-S3CAccessPointPolicyStatus",
               "Get-S3CAccessPointPolicyStatusForObjectLambda",
               "Get-S3CBucket",
               "Get-S3CBucketLifecycleConfiguration",
               "Get-S3CBucketPolicy",
               "Get-S3CBucketTagging",
               "Get-S3CBucketVersioning",
               "Get-S3CJobTagging",
               "Get-S3CMultiRegionAccessPoint",
               "Get-S3CMultiRegionAccessPointPolicy",
               "Get-S3CMultiRegionAccessPointPolicyStatus",
               "Get-S3CPublicAccessBlock",
               "Get-S3CStorageLensConfiguration",
               "Get-S3CStorageLensConfigurationTagging",
               "Get-S3CAccessPointList",
               "Get-S3CAccessPointsForObjectLambdaList",
               "Get-S3CJobList",
               "Get-S3CMultiRegionAccessPointList",
               "Get-S3CRegionalBucketList",
               "Get-S3CStorageLensConfigurationList",
               "Write-S3CAccessPointConfigurationForObjectLambda",
               "Write-S3CAccessPointPolicy",
               "Write-S3CAccessPointPolicyForObjectLambda",
               "Write-S3CBucketLifecycleConfiguration",
               "Write-S3CBucketPolicy",
               "Write-S3CBucketTagging",
               "Write-S3CBucketVersioning",
               "Add-S3CJobTagging",
               "Write-S3CMultiRegionAccessPointPolicy",
               "Add-S3CPublicAccessBlock",
               "Write-S3CStorageLensConfiguration",
               "Write-S3CStorageLensConfigurationTagging",
               "Update-S3CJobPriority",
               "Update-S3CJobStatus")
}

_awsArgumentCompleterRegistration $S3C_SelectCompleters $S3C_SelectMap
# Argument completions for service Amazon S3 Outposts


$S3O_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.S3Outposts.EndpointAccessType
        "New-S3OEndpoint/AccessType"
        {
            $v = "CustomerOwnedIp","Private"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3O_map = @{
    "AccessType"=@("New-S3OEndpoint")
}

_awsArgumentCompleterRegistration $S3O_Completers $S3O_map

$S3O_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.S3O.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3O_SelectMap = @{
    "Select"=@("New-S3OEndpoint",
               "Remove-S3OEndpoint",
               "Get-S3OEndpointList",
               "Get-S3OSharedEndpointList")
}

_awsArgumentCompleterRegistration $S3O_SelectCompleters $S3O_SelectMap
# Argument completions for service Amazon SageMaker Service


$SM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SageMaker.ActionStatus
        {
            ($_ -eq "New-SMAction/Status") -Or
            ($_ -eq "Update-SMAction/Status")
        }
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping","Unknown"
            break
        }

        # Amazon.SageMaker.AlgorithmSortBy
        "Get-SMAlgorithmList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.AppImageConfigSortKey
        "Get-SMAppImageConfigList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.AppInstanceType
        {
            ($_ -eq "New-SMDomain/DomainSettings_RStudioServerProDomainSettings_DefaultResourceSpec_InstanceType") -Or
            ($_ -eq "Update-SMDomain/DomainSettingsForUpdate_RStudioServerProDomainSettingsForUpdate_DefaultResourceSpec_InstanceType") -Or
            ($_ -eq "New-SMApp/ResourceSpec_InstanceType")
        }
        {
            $v = "ml.c5.12xlarge","ml.c5.18xlarge","ml.c5.24xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.large","ml.c5.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.g5.12xlarge","ml.g5.16xlarge","ml.g5.24xlarge","ml.g5.2xlarge","ml.g5.48xlarge","ml.g5.4xlarge","ml.g5.8xlarge","ml.g5.xlarge","ml.m5.12xlarge","ml.m5.16xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.8xlarge","ml.m5.large","ml.m5.xlarge","ml.m5d.12xlarge","ml.m5d.16xlarge","ml.m5d.24xlarge","ml.m5d.2xlarge","ml.m5d.4xlarge","ml.m5d.8xlarge","ml.m5d.large","ml.m5d.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.p3dn.24xlarge","ml.r5.12xlarge","ml.r5.16xlarge","ml.r5.24xlarge","ml.r5.2xlarge","ml.r5.4xlarge","ml.r5.8xlarge","ml.r5.large","ml.r5.xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.micro","ml.t3.small","ml.t3.xlarge","system"
            break
        }

        # Amazon.SageMaker.AppNetworkAccessType
        "New-SMDomain/AppNetworkAccessType"
        {
            $v = "PublicInternetOnly","VpcOnly"
            break
        }

        # Amazon.SageMaker.AppSecurityGroupManagement
        "New-SMDomain/AppSecurityGroupManagement"
        {
            $v = "Customer","Service"
            break
        }

        # Amazon.SageMaker.AppSortKey
        "Get-SMAppList/SortBy"
        {
            $v = "CreationTime"
            break
        }

        # Amazon.SageMaker.AppType
        {
            ($_ -eq "Get-SMApp/AppType") -Or
            ($_ -eq "New-SMApp/AppType") -Or
            ($_ -eq "Remove-SMApp/AppType")
        }
        {
            $v = "JupyterServer","KernelGateway","RSessionGateway","RStudioServerPro","TensorBoard"
            break
        }

        # Amazon.SageMaker.AssemblyType
        "New-SMTransformJob/TransformOutput_AssembleWith"
        {
            $v = "Line","None"
            break
        }

        # Amazon.SageMaker.AssociationEdgeType
        {
            ($_ -eq "Add-SMAssociation/AssociationType") -Or
            ($_ -eq "Get-SMAssociationList/AssociationType")
        }
        {
            $v = "AssociatedWith","ContributedTo","DerivedFrom","Produced"
            break
        }

        # Amazon.SageMaker.AuthMode
        "New-SMDomain/AuthMode"
        {
            $v = "IAM","SSO"
            break
        }

        # Amazon.SageMaker.AutoMLJobStatus
        "Get-SMAutoMLJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.AutoMLMetricEnum
        "New-SMAutoMLJob/AutoMLJobObjective_MetricName"
        {
            $v = "Accuracy","AUC","F1","F1macro","MSE"
            break
        }

        # Amazon.SageMaker.AutoMLMode
        "New-SMAutoMLJob/AutoMLJobConfig_Mode"
        {
            $v = "AUTO","ENSEMBLING","HYPERPARAMETER_TUNING"
            break
        }

        # Amazon.SageMaker.AutoMLSortBy
        "Get-SMAutoMLJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.AutoMLSortOrder
        {
            ($_ -eq "Get-SMAutoMLJobList/SortOrder") -Or
            ($_ -eq "Get-SMCandidatesForAutoMLJobList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.AwsManagedHumanLoopRequestSource
        "New-SMFlowDefinition/HumanLoopRequestSource_AwsManagedHumanLoopRequestSource"
        {
            $v = "AWS/Rekognition/DetectModerationLabels/Image/V3","AWS/Textract/AnalyzeDocument/Forms/V1"
            break
        }

        # Amazon.SageMaker.BatchStrategy
        "New-SMTransformJob/BatchStrategy"
        {
            $v = "MultiRecord","SingleRecord"
            break
        }

        # Amazon.SageMaker.BooleanOperator
        "Search-SMResource/SearchExpression_Operator"
        {
            $v = "And","Or"
            break
        }

        # Amazon.SageMaker.CandidateSortBy
        "Get-SMCandidatesForAutoMLJobList/SortBy"
        {
            $v = "CreationTime","FinalObjectiveMetricValue","Status"
            break
        }

        # Amazon.SageMaker.CandidateStatus
        "Get-SMCandidatesForAutoMLJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.CapacitySizeType
        {
            ($_ -eq "New-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_CanarySize_Type") -Or
            ($_ -eq "Update-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_CanarySize_Type") -Or
            ($_ -eq "New-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_LinearStepSize_Type") -Or
            ($_ -eq "Update-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_LinearStepSize_Type")
        }
        {
            $v = "CAPACITY_PERCENT","INSTANCE_COUNT"
            break
        }

        # Amazon.SageMaker.ClarifyTextGranularity
        "New-SMEndpointConfig/ExplainerConfig_ClarifyExplainerConfig_ShapConfig_TextConfig_Granularity"
        {
            $v = "paragraph","sentence","token"
            break
        }

        # Amazon.SageMaker.ClarifyTextLanguage
        "New-SMEndpointConfig/ExplainerConfig_ClarifyExplainerConfig_ShapConfig_TextConfig_Language"
        {
            $v = "af","ar","bg","bn","ca","cs","da","de","el","en","es","et","eu","fa","fi","fr","ga","gu","he","hi","hr","hu","hy","id","is","it","kn","ky","lb","lij","lt","lv","mk","ml","mr","nb","ne","nl","pl","pt","ro","ru","sa","si","sk","sl","sq","sr","sv","ta","te","tl","tn","tr","tt","uk","ur","xx","yo","zh"
            break
        }

        # Amazon.SageMaker.CodeRepositorySortBy
        "Get-SMCodeRepositoryList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.CodeRepositorySortOrder
        "Get-SMCodeRepositoryList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.CompilationJobStatus
        "Get-SMCompilationJobList/StatusEquals"
        {
            $v = "COMPLETED","FAILED","INPROGRESS","STARTING","STOPPED","STOPPING"
            break
        }

        # Amazon.SageMaker.CompressionType
        "New-SMTransformJob/TransformInput_CompressionType"
        {
            $v = "Gzip","None"
            break
        }

        # Amazon.SageMaker.DirectInternetAccess
        "New-SMNotebookInstance/DirectInternetAccess"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.SageMaker.Direction
        "Find-SMLineage/Direction"
        {
            $v = "Ascendants","Both","Descendants"
            break
        }

        # Amazon.SageMaker.EdgePackagingJobStatus
        "Get-SMEdgePackagingJobList/StatusEquals"
        {
            $v = "COMPLETED","FAILED","INPROGRESS","STARTING","STOPPED","STOPPING"
            break
        }

        # Amazon.SageMaker.EdgePresetDeploymentType
        {
            ($_ -eq "New-SMDeviceFleet/OutputConfig_PresetDeploymentType") -Or
            ($_ -eq "New-SMEdgePackagingJob/OutputConfig_PresetDeploymentType") -Or
            ($_ -eq "Update-SMDeviceFleet/OutputConfig_PresetDeploymentType")
        }
        {
            $v = "GreengrassV2Component"
            break
        }

        # Amazon.SageMaker.EndpointConfigSortKey
        "Get-SMConfigList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.EndpointSortKey
        "Get-SMEndpointList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.EndpointStatus
        "Get-SMEndpointList/StatusEquals"
        {
            $v = "Creating","Deleting","Failed","InService","OutOfService","RollingBack","SystemUpdating","Updating"
            break
        }

        # Amazon.SageMaker.ExecutionRoleIdentityConfig
        {
            ($_ -eq "New-SMDomain/DomainSettings_ExecutionRoleIdentityConfig") -Or
            ($_ -eq "Update-SMDomain/DomainSettingsForUpdate_ExecutionRoleIdentityConfig")
        }
        {
            $v = "DISABLED","USER_PROFILE_NAME"
            break
        }

        # Amazon.SageMaker.ExecutionStatus
        "Get-SMMonitoringExecutionList/StatusEquals"
        {
            $v = "Completed","CompletedWithViolations","Failed","InProgress","Pending","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.FeatureGroupSortBy
        "Get-SMFeatureGroupList/SortBy"
        {
            $v = "CreationTime","FeatureGroupStatus","Name","OfflineStoreStatus"
            break
        }

        # Amazon.SageMaker.FeatureGroupSortOrder
        "Get-SMFeatureGroupList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.FeatureGroupStatus
        "Get-SMFeatureGroupList/FeatureGroupStatusEquals"
        {
            $v = "Created","CreateFailed","Creating","DeleteFailed","Deleting"
            break
        }

        # Amazon.SageMaker.Framework
        "New-SMCompilationJob/InputConfig_Framework"
        {
            $v = "DARKNET","KERAS","MXNET","ONNX","PYTORCH","SKLEARN","TENSORFLOW","TFLITE","XGBOOST"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningAllocationStrategy
        "New-SMHyperParameterTuningJob/TrainingJobDefinition_HyperParameterTuningResourceConfig_AllocationStrategy"
        {
            $v = "Prioritized"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobObjectiveType
        {
            ($_ -eq "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_HyperParameterTuningJobObjective_Type") -Or
            ($_ -eq "New-SMHyperParameterTuningJob/TrainingJobDefinition_TuningObjective_Type")
        }
        {
            $v = "Maximize","Minimize"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobSortByOptions
        "Get-SMHyperParameterTuningJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobStatus
        "Get-SMHyperParameterTuningJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobStrategyType
        "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_Strategy"
        {
            $v = "Bayesian","Grid","Hyperband","Random"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobWarmStartType
        "New-SMHyperParameterTuningJob/WarmStartConfig_WarmStartType"
        {
            $v = "IdenticalDataAndAlgorithm","TransferLearning"
            break
        }

        # Amazon.SageMaker.ImageSortBy
        "Get-SMImageList/SortBy"
        {
            $v = "CREATION_TIME","IMAGE_NAME","LAST_MODIFIED_TIME"
            break
        }

        # Amazon.SageMaker.ImageSortOrder
        "Get-SMImageList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.SageMaker.ImageVersionSortBy
        "Get-SMImageVersionList/SortBy"
        {
            $v = "CREATION_TIME","LAST_MODIFIED_TIME","VERSION"
            break
        }

        # Amazon.SageMaker.ImageVersionSortOrder
        "Get-SMImageVersionList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.SageMaker.InferenceExecutionMode
        "New-SMModel/InferenceExecutionConfig_Mode"
        {
            $v = "Direct","Serial"
            break
        }

        # Amazon.SageMaker.InstanceType
        {
            ($_ -eq "New-SMNotebookInstance/InstanceType") -Or
            ($_ -eq "Update-SMNotebookInstance/InstanceType")
        }
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.c5d.18xlarge","ml.c5d.2xlarge","ml.c5d.4xlarge","ml.c5d.9xlarge","ml.c5d.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.g5.12xlarge","ml.g5.16xlarge","ml.g5.24xlarge","ml.g5.2xlarge","ml.g5.48xlarge","ml.g5.4xlarge","ml.g5.8xlarge","ml.g5.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.xlarge","ml.m5d.12xlarge","ml.m5d.16xlarge","ml.m5d.24xlarge","ml.m5d.2xlarge","ml.m5d.4xlarge","ml.m5d.8xlarge","ml.m5d.large","ml.m5d.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.p3dn.24xlarge","ml.r5.12xlarge","ml.r5.16xlarge","ml.r5.24xlarge","ml.r5.2xlarge","ml.r5.4xlarge","ml.r5.8xlarge","ml.r5.large","ml.r5.xlarge","ml.t2.2xlarge","ml.t2.large","ml.t2.medium","ml.t2.xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.xlarge"
            break
        }

        # Amazon.SageMaker.JoinSource
        "New-SMTransformJob/DataProcessing_JoinSource"
        {
            $v = "Input","None"
            break
        }

        # Amazon.SageMaker.LabelingJobStatus
        "Get-SMLabelingJobList/StatusEquals"
        {
            $v = "Completed","Failed","Initializing","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.ListCompilationJobsSortBy
        "Get-SMCompilationJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.ListDeviceFleetsSortBy
        "Get-SMDeviceFleetList/SortBy"
        {
            $v = "CREATION_TIME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.SageMaker.ListEdgeDeploymentPlansSortBy
        "Get-SMEdgeDeploymentPlanList/SortBy"
        {
            $v = "CREATION_TIME","DEVICE_FLEET_NAME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.SageMaker.ListEdgePackagingJobsSortBy
        "Get-SMEdgePackagingJobList/SortBy"
        {
            $v = "CREATION_TIME","LAST_MODIFIED_TIME","MODEL_NAME","NAME","STATUS"
            break
        }

        # Amazon.SageMaker.ListInferenceRecommendationsJobsSortBy
        "Get-SMInferenceRecommendationsJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.ListLabelingJobsForWorkteamSortByOptions
        "Get-SMLabelingJobListForWorkteam/SortBy"
        {
            $v = "CreationTime"
            break
        }

        # Amazon.SageMaker.ListWorkforcesSortByOptions
        "Get-SMWorkforceList/SortBy"
        {
            $v = "CreateDate","Name"
            break
        }

        # Amazon.SageMaker.ListWorkteamsSortByOptions
        "Get-SMWorkteamList/SortBy"
        {
            $v = "CreateDate","Name"
            break
        }

        # Amazon.SageMaker.ModelApprovalStatus
        {
            ($_ -eq "Get-SMModelPackageList/ModelApprovalStatus") -Or
            ($_ -eq "New-SMModelPackage/ModelApprovalStatus") -Or
            ($_ -eq "Update-SMModelPackage/ModelApprovalStatus")
        }
        {
            $v = "Approved","PendingManualApproval","Rejected"
            break
        }

        # Amazon.SageMaker.ModelPackageGroupSortBy
        "Get-SMModelPackageGroupList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.ModelPackageSortBy
        "Get-SMModelPackageList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.ModelPackageType
        "Get-SMModelPackageList/ModelPackageType"
        {
            $v = "Both","Unversioned","Versioned"
            break
        }

        # Amazon.SageMaker.ModelSortKey
        "Get-SMModelList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.MonitoringExecutionSortKey
        "Get-SMMonitoringExecutionList/SortBy"
        {
            $v = "CreationTime","ScheduledTime","Status"
            break
        }

        # Amazon.SageMaker.MonitoringJobDefinitionSortKey
        {
            ($_ -eq "Get-SMDataQualityJobDefinitionList/SortBy") -Or
            ($_ -eq "Get-SMModelBiasJobDefinitionList/SortBy") -Or
            ($_ -eq "Get-SMModelExplainabilityJobDefinitionList/SortBy") -Or
            ($_ -eq "Get-SMModelQualityJobDefinitionList/SortBy")
        }
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.MonitoringProblemType
        "New-SMModelQualityJobDefinition/ModelQualityAppSpecification_ProblemType"
        {
            $v = "BinaryClassification","MulticlassClassification","Regression"
            break
        }

        # Amazon.SageMaker.MonitoringScheduleSortKey
        "Get-SMMonitoringScheduleList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.MonitoringType
        {
            ($_ -eq "Get-SMMonitoringExecutionList/MonitoringTypeEquals") -Or
            ($_ -eq "Get-SMMonitoringScheduleList/MonitoringTypeEquals")
        }
        {
            $v = "DataQuality","ModelBias","ModelExplainability","ModelQuality"
            break
        }

        # Amazon.SageMaker.NotebookInstanceLifecycleConfigSortKey
        "Get-SMNotebookInstanceLifecycleConfigList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.NotebookInstanceLifecycleConfigSortOrder
        "Get-SMNotebookInstanceLifecycleConfigList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.NotebookInstanceSortKey
        "Get-SMNotebookInstanceList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.NotebookInstanceSortOrder
        "Get-SMNotebookInstanceList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.NotebookInstanceStatus
        "Get-SMNotebookInstanceList/StatusEquals"
        {
            $v = "Deleting","Failed","InService","Pending","Stopped","Stopping","Updating"
            break
        }

        # Amazon.SageMaker.OfflineStoreStatusValue
        "Get-SMFeatureGroupList/OfflineStoreStatusEquals"
        {
            $v = "Active","Blocked","Disabled"
            break
        }

        # Amazon.SageMaker.OrderKey
        {
            ($_ -eq "Get-SMConfigList/SortOrder") -Or
            ($_ -eq "Get-SMEndpointList/SortOrder") -Or
            ($_ -eq "Get-SMModelList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.ProblemType
        "New-SMAutoMLJob/ProblemType"
        {
            $v = "BinaryClassification","MulticlassClassification","Regression"
            break
        }

        # Amazon.SageMaker.ProcessingInstanceType
        {
            ($_ -eq "New-SMDataQualityJobDefinition/JobResources_ClusterConfig_InstanceType") -Or
            ($_ -eq "New-SMModelBiasJobDefinition/JobResources_ClusterConfig_InstanceType") -Or
            ($_ -eq "New-SMModelExplainabilityJobDefinition/JobResources_ClusterConfig_InstanceType") -Or
            ($_ -eq "New-SMModelQualityJobDefinition/JobResources_ClusterConfig_InstanceType") -Or
            ($_ -eq "New-SMProcessingJob/ProcessingResources_ClusterConfig_InstanceType")
        }
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.r5.12xlarge","ml.r5.16xlarge","ml.r5.24xlarge","ml.r5.2xlarge","ml.r5.4xlarge","ml.r5.8xlarge","ml.r5.large","ml.r5.xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.xlarge"
            break
        }

        # Amazon.SageMaker.ProcessingJobStatus
        "Get-SMProcessingJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.ProcessingS3DataDistributionType
        {
            ($_ -eq "New-SMDataQualityJobDefinition/DataQualityJobInput_BatchTransformInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMDataQualityJobDefinition/DataQualityJobInput_EndpointInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelBiasJobDefinition/ModelBiasJobInput_BatchTransformInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelBiasJobDefinition/ModelBiasJobInput_EndpointInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelExplainabilityJobDefinition/ModelExplainabilityJobInput_BatchTransformInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelExplainabilityJobDefinition/ModelExplainabilityJobInput_EndpointInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelQualityJobDefinition/ModelQualityJobInput_BatchTransformInput_S3DataDistributionType") -Or
            ($_ -eq "New-SMModelQualityJobDefinition/ModelQualityJobInput_EndpointInput_S3DataDistributionType")
        }
        {
            $v = "FullyReplicated","ShardedByS3Key"
            break
        }

        # Amazon.SageMaker.ProcessingS3InputMode
        {
            ($_ -eq "New-SMDataQualityJobDefinition/DataQualityJobInput_BatchTransformInput_S3InputMode") -Or
            ($_ -eq "New-SMDataQualityJobDefinition/DataQualityJobInput_EndpointInput_S3InputMode") -Or
            ($_ -eq "New-SMModelBiasJobDefinition/ModelBiasJobInput_BatchTransformInput_S3InputMode") -Or
            ($_ -eq "New-SMModelBiasJobDefinition/ModelBiasJobInput_EndpointInput_S3InputMode") -Or
            ($_ -eq "New-SMModelExplainabilityJobDefinition/ModelExplainabilityJobInput_BatchTransformInput_S3InputMode") -Or
            ($_ -eq "New-SMModelExplainabilityJobDefinition/ModelExplainabilityJobInput_EndpointInput_S3InputMode") -Or
            ($_ -eq "New-SMModelQualityJobDefinition/ModelQualityJobInput_BatchTransformInput_S3InputMode") -Or
            ($_ -eq "New-SMModelQualityJobDefinition/ModelQualityJobInput_EndpointInput_S3InputMode")
        }
        {
            $v = "File","Pipe"
            break
        }

        # Amazon.SageMaker.ProjectSortBy
        "Get-SMProjectList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.ProjectSortOrder
        "Get-SMProjectList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.RecommendationJobStatus
        {
            ($_ -eq "Get-SMInferenceRecommendationsJobStepList/Status") -Or
            ($_ -eq "Get-SMInferenceRecommendationsJobList/StatusEquals")
        }
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","PENDING","STOPPED","STOPPING"
            break
        }

        # Amazon.SageMaker.RecommendationJobType
        "New-SMInferenceRecommendationsJob/JobType"
        {
            $v = "Advanced","Default"
            break
        }

        # Amazon.SageMaker.RecommendationStepType
        "Get-SMInferenceRecommendationsJobStepList/StepType"
        {
            $v = "BENCHMARK"
            break
        }

        # Amazon.SageMaker.ResourceType
        {
            ($_ -eq "Get-SMSearchSuggestion/Resource") -Or
            ($_ -eq "Search-SMResource/Resource")
        }
        {
            $v = "Endpoint","Experiment","ExperimentTrial","ExperimentTrialComponent","FeatureGroup","FeatureMetadata","HyperParameterTuningJob","ModelPackage","ModelPackageGroup","Pipeline","PipelineExecution","Project","TrainingJob"
            break
        }

        # Amazon.SageMaker.RetentionType
        "Remove-SMDomain/RetentionPolicy_HomeEfsFileSystem"
        {
            $v = "Delete","Retain"
            break
        }

        # Amazon.SageMaker.RootAccess
        {
            ($_ -eq "New-SMNotebookInstance/RootAccess") -Or
            ($_ -eq "Update-SMNotebookInstance/RootAccess")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.SageMaker.S3DataType
        "New-SMTransformJob/TransformInput_DataSource_S3DataSource_S3DataType"
        {
            $v = "AugmentedManifestFile","ManifestFile","S3Prefix"
            break
        }

        # Amazon.SageMaker.ScheduleStatus
        "Get-SMMonitoringScheduleList/StatusEquals"
        {
            $v = "Failed","Pending","Scheduled","Stopped"
            break
        }

        # Amazon.SageMaker.SearchSortOrder
        "Search-SMResource/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.SortActionsBy
        "Get-SMActionList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortArtifactsBy
        "Get-SMArtifactList/SortBy"
        {
            $v = "CreationTime"
            break
        }

        # Amazon.SageMaker.SortAssociationsBy
        "Get-SMAssociationList/SortBy"
        {
            $v = "CreationTime","DestinationArn","DestinationType","SourceArn","SourceType"
            break
        }

        # Amazon.SageMaker.SortBy
        {
            ($_ -eq "Get-SMLabelingJobList/SortBy") -Or
            ($_ -eq "Get-SMProcessingJobList/SortBy") -Or
            ($_ -eq "Get-SMTrainingJobList/SortBy") -Or
            ($_ -eq "Get-SMTransformJobList/SortBy")
        }
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.SortContextsBy
        "Get-SMContextList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortExperimentsBy
        "Get-SMExperimentList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortLineageGroupsBy
        "Get-SMLineageGroupList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortOrder
        {
            ($_ -eq "Get-SMActionList/SortOrder") -Or
            ($_ -eq "Get-SMAlgorithmList/SortOrder") -Or
            ($_ -eq "Get-SMAppImageConfigList/SortOrder") -Or
            ($_ -eq "Get-SMAppList/SortOrder") -Or
            ($_ -eq "Get-SMArtifactList/SortOrder") -Or
            ($_ -eq "Get-SMAssociationList/SortOrder") -Or
            ($_ -eq "Get-SMCompilationJobList/SortOrder") -Or
            ($_ -eq "Get-SMContextList/SortOrder") -Or
            ($_ -eq "Get-SMDataQualityJobDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMDeviceFleetList/SortOrder") -Or
            ($_ -eq "Get-SMEdgeDeploymentPlanList/SortOrder") -Or
            ($_ -eq "Get-SMEdgePackagingJobList/SortOrder") -Or
            ($_ -eq "Get-SMExperimentList/SortOrder") -Or
            ($_ -eq "Get-SMFlowDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMHumanTaskUiList/SortOrder") -Or
            ($_ -eq "Get-SMHyperParameterTuningJobList/SortOrder") -Or
            ($_ -eq "Get-SMInferenceRecommendationsJobList/SortOrder") -Or
            ($_ -eq "Get-SMLabelingJobList/SortOrder") -Or
            ($_ -eq "Get-SMLabelingJobListForWorkteam/SortOrder") -Or
            ($_ -eq "Get-SMLineageGroupList/SortOrder") -Or
            ($_ -eq "Get-SMModelBiasJobDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMModelExplainabilityJobDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMModelPackageGroupList/SortOrder") -Or
            ($_ -eq "Get-SMModelPackageList/SortOrder") -Or
            ($_ -eq "Get-SMModelQualityJobDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMMonitoringExecutionList/SortOrder") -Or
            ($_ -eq "Get-SMMonitoringScheduleList/SortOrder") -Or
            ($_ -eq "Get-SMPipelineExecutionList/SortOrder") -Or
            ($_ -eq "Get-SMPipelineExecutionStepList/SortOrder") -Or
            ($_ -eq "Get-SMPipelineList/SortOrder") -Or
            ($_ -eq "Get-SMProcessingJobList/SortOrder") -Or
            ($_ -eq "Get-SMStudioLifecycleConfigList/SortOrder") -Or
            ($_ -eq "Get-SMTrainingJobList/SortOrder") -Or
            ($_ -eq "Get-SMTrainingJobsForHyperParameterTuningJobList/SortOrder") -Or
            ($_ -eq "Get-SMTransformJobList/SortOrder") -Or
            ($_ -eq "Get-SMTrialComponentList/SortOrder") -Or
            ($_ -eq "Get-SMTrialList/SortOrder") -Or
            ($_ -eq "Get-SMUserProfileList/SortOrder") -Or
            ($_ -eq "Get-SMWorkforceList/SortOrder") -Or
            ($_ -eq "Get-SMWorkteamList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.SortPipelineExecutionsBy
        "Get-SMPipelineExecutionList/SortBy"
        {
            $v = "CreationTime","PipelineExecutionArn"
            break
        }

        # Amazon.SageMaker.SortPipelinesBy
        "Get-SMPipelineList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortTrialComponentsBy
        "Get-SMTrialComponentList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortTrialsBy
        "Get-SMTrialList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SplitType
        "New-SMTransformJob/TransformInput_SplitType"
        {
            $v = "Line","None","RecordIO","TFRecord"
            break
        }

        # Amazon.SageMaker.StudioLifecycleConfigAppType
        {
            ($_ -eq "Get-SMStudioLifecycleConfigList/AppTypeEquals") -Or
            ($_ -eq "New-SMStudioLifecycleConfig/StudioLifecycleConfigAppType")
        }
        {
            $v = "JupyterServer","KernelGateway"
            break
        }

        # Amazon.SageMaker.StudioLifecycleConfigSortKey
        "Get-SMStudioLifecycleConfigList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.TargetDevice
        "New-SMCompilationJob/OutputConfig_TargetDevice"
        {
            $v = "aisage","amba_cv2","amba_cv22","amba_cv25","coreml","deeplens","imx8mplus","imx8qm","jacinto_tda4vm","jetson_nano","jetson_tx1","jetson_tx2","jetson_xavier","lambda","ml_c4","ml_c5","ml_eia2","ml_g4dn","ml_inf1","ml_m4","ml_m5","ml_p2","ml_p3","qcs603","qcs605","rasp3b","rk3288","rk3399","sbe_c","sitara_am57x","x86_win32","x86_win64"
            break
        }

        # Amazon.SageMaker.TargetPlatformAccelerator
        "New-SMCompilationJob/OutputConfig_TargetPlatform_Accelerator"
        {
            $v = "INTEL_GRAPHICS","MALI","NNA","NVIDIA"
            break
        }

        # Amazon.SageMaker.TargetPlatformArch
        "New-SMCompilationJob/OutputConfig_TargetPlatform_Arch"
        {
            $v = "ARM64","ARM_EABI","ARM_EABIHF","X86","X86_64"
            break
        }

        # Amazon.SageMaker.TargetPlatformOs
        "New-SMCompilationJob/OutputConfig_TargetPlatform_Os"
        {
            $v = "ANDROID","LINUX"
            break
        }

        # Amazon.SageMaker.TrafficRoutingConfigType
        {
            ($_ -eq "New-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_Type") -Or
            ($_ -eq "Update-SMEndpoint/DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_Type")
        }
        {
            $v = "ALL_AT_ONCE","CANARY","LINEAR"
            break
        }

        # Amazon.SageMaker.TrafficType
        "New-SMInferenceRecommendationsJob/InputConfig_TrafficPattern_TrafficType"
        {
            $v = "PHASES"
            break
        }

        # Amazon.SageMaker.TrainingInputMode
        "New-SMHyperParameterTuningJob/TrainingJobDefinition_AlgorithmSpecification_TrainingInputMode"
        {
            $v = "FastFile","File","Pipe"
            break
        }

        # Amazon.SageMaker.TrainingInstanceType
        "New-SMHyperParameterTuningJob/TrainingJobDefinition_HyperParameterTuningResourceConfig_InstanceType"
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.c5n.18xlarge","ml.c5n.2xlarge","ml.c5n.4xlarge","ml.c5n.9xlarge","ml.c5n.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.g5.12xlarge","ml.g5.16xlarge","ml.g5.24xlarge","ml.g5.2xlarge","ml.g5.48xlarge","ml.g5.4xlarge","ml.g5.8xlarge","ml.g5.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.p3dn.24xlarge","ml.p4d.24xlarge","ml.trn1.2xlarge","ml.trn1.32xlarge"
            break
        }

        # Amazon.SageMaker.TrainingJobEarlyStoppingType
        "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_TrainingJobEarlyStoppingType"
        {
            $v = "Auto","Off"
            break
        }

        # Amazon.SageMaker.TrainingJobSortByOptions
        "Get-SMTrainingJobsForHyperParameterTuningJobList/SortBy"
        {
            $v = "CreationTime","FinalObjectiveMetricValue","Name","Status"
            break
        }

        # Amazon.SageMaker.TrainingJobStatus
        {
            ($_ -eq "Get-SMTrainingJobList/StatusEquals") -Or
            ($_ -eq "Get-SMTrainingJobsForHyperParameterTuningJobList/StatusEquals")
        }
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.TransformInstanceType
        "New-SMTransformJob/TransformResources_InstanceType"
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge"
            break
        }

        # Amazon.SageMaker.TransformJobStatus
        "Get-SMTransformJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.TrialComponentPrimaryStatus
        {
            ($_ -eq "New-SMTrialComponent/Status_PrimaryStatus") -Or
            ($_ -eq "Update-SMTrialComponent/Status_PrimaryStatus")
        }
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.UserProfileSortKey
        "Get-SMUserProfileList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime"
            break
        }

        # Amazon.SageMaker.WarmPoolResourceStatus
        "Get-SMTrainingJobList/WarmPoolStatusEquals"
        {
            $v = "Available","InUse","Reused","Terminated"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SM_map = @{
    "AppNetworkAccessType"=@("New-SMDomain")
    "AppSecurityGroupManagement"=@("New-SMDomain")
    "AppType"=@("Get-SMApp","New-SMApp","Remove-SMApp")
    "AppTypeEquals"=@("Get-SMStudioLifecycleConfigList")
    "AssociationType"=@("Add-SMAssociation","Get-SMAssociationList")
    "AuthMode"=@("New-SMDomain")
    "AutoMLJobConfig_Mode"=@("New-SMAutoMLJob")
    "AutoMLJobObjective_MetricName"=@("New-SMAutoMLJob")
    "BatchStrategy"=@("New-SMTransformJob")
    "DataProcessing_JoinSource"=@("New-SMTransformJob")
    "DataQualityJobInput_BatchTransformInput_S3DataDistributionType"=@("New-SMDataQualityJobDefinition")
    "DataQualityJobInput_BatchTransformInput_S3InputMode"=@("New-SMDataQualityJobDefinition")
    "DataQualityJobInput_EndpointInput_S3DataDistributionType"=@("New-SMDataQualityJobDefinition")
    "DataQualityJobInput_EndpointInput_S3InputMode"=@("New-SMDataQualityJobDefinition")
    "DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_CanarySize_Type"=@("New-SMEndpoint","Update-SMEndpoint")
    "DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_LinearStepSize_Type"=@("New-SMEndpoint","Update-SMEndpoint")
    "DeploymentConfig_BlueGreenUpdatePolicy_TrafficRoutingConfiguration_Type"=@("New-SMEndpoint","Update-SMEndpoint")
    "DirectInternetAccess"=@("New-SMNotebookInstance")
    "Direction"=@("Find-SMLineage")
    "DomainSettings_ExecutionRoleIdentityConfig"=@("New-SMDomain")
    "DomainSettings_RStudioServerProDomainSettings_DefaultResourceSpec_InstanceType"=@("New-SMDomain")
    "DomainSettingsForUpdate_ExecutionRoleIdentityConfig"=@("Update-SMDomain")
    "DomainSettingsForUpdate_RStudioServerProDomainSettingsForUpdate_DefaultResourceSpec_InstanceType"=@("Update-SMDomain")
    "ExplainerConfig_ClarifyExplainerConfig_ShapConfig_TextConfig_Granularity"=@("New-SMEndpointConfig")
    "ExplainerConfig_ClarifyExplainerConfig_ShapConfig_TextConfig_Language"=@("New-SMEndpointConfig")
    "FeatureGroupStatusEquals"=@("Get-SMFeatureGroupList")
    "HumanLoopRequestSource_AwsManagedHumanLoopRequestSource"=@("New-SMFlowDefinition")
    "HyperParameterTuningJobConfig_HyperParameterTuningJobObjective_Type"=@("New-SMHyperParameterTuningJob")
    "HyperParameterTuningJobConfig_Strategy"=@("New-SMHyperParameterTuningJob")
    "HyperParameterTuningJobConfig_TrainingJobEarlyStoppingType"=@("New-SMHyperParameterTuningJob")
    "InferenceExecutionConfig_Mode"=@("New-SMModel")
    "InputConfig_Framework"=@("New-SMCompilationJob")
    "InputConfig_TrafficPattern_TrafficType"=@("New-SMInferenceRecommendationsJob")
    "InstanceType"=@("New-SMNotebookInstance","Update-SMNotebookInstance")
    "JobResources_ClusterConfig_InstanceType"=@("New-SMDataQualityJobDefinition","New-SMModelBiasJobDefinition","New-SMModelExplainabilityJobDefinition","New-SMModelQualityJobDefinition")
    "JobType"=@("New-SMInferenceRecommendationsJob")
    "ModelApprovalStatus"=@("Get-SMModelPackageList","New-SMModelPackage","Update-SMModelPackage")
    "ModelBiasJobInput_BatchTransformInput_S3DataDistributionType"=@("New-SMModelBiasJobDefinition")
    "ModelBiasJobInput_BatchTransformInput_S3InputMode"=@("New-SMModelBiasJobDefinition")
    "ModelBiasJobInput_EndpointInput_S3DataDistributionType"=@("New-SMModelBiasJobDefinition")
    "ModelBiasJobInput_EndpointInput_S3InputMode"=@("New-SMModelBiasJobDefinition")
    "ModelExplainabilityJobInput_BatchTransformInput_S3DataDistributionType"=@("New-SMModelExplainabilityJobDefinition")
    "ModelExplainabilityJobInput_BatchTransformInput_S3InputMode"=@("New-SMModelExplainabilityJobDefinition")
    "ModelExplainabilityJobInput_EndpointInput_S3DataDistributionType"=@("New-SMModelExplainabilityJobDefinition")
    "ModelExplainabilityJobInput_EndpointInput_S3InputMode"=@("New-SMModelExplainabilityJobDefinition")
    "ModelPackageType"=@("Get-SMModelPackageList")
    "ModelQualityAppSpecification_ProblemType"=@("New-SMModelQualityJobDefinition")
    "ModelQualityJobInput_BatchTransformInput_S3DataDistributionType"=@("New-SMModelQualityJobDefinition")
    "ModelQualityJobInput_BatchTransformInput_S3InputMode"=@("New-SMModelQualityJobDefinition")
    "ModelQualityJobInput_EndpointInput_S3DataDistributionType"=@("New-SMModelQualityJobDefinition")
    "ModelQualityJobInput_EndpointInput_S3InputMode"=@("New-SMModelQualityJobDefinition")
    "MonitoringTypeEquals"=@("Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList")
    "OfflineStoreStatusEquals"=@("Get-SMFeatureGroupList")
    "OutputConfig_PresetDeploymentType"=@("New-SMDeviceFleet","New-SMEdgePackagingJob","Update-SMDeviceFleet")
    "OutputConfig_TargetDevice"=@("New-SMCompilationJob")
    "OutputConfig_TargetPlatform_Accelerator"=@("New-SMCompilationJob")
    "OutputConfig_TargetPlatform_Arch"=@("New-SMCompilationJob")
    "OutputConfig_TargetPlatform_Os"=@("New-SMCompilationJob")
    "ProblemType"=@("New-SMAutoMLJob")
    "ProcessingResources_ClusterConfig_InstanceType"=@("New-SMProcessingJob")
    "Resource"=@("Get-SMSearchSuggestion","Search-SMResource")
    "ResourceSpec_InstanceType"=@("New-SMApp")
    "RetentionPolicy_HomeEfsFileSystem"=@("Remove-SMDomain")
    "RootAccess"=@("New-SMNotebookInstance","Update-SMNotebookInstance")
    "SearchExpression_Operator"=@("Search-SMResource")
    "SortBy"=@("Get-SMActionList","Get-SMAlgorithmList","Get-SMAppImageConfigList","Get-SMAppList","Get-SMArtifactList","Get-SMAssociationList","Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCodeRepositoryList","Get-SMCompilationJobList","Get-SMConfigList","Get-SMContextList","Get-SMDataQualityJobDefinitionList","Get-SMDeviceFleetList","Get-SMEdgeDeploymentPlanList","Get-SMEdgePackagingJobList","Get-SMEndpointList","Get-SMExperimentList","Get-SMFeatureGroupList","Get-SMHyperParameterTuningJobList","Get-SMImageList","Get-SMImageVersionList","Get-SMInferenceRecommendationsJobList","Get-SMLabelingJobList","Get-SMLabelingJobListForWorkteam","Get-SMLineageGroupList","Get-SMModelBiasJobDefinitionList","Get-SMModelExplainabilityJobDefinitionList","Get-SMModelList","Get-SMModelPackageGroupList","Get-SMModelPackageList","Get-SMModelQualityJobDefinitionList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceLifecycleConfigList","Get-SMNotebookInstanceList","Get-SMPipelineExecutionList","Get-SMPipelineList","Get-SMProcessingJobList","Get-SMProjectList","Get-SMStudioLifecycleConfigList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList","Get-SMTrialComponentList","Get-SMTrialList","Get-SMUserProfileList","Get-SMWorkforceList","Get-SMWorkteamList")
    "SortOrder"=@("Get-SMActionList","Get-SMAlgorithmList","Get-SMAppImageConfigList","Get-SMAppList","Get-SMArtifactList","Get-SMAssociationList","Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCodeRepositoryList","Get-SMCompilationJobList","Get-SMConfigList","Get-SMContextList","Get-SMDataQualityJobDefinitionList","Get-SMDeviceFleetList","Get-SMEdgeDeploymentPlanList","Get-SMEdgePackagingJobList","Get-SMEndpointList","Get-SMExperimentList","Get-SMFeatureGroupList","Get-SMFlowDefinitionList","Get-SMHumanTaskUiList","Get-SMHyperParameterTuningJobList","Get-SMImageList","Get-SMImageVersionList","Get-SMInferenceRecommendationsJobList","Get-SMLabelingJobList","Get-SMLabelingJobListForWorkteam","Get-SMLineageGroupList","Get-SMModelBiasJobDefinitionList","Get-SMModelExplainabilityJobDefinitionList","Get-SMModelList","Get-SMModelPackageGroupList","Get-SMModelPackageList","Get-SMModelQualityJobDefinitionList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceLifecycleConfigList","Get-SMNotebookInstanceList","Get-SMPipelineExecutionList","Get-SMPipelineExecutionStepList","Get-SMPipelineList","Get-SMProcessingJobList","Get-SMProjectList","Get-SMStudioLifecycleConfigList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList","Get-SMTrialComponentList","Get-SMTrialList","Get-SMUserProfileList","Get-SMWorkforceList","Get-SMWorkteamList","Search-SMResource")
    "Status"=@("Get-SMInferenceRecommendationsJobStepList","New-SMAction","Update-SMAction")
    "Status_PrimaryStatus"=@("New-SMTrialComponent","Update-SMTrialComponent")
    "StatusEquals"=@("Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCompilationJobList","Get-SMEdgePackagingJobList","Get-SMEndpointList","Get-SMHyperParameterTuningJobList","Get-SMInferenceRecommendationsJobList","Get-SMLabelingJobList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceList","Get-SMProcessingJobList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList")
    "StepType"=@("Get-SMInferenceRecommendationsJobStepList")
    "StudioLifecycleConfigAppType"=@("New-SMStudioLifecycleConfig")
    "TrainingJobDefinition_AlgorithmSpecification_TrainingInputMode"=@("New-SMHyperParameterTuningJob")
    "TrainingJobDefinition_HyperParameterTuningResourceConfig_AllocationStrategy"=@("New-SMHyperParameterTuningJob")
    "TrainingJobDefinition_HyperParameterTuningResourceConfig_InstanceType"=@("New-SMHyperParameterTuningJob")
    "TrainingJobDefinition_TuningObjective_Type"=@("New-SMHyperParameterTuningJob")
    "TransformInput_CompressionType"=@("New-SMTransformJob")
    "TransformInput_DataSource_S3DataSource_S3DataType"=@("New-SMTransformJob")
    "TransformInput_SplitType"=@("New-SMTransformJob")
    "TransformOutput_AssembleWith"=@("New-SMTransformJob")
    "TransformResources_InstanceType"=@("New-SMTransformJob")
    "WarmPoolStatusEquals"=@("Get-SMTrainingJobList")
    "WarmStartConfig_WarmStartType"=@("New-SMHyperParameterTuningJob")
}

_awsArgumentCompleterRegistration $SM_Completers $SM_map

$SM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SM_SelectMap = @{
    "Select"=@("Add-SMAssociation",
               "Add-SMResourceTag",
               "Register-SMTrialComponent",
               "Get-SMDescribeModelPackage",
               "New-SMAction",
               "New-SMAlgorithm",
               "New-SMApp",
               "New-SMAppImageConfig",
               "New-SMArtifact",
               "New-SMAutoMLJob",
               "New-SMCodeRepository",
               "New-SMCompilationJob",
               "New-SMContext",
               "New-SMDataQualityJobDefinition",
               "New-SMDeviceFleet",
               "New-SMDomain",
               "New-SMEdgeDeploymentPlan",
               "New-SMEdgeDeploymentStage",
               "New-SMEdgePackagingJob",
               "New-SMEndpoint",
               "New-SMEndpointConfig",
               "New-SMExperiment",
               "New-SMFeatureGroup",
               "New-SMFlowDefinition",
               "New-SMHumanTaskUi",
               "New-SMHyperParameterTuningJob",
               "New-SMImage",
               "New-SMImageVersion",
               "New-SMInferenceRecommendationsJob",
               "New-SMLabelingJob",
               "New-SMModel",
               "New-SMModelBiasJobDefinition",
               "New-SMModelExplainabilityJobDefinition",
               "New-SMModelPackage",
               "New-SMModelPackageGroup",
               "New-SMModelQualityJobDefinition",
               "New-SMMonitoringSchedule",
               "New-SMNotebookInstance",
               "New-SMNotebookInstanceLifecycleConfig",
               "New-SMPipeline",
               "New-SMPresignedDomainUrl",
               "New-SMPresignedNotebookInstanceUrl",
               "New-SMProcessingJob",
               "New-SMProject",
               "New-SMStudioLifecycleConfig",
               "New-SMTrainingJob",
               "New-SMTransformJob",
               "New-SMTrial",
               "New-SMTrialComponent",
               "New-SMUserProfile",
               "New-SMWorkforce",
               "New-SMWorkteam",
               "Remove-SMAction",
               "Remove-SMAlgorithm",
               "Remove-SMApp",
               "Remove-SMAppImageConfig",
               "Remove-SMArtifact",
               "Remove-SMAssociation",
               "Remove-SMCodeRepository",
               "Remove-SMContext",
               "Remove-SMDataQualityJobDefinition",
               "Remove-SMDeviceFleet",
               "Remove-SMDomain",
               "Remove-SMEdgeDeploymentPlan",
               "Remove-SMEdgeDeploymentStage",
               "Remove-SMEndpoint",
               "Remove-SMEndpointConfig",
               "Remove-SMExperiment",
               "Remove-SMFeatureGroup",
               "Remove-SMFlowDefinition",
               "Remove-SMHumanTaskUi",
               "Remove-SMImage",
               "Remove-SMImageVersion",
               "Remove-SMModel",
               "Remove-SMModelBiasJobDefinition",
               "Remove-SMModelExplainabilityJobDefinition",
               "Remove-SMModelPackage",
               "Remove-SMModelPackageGroup",
               "Remove-SMModelPackageGroupPolicy",
               "Remove-SMModelQualityJobDefinition",
               "Remove-SMMonitoringSchedule",
               "Remove-SMNotebookInstance",
               "Remove-SMNotebookInstanceLifecycleConfig",
               "Remove-SMPipeline",
               "Remove-SMProject",
               "Remove-SMStudioLifecycleConfig",
               "Remove-SMResourceTag",
               "Remove-SMTrial",
               "Remove-SMTrialComponent",
               "Remove-SMUserProfile",
               "Remove-SMWorkforce",
               "Remove-SMWorkteam",
               "Remove-SMDevice",
               "Get-SMAction",
               "Get-SMAlgorithm",
               "Get-SMApp",
               "Get-SMAppImageConfig",
               "Get-SMArtifact",
               "Get-SMAutoMLJob",
               "Get-SMCodeRepository",
               "Get-SMCompilationJob",
               "Get-SMContext",
               "Get-SMDataQualityJobDefinition",
               "Get-SMDevice",
               "Get-SMDeviceFleet",
               "Get-SMDomain",
               "Get-SMEdgeDeploymentPlan",
               "Get-SMEdgePackagingJob",
               "Get-SMEndpoint",
               "Get-SMEndpointConfig",
               "Get-SMExperiment",
               "Get-SMFeatureGroup",
               "Get-SMFeatureMetadata",
               "Get-SMFlowDefinition",
               "Get-SMHumanTaskUi",
               "Get-SMHyperParameterTuningJob",
               "Get-SMImage",
               "Get-SMImageVersion",
               "Get-SMInferenceRecommendationsJob",
               "Get-SMLabelingJob",
               "Get-SMLineageGroup",
               "Get-SMModel",
               "Get-SMModelBiasJobDefinition",
               "Get-SMModelExplainabilityJobDefinition",
               "Get-SMModelPackage",
               "Get-SMModelPackageGroup",
               "Get-SMModelQualityJobDefinition",
               "Get-SMMonitoringSchedule",
               "Get-SMNotebookInstance",
               "Get-SMNotebookInstanceLifecycleConfig",
               "Get-SMPipeline",
               "Get-SMPipelineDefinitionForExecution",
               "Get-SMPipelineExecution",
               "Get-SMProcessingJob",
               "Get-SMProject",
               "Get-SMStudioLifecycleConfig",
               "Get-SMSubscribedWorkteam",
               "Get-SMTrainingJob",
               "Get-SMTransformJob",
               "Get-SMTrial",
               "Get-SMTrialComponent",
               "Get-SMUserProfile",
               "Get-SMWorkforce",
               "Get-SMWorkteam",
               "Disable-SMSagemakerServicecatalogPortfolio",
               "Unregister-SMTrialComponent",
               "Enable-SMSagemakerServicecatalogPortfolio",
               "Get-SMDeviceFleetReport",
               "Get-SMLineageGroupPolicy",
               "Get-SMModelPackageGroupPolicy",
               "Get-SMSagemakerServicecatalogPortfolioStatus",
               "Get-SMSearchSuggestion",
               "Get-SMActionList",
               "Get-SMAlgorithmList",
               "Get-SMAppImageConfigList",
               "Get-SMAppList",
               "Get-SMArtifactList",
               "Get-SMAssociationList",
               "Get-SMAutoMLJobList",
               "Get-SMCandidatesForAutoMLJobList",
               "Get-SMCodeRepositoryList",
               "Get-SMCompilationJobList",
               "Get-SMContextList",
               "Get-SMDataQualityJobDefinitionList",
               "Get-SMDeviceFleetList",
               "Get-SMDeviceList",
               "Get-SMDomainList",
               "Get-SMEdgeDeploymentPlanList",
               "Get-SMEdgePackagingJobList",
               "Get-SMConfigList",
               "Get-SMEndpointList",
               "Get-SMExperimentList",
               "Get-SMFeatureGroupList",
               "Get-SMFlowDefinitionList",
               "Get-SMHumanTaskUiList",
               "Get-SMHyperParameterTuningJobList",
               "Get-SMImageList",
               "Get-SMImageVersionList",
               "Get-SMInferenceRecommendationsJobList",
               "Get-SMInferenceRecommendationsJobStepList",
               "Get-SMLabelingJobList",
               "Get-SMLabelingJobListForWorkteam",
               "Get-SMLineageGroupList",
               "Get-SMModelBiasJobDefinitionList",
               "Get-SMModelExplainabilityJobDefinitionList",
               "Get-SMModelMetadataList",
               "Get-SMModelPackageGroupList",
               "Get-SMModelPackageList",
               "Get-SMModelQualityJobDefinitionList",
               "Get-SMModelList",
               "Get-SMMonitoringExecutionList",
               "Get-SMMonitoringScheduleList",
               "Get-SMNotebookInstanceLifecycleConfigList",
               "Get-SMNotebookInstanceList",
               "Get-SMPipelineExecutionList",
               "Get-SMPipelineExecutionStepList",
               "Get-SMPipelineParametersForExecutionList",
               "Get-SMPipelineList",
               "Get-SMProcessingJobList",
               "Get-SMProjectList",
               "Get-SMStageDeviceList",
               "Get-SMStudioLifecycleConfigList",
               "Get-SMSubscribedWorkteamList",
               "Get-SMResourceTagList",
               "Get-SMTrainingJobList",
               "Get-SMTrainingJobsForHyperParameterTuningJobList",
               "Get-SMTransformJobList",
               "Get-SMTrialComponentList",
               "Get-SMTrialList",
               "Get-SMUserProfileList",
               "Get-SMWorkforceList",
               "Get-SMWorkteamList",
               "Write-SMModelPackageGroupPolicy",
               "Find-SMLineage",
               "Register-SMDevice",
               "Invoke-SMUiTemplateRendering",
               "Restart-SMPipelineExecution",
               "Search-SMResource",
               "Send-SMPipelineExecutionStepFailure",
               "Send-SMPipelineExecutionStepSuccess",
               "Start-SMEdgeDeploymentStage",
               "Start-SMMonitoringSchedule",
               "Start-SMNotebookInstance",
               "Start-SMPipelineExecution",
               "Stop-SMAutoMLJob",
               "Stop-SMCompilationJob",
               "Stop-SMEdgeDeploymentStage",
               "Stop-SMEdgePackagingJob",
               "Stop-SMHyperParameterTuningJob",
               "Stop-SMInferenceRecommendationsJob",
               "Stop-SMLabelingJob",
               "Stop-SMMonitoringSchedule",
               "Stop-SMNotebookInstance",
               "Stop-SMPipelineExecution",
               "Stop-SMProcessingJob",
               "Stop-SMTrainingJob",
               "Stop-SMTransformJob",
               "Update-SMAction",
               "Update-SMAppImageConfig",
               "Update-SMArtifact",
               "Update-SMCodeRepository",
               "Update-SMContext",
               "Update-SMDeviceFleet",
               "Update-SMDevice",
               "Update-SMDomain",
               "Update-SMEndpoint",
               "Update-SMEndpointWeightAndCapacity",
               "Update-SMExperiment",
               "Update-SMFeatureGroup",
               "Update-SMFeatureMetadata",
               "Update-SMImage",
               "Update-SMModelPackage",
               "Update-SMMonitoringSchedule",
               "Update-SMNotebookInstance",
               "Update-SMNotebookInstanceLifecycleConfig",
               "Update-SMPipeline",
               "Update-SMPipelineExecution",
               "Update-SMProject",
               "Update-SMTrainingJob",
               "Update-SMTrial",
               "Update-SMTrialComponent",
               "Update-SMUserProfile",
               "Update-SMWorkforce",
               "Update-SMWorkteam")
}

_awsArgumentCompleterRegistration $SM_SelectCompleters $SM_SelectMap
# Argument completions for service Amazon Augmented AI (A2I) Runtime


$A2IR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AugmentedAIRuntime.SortOrder
        "Get-A2IRHumanLoopList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$A2IR_map = @{
    "SortOrder"=@("Get-A2IRHumanLoopList")
}

_awsArgumentCompleterRegistration $A2IR_Completers $A2IR_map

$A2IR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.A2IR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$A2IR_SelectMap = @{
    "Select"=@("Remove-A2IRHumanLoop",
               "Get-A2IRHumanLoop",
               "Get-A2IRHumanLoopList",
               "Start-A2IRHumanLoop",
               "Stop-A2IRHumanLoop")
}

_awsArgumentCompleterRegistration $A2IR_SelectCompleters $A2IR_SelectMap
# Argument completions for service Amazon Sagemaker Edge Manager


$SME_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SME.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SME_SelectMap = @{
    "Select"=@("Get-SMEDeployment",
               "Get-SMEDeviceRegistration",
               "Send-SMEHeartbeat")
}

_awsArgumentCompleterRegistration $SME_SelectCompleters $SME_SelectMap
# Argument completions for service Amazon SageMaker Feature Store Runtime


$SMFS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMFS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMFS_SelectMap = @{
    "Select"=@("Get-SMFSRecordBatch",
               "Remove-SMFSRecord",
               "Get-SMFSRecord",
               "Write-SMFSRecord")
}

_awsArgumentCompleterRegistration $SMFS_SelectCompleters $SMFS_SelectMap
# Argument completions for service AWS Savings Plans


$SP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SavingsPlans.SavingsPlanProductType
        "Get-SPSavingsPlansOffering/ProductType"
        {
            $v = "EC2","Fargate","Lambda","SageMaker"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SP_map = @{
    "ProductType"=@("Get-SPSavingsPlansOffering")
}

_awsArgumentCompleterRegistration $SP_Completers $SP_map

$SP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SP_SelectMap = @{
    "Select"=@("New-SPSavingsPlan",
               "Remove-SPQueuedSavingsPlan",
               "Get-SPSavingsPlanRate",
               "Get-SPSavingsPlan",
               "Get-SPSavingsPlansOfferingRate",
               "Get-SPSavingsPlansOffering",
               "Get-SPResourceTag",
               "Add-SPResourceTag",
               "Remove-SPResourceTag")
}

_awsArgumentCompleterRegistration $SP_SelectCompleters $SP_SelectMap
# Argument completions for service Amazon EventBridge Scheduler


$SCH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Scheduler.AssignPublicIp
        {
            ($_ -eq "New-SCHSchedule/Target_EcsParameters_NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "Update-SCHSchedule/Target_EcsParameters_NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Scheduler.FlexibleTimeWindowMode
        {
            ($_ -eq "New-SCHSchedule/FlexibleTimeWindow_Mode") -Or
            ($_ -eq "Update-SCHSchedule/FlexibleTimeWindow_Mode")
        }
        {
            $v = "FLEXIBLE","OFF"
            break
        }

        # Amazon.Scheduler.LaunchType
        {
            ($_ -eq "New-SCHSchedule/Target_EcsParameters_LaunchType") -Or
            ($_ -eq "Update-SCHSchedule/Target_EcsParameters_LaunchType")
        }
        {
            $v = "EC2","EXTERNAL","FARGATE"
            break
        }

        # Amazon.Scheduler.PropagateTags
        {
            ($_ -eq "New-SCHSchedule/Target_EcsParameters_PropagateTags") -Or
            ($_ -eq "Update-SCHSchedule/Target_EcsParameters_PropagateTags")
        }
        {
            $v = "TASK_DEFINITION"
            break
        }

        # Amazon.Scheduler.ScheduleState
        {
            ($_ -eq "Get-SCHScheduleList/State") -Or
            ($_ -eq "New-SCHSchedule/State") -Or
            ($_ -eq "Update-SCHSchedule/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCH_map = @{
    "FlexibleTimeWindow_Mode"=@("New-SCHSchedule","Update-SCHSchedule")
    "State"=@("Get-SCHScheduleList","New-SCHSchedule","Update-SCHSchedule")
    "Target_EcsParameters_LaunchType"=@("New-SCHSchedule","Update-SCHSchedule")
    "Target_EcsParameters_NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp"=@("New-SCHSchedule","Update-SCHSchedule")
    "Target_EcsParameters_PropagateTags"=@("New-SCHSchedule","Update-SCHSchedule")
}

_awsArgumentCompleterRegistration $SCH_Completers $SCH_map

$SCH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SCH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCH_SelectMap = @{
    "Select"=@("New-SCHSchedule",
               "New-SCHScheduleGroup",
               "Remove-SCHSchedule",
               "Remove-SCHScheduleGroup",
               "Get-SCHSchedule",
               "Get-SCHScheduleGroup",
               "Get-SCHScheduleGroupList",
               "Get-SCHScheduleList",
               "Get-SCHResourceTag",
               "Add-SCHResourceTag",
               "Remove-SCHResourceTag",
               "Update-SCHSchedule")
}

_awsArgumentCompleterRegistration $SCH_SelectCompleters $SCH_SelectMap
# Argument completions for service Amazon EventBridge Schema Registry


$SCHM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Schemas.Type
        {
            ($_ -eq "Get-SCHMDiscoveredSchema/Type") -Or
            ($_ -eq "New-SCHMSchema/Type") -Or
            ($_ -eq "Update-SCHMSchema/Type")
        }
        {
            $v = "JSONSchemaDraft4","OpenApi3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCHM_map = @{
    "Type"=@("Get-SCHMDiscoveredSchema","New-SCHMSchema","Update-SCHMSchema")
}

_awsArgumentCompleterRegistration $SCHM_Completers $SCHM_map

$SCHM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SCHM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCHM_SelectMap = @{
    "Select"=@("New-SCHMDiscoverer",
               "New-SCHMRegistry",
               "New-SCHMSchema",
               "Remove-SCHMDiscoverer",
               "Remove-SCHMRegistry",
               "Remove-SCHMResourcePolicy",
               "Remove-SCHMSchema",
               "Remove-SCHMSchemaVersion",
               "Get-SCHMCodeBinding",
               "Get-SCHMDiscoverer",
               "Get-SCHMRegistry",
               "Get-SCHMSchema",
               "Export-SCHMSchema",
               "Get-SCHMCodeBindingSource",
               "Get-SCHMDiscoveredSchema",
               "Get-SCHMResourcePolicy",
               "Get-SCHMDiscovererList",
               "Get-SCHMRegistryList",
               "Get-SCHMSchemaList",
               "Get-SCHMSchemaVersionList",
               "Get-SCHMResourceTag",
               "Write-SCHMCodeBinding",
               "Write-SCHMResourcePolicy",
               "Search-SCHMSchema",
               "Start-SCHMDiscoverer",
               "Stop-SCHMDiscoverer",
               "Add-SCHMResourceTag",
               "Remove-SCHMResourceTag",
               "Update-SCHMDiscoverer",
               "Update-SCHMRegistry",
               "Update-SCHMSchema")
}

_awsArgumentCompleterRegistration $SCHM_SelectCompleters $SCHM_SelectMap
# Argument completions for service AWS Secrets Manager


$SEC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SecretsManager.SortOrderType
        "Get-SECSecretList/SortOrder"
        {
            $v = "asc","desc"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SEC_map = @{
    "SortOrder"=@("Get-SECSecretList")
}

_awsArgumentCompleterRegistration $SEC_Completers $SEC_map

$SEC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SEC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SEC_SelectMap = @{
    "Select"=@("Stop-SECSecretRotation",
               "New-SECSecret",
               "Remove-SECResourcePolicy",
               "Remove-SECSecret",
               "Get-SECSecret",
               "Get-SECRandomPassword",
               "Get-SECResourcePolicy",
               "Get-SECSecretValue",
               "Get-SECSecretList",
               "Get-SECSecretVersionIdList",
               "Write-SECResourcePolicy",
               "Write-SECSecretValue",
               "Remove-SECRegionsFromReplication",
               "Add-SECSecretToRegion",
               "Restore-SECSecret",
               "Invoke-SECSecretRotation",
               "Stop-SECReplicationToReplica",
               "Add-SECResourceTag",
               "Remove-SECResourceTag",
               "Update-SECSecret",
               "Update-SECSecretVersionStage",
               "Test-SECResourcePolicy")
}

_awsArgumentCompleterRegistration $SEC_SelectCompleters $SEC_SelectMap
# Argument completions for service AWS Security Hub


$SHUB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SecurityHub.AutoEnableStandards
        "Update-SHUBOrganizationConfiguration/AutoEnableStandards"
        {
            $v = "DEFAULT","NONE"
            break
        }

        # Amazon.SecurityHub.ControlStatus
        "Update-SHUBStandardsControl/ControlStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.SecurityHub.RecordState
        "Update-SHUBFinding/RecordState"
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }

        # Amazon.SecurityHub.SeverityLabel
        "Update-SHUBFindingsBatch/Severity_Label"
        {
            $v = "CRITICAL","HIGH","INFORMATIONAL","LOW","MEDIUM"
            break
        }

        # Amazon.SecurityHub.VerificationState
        "Update-SHUBFindingsBatch/VerificationState"
        {
            $v = "BENIGN_POSITIVE","FALSE_POSITIVE","TRUE_POSITIVE","UNKNOWN"
            break
        }

        # Amazon.SecurityHub.WorkflowStatus
        "Update-SHUBFindingsBatch/Workflow_Status"
        {
            $v = "NEW","NOTIFIED","RESOLVED","SUPPRESSED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHUB_map = @{
    "AutoEnableStandards"=@("Update-SHUBOrganizationConfiguration")
    "ControlStatus"=@("Update-SHUBStandardsControl")
    "RecordState"=@("Update-SHUBFinding")
    "Severity_Label"=@("Update-SHUBFindingsBatch")
    "VerificationState"=@("Update-SHUBFindingsBatch")
    "Workflow_Status"=@("Update-SHUBFindingsBatch")
}

_awsArgumentCompleterRegistration $SHUB_Completers $SHUB_map

$SHUB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SHUB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHUB_SelectMap = @{
    "Select"=@("Confirm-SHUBAdministratorInvitation",
               "Confirm-SHUBInvitation",
               "Disable-SHUBStandardsBatch",
               "Enable-SHUBStandardsBatch",
               "Import-SHUBFindingsBatch",
               "Update-SHUBFindingsBatch",
               "New-SHUBActionTarget",
               "New-SHUBFindingAggregator",
               "New-SHUBInsight",
               "New-SHUBMember",
               "Deny-SHUBInvitation",
               "Remove-SHUBActionTarget",
               "Remove-SHUBFindingAggregator",
               "Remove-SHUBInsight",
               "Remove-SHUBInvitation",
               "Remove-SHUBMember",
               "Get-SHUBActionTarget",
               "Get-SHUBHub",
               "Get-SHUBOrganizationConfiguration",
               "Get-SHUBProduct",
               "Get-SHUBStandard",
               "Get-SHUBStandardsControl",
               "Disable-SHUBImportFindingsForProduct",
               "Disable-SHUBOrganizationAdminAccount",
               "Disable-SHUBSecurityHub",
               "Remove-SHUBFromAdministratorAccount",
               "Remove-SHUBMasterAccountAssociation",
               "Remove-SHUBMemberAssociation",
               "Enable-SHUBImportFindingsForProduct",
               "Enable-SHUBOrganizationAdminAccount",
               "Enable-SHUBSecurityHub",
               "Get-SHUBAdministratorAccount",
               "Get-SHUBEnabledStandard",
               "Get-SHUBFindingAggregator",
               "Get-SHUBFinding",
               "Get-SHUBInsightResult",
               "Get-SHUBInsight",
               "Get-SHUBInvitationsCount",
               "Get-SHUBMasterAccount",
               "Get-SHUBMember",
               "Send-SHUBMemberInvitation",
               "Get-SHUBEnabledProductsForImportList",
               "Get-SHUBFindingAggregatorList",
               "Get-SHUBInvitationList",
               "Get-SHUBMemberList",
               "Get-SHUBOrganizationAdminAccountList",
               "Get-SHUBResourceTag",
               "Add-SHUBResourceTag",
               "Remove-SHUBResourceTag",
               "Update-SHUBActionTarget",
               "Update-SHUBFindingAggregator",
               "Update-SHUBFinding",
               "Update-SHUBInsight",
               "Update-SHUBOrganizationConfiguration",
               "Update-SHUBSecurityHubConfiguration",
               "Update-SHUBStandardsControl")
}

_awsArgumentCompleterRegistration $SHUB_SelectCompleters $SHUB_SelectMap
# Argument completions for service AWS Serverless Application Repository


$SAR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SAR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SAR_SelectMap = @{
    "Select"=@("New-SARApplication",
               "New-SARApplicationVersion",
               "New-SARCloudFormationChangeSet",
               "New-SARCloudFormationTemplate",
               "Remove-SARApplication",
               "Get-SARApplication",
               "Get-SARApplicationPolicy",
               "Get-SARCloudFormationTemplate",
               "Get-SARApplicationDependencyList",
               "Get-SARApplicationList",
               "Get-SARApplicationVersionList",
               "Set-SARApplicationPolicy",
               "Revoke-SARApplicationSharing",
               "Update-SARApplication")
}

_awsArgumentCompleterRegistration $SAR_SelectCompleters $SAR_SelectMap
# Argument completions for service AWS Service Catalog


$SC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceCatalog.AccessLevelFilterKey
        {
            ($_ -eq "Find-SCProvisionedProduct/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCProvisionedProduct/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCProvisionedProductPlanList/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCRecordHistory/AccessLevelFilter_Key")
        }
        {
            $v = "Account","Role","User"
            break
        }

        # Amazon.ServiceCatalog.DescribePortfolioShareType
        "Get-SCPortfolioShare/Type"
        {
            $v = "ACCOUNT","ORGANIZATION","ORGANIZATIONAL_UNIT","ORGANIZATION_MEMBER_ACCOUNT"
            break
        }

        # Amazon.ServiceCatalog.OrganizationNodeType
        {
            ($_ -eq "New-SCPortfolioShare/OrganizationNode_Type") -Or
            ($_ -eq "Remove-SCPortfolioShare/OrganizationNode_Type") -Or
            ($_ -eq "Update-SCPortfolioShare/OrganizationNode_Type") -Or
            ($_ -eq "Get-SCOrganizationPortfolioAccessList/OrganizationNodeType")
        }
        {
            $v = "ACCOUNT","ORGANIZATION","ORGANIZATIONAL_UNIT"
            break
        }

        # Amazon.ServiceCatalog.PortfolioShareType
        {
            ($_ -eq "Deny-SCPortfolioShare/PortfolioShareType") -Or
            ($_ -eq "Get-SCAcceptedPortfolioShareList/PortfolioShareType") -Or
            ($_ -eq "Receive-SCPortfolioShare/PortfolioShareType")
        }
        {
            $v = "AWS_ORGANIZATIONS","AWS_SERVICECATALOG","IMPORTED"
            break
        }

        # Amazon.ServiceCatalog.PrincipalType
        "Register-SCPrincipalWithPortfolio/PrincipalType"
        {
            $v = "IAM"
            break
        }

        # Amazon.ServiceCatalog.ProductSource
        "Find-SCProductsAsAdmin/ProductSource"
        {
            $v = "ACCOUNT"
            break
        }

        # Amazon.ServiceCatalog.ProductType
        "New-SCProduct/ProductType"
        {
            $v = "CLOUD_FORMATION_TEMPLATE","MARKETPLACE"
            break
        }

        # Amazon.ServiceCatalog.ProductViewSortBy
        {
            ($_ -eq "Find-SCProduct/SortBy") -Or
            ($_ -eq "Find-SCProductsAsAdmin/SortBy")
        }
        {
            $v = "CreationDate","Title","VersionCount"
            break
        }

        # Amazon.ServiceCatalog.ProvisionedProductPlanType
        "New-SCProvisionedProductPlan/PlanType"
        {
            $v = "CLOUDFORMATION"
            break
        }

        # Amazon.ServiceCatalog.ProvisioningArtifactGuidance
        "Update-SCProvisioningArtifact/Guidance"
        {
            $v = "DEFAULT","DEPRECATED"
            break
        }

        # Amazon.ServiceCatalog.ProvisioningArtifactType
        {
            ($_ -eq "New-SCProvisioningArtifact/Parameters_Type") -Or
            ($_ -eq "New-SCProduct/ProvisioningArtifactParameters_Type")
        }
        {
            $v = "CLOUD_FORMATION_TEMPLATE","MARKETPLACE_AMI","MARKETPLACE_CAR"
            break
        }

        # Amazon.ServiceCatalog.ServiceActionDefinitionType
        "New-SCServiceAction/DefinitionType"
        {
            $v = "SSM_AUTOMATION"
            break
        }

        # Amazon.ServiceCatalog.SortOrder
        {
            ($_ -eq "Find-SCProduct/SortOrder") -Or
            ($_ -eq "Find-SCProductsAsAdmin/SortOrder") -Or
            ($_ -eq "Find-SCProvisionedProduct/SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.ServiceCatalog.StackSetOperationType
        "Update-SCProvisionedProduct/ProvisioningPreferences_StackSetOperationType"
        {
            $v = "CREATE","DELETE","UPDATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SC_map = @{
    "AccessLevelFilter_Key"=@("Find-SCProvisionedProduct","Get-SCProvisionedProduct","Get-SCProvisionedProductPlanList","Get-SCRecordHistory")
    "DefinitionType"=@("New-SCServiceAction")
    "Guidance"=@("Update-SCProvisioningArtifact")
    "OrganizationNode_Type"=@("New-SCPortfolioShare","Remove-SCPortfolioShare","Update-SCPortfolioShare")
    "OrganizationNodeType"=@("Get-SCOrganizationPortfolioAccessList")
    "Parameters_Type"=@("New-SCProvisioningArtifact")
    "PlanType"=@("New-SCProvisionedProductPlan")
    "PortfolioShareType"=@("Deny-SCPortfolioShare","Get-SCAcceptedPortfolioShareList","Receive-SCPortfolioShare")
    "PrincipalType"=@("Register-SCPrincipalWithPortfolio")
    "ProductSource"=@("Find-SCProductsAsAdmin")
    "ProductType"=@("New-SCProduct")
    "ProvisioningArtifactParameters_Type"=@("New-SCProduct")
    "ProvisioningPreferences_StackSetOperationType"=@("Update-SCProvisionedProduct")
    "SortBy"=@("Find-SCProduct","Find-SCProductsAsAdmin")
    "SortOrder"=@("Find-SCProduct","Find-SCProductsAsAdmin","Find-SCProvisionedProduct")
    "Type"=@("Get-SCPortfolioShare")
}

_awsArgumentCompleterRegistration $SC_Completers $SC_map

$SC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SC_SelectMap = @{
    "Select"=@("Receive-SCPortfolioShare",
               "Register-SCBudgetWithResource",
               "Register-SCPrincipalWithPortfolio",
               "Register-SCProductWithPortfolio",
               "Add-SCServiceActionAssociationWithProvisioningArtifact",
               "Add-SCTagOptionToResource",
               "Add-SCServiceActionAssociationWithProvisioningArtifactBatch",
               "Remove-SCServiceActionAssociationFromProvisioningArtifactBatch",
               "Copy-SCProduct",
               "New-SCConstraint",
               "New-SCPortfolio",
               "New-SCPortfolioShare",
               "New-SCProduct",
               "New-SCProvisionedProductPlan",
               "New-SCProvisioningArtifact",
               "New-SCServiceAction",
               "New-SCTagOption",
               "Remove-SCConstraint",
               "Remove-SCPortfolio",
               "Remove-SCPortfolioShare",
               "Remove-SCProduct",
               "Remove-SCProvisionedProductPlan",
               "Remove-SCProvisioningArtifact",
               "Remove-SCServiceAction",
               "Remove-SCTagOption",
               "Get-SCConstraint",
               "Get-SCCopyProductStatus",
               "Get-SCPortfolio",
               "Get-SCPortfolioShare",
               "Get-SCPortfolioShareStatus",
               "Get-SCProduct",
               "Get-SCProductAsAdmin",
               "Get-SCProductView",
               "Get-SCProvisionedProductDetail",
               "Get-SCProvisionedProductPlan",
               "Get-SCProvisioningArtifact",
               "Get-SCProvisioningParameter",
               "Get-SCRecord",
               "Get-SCServiceAction",
               "Get-SCServiceActionExecutionParameter",
               "Get-SCTagOption",
               "Disable-SCAWSOrganizationsAccess",
               "Unregister-SCBudgetFromResource",
               "Unregister-SCPrincipalFromPortfolio",
               "Unregister-SCProductFromPortfolio",
               "Remove-SCServiceActionAssociationFromProvisioningArtifact",
               "Remove-SCTagOptionFromResource",
               "Enable-SCAWSOrganizationsAccess",
               "Start-SCProvisionedProductPlanExecution",
               "Start-SCProvisionedProductServiceActionExecution",
               "Get-SCAWSOrganizationsAccessStatus",
               "Get-SCProvisionedProductOutput",
               "Import-SCAsProvisionedProduct",
               "Get-SCAcceptedPortfolioShareList",
               "Get-SCBudgetsForResource",
               "Get-SCConstrainsForPortfolioList",
               "Get-SCLaunchPath",
               "Get-SCOrganizationPortfolioAccessList",
               "Get-SCPortfolioAccessList",
               "Get-SCPortfolioList",
               "Get-SCProductPortfolioList",
               "Get-SCPrincipalsForPortfolio",
               "Get-SCProvisionedProductPlanList",
               "Get-SCProvisioningArtifactList",
               "Get-SCProvisioningArtifactsForServiceActionList",
               "Get-SCRecordHistory",
               "Get-SCResourcesForTagOption",
               "Get-SCServiceActionList",
               "Get-SCServiceActionsForProvisioningArtifactList",
               "Get-SCStackInstancesForProvisionedProduct",
               "Get-SCTagOptionList",
               "New-SCProvisionedProduct",
               "Deny-SCPortfolioShare",
               "Get-SCProvisionedProduct",
               "Find-SCProduct",
               "Find-SCProductsAsAdmin",
               "Find-SCProvisionedProduct",
               "Remove-SCProvisionedProduct",
               "Update-SCConstraint",
               "Update-SCPortfolio",
               "Update-SCPortfolioShare",
               "Update-SCProduct",
               "Update-SCProvisionedProduct",
               "Update-SCProvisionedProductProperty",
               "Update-SCProvisioningArtifact",
               "Update-SCServiceAction",
               "Update-SCTagOption")
}

_awsArgumentCompleterRegistration $SC_SelectCompleters $SC_SelectMap
# Argument completions for service AWS Service Catalog App Registry


$SCAR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppRegistry.ResourceType
        {
            ($_ -eq "Get-SCARAssociatedResource/ResourceType") -Or
            ($_ -eq "Register-SCARResource/ResourceType") -Or
            ($_ -eq "Sync-SCARResource/ResourceType") -Or
            ($_ -eq "Unregister-SCARResource/ResourceType")
        }
        {
            $v = "CFN_STACK"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCAR_map = @{
    "ResourceType"=@("Get-SCARAssociatedResource","Register-SCARResource","Sync-SCARResource","Unregister-SCARResource")
}

_awsArgumentCompleterRegistration $SCAR_Completers $SCAR_map

$SCAR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SCAR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SCAR_SelectMap = @{
    "Select"=@("Register-SCARAttributeGroup",
               "Register-SCARResource",
               "New-SCARApplication",
               "New-SCARAttributeGroup",
               "Remove-SCARApplication",
               "Remove-SCARAttributeGroup",
               "Unregister-SCARAttributeGroup",
               "Unregister-SCARResource",
               "Get-SCARApplication",
               "Get-SCARAssociatedResource",
               "Get-SCARAttributeGroup",
               "Get-SCARApplicationList",
               "Get-SCARAssociatedAttributeGroupList",
               "Get-SCARAssociatedResourceList",
               "Get-SCARAttributeGroupList",
               "Get-SCARAttributeGroupsForApplicationList",
               "Get-SCARResourceTag",
               "Sync-SCARResource",
               "Add-SCARResourceTag",
               "Remove-SCARResourceTag",
               "Update-SCARApplication",
               "Update-SCARAttributeGroup")
}

_awsArgumentCompleterRegistration $SCAR_SelectCompleters $SCAR_SelectMap
# Argument completions for service AWS Cloud Map


$SD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceDiscovery.CustomHealthStatus
        "Update-SDInstanceCustomHealthStatus/Status"
        {
            $v = "HEALTHY","UNHEALTHY"
            break
        }

        # Amazon.ServiceDiscovery.HealthCheckType
        "New-SDService/HealthCheckConfig_Type"
        {
            $v = "HTTP","HTTPS","TCP"
            break
        }

        # Amazon.ServiceDiscovery.HealthStatusFilter
        "Find-SDInstance/HealthStatus"
        {
            $v = "ALL","HEALTHY","HEALTHY_OR_ELSE_ALL","UNHEALTHY"
            break
        }

        # Amazon.ServiceDiscovery.ServiceTypeOption
        "New-SDService/Type"
        {
            $v = "HTTP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SD_map = @{
    "HealthCheckConfig_Type"=@("New-SDService")
    "HealthStatus"=@("Find-SDInstance")
    "Status"=@("Update-SDInstanceCustomHealthStatus")
    "Type"=@("New-SDService")
}

_awsArgumentCompleterRegistration $SD_Completers $SD_map

$SD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SD_SelectMap = @{
    "Select"=@("New-SDHttpNamespace",
               "New-SDPrivateDnsNamespace",
               "New-SDPublicDnsNamespace",
               "New-SDService",
               "Remove-SDNamespace",
               "Remove-SDService",
               "Remove-SDInstanceRegistration",
               "Find-SDInstance",
               "Get-SDInstance",
               "Get-SDInstancesHealthStatus",
               "Get-SDNamespace",
               "Get-SDOperation",
               "Get-SDService",
               "Get-SDInstanceList",
               "Get-SDNamespaceList",
               "Get-SDOperationList",
               "Get-SDServiceList",
               "Get-SDResourceTag",
               "New-SDInstanceRegistration",
               "Add-SDResourceTag",
               "Remove-SDResourceTag",
               "Update-SDHttpNamespace",
               "Update-SDInstanceCustomHealthStatus",
               "Update-SDPrivateDnsNamespace",
               "Update-SDPublicDnsNamespace",
               "Update-SDService")
}

_awsArgumentCompleterRegistration $SD_SelectCompleters $SD_SelectMap
# Argument completions for service AWS Service Quotas


$SQ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceQuotas.RequestStatus
        {
            ($_ -eq "Get-SQRequestedServiceQuotaChangeHistoryByQuotaList/Status") -Or
            ($_ -eq "Get-SQRequestedServiceQuotaChangeHistoryList/Status")
        }
        {
            $v = "APPROVED","CASE_CLOSED","CASE_OPENED","DENIED","PENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQ_map = @{
    "Status"=@("Get-SQRequestedServiceQuotaChangeHistoryByQuotaList","Get-SQRequestedServiceQuotaChangeHistoryList")
}

_awsArgumentCompleterRegistration $SQ_Completers $SQ_map

$SQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQ_SelectMap = @{
    "Select"=@("Register-SQServiceQuotaTemplate",
               "Remove-SQServiceQuotaIncreaseRequestFromTemplate",
               "Unregister-SQServiceQuotaTemplate",
               "Get-SQAssociationForServiceQuotaTemplate",
               "Get-SQAWSDefaultServiceQuota",
               "Get-SQRequestedServiceQuotaChange",
               "Get-SQServiceQuota",
               "Get-SQServiceQuotaIncreaseRequestFromTemplate",
               "Get-SQAWSDefaultServiceQuotaList",
               "Get-SQRequestedServiceQuotaChangeHistoryList",
               "Get-SQRequestedServiceQuotaChangeHistoryByQuotaList",
               "Get-SQServiceQuotaIncreaseRequestsInTemplateList",
               "Get-SQServiceQuotaList",
               "Get-SQServiceList",
               "Get-SQResourceTag",
               "Write-SQServiceQuotaIncreaseRequestIntoTemplate",
               "Request-SQServiceQuotaIncrease",
               "Add-SQResourceTag",
               "Remove-SQResourceTag")
}

_awsArgumentCompleterRegistration $SQ_SelectCompleters $SQ_SelectMap
# Argument completions for service Amazon Simple Email Service V2 (SES V2)


$SES2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleEmailV2.BehaviorOnMxFailure
        "Write-SES2EmailIdentityMailFromAttribute/BehaviorOnMxFailure"
        {
            $v = "REJECT_MESSAGE","USE_DEFAULT_VALUE"
            break
        }

        # Amazon.SimpleEmailV2.ContactLanguage
        "Write-SES2AccountDetail/ContactLanguage"
        {
            $v = "EN","JA"
            break
        }

        # Amazon.SimpleEmailV2.ContactListImportAction
        "New-SES2ImportJob/ImportDestination_ContactListDestination_ContactListImportAction"
        {
            $v = "DELETE","PUT"
            break
        }

        # Amazon.SimpleEmailV2.DataFormat
        "New-SES2ImportJob/ImportDataSource_DataFormat"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.SimpleEmailV2.DkimSigningAttributesOrigin
        "Write-SES2EmailIdentityDkimSigningAttribute/SigningAttributesOrigin"
        {
            $v = "AWS_SES","EXTERNAL"
            break
        }

        # Amazon.SimpleEmailV2.DkimSigningKeyLength
        {
            ($_ -eq "New-SES2EmailIdentity/DkimSigningAttributes_NextSigningKeyLength") -Or
            ($_ -eq "Write-SES2EmailIdentityDkimSigningAttribute/SigningAttributes_NextSigningKeyLength")
        }
        {
            $v = "RSA_1024_BIT","RSA_2048_BIT"
            break
        }

        # Amazon.SimpleEmailV2.FeatureStatus
        {
            ($_ -eq "Write-SES2AccountVdmAttribute/VdmAttributes_DashboardAttributes_EngagementMetrics") -Or
            ($_ -eq "Write-SES2AccountVdmAttribute/VdmAttributes_GuardianAttributes_OptimizedSharedDelivery") -Or
            ($_ -eq "Write-SES2AccountVdmAttribute/VdmAttributes_VdmEnabled") -Or
            ($_ -eq "New-SES2ConfigurationSet/VdmOptions_DashboardOptions_EngagementMetrics") -Or
            ($_ -eq "Write-SES2ConfigurationSetVdmOption/VdmOptions_DashboardOptions_EngagementMetrics") -Or
            ($_ -eq "New-SES2ConfigurationSet/VdmOptions_GuardianOptions_OptimizedSharedDelivery") -Or
            ($_ -eq "Write-SES2ConfigurationSetVdmOption/VdmOptions_GuardianOptions_OptimizedSharedDelivery")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.SimpleEmailV2.ImportDestinationType
        "Get-SES2ImportJobList/ImportDestinationType"
        {
            $v = "CONTACT_LIST","SUPPRESSION_LIST"
            break
        }

        # Amazon.SimpleEmailV2.MailType
        "Write-SES2AccountDetail/MailType"
        {
            $v = "MARKETING","TRANSACTIONAL"
            break
        }

        # Amazon.SimpleEmailV2.ScalingMode
        "New-SES2DedicatedIpPool/ScalingMode"
        {
            $v = "MANAGED","STANDARD"
            break
        }

        # Amazon.SimpleEmailV2.SubscriptionStatus
        "Get-SES2ContactCollection/Filter_FilteredStatus"
        {
            $v = "OPT_IN","OPT_OUT"
            break
        }

        # Amazon.SimpleEmailV2.SuppressionListImportAction
        "New-SES2ImportJob/ImportDestination_SuppressionListDestination_SuppressionListImportAction"
        {
            $v = "DELETE","PUT"
            break
        }

        # Amazon.SimpleEmailV2.SuppressionListReason
        "Write-SES2SuppressedDestination/Reason"
        {
            $v = "BOUNCE","COMPLAINT"
            break
        }

        # Amazon.SimpleEmailV2.TlsPolicy
        {
            ($_ -eq "New-SES2ConfigurationSet/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "Write-SES2ConfigurationSetDeliveryOption/TlsPolicy")
        }
        {
            $v = "OPTIONAL","REQUIRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES2_map = @{
    "BehaviorOnMxFailure"=@("Write-SES2EmailIdentityMailFromAttribute")
    "ContactLanguage"=@("Write-SES2AccountDetail")
    "DeliveryOptions_TlsPolicy"=@("New-SES2ConfigurationSet")
    "DkimSigningAttributes_NextSigningKeyLength"=@("New-SES2EmailIdentity")
    "Filter_FilteredStatus"=@("Get-SES2ContactCollection")
    "ImportDataSource_DataFormat"=@("New-SES2ImportJob")
    "ImportDestination_ContactListDestination_ContactListImportAction"=@("New-SES2ImportJob")
    "ImportDestination_SuppressionListDestination_SuppressionListImportAction"=@("New-SES2ImportJob")
    "ImportDestinationType"=@("Get-SES2ImportJobList")
    "MailType"=@("Write-SES2AccountDetail")
    "Reason"=@("Write-SES2SuppressedDestination")
    "ScalingMode"=@("New-SES2DedicatedIpPool")
    "SigningAttributes_NextSigningKeyLength"=@("Write-SES2EmailIdentityDkimSigningAttribute")
    "SigningAttributesOrigin"=@("Write-SES2EmailIdentityDkimSigningAttribute")
    "TlsPolicy"=@("Write-SES2ConfigurationSetDeliveryOption")
    "VdmAttributes_DashboardAttributes_EngagementMetrics"=@("Write-SES2AccountVdmAttribute")
    "VdmAttributes_GuardianAttributes_OptimizedSharedDelivery"=@("Write-SES2AccountVdmAttribute")
    "VdmAttributes_VdmEnabled"=@("Write-SES2AccountVdmAttribute")
    "VdmOptions_DashboardOptions_EngagementMetrics"=@("New-SES2ConfigurationSet","Write-SES2ConfigurationSetVdmOption")
    "VdmOptions_GuardianOptions_OptimizedSharedDelivery"=@("New-SES2ConfigurationSet","Write-SES2ConfigurationSetVdmOption")
}

_awsArgumentCompleterRegistration $SES2_Completers $SES2_map

$SES2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SES2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES2_SelectMap = @{
    "Select"=@("Get-SES2BatchMetricData",
               "New-SES2ConfigurationSet",
               "New-SES2ConfigurationSetEventDestination",
               "New-SES2Contact",
               "New-SES2ContactList",
               "New-SES2CustomVerificationEmailTemplate",
               "New-SES2DedicatedIpPool",
               "New-SES2DeliverabilityTestReport",
               "New-SES2EmailIdentity",
               "New-SES2EmailIdentityPolicy",
               "New-SES2EmailTemplate",
               "New-SES2ImportJob",
               "Remove-SES2ConfigurationSet",
               "Remove-SES2ConfigurationSetEventDestination",
               "Remove-SES2Contact",
               "Remove-SES2ContactList",
               "Remove-SES2CustomVerificationEmailTemplate",
               "Remove-SES2DedicatedIpPool",
               "Remove-SES2EmailIdentity",
               "Remove-SES2EmailIdentityPolicy",
               "Remove-SES2EmailTemplate",
               "Remove-SES2SuppressedDestination",
               "Get-SES2Account",
               "Get-SES2BlacklistReport",
               "Get-SES2ConfigurationSet",
               "Get-SES2ConfigurationSetEventDestination",
               "Get-SES2Contact",
               "Get-SES2ContactList",
               "Get-SES2CustomVerificationEmailTemplate",
               "Get-SES2DedicatedIp",
               "Get-SES2DedicatedIpPool",
               "Get-SES2DedicatedIpList",
               "Get-SES2DeliverabilityDashboardOption",
               "Get-SES2DeliverabilityTestReport",
               "Get-SES2DomainDeliverabilityCampaign",
               "Get-SES2DomainStatisticsReport",
               "Get-SES2EmailIdentity",
               "Get-SES2EmailIdentityPolicy",
               "Get-SES2EmailTemplate",
               "Get-SES2ImportJob",
               "Get-SES2SuppressedDestination",
               "Get-SES2ConfigurationSetList",
               "Get-SES2ContactListCollection",
               "Get-SES2ContactCollection",
               "Get-SES2CustomVerificationEmailTemplateList",
               "Get-SES2DedicatedIpPoolList",
               "Get-SES2DeliverabilityTestReportList",
               "Get-SES2DomainDeliverabilityCampaignList",
               "Get-SES2EmailIdentityList",
               "Get-SES2EmailTemplateList",
               "Get-SES2ImportJobList",
               "Get-SES2RecommendationList",
               "Get-SES2SuppressedDestinationList",
               "Get-SES2ResourceTag",
               "Write-SES2AccountDedicatedIpWarmupAttribute",
               "Write-SES2AccountDetail",
               "Write-SES2AccountSendingAttribute",
               "Write-SES2AccountSuppressionAttribute",
               "Write-SES2AccountVdmAttribute",
               "Write-SES2ConfigurationSetDeliveryOption",
               "Write-SES2ConfigurationSetReputationOption",
               "Write-SES2ConfigurationSetSendingOption",
               "Write-SES2ConfigurationSetSuppressionOption",
               "Write-SES2ConfigurationSetTrackingOption",
               "Write-SES2ConfigurationSetVdmOption",
               "Write-SES2DedicatedIpInPool",
               "Write-SES2DedicatedIpWarmupAttribute",
               "Write-SES2DeliverabilityDashboardOption",
               "Write-SES2EmailIdentityConfigurationSetAttribute",
               "Write-SES2EmailIdentityDkimAttribute",
               "Write-SES2EmailIdentityDkimSigningAttribute",
               "Write-SES2EmailIdentityFeedbackAttribute",
               "Write-SES2EmailIdentityMailFromAttribute",
               "Write-SES2SuppressedDestination",
               "Send-SES2BulkEmail",
               "Send-SES2CustomVerificationEmail",
               "Send-SES2Email",
               "Add-SES2ResourceTag",
               "Test-SES2RenderEmailTemplate",
               "Remove-SES2ResourceTag",
               "Update-SES2ConfigurationSetEventDestination",
               "Update-SES2Contact",
               "Update-SES2ContactList",
               "Update-SES2CustomVerificationEmailTemplate",
               "Update-SES2EmailIdentityPolicy",
               "Update-SES2EmailTemplate")
}

_awsArgumentCompleterRegistration $SES2_SelectCompleters $SES2_SelectMap
# Argument completions for service AWS Shield


$SHLD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Shield.AutoRenew
        "Update-SHLDSubscription/AutoRenew"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Shield.ProtectedResourceType
        {
            ($_ -eq "New-SHLDProtectionGroup/ResourceType") -Or
            ($_ -eq "Update-SHLDProtectionGroup/ResourceType")
        }
        {
            $v = "APPLICATION_LOAD_BALANCER","CLASSIC_LOAD_BALANCER","CLOUDFRONT_DISTRIBUTION","ELASTIC_IP_ALLOCATION","GLOBAL_ACCELERATOR","ROUTE_53_HOSTED_ZONE"
            break
        }

        # Amazon.Shield.ProtectionGroupAggregation
        {
            ($_ -eq "New-SHLDProtectionGroup/Aggregation") -Or
            ($_ -eq "Update-SHLDProtectionGroup/Aggregation")
        }
        {
            $v = "MAX","MEAN","SUM"
            break
        }

        # Amazon.Shield.ProtectionGroupPattern
        {
            ($_ -eq "New-SHLDProtectionGroup/Pattern") -Or
            ($_ -eq "Update-SHLDProtectionGroup/Pattern")
        }
        {
            $v = "ALL","ARBITRARY","BY_RESOURCE_TYPE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHLD_map = @{
    "Aggregation"=@("New-SHLDProtectionGroup","Update-SHLDProtectionGroup")
    "AutoRenew"=@("Update-SHLDSubscription")
    "Pattern"=@("New-SHLDProtectionGroup","Update-SHLDProtectionGroup")
    "ResourceType"=@("New-SHLDProtectionGroup","Update-SHLDProtectionGroup")
}

_awsArgumentCompleterRegistration $SHLD_Completers $SHLD_map

$SHLD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SHLD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHLD_SelectMap = @{
    "Select"=@("Grant-SHLDDRTLogBucketAssociation",
               "Grant-SHLDDRTRoleAssociation",
               "Add-SHLDHealthCheck",
               "Add-SHLDProactiveEngagementDetail",
               "New-SHLDProtection",
               "New-SHLDProtectionGroup",
               "New-SHLDSubscription",
               "Remove-SHLDProtection",
               "Remove-SHLDProtectionGroup",
               "Remove-SHLDSubscription",
               "Get-SHLDAttack",
               "Get-SHLDAttackStatistic",
               "Get-SHLDDRTAccess",
               "Get-SHLDEmergencyContactSetting",
               "Get-SHLDProtection",
               "Get-SHLDProtectionGroup",
               "Get-SHLDSubscription",
               "Disable-SHLDApplicationLayerAutomaticResponse",
               "Disable-SHLDProactiveEngagement",
               "Revoke-SHLDDRTLogBucketAssociation",
               "Revoke-SHLDDRTRoleAssociation",
               "Remove-SHLDHealthCheck",
               "Enable-SHLDApplicationLayerAutomaticResponse",
               "Enable-SHLDProactiveEngagement",
               "Get-SHLDSubscriptionState",
               "Get-SHLDAttackList",
               "Get-SHLDProtectionGroupList",
               "Get-SHLDProtectionList",
               "Get-SHLDResourcesInProtectionGroupList",
               "Get-SHLDResourceTag",
               "Add-SHLDResourceTag",
               "Remove-SHLDResourceTag",
               "Update-SHLDApplicationLayerAutomaticResponse",
               "Update-SHLDEmergencyContactSetting",
               "Update-SHLDProtectionGroup",
               "Update-SHLDSubscription")
}

_awsArgumentCompleterRegistration $SHLD_SelectCompleters $SHLD_SelectMap
# Argument completions for service AWS Server Migration Service


$SMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServerMigrationService.LicenseType
        {
            ($_ -eq "New-SMSReplicationJob/LicenseType") -Or
            ($_ -eq "Update-SMSReplicationJob/LicenseType")
        }
        {
            $v = "AWS","BYOL"
            break
        }

        # Amazon.ServerMigrationService.OutputFormat
        {
            ($_ -eq "New-SMSChangeSet/ChangesetFormat") -Or
            ($_ -eq "New-SMSTemplate/TemplateFormat")
        }
        {
            $v = "JSON","YAML"
            break
        }

        # Amazon.ServerMigrationService.ValidationStatus
        "Write-SMSAppValidationOutput/NotificationContext_Status"
        {
            $v = "FAILED","IN_PROGRESS","PENDING","READY_FOR_VALIDATION","SUCCEEDED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMS_map = @{
    "ChangesetFormat"=@("New-SMSChangeSet")
    "LicenseType"=@("New-SMSReplicationJob","Update-SMSReplicationJob")
    "NotificationContext_Status"=@("Write-SMSAppValidationOutput")
    "TemplateFormat"=@("New-SMSTemplate")
}

_awsArgumentCompleterRegistration $SMS_Completers $SMS_map

$SMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMS_SelectMap = @{
    "Select"=@("New-SMSApp",
               "New-SMSReplicationJob",
               "Remove-SMSApp",
               "Remove-SMSAppLaunchConfiguration",
               "Remove-SMSAppReplicationConfiguration",
               "Remove-SMSAppValidationConfiguration",
               "Remove-SMSReplicationJob",
               "Remove-SMSServerCatalog",
               "Unregister-SMSConnector",
               "New-SMSChangeSet",
               "New-SMSTemplate",
               "Get-SMSApp",
               "Get-SMSAppLaunchConfiguration",
               "Get-SMSAppReplicationConfiguration",
               "Get-SMSAppValidationConfiguration",
               "Get-SMSAppValidationOutput",
               "Get-SMSConnector",
               "Get-SMSReplicationJob",
               "Get-SMSReplicationRun",
               "Get-SMSServer",
               "Import-SMSAppCatalog",
               "Import-SMSServerCatalog",
               "Start-SMSApp",
               "Get-SMSAppList",
               "Write-SMSAppValidationOutput",
               "Write-SMSAppLaunchConfiguration",
               "Write-SMSAppReplicationConfiguration",
               "Write-SMSAppValidationConfiguration",
               "Start-SMSAppReplication",
               "Start-SMSOnDemandAppReplication",
               "Start-SMSOnDemandReplicationRun",
               "Stop-SMSAppReplication",
               "Stop-SMSApp",
               "Update-SMSApp",
               "Update-SMSReplicationJob")
}

_awsArgumentCompleterRegistration $SMS_SelectCompleters $SMS_SelectMap
# Argument completions for service AWS Import/Export Snowball


$SNOW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Snowball.JobType
        {
            ($_ -eq "New-SNOWCluster/JobType") -Or
            ($_ -eq "New-SNOWJob/JobType")
        }
        {
            $v = "EXPORT","IMPORT","LOCAL_USE"
            break
        }

        # Amazon.Snowball.LongTermPricingType
        "New-SNOWLongTermPricing/LongTermPricingType"
        {
            $v = "OneYear","ThreeYear"
            break
        }

        # Amazon.Snowball.RemoteManagement
        {
            ($_ -eq "New-SNOWCluster/RemoteManagement") -Or
            ($_ -eq "New-SNOWJob/RemoteManagement")
        }
        {
            $v = "INSTALLED_AUTOSTART","INSTALLED_ONLY"
            break
        }

        # Amazon.Snowball.ShipmentState
        "Update-SNOWJobShipmentState/ShipmentState"
        {
            $v = "RECEIVED","RETURNED"
            break
        }

        # Amazon.Snowball.ShippingOption
        {
            ($_ -eq "New-SNOWCluster/ShippingOption") -Or
            ($_ -eq "New-SNOWJob/ShippingOption") -Or
            ($_ -eq "New-SNOWReturnShippingLabel/ShippingOption") -Or
            ($_ -eq "Update-SNOWCluster/ShippingOption") -Or
            ($_ -eq "Update-SNOWJob/ShippingOption")
        }
        {
            $v = "EXPRESS","NEXT_DAY","SECOND_DAY","STANDARD"
            break
        }

        # Amazon.Snowball.SnowballCapacity
        {
            ($_ -eq "New-SNOWJob/SnowballCapacityPreference") -Or
            ($_ -eq "Update-SNOWJob/SnowballCapacityPreference")
        }
        {
            $v = "NoPreference","T100","T14","T32","T42","T50","T8","T80","T98"
            break
        }

        # Amazon.Snowball.SnowballType
        {
            ($_ -eq "New-SNOWCluster/SnowballType") -Or
            ($_ -eq "New-SNOWJob/SnowballType") -Or
            ($_ -eq "New-SNOWLongTermPricing/SnowballType")
        }
        {
            $v = "EDGE","EDGE_C","EDGE_CG","EDGE_S","SNC1_HDD","SNC1_SSD","STANDARD","V3_5C"
            break
        }

        # Amazon.Snowball.StorageUnit
        {
            ($_ -eq "New-SNOWCluster/OnDeviceServiceConfiguration_NFSOnDeviceService_StorageUnit") -Or
            ($_ -eq "New-SNOWJob/OnDeviceServiceConfiguration_NFSOnDeviceService_StorageUnit") -Or
            ($_ -eq "Update-SNOWCluster/OnDeviceServiceConfiguration_NFSOnDeviceService_StorageUnit") -Or
            ($_ -eq "Update-SNOWJob/OnDeviceServiceConfiguration_NFSOnDeviceService_StorageUnit") -Or
            ($_ -eq "New-SNOWCluster/OnDeviceServiceConfiguration_TGWOnDeviceService_StorageUnit") -Or
            ($_ -eq "New-SNOWJob/OnDeviceServiceConfiguration_TGWOnDeviceService_StorageUnit") -Or
            ($_ -eq "Update-SNOWCluster/OnDeviceServiceConfiguration_TGWOnDeviceService_StorageUnit") -Or
            ($_ -eq "Update-SNOWJob/OnDeviceServiceConfiguration_TGWOnDeviceService_StorageUnit")
        }
        {
            $v = "TB"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNOW_map = @{
    "JobType"=@("New-SNOWCluster","New-SNOWJob")
    "LongTermPricingType"=@("New-SNOWLongTermPricing")
    "OnDeviceServiceConfiguration_NFSOnDeviceService_StorageUnit"=@("New-SNOWCluster","New-SNOWJob","Update-SNOWCluster","Update-SNOWJob")
    "OnDeviceServiceConfiguration_TGWOnDeviceService_StorageUnit"=@("New-SNOWCluster","New-SNOWJob","Update-SNOWCluster","Update-SNOWJob")
    "RemoteManagement"=@("New-SNOWCluster","New-SNOWJob")
    "ShipmentState"=@("Update-SNOWJobShipmentState")
    "ShippingOption"=@("New-SNOWCluster","New-SNOWJob","New-SNOWReturnShippingLabel","Update-SNOWCluster","Update-SNOWJob")
    "SnowballCapacityPreference"=@("New-SNOWJob","Update-SNOWJob")
    "SnowballType"=@("New-SNOWCluster","New-SNOWJob","New-SNOWLongTermPricing")
}

_awsArgumentCompleterRegistration $SNOW_Completers $SNOW_map

$SNOW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SNOW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNOW_SelectMap = @{
    "Select"=@("Stop-SNOWCluster",
               "Stop-SNOWJob",
               "New-SNOWAddress",
               "New-SNOWCluster",
               "New-SNOWJob",
               "New-SNOWLongTermPricing",
               "New-SNOWReturnShippingLabel",
               "Get-SNOWAddress",
               "Get-SNOWAddressList",
               "Get-SNOWCluster",
               "Get-SNOWJob",
               "Get-SNOWReturnShippingLabel",
               "Get-SNOWJobManifest",
               "Get-SNOWJobUnlockCode",
               "Get-SNOWSnowballUsage",
               "Get-SNOWSoftwareUpdate",
               "Get-SNOWClusterJobList",
               "Get-SNOWClusterList",
               "Get-SNOWCompatibleImageList",
               "Get-SNOWJobList",
               "Get-SNOWLongTermPricing",
               "Update-SNOWCluster",
               "Update-SNOWJob",
               "Update-SNOWJobShipmentState",
               "Update-SNOWLongTermPricing")
}

_awsArgumentCompleterRegistration $SNOW_SelectCompleters $SNOW_SelectMap
# Argument completions for service AWS Snow Device Management


$SDMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SnowDeviceManagement.ExecutionState
        "Get-SDMSExecutionList/State"
        {
            $v = "CANCELED","FAILED","IN_PROGRESS","QUEUED","REJECTED","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.SnowDeviceManagement.TaskState
        "Get-SDMSTaskList/State"
        {
            $v = "CANCELED","COMPLETED","IN_PROGRESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SDMS_map = @{
    "State"=@("Get-SDMSExecutionList","Get-SDMSTaskList")
}

_awsArgumentCompleterRegistration $SDMS_Completers $SDMS_map

$SDMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SDMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SDMS_SelectMap = @{
    "Select"=@("Stop-SDMSTask",
               "New-SDMSTask",
               "Get-SDMSDevice",
               "Get-SDMSDeviceEc2Instance",
               "Get-SDMSExecution",
               "Get-SDMSTask",
               "Get-SDMSDeviceResourceList",
               "Get-SDMSDeviceList",
               "Get-SDMSExecutionList",
               "Get-SDMSResourceTag",
               "Get-SDMSTaskList",
               "Add-SDMSResourceTag",
               "Remove-SDMSResourceTag")
}

_awsArgumentCompleterRegistration $SDMS_SelectCompleters $SDMS_SelectMap
# Argument completions for service Amazon Simple Notification Service (SNS)


$SNS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleNotificationService.LanguageCodeString
        "New-SNSSMSSandboxPhoneNumber/LanguageCode"
        {
            $v = "de-DE","en-GB","en-US","es-419","es-ES","fr-CA","fr-FR","it-IT","ja-JP","kr-KR","pt-BR","zh-CN","zh-TW"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNS_map = @{
    "LanguageCode"=@("New-SNSSMSSandboxPhoneNumber")
}

_awsArgumentCompleterRegistration $SNS_Completers $SNS_map

$SNS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SNS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNS_SelectMap = @{
    "Select"=@("Add-SNSPermission",
               "Test-SNSIfPhoneNumberIsOptedOut",
               "Confirm-SNSSubscription",
               "New-SNSPlatformApplication",
               "New-SNSPlatformEndpoint",
               "New-SNSSMSSandboxPhoneNumber",
               "New-SNSTopic",
               "Remove-SNSEndpoint",
               "Remove-SNSPlatformApplication",
               "Remove-SNSSMSSandboxPhoneNumber",
               "Remove-SNSTopic",
               "Get-SNSDataProtectionPolicy",
               "Get-SNSEndpointAttribute",
               "Get-SNSPlatformApplicationAttribute",
               "Get-SNSSMSAttribute",
               "Get-SNSSMSSandboxAccountStatus",
               "Get-SNSSubscriptionAttribute",
               "Get-SNSTopicAttribute",
               "Get-SNSEndpointsByPlatformApplication",
               "Get-SNSOriginationNumber",
               "Get-SNSPhoneNumbersOptedOut",
               "Get-SNSPlatformApplicationList",
               "Get-SNSSMSSandboxPhoneNumber",
               "Get-SNSSubscription",
               "Get-SNSSubscriptionByTopic",
               "Get-SNSResourceTag",
               "Get-SNSTopic",
               "Enable-SNSPhoneNumber",
               "Publish-SNSMessage",
               "Publish-SNSBatch",
               "Set-SNSDataProtectionPolicy",
               "Remove-SNSPermission",
               "Set-SNSEndpointAttribute",
               "Set-SNSPlatformApplicationAttribute",
               "Set-SNSSMSAttribute",
               "Set-SNSSubscriptionAttribute",
               "Set-SNSTopicAttribute",
               "Connect-SNSNotification",
               "Add-SNSResourceTag",
               "Disconnect-SNSNotification",
               "Remove-SNSResourceTag",
               "Confirm-SNSSMSSandboxPhoneNumber")
}

_awsArgumentCompleterRegistration $SNS_SelectCompleters $SNS_SelectMap
# Argument completions for service Amazon Simple Queue Service (SQS)


$SQS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SQS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQS_SelectMap = @{
    "Select"=@("Add-SQSPermission",
               "Edit-SQSMessageVisibility",
               "Edit-SQSMessageVisibilityBatch",
               "New-SQSQueue",
               "Remove-SQSMessage",
               "Remove-SQSMessageBatch",
               "Remove-SQSQueue",
               "Get-SQSQueueAttribute",
               "Get-SQSQueueUrl",
               "Get-SQSDeadLetterSourceQueue",
               "Get-SQSQueue",
               "Get-SQSResourceTag",
               "Clear-SQSQueue",
               "Receive-SQSMessage",
               "Remove-SQSPermission",
               "Send-SQSMessage",
               "Send-SQSMessageBatch",
               "Set-SQSQueueAttribute",
               "Add-SQSResourceTag",
               "Remove-SQSResourceTag")
}

_awsArgumentCompleterRegistration $SQS_SelectCompleters $SQS_SelectMap
# Argument completions for service AWS Systems Manager


$SSM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleSystemsManagement.AssociationComplianceSeverity
        {
            ($_ -eq "New-SSMAssociation/ComplianceSeverity") -Or
            ($_ -eq "Update-SSMAssociation/ComplianceSeverity")
        }
        {
            $v = "CRITICAL","HIGH","LOW","MEDIUM","UNSPECIFIED"
            break
        }

        # Amazon.SimpleSystemsManagement.AssociationStatusName
        "Update-SSMAssociationStatus/AssociationStatus_Name"
        {
            $v = "Failed","Pending","Success"
            break
        }

        # Amazon.SimpleSystemsManagement.AssociationSyncCompliance
        {
            ($_ -eq "New-SSMAssociation/SyncCompliance") -Or
            ($_ -eq "Update-SSMAssociation/SyncCompliance")
        }
        {
            $v = "AUTO","MANUAL"
            break
        }

        # Amazon.SimpleSystemsManagement.ComplianceUploadType
        "Write-SSMComplianceItem/UploadType"
        {
            $v = "COMPLETE","PARTIAL"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentFormat
        {
            ($_ -eq "Get-SSMDocument/DocumentFormat") -Or
            ($_ -eq "New-SSMDocument/DocumentFormat") -Or
            ($_ -eq "Update-SSMDocument/DocumentFormat")
        }
        {
            $v = "JSON","TEXT","YAML"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentHashType
        {
            ($_ -eq "Send-SSMCommand/DocumentHashType") -Or
            ($_ -eq "Register-SSMTaskWithMaintenanceWindow/TaskInvocationParameters_RunCommand_DocumentHashType") -Or
            ($_ -eq "Update-SSMMaintenanceWindowTask/TaskInvocationParameters_RunCommand_DocumentHashType")
        }
        {
            $v = "Sha1","Sha256"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentMetadataEnum
        "Get-SSMDocumentMetadataHistory/Metadata"
        {
            $v = "DocumentReviews"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentPermissionType
        {
            ($_ -eq "Edit-SSMDocumentPermission/PermissionType") -Or
            ($_ -eq "Get-SSMDocumentPermission/PermissionType")
        }
        {
            $v = "Share"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentReviewAction
        "Update-SSMDocumentMetadata/DocumentReviews_Action"
        {
            $v = "Approve","Reject","SendForReview","UpdateReview"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentType
        "New-SSMDocument/DocumentType"
        {
            $v = "ApplicationConfiguration","ApplicationConfigurationSchema","Automation","Automation.ChangeTemplate","ChangeCalendar","CloudFormation","Command","ConformancePackTemplate","DeploymentStrategy","Package","Policy","ProblemAnalysis","ProblemAnalysisTemplate","Session"
            break
        }

        # Amazon.SimpleSystemsManagement.ExecutionMode
        "Start-SSMAutomationExecution/Mode"
        {
            $v = "Auto","Interactive"
            break
        }

        # Amazon.SimpleSystemsManagement.InventorySchemaDeleteOption
        "Remove-SSMInventory/SchemaDeleteOption"
        {
            $v = "DeleteSchema","DisableSchema"
            break
        }

        # Amazon.SimpleSystemsManagement.MaintenanceWindowResourceType
        {
            ($_ -eq "Get-SSMMaintenanceWindowSchedule/ResourceType") -Or
            ($_ -eq "Get-SSMMaintenanceWindowsForTarget/ResourceType") -Or
            ($_ -eq "Register-SSMTargetWithMaintenanceWindow/ResourceType")
        }
        {
            $v = "INSTANCE","RESOURCE_GROUP"
            break
        }

        # Amazon.SimpleSystemsManagement.MaintenanceWindowTaskCutoffBehavior
        {
            ($_ -eq "Register-SSMTaskWithMaintenanceWindow/CutoffBehavior") -Or
            ($_ -eq "Update-SSMMaintenanceWindowTask/CutoffBehavior")
        }
        {
            $v = "CANCEL_TASK","CONTINUE_TASK"
            break
        }

        # Amazon.SimpleSystemsManagement.MaintenanceWindowTaskType
        "Register-SSMTaskWithMaintenanceWindow/TaskType"
        {
            $v = "AUTOMATION","LAMBDA","RUN_COMMAND","STEP_FUNCTIONS"
            break
        }

        # Amazon.SimpleSystemsManagement.NotificationType
        {
            ($_ -eq "Send-SSMCommand/NotificationConfig_NotificationType") -Or
            ($_ -eq "Register-SSMTaskWithMaintenanceWindow/TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType") -Or
            ($_ -eq "Update-SSMMaintenanceWindowTask/TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType")
        }
        {
            $v = "Command","Invocation"
            break
        }

        # Amazon.SimpleSystemsManagement.OperatingSystem
        {
            ($_ -eq "Get-SSMDeployablePatchSnapshotForInstance/BaselineOverride_OperatingSystem") -Or
            ($_ -eq "Get-SSMDefaultPatchBaseline/OperatingSystem") -Or
            ($_ -eq "Get-SSMPatchBaselineForPatchGroup/OperatingSystem") -Or
            ($_ -eq "Get-SSMPatchProperty/OperatingSystem") -Or
            ($_ -eq "New-SSMPatchBaseline/OperatingSystem")
        }
        {
            $v = "AMAZON_LINUX","AMAZON_LINUX_2","AMAZON_LINUX_2022","CENTOS","DEBIAN","MACOS","ORACLE_LINUX","RASPBIAN","REDHAT_ENTERPRISE_LINUX","ROCKY_LINUX","SUSE","UBUNTU","WINDOWS"
            break
        }

        # Amazon.SimpleSystemsManagement.OpsItemStatus
        "Update-SSMOpsItem/Status"
        {
            $v = "Approved","Cancelled","Cancelling","ChangeCalendarOverrideApproved","ChangeCalendarOverrideRejected","Closed","CompletedWithFailure","CompletedWithSuccess","Failed","InProgress","Open","Pending","PendingApproval","PendingChangeCalendarOverride","Rejected","Resolved","RunbookInProgress","Scheduled","TimedOut"
            break
        }

        # Amazon.SimpleSystemsManagement.ParameterTier
        "Write-SSMParameter/Tier"
        {
            $v = "Advanced","Intelligent-Tiering","Standard"
            break
        }

        # Amazon.SimpleSystemsManagement.ParameterType
        "Write-SSMParameter/Type"
        {
            $v = "SecureString","String","StringList"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchAction
        {
            ($_ -eq "Get-SSMDeployablePatchSnapshotForInstance/BaselineOverride_RejectedPatchesAction") -Or
            ($_ -eq "New-SSMPatchBaseline/RejectedPatchesAction") -Or
            ($_ -eq "Update-SSMPatchBaseline/RejectedPatchesAction")
        }
        {
            $v = "ALLOW_AS_DEPENDENCY","BLOCK"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchComplianceLevel
        {
            ($_ -eq "New-SSMPatchBaseline/ApprovedPatchesComplianceLevel") -Or
            ($_ -eq "Update-SSMPatchBaseline/ApprovedPatchesComplianceLevel") -Or
            ($_ -eq "Get-SSMDeployablePatchSnapshotForInstance/BaselineOverride_ApprovedPatchesComplianceLevel")
        }
        {
            $v = "CRITICAL","HIGH","INFORMATIONAL","LOW","MEDIUM","UNSPECIFIED"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchProperty
        "Get-SSMPatchProperty/Property"
        {
            $v = "CLASSIFICATION","MSRC_SEVERITY","PRIORITY","PRODUCT","PRODUCT_FAMILY","SEVERITY"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchSet
        "Get-SSMPatchProperty/PatchSet"
        {
            $v = "APPLICATION","OS"
            break
        }

        # Amazon.SimpleSystemsManagement.ResourceDataSyncS3Format
        "New-SSMResourceDataSync/S3Destination_SyncFormat"
        {
            $v = "JsonSerDe"
            break
        }

        # Amazon.SimpleSystemsManagement.ResourceTypeForTagging
        {
            ($_ -eq "Add-SSMResourceTag/ResourceType") -Or
            ($_ -eq "Get-SSMResourceTag/ResourceType") -Or
            ($_ -eq "Remove-SSMResourceTag/ResourceType")
        }
        {
            $v = "Association","Automation","Document","MaintenanceWindow","ManagedInstance","OpsItem","OpsMetadata","Parameter","PatchBaseline"
            break
        }

        # Amazon.SimpleSystemsManagement.SessionState
        "Get-SSMSession/State"
        {
            $v = "Active","History"
            break
        }

        # Amazon.SimpleSystemsManagement.SignalType
        "Send-SSMAutomationSignal/SignalType"
        {
            $v = "Approve","Reject","Resume","StartStep","StopStep"
            break
        }

        # Amazon.SimpleSystemsManagement.StopType
        "Stop-SSMAutomationExecution/Type"
        {
            $v = "Cancel","Complete"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSM_map = @{
    "ApprovedPatchesComplianceLevel"=@("New-SSMPatchBaseline","Update-SSMPatchBaseline")
    "AssociationStatus_Name"=@("Update-SSMAssociationStatus")
    "BaselineOverride_ApprovedPatchesComplianceLevel"=@("Get-SSMDeployablePatchSnapshotForInstance")
    "BaselineOverride_OperatingSystem"=@("Get-SSMDeployablePatchSnapshotForInstance")
    "BaselineOverride_RejectedPatchesAction"=@("Get-SSMDeployablePatchSnapshotForInstance")
    "ComplianceSeverity"=@("New-SSMAssociation","Update-SSMAssociation")
    "CutoffBehavior"=@("Register-SSMTaskWithMaintenanceWindow","Update-SSMMaintenanceWindowTask")
    "DocumentFormat"=@("Get-SSMDocument","New-SSMDocument","Update-SSMDocument")
    "DocumentHashType"=@("Send-SSMCommand")
    "DocumentReviews_Action"=@("Update-SSMDocumentMetadata")
    "DocumentType"=@("New-SSMDocument")
    "Metadata"=@("Get-SSMDocumentMetadataHistory")
    "Mode"=@("Start-SSMAutomationExecution")
    "NotificationConfig_NotificationType"=@("Send-SSMCommand")
    "OperatingSystem"=@("Get-SSMDefaultPatchBaseline","Get-SSMPatchBaselineForPatchGroup","Get-SSMPatchProperty","New-SSMPatchBaseline")
    "PatchSet"=@("Get-SSMPatchProperty")
    "PermissionType"=@("Edit-SSMDocumentPermission","Get-SSMDocumentPermission")
    "Property"=@("Get-SSMPatchProperty")
    "RejectedPatchesAction"=@("New-SSMPatchBaseline","Update-SSMPatchBaseline")
    "ResourceType"=@("Add-SSMResourceTag","Get-SSMMaintenanceWindowSchedule","Get-SSMMaintenanceWindowsForTarget","Get-SSMResourceTag","Register-SSMTargetWithMaintenanceWindow","Remove-SSMResourceTag")
    "S3Destination_SyncFormat"=@("New-SSMResourceDataSync")
    "SchemaDeleteOption"=@("Remove-SSMInventory")
    "SignalType"=@("Send-SSMAutomationSignal")
    "State"=@("Get-SSMSession")
    "Status"=@("Update-SSMOpsItem")
    "SyncCompliance"=@("New-SSMAssociation","Update-SSMAssociation")
    "TaskInvocationParameters_RunCommand_DocumentHashType"=@("Register-SSMTaskWithMaintenanceWindow","Update-SSMMaintenanceWindowTask")
    "TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType"=@("Register-SSMTaskWithMaintenanceWindow","Update-SSMMaintenanceWindowTask")
    "TaskType"=@("Register-SSMTaskWithMaintenanceWindow")
    "Tier"=@("Write-SSMParameter")
    "Type"=@("Stop-SSMAutomationExecution","Write-SSMParameter")
    "UploadType"=@("Write-SSMComplianceItem")
}

_awsArgumentCompleterRegistration $SSM_Completers $SSM_map

$SSM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSM_SelectMap = @{
    "Select"=@("Add-SSMResourceTag",
               "Register-SSMOpsItemRelatedItem",
               "Stop-SSMCommand",
               "Stop-SSMMaintenanceWindowExecution",
               "New-SSMActivation",
               "New-SSMAssociation",
               "New-SSMAssociationFromBatch",
               "New-SSMDocument",
               "New-SSMMaintenanceWindow",
               "New-SSMOpsItem",
               "New-SSMOpsMetadata",
               "New-SSMPatchBaseline",
               "New-SSMResourceDataSync",
               "Remove-SSMActivation",
               "Remove-SSMAssociation",
               "Remove-SSMDocument",
               "Remove-SSMInventory",
               "Remove-SSMMaintenanceWindow",
               "Remove-SSMOpsMetadata",
               "Remove-SSMParameter",
               "Remove-SSMParameterCollection",
               "Remove-SSMPatchBaseline",
               "Remove-SSMResourceDataSync",
               "Remove-SSMResourcePolicy",
               "Unregister-SSMManagedInstance",
               "Unregister-SSMPatchBaselineForPatchGroup",
               "Unregister-SSMTargetFromMaintenanceWindow",
               "Unregister-SSMTaskFromMaintenanceWindow",
               "Get-SSMActivation",
               "Get-SSMAssociation",
               "Get-SSMAssociationExecution",
               "Get-SSMAssociationExecutionTarget",
               "Get-SSMAutomationExecutionList",
               "Get-SSMAutomationStepExecution",
               "Get-SSMAvailablePatch",
               "Get-SSMDocumentDescription",
               "Get-SSMDocumentPermission",
               "Get-SSMEffectiveInstanceAssociationList",
               "Get-SSMEffectivePatchesForPatchBaseline",
               "Get-SSMInstanceAssociationsStatus",
               "Get-SSMInstanceInformation",
               "Get-SSMInstancePatch",
               "Get-SSMInstancePatchState",
               "Get-SSMInstancePatchStatesForPatchGroup",
               "Get-SSMInventoryDeletionList",
               "Get-SSMMaintenanceWindowExecutionList",
               "Get-SSMMaintenanceWindowExecutionTaskInvocationList",
               "Get-SSMMaintenanceWindowExecutionTaskList",
               "Get-SSMMaintenanceWindowList",
               "Get-SSMMaintenanceWindowSchedule",
               "Get-SSMMaintenanceWindowsForTarget",
               "Get-SSMMaintenanceWindowTarget",
               "Get-SSMMaintenanceWindowTaskList",
               "Get-SSMOpsItemSummary",
               "Get-SSMParameterList",
               "Get-SSMPatchBaseline",
               "Get-SSMPatchGroup",
               "Get-SSMPatchGroupState",
               "Get-SSMPatchProperty",
               "Get-SSMSession",
               "Unregister-SSMOpsItemRelatedItem",
               "Get-SSMAutomationExecution",
               "Get-SSMCalendarState",
               "Get-SSMCommandInvocationDetail",
               "Get-SSMConnectionStatus",
               "Get-SSMDefaultPatchBaseline",
               "Get-SSMDeployablePatchSnapshotForInstance",
               "Get-SSMDocument",
               "Get-SSMInventory",
               "Get-SSMInventorySchema",
               "Get-SSMMaintenanceWindow",
               "Get-SSMMaintenanceWindowExecution",
               "Get-SSMMaintenanceWindowExecutionTask",
               "Get-SSMMaintenanceWindowExecutionTaskInvocation",
               "Get-SSMMaintenanceWindowTask",
               "Get-SSMOpsItem",
               "Get-SSMOpsMetadata",
               "Get-SSMOpsSummary",
               "Get-SSMParameter",
               "Get-SSMParameterHistory",
               "Get-SSMParameterValue",
               "Get-SSMParametersByPath",
               "Get-SSMPatchBaselineDetail",
               "Get-SSMPatchBaselineForPatchGroup",
               "Get-SSMResourcePolicy",
               "Get-SSMServiceSetting",
               "Set-SSMParameterVersionLabel",
               "Get-SSMAssociationList",
               "Get-SSMAssociationVersionList",
               "Get-SSMCommandInvocation",
               "Get-SSMCommand",
               "Get-SSMComplianceItemList",
               "Get-SSMComplianceSummaryList",
               "Get-SSMDocumentMetadataHistory",
               "Get-SSMDocumentList",
               "Get-SSMDocumentVersionList",
               "Get-SSMInventoryEntryList",
               "Get-SSMOpsItemEvent",
               "Get-SSMOpsItemRelatedItem",
               "Get-SSMOpsMetadataList",
               "Get-SSMResourceComplianceSummaryList",
               "Get-SSMResourceDataSync",
               "Get-SSMResourceTag",
               "Edit-SSMDocumentPermission",
               "Write-SSMComplianceItem",
               "Write-SSMInventory",
               "Write-SSMParameter",
               "Write-SSMResourcePolicy",
               "Register-SSMDefaultPatchBaseline",
               "Register-SSMPatchBaselineForPatchGroup",
               "Register-SSMTargetWithMaintenanceWindow",
               "Register-SSMTaskWithMaintenanceWindow",
               "Remove-SSMResourceTag",
               "Reset-SSMServiceSetting",
               "Resume-SSMSession",
               "Send-SSMAutomationSignal",
               "Send-SSMCommand",
               "Start-SSMAssociationsOnce",
               "Start-SSMAutomationExecution",
               "Start-SSMChangeRequestExecution",
               "Start-SSMSession",
               "Stop-SSMAutomationExecution",
               "Stop-SSMSession",
               "Reset-SSMParameterVersionLabel",
               "Update-SSMAssociation",
               "Update-SSMAssociationStatus",
               "Update-SSMDocument",
               "Update-SSMDocumentDefaultVersion",
               "Update-SSMDocumentMetadata",
               "Update-SSMMaintenanceWindow",
               "Update-SSMMaintenanceWindowTarget",
               "Update-SSMMaintenanceWindowTask",
               "Update-SSMManagedInstanceRole",
               "Update-SSMOpsItem",
               "Update-SSMOpsMetadata",
               "Update-SSMPatchBaseline",
               "Update-SSMResourceDataSync",
               "Update-SSMServiceSetting",
               "Get-SSMLatestEC2Image")
}

_awsArgumentCompleterRegistration $SSM_SelectCompleters $SSM_SelectMap
# Argument completions for service AWS System Manager Contacts


$SMC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SSMContacts.AcceptCodeValidation
        "Confirm-SMCPage/AcceptCodeValidation"
        {
            $v = "ENFORCE","IGNORE"
            break
        }

        # Amazon.SSMContacts.AcceptType
        "Confirm-SMCPage/AcceptType"
        {
            $v = "DELIVERED","READ"
            break
        }

        # Amazon.SSMContacts.ChannelType
        "New-SMCContactChannel/Type"
        {
            $v = "EMAIL","SMS","VOICE"
            break
        }

        # Amazon.SSMContacts.ContactType
        {
            ($_ -eq "Get-SMCContactList/Type") -Or
            ($_ -eq "New-SMCContact/Type")
        }
        {
            $v = "ESCALATION","PERSONAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMC_map = @{
    "AcceptCodeValidation"=@("Confirm-SMCPage")
    "AcceptType"=@("Confirm-SMCPage")
    "Type"=@("Get-SMCContactList","New-SMCContact","New-SMCContactChannel")
}

_awsArgumentCompleterRegistration $SMC_Completers $SMC_map

$SMC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMC_SelectMap = @{
    "Select"=@("Confirm-SMCPage",
               "Enable-SMCContactChannel",
               "New-SMCContact",
               "New-SMCContactChannel",
               "Disable-SMCContactChannel",
               "Remove-SMCContact",
               "Remove-SMCContactChannel",
               "Get-SMCEngagement",
               "Get-SMCPage",
               "Get-SMCContact",
               "Get-SMCContactChannel",
               "Get-SMCContactPolicy",
               "Get-SMCContactChannelList",
               "Get-SMCContactList",
               "Get-SMCEngagementList",
               "Get-SMCPageReceiptList",
               "Get-SMCPagesByContactList",
               "Get-SMCPagesByEngagementList",
               "Get-SMCResourceTag",
               "Write-SMCContactPolicy",
               "Send-SMCActivationCode",
               "Start-SMCEngagement",
               "Stop-SMCEngagement",
               "Add-SMCResourceTag",
               "Remove-SMCResourceTag",
               "Update-SMCContact",
               "Update-SMCContactChannel")
}

_awsArgumentCompleterRegistration $SMC_SelectCompleters $SMC_SelectMap
# Argument completions for service AWS Systems Manager Incident Manager


$SSMI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SSMIncidents.IncidentRecordStatus
        "Update-SSMIIncidentRecord/Status"
        {
            $v = "OPEN","RESOLVED"
            break
        }

        # Amazon.SSMIncidents.ItemType
        {
            ($_ -eq "Update-SSMIRelatedItem/RelatedItemsUpdate_ItemToAdd_Identifier_Type") -Or
            ($_ -eq "Update-SSMIRelatedItem/RelatedItemsUpdate_ItemToRemove_Type")
        }
        {
            $v = "ANALYSIS","ATTACHMENT","AUTOMATION","INCIDENT","INVOLVED_RESOURCE","METRIC","OTHER","PARENT","TASK"
            break
        }

        # Amazon.SSMIncidents.SortOrder
        "Get-SSMITimelineEventList/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.SSMIncidents.TimelineEventSort
        "Get-SSMITimelineEventList/SortBy"
        {
            $v = "EVENT_TIME"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSMI_map = @{
    "RelatedItemsUpdate_ItemToAdd_Identifier_Type"=@("Update-SSMIRelatedItem")
    "RelatedItemsUpdate_ItemToRemove_Type"=@("Update-SSMIRelatedItem")
    "SortBy"=@("Get-SSMITimelineEventList")
    "SortOrder"=@("Get-SSMITimelineEventList")
    "Status"=@("Update-SSMIIncidentRecord")
}

_awsArgumentCompleterRegistration $SSMI_Completers $SSMI_map

$SSMI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSMI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSMI_SelectMap = @{
    "Select"=@("New-SSMIReplicationSet",
               "New-SSMIResponsePlan",
               "New-SSMITimelineEvent",
               "Remove-SSMIIncidentRecord",
               "Remove-SSMIReplicationSet",
               "Remove-SSMIResourcePolicy",
               "Remove-SSMIResponsePlan",
               "Remove-SSMITimelineEvent",
               "Get-SSMIIncidentRecord",
               "Get-SSMIReplicationSet",
               "Get-SSMIResourcePolicy",
               "Get-SSMIResponsePlan",
               "Get-SSMITimelineEvent",
               "Get-SSMIIncidentRecordList",
               "Get-SSMIRelatedItemList",
               "Get-SSMIReplicationSetList",
               "Get-SSMIResponsePlanList",
               "Get-SSMIResourceTag",
               "Get-SSMITimelineEventList",
               "Write-SSMIResourcePolicy",
               "Start-SSMIIncident",
               "Add-SSMIResourceTag",
               "Remove-SSMIResourceTag",
               "Update-SSMIDeletionProtection",
               "Update-SSMIIncidentRecord",
               "Update-SSMIRelatedItem",
               "Update-SSMIReplicationSet",
               "Update-SSMIResponsePlan",
               "Update-SSMITimelineEvent")
}

_awsArgumentCompleterRegistration $SSMI_SelectCompleters $SSMI_SelectMap
# Argument completions for service AWS Systems Manager for SAP


$SMSAP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SsmSap.ApplicationType
        "Register-SMSAPApplication/ApplicationType"
        {
            $v = "HANA"
            break
        }

        # Amazon.SsmSap.PermissionActionType
        {
            ($_ -eq "Get-SMSAPResourcePermission/ActionType") -Or
            ($_ -eq "Remove-SMSAPResourcePermission/ActionType") -Or
            ($_ -eq "Write-SMSAPResourcePermission/ActionType")
        }
        {
            $v = "RESTORE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMSAP_map = @{
    "ActionType"=@("Get-SMSAPResourcePermission","Remove-SMSAPResourcePermission","Write-SMSAPResourcePermission")
    "ApplicationType"=@("Register-SMSAPApplication")
}

_awsArgumentCompleterRegistration $SMSAP_Completers $SMSAP_map

$SMSAP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMSAP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMSAP_SelectMap = @{
    "Select"=@("Remove-SMSAPResourcePermission",
               "Unregister-SMSAPApplication",
               "Get-SMSAPApplication",
               "Get-SMSAPComponent",
               "Get-SMSAPDatabase",
               "Get-SMSAPOperation",
               "Get-SMSAPResourcePermission",
               "Get-SMSAPApplicationList",
               "Get-SMSAPComponentList",
               "Get-SMSAPDatabasisList",
               "Get-SMSAPResourceTag",
               "Write-SMSAPResourcePermission",
               "Register-SMSAPApplication",
               "Add-SMSAPResourceTag",
               "Remove-SMSAPResourceTag",
               "Update-SMSAPApplicationSetting")
}

_awsArgumentCompleterRegistration $SMSAP_SelectCompleters $SMSAP_SelectMap
# Argument completions for service AWS Single Sign-On


$SSO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSO_SelectMap = @{
    "Select"=@("Get-SSORoleCredential",
               "Get-SSOAccountRoleList",
               "Get-SSOAccountList",
               "Close-SSOSession")
}

_awsArgumentCompleterRegistration $SSO_SelectCompleters $SSO_SelectMap
# Argument completions for service AWS Single Sign-On Admin


$SSOADMN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SSOAdmin.PrincipalType
        {
            ($_ -eq "New-SSOADMNAccountAssignment/PrincipalType") -Or
            ($_ -eq "Remove-SSOADMNAccountAssignment/PrincipalType")
        }
        {
            $v = "GROUP","USER"
            break
        }

        # Amazon.SSOAdmin.ProvisioningStatus
        {
            ($_ -eq "Get-SSOADMNAccountsForProvisionedPermissionSetList/ProvisioningStatus") -Or
            ($_ -eq "Get-SSOADMNPermissionSetsProvisionedToAccountList/ProvisioningStatus")
        }
        {
            $v = "LATEST_PERMISSION_SET_NOT_PROVISIONED","LATEST_PERMISSION_SET_PROVISIONED"
            break
        }

        # Amazon.SSOAdmin.ProvisionTargetType
        "Add-SSOADMNPermissionSetProvision/TargetType"
        {
            $v = "ALL_PROVISIONED_ACCOUNTS","AWS_ACCOUNT"
            break
        }

        # Amazon.SSOAdmin.StatusValues
        {
            ($_ -eq "Get-SSOADMNAccountAssignmentCreationStatusList/Filter_Status") -Or
            ($_ -eq "Get-SSOADMNAccountAssignmentDeletionStatusList/Filter_Status") -Or
            ($_ -eq "Get-SSOADMNPermissionSetProvisioningStatusList/Filter_Status")
        }
        {
            $v = "FAILED","IN_PROGRESS","SUCCEEDED"
            break
        }

        # Amazon.SSOAdmin.TargetType
        {
            ($_ -eq "New-SSOADMNAccountAssignment/TargetType") -Or
            ($_ -eq "Remove-SSOADMNAccountAssignment/TargetType")
        }
        {
            $v = "AWS_ACCOUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSOADMN_map = @{
    "Filter_Status"=@("Get-SSOADMNAccountAssignmentCreationStatusList","Get-SSOADMNAccountAssignmentDeletionStatusList","Get-SSOADMNPermissionSetProvisioningStatusList")
    "PrincipalType"=@("New-SSOADMNAccountAssignment","Remove-SSOADMNAccountAssignment")
    "ProvisioningStatus"=@("Get-SSOADMNAccountsForProvisionedPermissionSetList","Get-SSOADMNPermissionSetsProvisionedToAccountList")
    "TargetType"=@("Add-SSOADMNPermissionSetProvision","New-SSOADMNAccountAssignment","Remove-SSOADMNAccountAssignment")
}

_awsArgumentCompleterRegistration $SSOADMN_Completers $SSOADMN_map

$SSOADMN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSOADMN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSOADMN_SelectMap = @{
    "Select"=@("Mount-SSOADMNCustomerManagedPolicyReferenceToPermissionSet",
               "Mount-SSOADMNManagedPolicyToPermissionSet",
               "New-SSOADMNAccountAssignment",
               "New-SSOADMNInstanceAccessControlAttributeConfiguration",
               "New-SSOADMNPermissionSet",
               "Remove-SSOADMNAccountAssignment",
               "Remove-SSOADMNInlinePolicyFromPermissionSet",
               "Remove-SSOADMNInstanceAccessControlAttributeConfiguration",
               "Remove-SSOADMNPermissionsBoundaryFromPermissionSet",
               "Remove-SSOADMNPermissionSet",
               "Get-SSOADMNAccountAssignmentCreationStatus",
               "Get-SSOADMNAccountAssignmentDeletionStatus",
               "Get-SSOADMNInstanceAccessControlAttributeConfiguration",
               "Get-SSOADMNPermissionSet",
               "Get-SSOADMNPermissionSetProvisioningStatus",
               "Dismount-SSOADMNCustomerManagedPolicyReferenceFromPermissionSet",
               "Dismount-SSOADMNManagedPolicyFromPermissionSet",
               "Get-SSOADMNInlinePolicyForPermissionSet",
               "Get-SSOADMNPermissionsBoundaryForPermissionSet",
               "Get-SSOADMNAccountAssignmentCreationStatusList",
               "Get-SSOADMNAccountAssignmentDeletionStatusList",
               "Get-SSOADMNAccountAssignmentList",
               "Get-SSOADMNAccountsForProvisionedPermissionSetList",
               "Get-SSOADMNCustomerManagedPolicyReferencesInPermissionSetList",
               "Get-SSOADMNInstanceList",
               "Get-SSOADMNManagedPoliciesInPermissionSetList",
               "Get-SSOADMNPermissionSetProvisioningStatusList",
               "Get-SSOADMNPermissionSetList",
               "Get-SSOADMNPermissionSetsProvisionedToAccountList",
               "Get-SSOADMNResourceTag",
               "Add-SSOADMNPermissionSetProvision",
               "Write-SSOADMNInlinePolicyToPermissionSet",
               "Write-SSOADMNPermissionsBoundaryToPermissionSet",
               "Add-SSOADMNResourceTag",
               "Remove-SSOADMNResourceTag",
               "Update-SSOADMNInstanceAccessControlAttributeConfiguration",
               "Update-SSOADMNPermissionSet")
}

_awsArgumentCompleterRegistration $SSOADMN_SelectCompleters $SSOADMN_SelectMap
# Argument completions for service AWS Single Sign-On OIDC


$SSOOIDC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSOOIDC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSOOIDC_SelectMap = @{
    "Select"=@("New-SSOOIDCToken",
               "Register-SSOOIDCClient",
               "Start-SSOOIDCDeviceAuthorization")
}

_awsArgumentCompleterRegistration $SSOOIDC_SelectCompleters $SSOOIDC_SelectMap
# Argument completions for service AWS Step Functions


$SFN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.StepFunctions.ExecutionStatus
        "Get-SFNExecutionList/StatusFilter"
        {
            $v = "ABORTED","FAILED","RUNNING","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.StepFunctions.LogLevel
        {
            ($_ -eq "New-SFNStateMachine/LoggingConfiguration_Level") -Or
            ($_ -eq "Update-SFNStateMachine/LoggingConfiguration_Level")
        }
        {
            $v = "ALL","ERROR","FATAL","OFF"
            break
        }

        # Amazon.StepFunctions.StateMachineType
        "New-SFNStateMachine/Type"
        {
            $v = "EXPRESS","STANDARD"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SFN_map = @{
    "LoggingConfiguration_Level"=@("New-SFNStateMachine","Update-SFNStateMachine")
    "StatusFilter"=@("Get-SFNExecutionList")
    "Type"=@("New-SFNStateMachine")
}

_awsArgumentCompleterRegistration $SFN_Completers $SFN_map

$SFN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SFN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SFN_SelectMap = @{
    "Select"=@("New-SFNActivity",
               "New-SFNStateMachine",
               "Remove-SFNActivity",
               "Remove-SFNStateMachine",
               "Get-SFNActivity",
               "Get-SFNExecution",
               "Get-SFNStateMachine",
               "Get-SFNStateMachineForExecution",
               "Get-SFNActivityTask",
               "Get-SFNExecutionHistory",
               "Get-SFNActivityList",
               "Get-SFNExecutionList",
               "Get-SFNStateMachineList",
               "Get-SFNResourceTag",
               "Send-SFNTaskFailure",
               "Send-SFNTaskHeartbeat",
               "Send-SFNTaskSuccess",
               "Start-SFNExecution",
               "Start-SFNSyncExecution",
               "Stop-SFNExecution",
               "Add-SFNResourceTag",
               "Remove-SFNResourceTag",
               "Update-SFNStateMachine")
}

_awsArgumentCompleterRegistration $SFN_SelectCompleters $SFN_SelectMap
# Argument completions for service AWS Storage Gateway


$SG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.StorageGateway.CaseSensitivity
        {
            ($_ -eq "New-SGSMBFileShare/CaseSensitivity") -Or
            ($_ -eq "Update-SGSMBFileShare/CaseSensitivity")
        }
        {
            $v = "CaseSensitive","ClientSpecified"
            break
        }

        # Amazon.StorageGateway.GatewayCapacity
        "Update-SGGatewayInformation/GatewayCapacity"
        {
            $v = "Large","Medium","Small"
            break
        }

        # Amazon.StorageGateway.ObjectACL
        {
            ($_ -eq "New-SGNFSFileShare/ObjectACL") -Or
            ($_ -eq "New-SGSMBFileShare/ObjectACL") -Or
            ($_ -eq "Update-SGNFSFileShare/ObjectACL") -Or
            ($_ -eq "Update-SGSMBFileShare/ObjectACL")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","private","public-read","public-read-write"
            break
        }

        # Amazon.StorageGateway.RetentionLockType
        "New-SGTapePool/RetentionLockType"
        {
            $v = "COMPLIANCE","GOVERNANCE","NONE"
            break
        }

        # Amazon.StorageGateway.SMBSecurityStrategy
        "Update-SGSMBSecurityStrategy/SMBSecurityStrategy"
        {
            $v = "ClientSpecified","MandatoryEncryption","MandatorySigning"
            break
        }

        # Amazon.StorageGateway.TapeStorageClass
        "New-SGTapePool/StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SG_map = @{
    "CaseSensitivity"=@("New-SGSMBFileShare","Update-SGSMBFileShare")
    "GatewayCapacity"=@("Update-SGGatewayInformation")
    "ObjectACL"=@("New-SGNFSFileShare","New-SGSMBFileShare","Update-SGNFSFileShare","Update-SGSMBFileShare")
    "RetentionLockType"=@("New-SGTapePool")
    "SMBSecurityStrategy"=@("Update-SGSMBSecurityStrategy")
    "StorageClass"=@("New-SGTapePool")
}

_awsArgumentCompleterRegistration $SG_Completers $SG_map

$SG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SG_SelectMap = @{
    "Select"=@("Enable-SGGateway",
               "Add-SGCache",
               "Add-SGResourceTag",
               "Add-SGUploadBuffer",
               "Add-SGWorkingStorage",
               "Add-SGTapeToTapePool",
               "New-SGSGFileSystemAssociation",
               "Mount-SGVolume",
               "Stop-SGArchival",
               "Stop-SGRetrieval",
               "New-SGCachediSCSIVolume",
               "New-SGNFSFileShare",
               "New-SGSMBFileShare",
               "New-SGSnapshot",
               "New-SGSnapshotFromVolumeRecoveryPoint",
               "New-SGStorediSCSIVolume",
               "New-SGTapePool",
               "New-SGTape",
               "New-SGTapeWithBarcode",
               "Remove-SGAutomaticTapeCreationPolicy",
               "Remove-SGBandwidthRateLimit",
               "Remove-SGChapCredential",
               "Remove-SGFileShare",
               "Remove-SGGateway",
               "Remove-SGSnapshotSchedule",
               "Remove-SGTape",
               "Remove-SGTapeArchive",
               "Remove-SGTapePool",
               "Remove-SGVolume",
               "Get-SGAvailabilityMonitorTest",
               "Get-SGBandwidthRateLimit",
               "Get-SGBandwidthRateLimitSchedule",
               "Get-SGCache",
               "Get-SGCachediSCSIVolume",
               "Get-SGChapCredential",
               "Get-SGSGFileSystemAssociation",
               "Get-SGGatewayInformation",
               "Get-SGMaintenanceStartTime",
               "Get-SGNFSFileShareList",
               "Get-SGSMBFileShare",
               "Get-SGSMBSetting",
               "Get-SGSnapshotSchedule",
               "Get-SGStorediSCSIVolume",
               "Get-SGTapeArchiveList",
               "Get-SGTapeRecoveryPointList",
               "Get-SGTapeList",
               "Get-SGUploadBuffer",
               "Get-SGVTLDevice",
               "Get-SGWorkingStorage",
               "Dismount-SGVolume",
               "Disable-SGGateway",
               "Remove-SGSGFileSystemAssociation",
               "Join-SGDomain",
               "Get-SGAutomaticTapeCreationPolicy",
               "Get-SGFileShareList",
               "Get-SGSGFileSystemAssociationList",
               "Get-SGGateway",
               "Get-SGLocalDisk",
               "Get-SGResourceTag",
               "Get-SGTapePool",
               "Get-SGTape",
               "Get-SGVolumeInitiatorList",
               "Get-SGVolumeRecoveryPoint",
               "Get-SGVolume",
               "Send-SGUploadedNotification",
               "Invoke-SGCacheRefresh",
               "Remove-SGResourceTag",
               "Reset-SGCache",
               "Get-SGTapeArchive",
               "Get-SGTapeRecoveryPoint",
               "Set-SGLocalConsolePassword",
               "Set-SGSMBGuestPassword",
               "Stop-SGGateway",
               "Start-SGAvailabilityMonitorTest",
               "Start-SGGateway",
               "Update-SGAutomaticTapeCreationPolicy",
               "Update-SGBandwidthRateLimit",
               "Update-SGBandwidthRateLimitSchedule",
               "Update-SGChapCredential",
               "Update-SGSGFileSystemAssociation",
               "Update-SGGatewayInformation",
               "Update-SGGatewaySoftwareNow",
               "Update-SGMaintenanceStartTime",
               "Update-SGNFSFileShare",
               "Update-SGSMBFileShare",
               "Update-SGSMBFileShareVisibility",
               "Update-SGSGSMBLocalGroup",
               "Update-SGSMBSecurityStrategy",
               "Update-SGSnapshotSchedule",
               "Update-SGVTLDeviceType")
}

_awsArgumentCompleterRegistration $SG_SelectCompleters $SG_SelectMap
# Argument completions for service AWS Security Token Service (STS)


$STS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.STS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$STS_SelectMap = @{
    "Select"=@("Use-STSRole",
               "Convert-STSAuthorizationMessage",
               "Get-STSAccessKeyInfo",
               "Get-STSCallerIdentity",
               "Get-STSFederationToken",
               "Get-STSSessionToken",
               "Use-STSRoleWithSAML",
               "Use-STSWebIdentityRole")
}

_awsArgumentCompleterRegistration $STS_SelectCompleters $STS_SelectMap
# Argument completions for service AWS Support


$ASA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASA_SelectMap = @{
    "Select"=@("Add-ASAAttachmentsToSet",
               "Add-ASACommunicationToCase",
               "New-ASACase",
               "Get-ASAAttachment",
               "Get-ASACase",
               "Get-ASACommunication",
               "Get-ASAService",
               "Get-ASASeverityLevel",
               "Get-ASATrustedAdvisorCheckRefreshStatus",
               "Get-ASATrustedAdvisorCheckResult",
               "Get-ASATrustedAdvisorCheck",
               "Get-ASATrustedAdvisorCheckSummary",
               "Request-ASATrustedAdvisorCheckRefresh",
               "Resolve-ASACase")
}

_awsArgumentCompleterRegistration $ASA_SelectCompleters $ASA_SelectMap
# Argument completions for service AWS Support App


$SUP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SupportApp.NotificationSeverityLevel
        {
            ($_ -eq "New-SUPSlackChannelConfiguration/NotifyOnCaseSeverity") -Or
            ($_ -eq "Update-SUPSlackChannelConfiguration/NotifyOnCaseSeverity")
        }
        {
            $v = "all","high","none"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SUP_map = @{
    "NotifyOnCaseSeverity"=@("New-SUPSlackChannelConfiguration","Update-SUPSlackChannelConfiguration")
}

_awsArgumentCompleterRegistration $SUP_Completers $SUP_map

$SUP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SUP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SUP_SelectMap = @{
    "Select"=@("New-SUPSlackChannelConfiguration",
               "Remove-SUPAccountAlias",
               "Remove-SUPSlackChannelConfiguration",
               "Remove-SUPSlackWorkspaceConfiguration",
               "Get-SUPAccountAlias",
               "Get-SUPSlackChannelConfigurationList",
               "Get-SUPSlackWorkspaceConfigurationList",
               "Set-SUPAccountAlias",
               "Register-SUPSlackWorkspaceForOrganization",
               "Update-SUPSlackChannelConfiguration")
}

_awsArgumentCompleterRegistration $SUP_SelectCompleters $SUP_SelectMap
# Argument completions for service AWS Simple Workflow Service (SWF)


$SWF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleWorkflow.ChildPolicy
        {
            ($_ -eq "Start-SWFWorkflowExecution/ChildPolicy") -Or
            ($_ -eq "Stop-SWFWorkflowExecution/ChildPolicy") -Or
            ($_ -eq "New-SWFWorkflowType/DefaultChildPolicy")
        }
        {
            $v = "ABANDON","REQUEST_CANCEL","TERMINATE"
            break
        }

        # Amazon.SimpleWorkflow.CloseStatus
        {
            ($_ -eq "Get-SWFClosedWorkflowExecutionCount/CloseStatusFilter_Status") -Or
            ($_ -eq "Get-SWFClosedWorkflowExecutionList/CloseStatusFilter_Status")
        }
        {
            $v = "CANCELED","COMPLETED","CONTINUED_AS_NEW","FAILED","TERMINATED","TIMED_OUT"
            break
        }

        # Amazon.SimpleWorkflow.RegistrationStatus
        {
            ($_ -eq "Get-SWFActivityTypeList/RegistrationStatus") -Or
            ($_ -eq "Get-SWFDomainList/RegistrationStatus") -Or
            ($_ -eq "Get-SWFWorkflowTypeList/RegistrationStatus")
        }
        {
            $v = "DEPRECATED","REGISTERED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SWF_map = @{
    "ChildPolicy"=@("Start-SWFWorkflowExecution","Stop-SWFWorkflowExecution")
    "CloseStatusFilter_Status"=@("Get-SWFClosedWorkflowExecutionCount","Get-SWFClosedWorkflowExecutionList")
    "DefaultChildPolicy"=@("New-SWFWorkflowType")
    "RegistrationStatus"=@("Get-SWFActivityTypeList","Get-SWFDomainList","Get-SWFWorkflowTypeList")
}

_awsArgumentCompleterRegistration $SWF_Completers $SWF_map

$SWF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SWF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SWF_SelectMap = @{
    "Select"=@("Get-SWFClosedWorkflowExecutionCount",
               "Get-SWFOpenWorkflowExecutionCount",
               "Get-SWFPendingActivityTaskCount",
               "Get-SWFPendingDecisionTaskCount",
               "Remove-SWFActivityType",
               "Remove-SWFDomain",
               "Remove-SWFWorkflowType",
               "Get-SWFActivityType",
               "Get-SWFDomain",
               "Get-SWFWorkflowExecution",
               "Get-SWFWorkflowType",
               "Get-SWFWorkflowExecutionHistory",
               "Get-SWFActivityTypeList",
               "Get-SWFClosedWorkflowExecutionList",
               "Get-SWFDomainList",
               "Get-SWFResourceTag",
               "Get-SWFWorkflowTypeList",
               "New-SWFActivityType",
               "New-SWFDomain",
               "New-SWFWorkflowType",
               "Request-SWFCancelWorkflowExecution",
               "Send-SWFSignalToWorkflowExecution",
               "Start-SWFWorkflowExecution",
               "Add-SWFResourceTag",
               "Stop-SWFWorkflowExecution",
               "Restore-SWFActivityType",
               "Restore-SWFDomain",
               "Restore-SWFWorkflowType",
               "Remove-SWFResourceTag")
}

_awsArgumentCompleterRegistration $SWF_SelectCompleters $SWF_SelectMap
# Argument completions for service Amazon CloudWatch Synthetics


$CWSYN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Synthetics.EncryptionMode
        {
            ($_ -eq "New-CWSYNCanary/ArtifactConfig_S3Encryption_EncryptionMode") -Or
            ($_ -eq "Update-CWSYNCanary/ArtifactConfig_S3Encryption_EncryptionMode")
        }
        {
            $v = "SSE_KMS","SSE_S3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWSYN_map = @{
    "ArtifactConfig_S3Encryption_EncryptionMode"=@("New-CWSYNCanary","Update-CWSYNCanary")
}

_awsArgumentCompleterRegistration $CWSYN_Completers $CWSYN_map

$CWSYN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWSYN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWSYN_SelectMap = @{
    "Select"=@("Add-CWSYNResource",
               "New-CWSYNCanary",
               "New-CWSYNGroup",
               "Remove-CWSYNCanary",
               "Remove-CWSYNGroup",
               "Get-CWSYNCanaryList",
               "Get-CWSYNCanariesLastRun",
               "Get-CWSYNRuntimeVersion",
               "Remove-CWSYNResource",
               "Get-CWSYNCanary",
               "Get-CWSYNCanaryRun",
               "Get-CWSYNGroup",
               "Get-CWSYNAssociatedGroupList",
               "Get-CWSYNGroupResourceList",
               "Get-CWSYNGroupList",
               "Get-CWSYNResourceTag",
               "Start-CWSYNCanary",
               "Stop-CWSYNCanary",
               "Add-CWSYNResourceTag",
               "Remove-CWSYNResourceTag",
               "Update-CWSYNCanary")
}

_awsArgumentCompleterRegistration $CWSYN_SelectCompleters $CWSYN_SelectMap
# Argument completions for service Amazon Textract


$TXT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TXT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TXT_SelectMap = @{
    "Select"=@("Invoke-TXTDocumentAnalysis",
               "Invoke-TXTExpenseAnalysis",
               "Invoke-TXTAnalyzeID",
               "Find-TXTDocumentText",
               "Get-TXTDocumentAnalysis",
               "Get-TXTDocumentTextDetection",
               "Get-TXTExpenseAnalysis",
               "Start-TXTDocumentAnalysis",
               "Start-TXTDocumentTextDetection",
               "Start-TXTExpenseAnalysis")
}

_awsArgumentCompleterRegistration $TXT_SelectCompleters $TXT_SelectMap
# Argument completions for service Amazon Timestream Query


$TSQ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.TimestreamQuery.S3EncryptionOption
        "New-TSQScheduledQuery/ErrorReportConfiguration_S3Configuration_EncryptionOption"
        {
            $v = "SSE_KMS","SSE_S3"
            break
        }

        # Amazon.TimestreamQuery.ScheduledQueryState
        "Update-TSQScheduledQuery/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TSQ_map = @{
    "ErrorReportConfiguration_S3Configuration_EncryptionOption"=@("New-TSQScheduledQuery")
    "State"=@("Update-TSQScheduledQuery")
}

_awsArgumentCompleterRegistration $TSQ_Completers $TSQ_map

$TSQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TSQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TSQ_SelectMap = @{
    "Select"=@("Stop-TSQQuery",
               "New-TSQScheduledQuery",
               "Remove-TSQScheduledQuery",
               "Get-TSQEndpointList",
               "Get-TSQScheduledQuery",
               "Start-TSQScheduledQuery",
               "Get-TSQScheduledQueryList",
               "Get-TSQResourceTag",
               "Initialize-TSQQuery",
               "Invoke-TSQQuery",
               "Add-TSQResourceTag",
               "Remove-TSQResourceTag",
               "Update-TSQScheduledQuery")
}

_awsArgumentCompleterRegistration $TSQ_SelectCompleters $TSQ_SelectMap
# Argument completions for service Amazon Timestream Write


$TSW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.TimestreamWrite.MeasureValueType
        "Write-TSWRecord/CommonAttributes_MeasureValueType"
        {
            $v = "BIGINT","BOOLEAN","DOUBLE","MULTI","TIMESTAMP","VARCHAR"
            break
        }

        # Amazon.TimestreamWrite.S3EncryptionOption
        {
            ($_ -eq "New-TSWTable/MagneticStoreWriteProperties_MagneticStoreRejectedDataLocation_S3Configuration_EncryptionOption") -Or
            ($_ -eq "Update-TSWTable/MagneticStoreWriteProperties_MagneticStoreRejectedDataLocation_S3Configuration_EncryptionOption")
        }
        {
            $v = "SSE_KMS","SSE_S3"
            break
        }

        # Amazon.TimestreamWrite.TimeUnit
        "Write-TSWRecord/CommonAttributes_TimeUnit"
        {
            $v = "MICROSECONDS","MILLISECONDS","NANOSECONDS","SECONDS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TSW_map = @{
    "CommonAttributes_MeasureValueType"=@("Write-TSWRecord")
    "CommonAttributes_TimeUnit"=@("Write-TSWRecord")
    "MagneticStoreWriteProperties_MagneticStoreRejectedDataLocation_S3Configuration_EncryptionOption"=@("New-TSWTable","Update-TSWTable")
}

_awsArgumentCompleterRegistration $TSW_Completers $TSW_map

$TSW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TSW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TSW_SelectMap = @{
    "Select"=@("New-TSWDatabase",
               "New-TSWTable",
               "Remove-TSWDatabase",
               "Remove-TSWTable",
               "Get-TSWDatabase",
               "Get-TSWEndpointList",
               "Get-TSWTable",
               "Get-TSWDatabaseList",
               "Get-TSWTableList",
               "Get-TSWResourceTagList",
               "Add-TSWResourceTag",
               "Remove-TSWResourceTag",
               "Update-TSWDatabase",
               "Update-TSWTable",
               "Write-TSWRecord")
}

_awsArgumentCompleterRegistration $TSW_SelectCompleters $TSW_SelectMap
# Argument completions for service Amazon Transcribe Service


$TRS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.TranscribeService.BaseModelName
        "New-TRSLanguageModel/BaseModelName"
        {
            $v = "NarrowBand","WideBand"
            break
        }

        # Amazon.TranscribeService.CallAnalyticsJobStatus
        "Get-TRSCallAnalyticsJobList/Status"
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","QUEUED"
            break
        }

        # Amazon.TranscribeService.CLMLanguageCode
        "New-TRSLanguageModel/LanguageCode"
        {
            $v = "en-AU","en-GB","en-US","es-US","hi-IN"
            break
        }

        # Amazon.TranscribeService.LanguageCode
        {
            ($_ -eq "New-TRSMedicalVocabulary/LanguageCode") -Or
            ($_ -eq "New-TRSVocabulary/LanguageCode") -Or
            ($_ -eq "New-TRSVocabularyFilter/LanguageCode") -Or
            ($_ -eq "Start-TRSMedicalTranscriptionJob/LanguageCode") -Or
            ($_ -eq "Start-TRSTranscriptionJob/LanguageCode") -Or
            ($_ -eq "Update-TRSMedicalVocabulary/LanguageCode") -Or
            ($_ -eq "Update-TRSVocabulary/LanguageCode")
        }
        {
            $v = "af-ZA","ar-AE","ar-SA","da-DK","de-CH","de-DE","en-AB","en-AU","en-GB","en-IE","en-IN","en-NZ","en-US","en-WL","en-ZA","es-ES","es-US","fa-IR","fr-CA","fr-FR","he-IL","hi-IN","id-ID","it-IT","ja-JP","ko-KR","ms-MY","nl-NL","pt-BR","pt-PT","ru-RU","ta-IN","te-IN","th-TH","tr-TR","zh-CN","zh-TW"
            break
        }

        # Amazon.TranscribeService.MediaFormat
        {
            ($_ -eq "Start-TRSMedicalTranscriptionJob/MediaFormat") -Or
            ($_ -eq "Start-TRSTranscriptionJob/MediaFormat")
        }
        {
            $v = "amr","flac","mp3","mp4","ogg","wav","webm"
            break
        }

        # Amazon.TranscribeService.MedicalContentIdentificationType
        "Start-TRSMedicalTranscriptionJob/ContentIdentificationType"
        {
            $v = "PHI"
            break
        }

        # Amazon.TranscribeService.ModelStatus
        "Get-TRSLanguageModelList/StatusEquals"
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.TranscribeService.RedactionOutput
        {
            ($_ -eq "Start-TRSTranscriptionJob/ContentRedaction_RedactionOutput") -Or
            ($_ -eq "Start-TRSCallAnalyticsJob/Settings_ContentRedaction_RedactionOutput")
        }
        {
            $v = "redacted","redacted_and_unredacted"
            break
        }

        # Amazon.TranscribeService.RedactionType
        {
            ($_ -eq "Start-TRSTranscriptionJob/ContentRedaction_RedactionType") -Or
            ($_ -eq "Start-TRSCallAnalyticsJob/Settings_ContentRedaction_RedactionType")
        }
        {
            $v = "PII"
            break
        }

        # Amazon.TranscribeService.Specialty
        "Start-TRSMedicalTranscriptionJob/Specialty"
        {
            $v = "PRIMARYCARE"
            break
        }

        # Amazon.TranscribeService.TranscriptionJobStatus
        {
            ($_ -eq "Get-TRSMedicalTranscriptionJobList/Status") -Or
            ($_ -eq "Get-TRSTranscriptionJobList/Status")
        }
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","QUEUED"
            break
        }

        # Amazon.TranscribeService.Type
        "Start-TRSMedicalTranscriptionJob/Type"
        {
            $v = "CONVERSATION","DICTATION"
            break
        }

        # Amazon.TranscribeService.VocabularyFilterMethod
        {
            ($_ -eq "Start-TRSCallAnalyticsJob/Settings_VocabularyFilterMethod") -Or
            ($_ -eq "Start-TRSTranscriptionJob/Settings_VocabularyFilterMethod")
        }
        {
            $v = "mask","remove","tag"
            break
        }

        # Amazon.TranscribeService.VocabularyState
        {
            ($_ -eq "Get-TRSMedicalVocabularyList/StateEquals") -Or
            ($_ -eq "Get-TRSVocabularyList/StateEquals")
        }
        {
            $v = "FAILED","PENDING","READY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRS_map = @{
    "BaseModelName"=@("New-TRSLanguageModel")
    "ContentIdentificationType"=@("Start-TRSMedicalTranscriptionJob")
    "ContentRedaction_RedactionOutput"=@("Start-TRSTranscriptionJob")
    "ContentRedaction_RedactionType"=@("Start-TRSTranscriptionJob")
    "LanguageCode"=@("New-TRSLanguageModel","New-TRSMedicalVocabulary","New-TRSVocabulary","New-TRSVocabularyFilter","Start-TRSMedicalTranscriptionJob","Start-TRSTranscriptionJob","Update-TRSMedicalVocabulary","Update-TRSVocabulary")
    "MediaFormat"=@("Start-TRSMedicalTranscriptionJob","Start-TRSTranscriptionJob")
    "Settings_ContentRedaction_RedactionOutput"=@("Start-TRSCallAnalyticsJob")
    "Settings_ContentRedaction_RedactionType"=@("Start-TRSCallAnalyticsJob")
    "Settings_VocabularyFilterMethod"=@("Start-TRSCallAnalyticsJob","Start-TRSTranscriptionJob")
    "Specialty"=@("Start-TRSMedicalTranscriptionJob")
    "StateEquals"=@("Get-TRSMedicalVocabularyList","Get-TRSVocabularyList")
    "Status"=@("Get-TRSCallAnalyticsJobList","Get-TRSMedicalTranscriptionJobList","Get-TRSTranscriptionJobList")
    "StatusEquals"=@("Get-TRSLanguageModelList")
    "Type"=@("Start-TRSMedicalTranscriptionJob")
}

_awsArgumentCompleterRegistration $TRS_Completers $TRS_map

$TRS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TRS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRS_SelectMap = @{
    "Select"=@("New-TRSCallAnalyticsCategory",
               "New-TRSLanguageModel",
               "New-TRSMedicalVocabulary",
               "New-TRSVocabulary",
               "New-TRSVocabularyFilter",
               "Remove-TRSCallAnalyticsCategory",
               "Remove-TRSCallAnalyticsJob",
               "Remove-TRSLanguageModel",
               "Remove-TRSMedicalTranscriptionJob",
               "Remove-TRSMedicalVocabulary",
               "Remove-TRSTranscriptionJob",
               "Remove-TRSVocabulary",
               "Remove-TRSVocabularyFilter",
               "Get-TRSLanguageModel",
               "Get-TRSCallAnalyticsCategory",
               "Get-TRSCallAnalyticsJob",
               "Get-TRSMedicalTranscriptionJob",
               "Get-TRSMedicalVocabulary",
               "Get-TRSTranscriptionJob",
               "Get-TRSVocabulary",
               "Get-TRSVocabularyFilter",
               "Get-TRSCallAnalyticsCategoryList",
               "Get-TRSCallAnalyticsJobList",
               "Get-TRSLanguageModelList",
               "Get-TRSMedicalTranscriptionJobList",
               "Get-TRSMedicalVocabularyList",
               "Get-TRSResourceTag",
               "Get-TRSTranscriptionJobList",
               "Get-TRSVocabularyList",
               "Get-TRSVocabularyFilterList",
               "Start-TRSCallAnalyticsJob",
               "Start-TRSMedicalTranscriptionJob",
               "Start-TRSTranscriptionJob",
               "Add-TRSResourceTag",
               "Remove-TRSResourceTag",
               "Update-TRSCallAnalyticsCategory",
               "Update-TRSMedicalVocabulary",
               "Update-TRSVocabulary",
               "Update-TRSVocabularyFilter")
}

_awsArgumentCompleterRegistration $TRS_SelectCompleters $TRS_SelectMap
# Argument completions for service AWS Transfer for SFTP


$TFR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Transfer.AgreementStatusType
        {
            ($_ -eq "New-TFRAgreement/Status") -Or
            ($_ -eq "Update-TFRAgreement/Status")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.Transfer.CertificateUsageType
        "Import-TFRCertificate/Usage"
        {
            $v = "ENCRYPTION","SIGNING"
            break
        }

        # Amazon.Transfer.CompressionEnum
        {
            ($_ -eq "New-TFRConnector/As2Config_Compression") -Or
            ($_ -eq "Update-TFRConnector/As2Config_Compression")
        }
        {
            $v = "DISABLED","ZLIB"
            break
        }

        # Amazon.Transfer.CustomStepStatus
        "Send-TFRWorkflowStepState/Status"
        {
            $v = "FAILURE","SUCCESS"
            break
        }

        # Amazon.Transfer.Domain
        "New-TFRServer/Domain"
        {
            $v = "EFS","S3"
            break
        }

        # Amazon.Transfer.EncryptionAlg
        {
            ($_ -eq "New-TFRConnector/As2Config_EncryptionAlgorithm") -Or
            ($_ -eq "Update-TFRConnector/As2Config_EncryptionAlgorithm")
        }
        {
            $v = "AES128_CBC","AES192_CBC","AES256_CBC"
            break
        }

        # Amazon.Transfer.EndpointType
        {
            ($_ -eq "New-TFRServer/EndpointType") -Or
            ($_ -eq "Update-TFRServer/EndpointType")
        }
        {
            $v = "PUBLIC","VPC","VPC_ENDPOINT"
            break
        }

        # Amazon.Transfer.HomeDirectoryType
        {
            ($_ -eq "New-TFRAccess/HomeDirectoryType") -Or
            ($_ -eq "New-TFRUser/HomeDirectoryType") -Or
            ($_ -eq "Update-TFRAccess/HomeDirectoryType") -Or
            ($_ -eq "Update-TFRUser/HomeDirectoryType")
        }
        {
            $v = "LOGICAL","PATH"
            break
        }

        # Amazon.Transfer.IdentityProviderType
        "New-TFRServer/IdentityProviderType"
        {
            $v = "API_GATEWAY","AWS_DIRECTORY_SERVICE","AWS_LAMBDA","SERVICE_MANAGED"
            break
        }

        # Amazon.Transfer.MdnResponse
        {
            ($_ -eq "New-TFRConnector/As2Config_MdnResponse") -Or
            ($_ -eq "Update-TFRConnector/As2Config_MdnResponse")
        }
        {
            $v = "NONE","SYNC"
            break
        }

        # Amazon.Transfer.MdnSigningAlg
        {
            ($_ -eq "New-TFRConnector/As2Config_MdnSigningAlgorithm") -Or
            ($_ -eq "Update-TFRConnector/As2Config_MdnSigningAlgorithm")
        }
        {
            $v = "DEFAULT","NONE","SHA1","SHA256","SHA384","SHA512"
            break
        }

        # Amazon.Transfer.ProfileType
        {
            ($_ -eq "Get-TFRProfileList/ProfileType") -Or
            ($_ -eq "New-TFRProfile/ProfileType")
        }
        {
            $v = "LOCAL","PARTNER"
            break
        }

        # Amazon.Transfer.Protocol
        "Test-TFRIdentityProvider/ServerProtocol"
        {
            $v = "AS2","FTP","FTPS","SFTP"
            break
        }

        # Amazon.Transfer.SetStatOption
        {
            ($_ -eq "New-TFRServer/ProtocolDetails_SetStatOption") -Or
            ($_ -eq "Update-TFRServer/ProtocolDetails_SetStatOption")
        }
        {
            $v = "DEFAULT","ENABLE_NO_OP"
            break
        }

        # Amazon.Transfer.SigningAlg
        {
            ($_ -eq "New-TFRConnector/As2Config_SigningAlgorithm") -Or
            ($_ -eq "Update-TFRConnector/As2Config_SigningAlgorithm")
        }
        {
            $v = "NONE","SHA1","SHA256","SHA384","SHA512"
            break
        }

        # Amazon.Transfer.TlsSessionResumptionMode
        {
            ($_ -eq "New-TFRServer/ProtocolDetails_TlsSessionResumptionMode") -Or
            ($_ -eq "Update-TFRServer/ProtocolDetails_TlsSessionResumptionMode")
        }
        {
            $v = "DISABLED","ENABLED","ENFORCED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TFR_map = @{
    "As2Config_Compression"=@("New-TFRConnector","Update-TFRConnector")
    "As2Config_EncryptionAlgorithm"=@("New-TFRConnector","Update-TFRConnector")
    "As2Config_MdnResponse"=@("New-TFRConnector","Update-TFRConnector")
    "As2Config_MdnSigningAlgorithm"=@("New-TFRConnector","Update-TFRConnector")
    "As2Config_SigningAlgorithm"=@("New-TFRConnector","Update-TFRConnector")
    "Domain"=@("New-TFRServer")
    "EndpointType"=@("New-TFRServer","Update-TFRServer")
    "HomeDirectoryType"=@("New-TFRAccess","New-TFRUser","Update-TFRAccess","Update-TFRUser")
    "IdentityProviderType"=@("New-TFRServer")
    "ProfileType"=@("Get-TFRProfileList","New-TFRProfile")
    "ProtocolDetails_SetStatOption"=@("New-TFRServer","Update-TFRServer")
    "ProtocolDetails_TlsSessionResumptionMode"=@("New-TFRServer","Update-TFRServer")
    "ServerProtocol"=@("Test-TFRIdentityProvider")
    "Status"=@("New-TFRAgreement","Send-TFRWorkflowStepState","Update-TFRAgreement")
    "Usage"=@("Import-TFRCertificate")
}

_awsArgumentCompleterRegistration $TFR_Completers $TFR_map

$TFR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TFR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TFR_SelectMap = @{
    "Select"=@("New-TFRAccess",
               "New-TFRAgreement",
               "New-TFRConnector",
               "New-TFRProfile",
               "New-TFRServer",
               "New-TFRUser",
               "New-TFRWorkflow",
               "Remove-TFRAccess",
               "Remove-TFRAgreement",
               "Remove-TFRCertificate",
               "Remove-TFRConnector",
               "Remove-TFRHostKey",
               "Remove-TFRProfile",
               "Remove-TFRServer",
               "Remove-TFRSshPublicKey",
               "Remove-TFRUser",
               "Remove-TFRWorkflow",
               "Get-TFRAccess",
               "Get-TFRAgreement",
               "Get-TFRCertificate",
               "Get-TFRConnector",
               "Get-TFRExecution",
               "Get-TFRHostKey",
               "Get-TFRProfile",
               "Get-TFRSecurityPolicy",
               "Get-TFRServer",
               "Get-TFRUser",
               "Get-TFRWorkflow",
               "Import-TFRCertificate",
               "Import-TFRHostKey",
               "Import-TFRSshPublicKey",
               "Get-TFRAccessList",
               "Get-TFRAgreementList",
               "Get-TFRCertificateList",
               "Get-TFRConnectorList",
               "Get-TFRExecutionList",
               "Get-TFRHostKeyList",
               "Get-TFRProfileList",
               "Get-TFRSecurityPolicyList",
               "Get-TFRServerList",
               "Get-TFRResourceTagList",
               "Get-TFRUserList",
               "Get-TFRWorkflowList",
               "Send-TFRWorkflowStepState",
               "Start-TFRFileTransfer",
               "Start-TFRServer",
               "Stop-TFRServer",
               "Add-TFRResourceTag",
               "Test-TFRIdentityProvider",
               "Remove-TFRResourceTag",
               "Update-TFRAccess",
               "Update-TFRAgreement",
               "Update-TFRCertificate",
               "Update-TFRConnector",
               "Update-TFRHostKey",
               "Update-TFRProfile",
               "Update-TFRServer",
               "Update-TFRUser")
}

_awsArgumentCompleterRegistration $TFR_SelectCompleters $TFR_SelectMap
# Argument completions for service Amazon Translate


$TRN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Translate.Directionality
        "Import-TRNTerminology/TerminologyData_Directionality"
        {
            $v = "MULTI","UNI"
            break
        }

        # Amazon.Translate.DisplayLanguageCode
        "Get-TRNLanguageList/DisplayLanguageCode"
        {
            $v = "de","en","es","fr","it","ja","ko","pt","zh","zh-TW"
            break
        }

        # Amazon.Translate.EncryptionKeyType
        {
            ($_ -eq "Import-TRNTerminology/EncryptionKey_Type") -Or
            ($_ -eq "New-TRNParallelData/EncryptionKey_Type") -Or
            ($_ -eq "Start-TRNTextTranslationJob/OutputDataConfig_EncryptionKey_Type")
        }
        {
            $v = "KMS"
            break
        }

        # Amazon.Translate.Formality
        {
            ($_ -eq "ConvertTo-TRNTargetLanguage/Settings_Formality") -Or
            ($_ -eq "Start-TRNTextTranslationJob/Settings_Formality")
        }
        {
            $v = "FORMAL","INFORMAL"
            break
        }

        # Amazon.Translate.JobStatus
        "Get-TRNTextTranslationJobList/Filter_JobStatus"
        {
            $v = "COMPLETED","COMPLETED_WITH_ERROR","FAILED","IN_PROGRESS","STOPPED","STOP_REQUESTED","SUBMITTED"
            break
        }

        # Amazon.Translate.MergeStrategy
        "Import-TRNTerminology/MergeStrategy"
        {
            $v = "OVERWRITE"
            break
        }

        # Amazon.Translate.ParallelDataFormat
        {
            ($_ -eq "New-TRNParallelData/ParallelDataConfig_Format") -Or
            ($_ -eq "Update-TRNParallelData/ParallelDataConfig_Format")
        }
        {
            $v = "CSV","TMX","TSV"
            break
        }

        # Amazon.Translate.Profanity
        {
            ($_ -eq "ConvertTo-TRNTargetLanguage/Settings_Profanity") -Or
            ($_ -eq "Start-TRNTextTranslationJob/Settings_Profanity")
        }
        {
            $v = "MASK"
            break
        }

        # Amazon.Translate.TerminologyDataFormat
        {
            ($_ -eq "Import-TRNTerminology/TerminologyData_Format") -Or
            ($_ -eq "Get-TRNTerminology/TerminologyDataFormat")
        }
        {
            $v = "CSV","TMX","TSV"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRN_map = @{
    "DisplayLanguageCode"=@("Get-TRNLanguageList")
    "EncryptionKey_Type"=@("Import-TRNTerminology","New-TRNParallelData")
    "Filter_JobStatus"=@("Get-TRNTextTranslationJobList")
    "MergeStrategy"=@("Import-TRNTerminology")
    "OutputDataConfig_EncryptionKey_Type"=@("Start-TRNTextTranslationJob")
    "ParallelDataConfig_Format"=@("New-TRNParallelData","Update-TRNParallelData")
    "Settings_Formality"=@("ConvertTo-TRNTargetLanguage","Start-TRNTextTranslationJob")
    "Settings_Profanity"=@("ConvertTo-TRNTargetLanguage","Start-TRNTextTranslationJob")
    "TerminologyData_Directionality"=@("Import-TRNTerminology")
    "TerminologyData_Format"=@("Import-TRNTerminology")
    "TerminologyDataFormat"=@("Get-TRNTerminology")
}

_awsArgumentCompleterRegistration $TRN_Completers $TRN_map

$TRN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TRN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRN_SelectMap = @{
    "Select"=@("New-TRNParallelData",
               "Remove-TRNParallelData",
               "Remove-TRNTerminology",
               "Get-TRNTextTranslationJob",
               "Get-TRNParallelData",
               "Get-TRNTerminology",
               "Import-TRNTerminology",
               "Get-TRNLanguageList",
               "Get-TRNParallelDataList",
               "Get-TRNResourceTag",
               "Get-TRNTerminologyList",
               "Get-TRNTextTranslationJobList",
               "Start-TRNTextTranslationJob",
               "Stop-TRNTextTranslationJob",
               "Add-TRNResourceTag",
               "ConvertTo-TRNTargetLanguage",
               "Remove-TRNResourceTag",
               "Update-TRNParallelData")
}

_awsArgumentCompleterRegistration $TRN_SelectCompleters $TRN_SelectMap
# Argument completions for service Amazon Voice ID


$VID_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.VoiceID.DuplicateRegistrationAction
        "Start-VIDFraudsterRegistrationJob/RegistrationConfig_DuplicateRegistrationAction"
        {
            $v = "REGISTER_AS_NEW","SKIP"
            break
        }

        # Amazon.VoiceID.ExistingEnrollmentAction
        "Start-VIDSpeakerEnrollmentJob/EnrollmentConfig_ExistingEnrollmentAction"
        {
            $v = "OVERWRITE","SKIP"
            break
        }

        # Amazon.VoiceID.FraudDetectionAction
        "Start-VIDSpeakerEnrollmentJob/EnrollmentConfig_FraudDetectionConfig_FraudDetectionAction"
        {
            $v = "FAIL","IGNORE"
            break
        }

        # Amazon.VoiceID.FraudsterRegistrationJobStatus
        "Get-VIDFraudsterRegistrationJobList/JobStatus"
        {
            $v = "COMPLETED","COMPLETED_WITH_ERRORS","FAILED","IN_PROGRESS","SUBMITTED"
            break
        }

        # Amazon.VoiceID.SpeakerEnrollmentJobStatus
        "Get-VIDSpeakerEnrollmentJobList/JobStatus"
        {
            $v = "COMPLETED","COMPLETED_WITH_ERRORS","FAILED","IN_PROGRESS","SUBMITTED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$VID_map = @{
    "EnrollmentConfig_ExistingEnrollmentAction"=@("Start-VIDSpeakerEnrollmentJob")
    "EnrollmentConfig_FraudDetectionConfig_FraudDetectionAction"=@("Start-VIDSpeakerEnrollmentJob")
    "JobStatus"=@("Get-VIDFraudsterRegistrationJobList","Get-VIDSpeakerEnrollmentJobList")
    "RegistrationConfig_DuplicateRegistrationAction"=@("Start-VIDFraudsterRegistrationJob")
}

_awsArgumentCompleterRegistration $VID_Completers $VID_map

$VID_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.VID.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$VID_SelectMap = @{
    "Select"=@("New-VIDDomain",
               "Remove-VIDDomain",
               "Remove-VIDFraudster",
               "Remove-VIDSpeaker",
               "Get-VIDDomain",
               "Get-VIDFraudster",
               "Get-VIDFraudsterRegistrationJob",
               "Get-VIDSpeaker",
               "Get-VIDSpeakerEnrollmentJob",
               "Get-VIDSessionEvaluation",
               "Get-VIDDomainList",
               "Get-VIDFraudsterRegistrationJobList",
               "Get-VIDSpeakerEnrollmentJobList",
               "Get-VIDSpeakerList",
               "Get-VIDResourceTag",
               "Set-VIDOptOutSpeaker",
               "Start-VIDFraudsterRegistrationJob",
               "Start-VIDSpeakerEnrollmentJob",
               "Add-VIDResourceTag",
               "Remove-VIDResourceTag",
               "Edit-VIDDomain")
}

_awsArgumentCompleterRegistration $VID_SelectCompleters $VID_SelectMap
# Argument completions for service AWS WAF


$WAF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAF.RateKey
        "New-WAFRateBasedRule/RateKey"
        {
            $v = "IP"
            break
        }

        # Amazon.WAF.WafActionType
        {
            ($_ -eq "New-WAFWebACL/DefaultAction_Type") -Or
            ($_ -eq "Update-WAFWebACL/DefaultAction_Type")
        }
        {
            $v = "ALLOW","BLOCK","COUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF_map = @{
    "DefaultAction_Type"=@("New-WAFWebACL","Update-WAFWebACL")
    "RateKey"=@("New-WAFRateBasedRule")
}

_awsArgumentCompleterRegistration $WAF_Completers $WAF_map

$WAF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF_SelectMap = @{
    "Select"=@("New-WAFByteMatchSet",
               "New-WAFGeoMatchSet",
               "New-WAFIPSet",
               "New-WAFRateBasedRule",
               "New-WAFRegexMatchSet",
               "New-WAFRegexPatternSet",
               "New-WAFRule",
               "New-WAFRuleGroup",
               "New-WAFSizeConstraintSet",
               "New-WAFSqlInjectionMatchSet",
               "New-WAFWebACL",
               "New-WAFWebACLMigrationStack",
               "New-WAFXssMatchSet",
               "Remove-WAFByteMatchSet",
               "Remove-WAFGeoMatchSet",
               "Remove-WAFIPSet",
               "Remove-WAFLoggingConfiguration",
               "Remove-WAFPermissionPolicy",
               "Remove-WAFRateBasedRule",
               "Remove-WAFRegexMatchSet",
               "Remove-WAFRegexPatternSet",
               "Remove-WAFRule",
               "Remove-WAFRuleGroup",
               "Remove-WAFSizeConstraintSet",
               "Remove-WAFSqlInjectionMatchSet",
               "Remove-WAFWebACL",
               "Remove-WAFXssMatchSet",
               "Get-WAFByteMatchSet",
               "Get-WAFChangeToken",
               "Get-WAFChangeTokenStatus",
               "Get-WAFGeoMatchSet",
               "Get-WAFIPSet",
               "Get-WAFLoggingConfiguration",
               "Get-WAFPermissionPolicy",
               "Get-WAFRateBasedRule",
               "Get-WAFRateBasedRuleManagedKey",
               "Get-WAFRegexMatchSet",
               "Get-WAFRegexPatternSet",
               "Get-WAFRule",
               "Get-WAFRuleGroup",
               "Get-WAFSampledRequestList",
               "Get-WAFSizeConstraintSet",
               "Get-WAFSqlInjectionMatchSet",
               "Get-WAFWebACL",
               "Get-WAFXssMatchSet",
               "Get-WAFActivatedRulesInRuleGroupList",
               "Get-WAFByteMatchSetList",
               "Get-WAFGeoMatchSetList",
               "Get-WAFIPSetList",
               "Get-WAFLoggingConfigurationList",
               "Get-WAFRateBasedRuleList",
               "Get-WAFRegexMatchSetList",
               "Get-WAFRegexPatternSetList",
               "Get-WAFRuleGroupList",
               "Get-WAFRuleList",
               "Get-WAFSizeConstraintSetList",
               "Get-WAFSqlInjectionMatchSetList",
               "Get-WAFSubscribedRuleGroupList",
               "Get-WAFResourceTag",
               "Get-WAFWebACLList",
               "Get-WAFXssMatchSetList",
               "Write-WAFLoggingConfiguration",
               "Write-WAFPermissionPolicy",
               "Add-WAFResourceTag",
               "Remove-WAFResourceTag",
               "Update-WAFByteMatchSet",
               "Update-WAFGeoMatchSet",
               "Update-WAFIPSet",
               "Update-WAFRateBasedRule",
               "Update-WAFRegexMatchSet",
               "Update-WAFRegexPatternSet",
               "Update-WAFRule",
               "Update-WAFRuleGroup",
               "Update-WAFSizeConstraintSet",
               "Update-WAFSqlInjectionMatchSet",
               "Update-WAFWebACL",
               "Update-WAFXssMatchSet")
}

_awsArgumentCompleterRegistration $WAF_SelectCompleters $WAF_SelectMap
# Argument completions for service AWS WAF Regional


$WAFR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAFRegional.RateKey
        "New-WAFRRateBasedRule/RateKey"
        {
            $v = "IP"
            break
        }

        # Amazon.WAFRegional.ResourceType
        "Get-WAFRResourceForWebACLList/ResourceType"
        {
            $v = "API_GATEWAY","APPLICATION_LOAD_BALANCER"
            break
        }

        # Amazon.WAFRegional.WafActionType
        {
            ($_ -eq "New-WAFRWebACL/DefaultAction_Type") -Or
            ($_ -eq "Update-WAFRWebACL/DefaultAction_Type")
        }
        {
            $v = "ALLOW","BLOCK","COUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAFR_map = @{
    "DefaultAction_Type"=@("New-WAFRWebACL","Update-WAFRWebACL")
    "RateKey"=@("New-WAFRRateBasedRule")
    "ResourceType"=@("Get-WAFRResourceForWebACLList")
}

_awsArgumentCompleterRegistration $WAFR_Completers $WAFR_map

$WAFR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAFR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAFR_SelectMap = @{
    "Select"=@("Register-WAFRWebACL",
               "New-WAFRByteMatchSet",
               "New-WAFRGeoMatchSet",
               "New-WAFRIPSet",
               "New-WAFRRateBasedRule",
               "New-WAFRRegexMatchSet",
               "New-WAFRRegexPatternSet",
               "New-WAFRRule",
               "New-WAFRRuleGroup",
               "New-WAFRSizeConstraintSet",
               "New-WAFRSqlInjectionMatchSet",
               "New-WAFRWebACL",
               "New-WAFRWebACLMigrationStack",
               "New-WAFRXssMatchSet",
               "Remove-WAFRByteMatchSet",
               "Remove-WAFRGeoMatchSet",
               "Remove-WAFRIPSet",
               "Remove-WAFRLoggingConfiguration",
               "Remove-WAFRPermissionPolicy",
               "Remove-WAFRRateBasedRule",
               "Remove-WAFRRegexMatchSet",
               "Remove-WAFRRegexPatternSet",
               "Remove-WAFRRule",
               "Remove-WAFRRuleGroup",
               "Remove-WAFRSizeConstraintSet",
               "Remove-WAFRSqlInjectionMatchSet",
               "Remove-WAFRWebACL",
               "Remove-WAFRXssMatchSet",
               "Unregister-WAFRWebACL",
               "Get-WAFRByteMatchSet",
               "Get-WAFRChangeToken",
               "Get-WAFRChangeTokenStatus",
               "Get-WAFRGeoMatchSet",
               "Get-WAFRIPSet",
               "Get-WAFRLoggingConfiguration",
               "Get-WAFRPermissionPolicy",
               "Get-WAFRRateBasedRule",
               "Get-WAFRRateBasedRuleManagedKey",
               "Get-WAFRRegexMatchSet",
               "Get-WAFRRegexPatternSet",
               "Get-WAFRRule",
               "Get-WAFRRuleGroup",
               "Get-WAFRSampledRequestList",
               "Get-WAFRSizeConstraintSet",
               "Get-WAFRSqlInjectionMatchSet",
               "Get-WAFRWebACL",
               "Get-WAFRWebACLForResource",
               "Get-WAFRXssMatchSet",
               "Get-WAFRActivatedRulesInRuleGroupList",
               "Get-WAFRByteMatchSetList",
               "Get-WAFRGeoMatchSetList",
               "Get-WAFRIPSetList",
               "Get-WAFRLoggingConfigurationList",
               "Get-WAFRRateBasedRuleList",
               "Get-WAFRRegexMatchSetList",
               "Get-WAFRRegexPatternSetList",
               "Get-WAFRResourceForWebACLList",
               "Get-WAFRRuleGroupList",
               "Get-WAFRRuleList",
               "Get-WAFRSizeConstraintSetList",
               "Get-WAFRSqlInjectionMatchSetList",
               "Get-WAFRSubscribedRuleGroup",
               "Get-WAFRResourceTag",
               "Get-WAFRWebACLList",
               "Get-WAFRXssMatchSetList",
               "Write-WAFRLoggingConfiguration",
               "Write-WAFRPermissionPolicy",
               "Add-WAFRResourceTag",
               "Remove-WAFRResourceTag",
               "Update-WAFRByteMatchSet",
               "Update-WAFRGeoMatchSet",
               "Update-WAFRIPSet",
               "Update-WAFRRateBasedRule",
               "Update-WAFRRegexMatchSet",
               "Update-WAFRRegexPatternSet",
               "Update-WAFRRule",
               "Update-WAFRRuleGroup",
               "Update-WAFRSizeConstraintSet",
               "Update-WAFRSqlInjectionMatchSet",
               "Update-WAFRWebACL",
               "Update-WAFRXssMatchSet")
}

_awsArgumentCompleterRegistration $WAFR_SelectCompleters $WAFR_SelectMap
# Argument completions for service AWS WAF V2


$WAF2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAFV2.FilterBehavior
        "Write-WAF2LoggingConfiguration/LoggingConfiguration_LoggingFilter_DefaultBehavior"
        {
            $v = "DROP","KEEP"
            break
        }

        # Amazon.WAFV2.IPAddressVersion
        "New-WAF2IPSet/IPAddressVersion"
        {
            $v = "IPV4","IPV6"
            break
        }

        # Amazon.WAFV2.Platform
        {
            ($_ -eq "Get-WAF2MobileSdkRelease/Platform") -Or
            ($_ -eq "Get-WAF2MobileSdkReleaseList/Platform") -Or
            ($_ -eq "New-WAF2MobileSdkReleaseUrl/Platform")
        }
        {
            $v = "ANDROID","IOS"
            break
        }

        # Amazon.WAFV2.ResourceType
        "Get-WAF2ResourcesForWebACLList/ResourceType"
        {
            $v = "API_GATEWAY","APPLICATION_LOAD_BALANCER","APPSYNC","COGNITO_USER_POOL"
            break
        }

        # Amazon.WAFV2.Scope
        {
            ($_ -eq "Get-WAF2AvailableManagedRuleGroupList/Scope") -Or
            ($_ -eq "Get-WAF2AvailableManagedRuleGroupVersionList/Scope") -Or
            ($_ -eq "Get-WAF2IPSet/Scope") -Or
            ($_ -eq "Get-WAF2IPSetList/Scope") -Or
            ($_ -eq "Get-WAF2LoggingConfigurationList/Scope") -Or
            ($_ -eq "Get-WAF2ManagedRuleGroup/Scope") -Or
            ($_ -eq "Get-WAF2ManagedRuleSet/Scope") -Or
            ($_ -eq "Get-WAF2ManagedRuleSetList/Scope") -Or
            ($_ -eq "Get-WAF2RateBasedStatementManagedKey/Scope") -Or
            ($_ -eq "Get-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Get-WAF2RegexPatternSetList/Scope") -Or
            ($_ -eq "Get-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Get-WAF2RuleGroupList/Scope") -Or
            ($_ -eq "Get-WAF2SampledRequest/Scope") -Or
            ($_ -eq "Get-WAF2WebACL/Scope") -Or
            ($_ -eq "Get-WAF2WebACLsList/Scope") -Or
            ($_ -eq "New-WAF2IPSet/Scope") -Or
            ($_ -eq "New-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "New-WAF2RuleGroup/Scope") -Or
            ($_ -eq "New-WAF2WebACL/Scope") -Or
            ($_ -eq "Remove-WAF2IPSet/Scope") -Or
            ($_ -eq "Remove-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Remove-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Remove-WAF2WebACL/Scope") -Or
            ($_ -eq "Test-WAF2Capacity/Scope") -Or
            ($_ -eq "Update-WAF2IPSet/Scope") -Or
            ($_ -eq "Update-WAF2ManagedRuleSetVersionExpiryDate/Scope") -Or
            ($_ -eq "Update-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Update-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Update-WAF2WebACL/Scope") -Or
            ($_ -eq "Write-WAF2ManagedRuleSetVersion/Scope")
        }
        {
            $v = "CLOUDFRONT","REGIONAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF2_map = @{
    "IPAddressVersion"=@("New-WAF2IPSet")
    "LoggingConfiguration_LoggingFilter_DefaultBehavior"=@("Write-WAF2LoggingConfiguration")
    "Platform"=@("Get-WAF2MobileSdkRelease","Get-WAF2MobileSdkReleaseList","New-WAF2MobileSdkReleaseUrl")
    "ResourceType"=@("Get-WAF2ResourcesForWebACLList")
    "Scope"=@("Get-WAF2AvailableManagedRuleGroupList","Get-WAF2AvailableManagedRuleGroupVersionList","Get-WAF2IPSet","Get-WAF2IPSetList","Get-WAF2LoggingConfigurationList","Get-WAF2ManagedRuleGroup","Get-WAF2ManagedRuleSet","Get-WAF2ManagedRuleSetList","Get-WAF2RateBasedStatementManagedKey","Get-WAF2RegexPatternSet","Get-WAF2RegexPatternSetList","Get-WAF2RuleGroup","Get-WAF2RuleGroupList","Get-WAF2SampledRequest","Get-WAF2WebACL","Get-WAF2WebACLsList","New-WAF2IPSet","New-WAF2RegexPatternSet","New-WAF2RuleGroup","New-WAF2WebACL","Remove-WAF2IPSet","Remove-WAF2RegexPatternSet","Remove-WAF2RuleGroup","Remove-WAF2WebACL","Test-WAF2Capacity","Update-WAF2IPSet","Update-WAF2ManagedRuleSetVersionExpiryDate","Update-WAF2RegexPatternSet","Update-WAF2RuleGroup","Update-WAF2WebACL","Write-WAF2ManagedRuleSetVersion")
}

_awsArgumentCompleterRegistration $WAF2_Completers $WAF2_map

$WAF2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAF2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF2_SelectMap = @{
    "Select"=@("Add-WAF2WebACLToResource",
               "Test-WAF2Capacity",
               "New-WAF2IPSet",
               "New-WAF2RegexPatternSet",
               "New-WAF2RuleGroup",
               "New-WAF2WebACL",
               "Remove-WAF2FirewallManagerRuleGroup",
               "Remove-WAF2IPSet",
               "Remove-WAF2LoggingConfiguration",
               "Remove-WAF2PermissionPolicy",
               "Remove-WAF2RegexPatternSet",
               "Remove-WAF2RuleGroup",
               "Remove-WAF2WebACL",
               "Get-WAF2ManagedRuleGroup",
               "Remove-WAF2WebACLFromResource",
               "New-WAF2MobileSdkReleaseUrl",
               "Get-WAF2IPSet",
               "Get-WAF2LoggingConfiguration",
               "Get-WAF2ManagedRuleSet",
               "Get-WAF2MobileSdkRelease",
               "Get-WAF2PermissionPolicy",
               "Get-WAF2RateBasedStatementManagedKey",
               "Get-WAF2RegexPatternSet",
               "Get-WAF2RuleGroup",
               "Get-WAF2SampledRequest",
               "Get-WAF2WebACL",
               "Get-WAF2WebACLForResource",
               "Get-WAF2AvailableManagedRuleGroupList",
               "Get-WAF2AvailableManagedRuleGroupVersionList",
               "Get-WAF2IPSetList",
               "Get-WAF2LoggingConfigurationList",
               "Get-WAF2ManagedRuleSetList",
               "Get-WAF2MobileSdkReleaseList",
               "Get-WAF2RegexPatternSetList",
               "Get-WAF2ResourcesForWebACLList",
               "Get-WAF2RuleGroupList",
               "Get-WAF2ResourceTag",
               "Get-WAF2WebACLsList",
               "Write-WAF2LoggingConfiguration",
               "Write-WAF2ManagedRuleSetVersion",
               "Write-WAF2PermissionPolicy",
               "Add-WAF2ResourceTag",
               "Remove-WAF2ResourceTag",
               "Update-WAF2IPSet",
               "Update-WAF2ManagedRuleSetVersionExpiryDate",
               "Update-WAF2RegexPatternSet",
               "Update-WAF2RuleGroup",
               "Update-WAF2WebACL")
}

_awsArgumentCompleterRegistration $WAF2_SelectCompleters $WAF2_SelectMap
# Argument completions for service AWS Well-Architected Tool


$WAT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WellArchitected.AnswerReason
        "Update-WATAnswer/Reason"
        {
            $v = "ARCHITECTURE_CONSTRAINTS","BUSINESS_PRIORITIES","NONE","OTHER","OUT_OF_SCOPE"
            break
        }

        # Amazon.WellArchitected.LensStatusType
        {
            ($_ -eq "Get-WATLensList/LensStatus") -Or
            ($_ -eq "Remove-WATLens/LensStatus")
        }
        {
            $v = "ALL","DRAFT","PUBLISHED"
            break
        }

        # Amazon.WellArchitected.LensType
        "Get-WATLensList/LensType"
        {
            $v = "AWS_OFFICIAL","CUSTOM_SELF","CUSTOM_SHARED"
            break
        }

        # Amazon.WellArchitected.OrganizationSharingStatus
        "Update-WATGlobalSetting/OrganizationSharingStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WellArchitected.PermissionType
        {
            ($_ -eq "New-WATWorkloadShare/PermissionType") -Or
            ($_ -eq "Update-WATWorkloadShare/PermissionType")
        }
        {
            $v = "CONTRIBUTOR","READONLY"
            break
        }

        # Amazon.WellArchitected.ShareInvitationAction
        "Update-WATShareInvitation/ShareInvitationAction"
        {
            $v = "ACCEPT","REJECT"
            break
        }

        # Amazon.WellArchitected.ShareResourceType
        "Get-WATShareInvitationList/ShareResourceType"
        {
            $v = "LENS","WORKLOAD"
            break
        }

        # Amazon.WellArchitected.ShareStatus
        {
            ($_ -eq "Get-WATLensShareList/Status") -Or
            ($_ -eq "Get-WATWorkloadShareList/Status")
        }
        {
            $v = "ACCEPTED","ASSOCIATED","ASSOCIATING","EXPIRED","FAILED","PENDING","REJECTED","REVOKED"
            break
        }

        # Amazon.WellArchitected.TrustedAdvisorIntegrationStatus
        {
            ($_ -eq "New-WATWorkload/DiscoveryConfig_TrustedAdvisorIntegrationStatus") -Or
            ($_ -eq "Update-WATWorkload/DiscoveryConfig_TrustedAdvisorIntegrationStatus")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WellArchitected.WorkloadEnvironment
        {
            ($_ -eq "New-WATWorkload/Environment") -Or
            ($_ -eq "Update-WATWorkload/Environment")
        }
        {
            $v = "PREPRODUCTION","PRODUCTION"
            break
        }

        # Amazon.WellArchitected.WorkloadImprovementStatus
        "Update-WATWorkload/ImprovementStatus"
        {
            $v = "COMPLETE","IN_PROGRESS","NOT_APPLICABLE","NOT_STARTED","RISK_ACKNOWLEDGED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAT_map = @{
    "DiscoveryConfig_TrustedAdvisorIntegrationStatus"=@("New-WATWorkload","Update-WATWorkload")
    "Environment"=@("New-WATWorkload","Update-WATWorkload")
    "ImprovementStatus"=@("Update-WATWorkload")
    "LensStatus"=@("Get-WATLensList","Remove-WATLens")
    "LensType"=@("Get-WATLensList")
    "OrganizationSharingStatus"=@("Update-WATGlobalSetting")
    "PermissionType"=@("New-WATWorkloadShare","Update-WATWorkloadShare")
    "Reason"=@("Update-WATAnswer")
    "ShareInvitationAction"=@("Update-WATShareInvitation")
    "ShareResourceType"=@("Get-WATShareInvitationList")
    "Status"=@("Get-WATLensShareList","Get-WATWorkloadShareList")
}

_awsArgumentCompleterRegistration $WAT_Completers $WAT_map

$WAT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAT_SelectMap = @{
    "Select"=@("Register-WATLens",
               "New-WATLensShare",
               "New-WATLensVersion",
               "New-WATMilestone",
               "New-WATWorkload",
               "New-WATWorkloadShare",
               "Remove-WATLens",
               "Remove-WATLensShare",
               "Remove-WATWorkload",
               "Remove-WATWorkloadShare",
               "Unregister-WATLens",
               "Export-WATLens",
               "Get-WATAnswer",
               "Get-WATLens",
               "Get-WATLensReview",
               "Get-WATLensReviewReport",
               "Get-WATLensVersionDifference",
               "Get-WATMilestone",
               "Get-WATWorkload",
               "Import-WATLens",
               "Get-WATAnswerList",
               "Get-WATCheckDetailList",
               "Get-WATCheckSummaryList",
               "Get-WATLensList",
               "Get-WATLensReviewImprovementList",
               "Get-WATLensReviewList",
               "Get-WATLensShareList",
               "Get-WATMilestoneList",
               "Get-WATNotificationList",
               "Get-WATShareInvitationList",
               "Get-WATResourceTag",
               "Get-WATWorkloadList",
               "Get-WATWorkloadShareList",
               "Add-WATResourceTag",
               "Remove-WATResourceTag",
               "Update-WATAnswer",
               "Update-WATGlobalSetting",
               "Update-WATLensReview",
               "Update-WATShareInvitation",
               "Update-WATWorkload",
               "Update-WATWorkloadShare",
               "Convert-WATLensReview")
}

_awsArgumentCompleterRegistration $WAT_SelectCompleters $WAT_SelectMap
# Argument completions for service Amazon Connect Wisdom Service


$WSDM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConnectWisdomService.AssistantType
        "New-WSDMAssistant/Type"
        {
            $v = "AGENT"
            break
        }

        # Amazon.ConnectWisdomService.AssociationType
        "New-WSDMAssistantAssociation/AssociationType"
        {
            $v = "KNOWLEDGE_BASE"
            break
        }

        # Amazon.ConnectWisdomService.KnowledgeBaseType
        "New-WSDMKnowledgeBase/KnowledgeBaseType"
        {
            $v = "CUSTOM","EXTERNAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WSDM_map = @{
    "AssociationType"=@("New-WSDMAssistantAssociation")
    "KnowledgeBaseType"=@("New-WSDMKnowledgeBase")
    "Type"=@("New-WSDMAssistant")
}

_awsArgumentCompleterRegistration $WSDM_Completers $WSDM_map

$WSDM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WSDM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WSDM_SelectMap = @{
    "Select"=@("New-WSDMAssistant",
               "New-WSDMAssistantAssociation",
               "New-WSDMContent",
               "New-WSDMKnowledgeBase",
               "New-WSDMSession",
               "Remove-WSDMAssistant",
               "Remove-WSDMAssistantAssociation",
               "Remove-WSDMContent",
               "Remove-WSDMKnowledgeBase",
               "Get-WSDMAssistant",
               "Get-WSDMAssistantAssociation",
               "Get-WSDMContent",
               "Get-WSDMContentSummary",
               "Get-WSDMKnowledgeBase",
               "Get-WSDMRecommendation",
               "Get-WSDMSession",
               "Get-WSDMAssistantAssociationList",
               "Get-WSDMAssistantList",
               "Get-WSDMContentList",
               "Get-WSDMKnowledgeBasisList",
               "Get-WSDMResourceTag",
               "Remove-WSDMRecommendationsReceived",
               "Search-WSDMAssistant",
               "Remove-WSDMKnowledgeBaseTemplateUri",
               "Search-WSDMContent",
               "Search-WSDMSession",
               "Start-WSDMContentUpload",
               "Add-WSDMResourceTag",
               "Remove-WSDMResourceTag",
               "Update-WSDMContent",
               "Update-WSDMKnowledgeBaseTemplateUri")
}

_awsArgumentCompleterRegistration $WSDM_SelectCompleters $WSDM_SelectMap
# Argument completions for service Amazon WorkDocs


$WD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkDocs.BooleanEnumType
        "Update-WDUser/GrantPoweruserPrivileges"
        {
            $v = "FALSE","TRUE"
            break
        }

        # Amazon.WorkDocs.CommentVisibilityType
        "New-WDComment/Visibility"
        {
            $v = "PRIVATE","PUBLIC"
            break
        }

        # Amazon.WorkDocs.DocumentVersionStatus
        "Update-WDDocumentVersion/VersionStatus"
        {
            $v = "ACTIVE"
            break
        }

        # Amazon.WorkDocs.FolderContentType
        "Get-WDFolderContent/Type"
        {
            $v = "ALL","DOCUMENT","FOLDER"
            break
        }

        # Amazon.WorkDocs.LocaleType
        "Update-WDUser/Locale"
        {
            $v = "de","default","en","es","fr","ja","ko","pt_BR","ru","zh_CN","zh_TW"
            break
        }

        # Amazon.WorkDocs.OrderType
        {
            ($_ -eq "Get-WDFolderContent/Order") -Or
            ($_ -eq "Get-WDUserList/Order")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.WorkDocs.PrincipalType
        "Remove-WDResourcePermission/PrincipalType"
        {
            $v = "ANONYMOUS","GROUP","INVITE","ORGANIZATION","USER"
            break
        }

        # Amazon.WorkDocs.ResourceCollectionType
        "Get-WDResource/CollectionType"
        {
            $v = "SHARED_WITH_ME"
            break
        }

        # Amazon.WorkDocs.ResourceSortType
        "Get-WDFolderContent/Sort"
        {
            $v = "DATE","NAME"
            break
        }

        # Amazon.WorkDocs.ResourceStateType
        {
            ($_ -eq "Update-WDDocument/ResourceState") -Or
            ($_ -eq "Update-WDFolder/ResourceState")
        }
        {
            $v = "ACTIVE","RECYCLED","RECYCLING","RESTORING"
            break
        }

        # Amazon.WorkDocs.StorageType
        {
            ($_ -eq "New-WDUser/StorageRule_StorageType") -Or
            ($_ -eq "Update-WDUser/StorageRule_StorageType")
        }
        {
            $v = "QUOTA","UNLIMITED"
            break
        }

        # Amazon.WorkDocs.SubscriptionProtocolType
        "New-WDNotificationSubscription/Protocol"
        {
            $v = "HTTPS","SQS"
            break
        }

        # Amazon.WorkDocs.SubscriptionType
        "New-WDNotificationSubscription/SubscriptionType"
        {
            $v = "ALL"
            break
        }

        # Amazon.WorkDocs.UserFilterType
        "Get-WDUserList/Include"
        {
            $v = "ACTIVE_PENDING","ALL"
            break
        }

        # Amazon.WorkDocs.UserSortType
        "Get-WDUserList/Sort"
        {
            $v = "FULL_NAME","STORAGE_LIMIT","STORAGE_USED","USER_NAME","USER_STATUS"
            break
        }

        # Amazon.WorkDocs.UserType
        "Update-WDUser/Type"
        {
            $v = "ADMIN","MINIMALUSER","POWERUSER","USER","WORKSPACESUSER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WD_map = @{
    "CollectionType"=@("Get-WDResource")
    "GrantPoweruserPrivileges"=@("Update-WDUser")
    "Include"=@("Get-WDUserList")
    "Locale"=@("Update-WDUser")
    "Order"=@("Get-WDFolderContent","Get-WDUserList")
    "PrincipalType"=@("Remove-WDResourcePermission")
    "Protocol"=@("New-WDNotificationSubscription")
    "ResourceState"=@("Update-WDDocument","Update-WDFolder")
    "Sort"=@("Get-WDFolderContent","Get-WDUserList")
    "StorageRule_StorageType"=@("New-WDUser","Update-WDUser")
    "SubscriptionType"=@("New-WDNotificationSubscription")
    "Type"=@("Get-WDFolderContent","Update-WDUser")
    "VersionStatus"=@("Update-WDDocumentVersion")
    "Visibility"=@("New-WDComment")
}

_awsArgumentCompleterRegistration $WD_Completers $WD_map

$WD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WD_SelectMap = @{
    "Select"=@("Stop-WDDocumentVersionUpload",
               "Enable-WDUser",
               "Add-WDResourcePermission",
               "New-WDComment",
               "New-WDCustomMetadata",
               "New-WDFolder",
               "New-WDLabel",
               "New-WDNotificationSubscription",
               "New-WDUser",
               "Disable-WDUser",
               "Remove-WDComment",
               "Remove-WDCustomMetadata",
               "Remove-WDDocument",
               "Remove-WDDocumentVersion",
               "Remove-WDFolder",
               "Remove-WDFolderContent",
               "Remove-WDLabel",
               "Remove-WDNotificationSubscription",
               "Remove-WDUser",
               "Get-WDActivity",
               "Get-WDComment",
               "Get-WDDocumentVersionList",
               "Get-WDFolderContent",
               "Get-WDGroup",
               "Get-WDNotificationSubscriptionList",
               "Get-WDResourcePermissionList",
               "Get-WDRootFolder",
               "Get-WDUserList",
               "Get-WDCurrentUser",
               "Get-WDDocument",
               "Get-WDDocumentPath",
               "Get-WDDocumentVersion",
               "Get-WDFolder",
               "Get-WDFolderPath",
               "Get-WDResource",
               "Start-WDDocumentVersionUpload",
               "Remove-WDResourcePermission",
               "Restore-WDDocumentVersion",
               "Update-WDDocument",
               "Update-WDDocumentVersion",
               "Update-WDFolder",
               "Update-WDUser")
}

_awsArgumentCompleterRegistration $WD_SelectCompleters $WD_SelectMap
# Argument completions for service Amazon WorkLink


$WL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkLink.AuthorizationProviderType
        "Add-WLWebsiteAuthorizationProviderToFleet/AuthorizationProviderType"
        {
            $v = "SAML"
            break
        }

        # Amazon.WorkLink.IdentityProviderType
        "Update-WLIdentityProviderConfiguration/IdentityProviderType"
        {
            $v = "SAML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WL_map = @{
    "AuthorizationProviderType"=@("Add-WLWebsiteAuthorizationProviderToFleet")
    "IdentityProviderType"=@("Update-WLIdentityProviderConfiguration")
}

_awsArgumentCompleterRegistration $WL_Completers $WL_map

$WL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WL_SelectMap = @{
    "Select"=@("Register-WLDomain",
               "Add-WLWebsiteAuthorizationProviderToFleet",
               "Register-WLWebsiteCertificateAuthority",
               "New-WLFleet",
               "Remove-WLFleet",
               "Get-WLAuditStreamConfiguration",
               "Get-WLCompanyNetworkConfiguration",
               "Get-WLDevice",
               "Get-WLDevicePolicyConfiguration",
               "Get-WLDomain",
               "Get-WLFleetMetadata",
               "Get-WLIdentityProviderConfiguration",
               "Get-WLWebsiteCertificateAuthority",
               "Unregister-WLDomain",
               "Remove-WLWebsiteAuthorizationProviderFromFleet",
               "Unregister-WLWebsiteCertificateAuthority",
               "Get-WLDeviceList",
               "Get-WLDomainList",
               "Get-WLFleetList",
               "Get-WLResourceTag",
               "Get-WLWebsiteAuthorizationProviderList",
               "Get-WLWebsiteCertificateAuthorityList",
               "Restore-WLDomainAccess",
               "Revoke-WLDomainAccess",
               "Disconnect-WLUser",
               "Add-WLResourceTag",
               "Remove-WLResourceTag",
               "Update-WLAuditStreamConfiguration",
               "Update-WLCompanyNetworkConfiguration",
               "Update-WLDevicePolicyConfiguration",
               "Update-WLDomainMetadata",
               "Update-WLFleetMetadata",
               "Update-WLIdentityProviderConfiguration")
}

_awsArgumentCompleterRegistration $WL_SelectCompleters $WL_SelectMap
# Argument completions for service Amazon WorkMail


$WM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkMail.AccessControlRuleEffect
        "Write-WMAccessControlRule/Effect"
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.WorkMail.ImpersonationRoleType
        {
            ($_ -eq "New-WMImpersonationRole/Type") -Or
            ($_ -eq "Update-WMImpersonationRole/Type")
        }
        {
            $v = "FULL_ACCESS","READ_ONLY"
            break
        }

        # Amazon.WorkMail.MobileDeviceAccessRuleEffect
        {
            ($_ -eq "New-WMMobileDeviceAccessRule/Effect") -Or
            ($_ -eq "Update-WMMobileDeviceAccessRule/Effect") -Or
            ($_ -eq "Write-WMMobileDeviceAccessOverride/Effect")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.WorkMail.ResourceType
        "New-WMResource/Type"
        {
            $v = "EQUIPMENT","ROOM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WM_map = @{
    "Effect"=@("New-WMMobileDeviceAccessRule","Update-WMMobileDeviceAccessRule","Write-WMAccessControlRule","Write-WMMobileDeviceAccessOverride")
    "Type"=@("New-WMImpersonationRole","New-WMResource","Update-WMImpersonationRole")
}

_awsArgumentCompleterRegistration $WM_Completers $WM_map

$WM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WM_SelectMap = @{
    "Select"=@("Add-WMDelegateToResource",
               "Add-WMMemberToGroup",
               "Invoke-WMImpersonationRole",
               "Stop-WMMailboxExportJob",
               "New-WMAlias",
               "New-WMAvailabilityConfiguration",
               "New-WMGroup",
               "New-WMImpersonationRole",
               "New-WMMobileDeviceAccessRule",
               "New-WMOrganization",
               "New-WMResource",
               "New-WMUser",
               "Remove-WMAccessControlRule",
               "Remove-WMAlias",
               "Remove-WMAvailabilityConfiguration",
               "Remove-WMEmailMonitoringConfiguration",
               "Remove-WMGroup",
               "Remove-WMImpersonationRole",
               "Remove-WMMailboxPermission",
               "Remove-WMMobileDeviceAccessOverride",
               "Remove-WMMobileDeviceAccessRule",
               "Remove-WMOrganization",
               "Remove-WMResource",
               "Remove-WMRetentionPolicy",
               "Remove-WMUser",
               "Remove-WMFromWorkMail",
               "Remove-WMMailDomain",
               "Get-WMEmailMonitoringConfiguration",
               "Get-WMGroup",
               "Get-WMInboundDmarcSetting",
               "Get-WMMailboxExportJob",
               "Get-WMOrganization",
               "Get-WMResource",
               "Get-WMUser",
               "Remove-WMDelegateFromResource",
               "Remove-WMMemberFromGroup",
               "Get-WMAccessControlEffect",
               "Get-WMDefaultRetentionPolicy",
               "Get-WMImpersonationRole",
               "Get-WMImpersonationRoleEffect",
               "Get-WMMailboxDetail",
               "Get-WMMailDomain",
               "Get-WMMobileDeviceAccessEffect",
               "Get-WMMobileDeviceAccessOverride",
               "Get-WMAccessControlRuleList",
               "Get-WMAliasList",
               "Get-WMAvailabilityConfigurationList",
               "Get-WMMemberList",
               "Get-WMGroupList",
               "Get-WMImpersonationRoleList",
               "Get-WMMailboxExportJobList",
               "Get-WMMailboxPermissionList",
               "Get-WMMailDomainList",
               "Get-WMMobileDeviceAccessOverrideList",
               "Get-WMMobileDeviceAccessRuleList",
               "Get-WMOrganizationList",
               "Get-WMDelegateList",
               "Get-WMResourceList",
               "Get-WMResourceTag",
               "Get-WMUserList",
               "Write-WMAccessControlRule",
               "Write-WMEmailMonitoringConfiguration",
               "Write-WMInboundDmarcSetting",
               "Write-WMMailboxPermission",
               "Write-WMMobileDeviceAccessOverride",
               "Write-WMRetentionPolicy",
               "Add-WMMailDomain",
               "Register-WMToWorkMail",
               "Reset-WMPassword",
               "Start-WMMailboxExportJob",
               "Add-WMResourceTag",
               "Test-WMAvailabilityConfiguration",
               "Remove-WMResourceTag",
               "Update-WMAvailabilityConfiguration",
               "Update-WMDefaultMailDomain",
               "Update-WMImpersonationRole",
               "Update-WMMailboxQuota",
               "Update-WMMobileDeviceAccessRule",
               "Update-WMPrimaryEmailAddress",
               "Update-WMResource")
}

_awsArgumentCompleterRegistration $WM_SelectCompleters $WM_SelectMap
# Argument completions for service Amazon WorkMail Message Flow


$WMMF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WMMF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WMMF_SelectMap = @{
    "Select"=@("Get-WMMFRawMessageContent",
               "Write-WMMFRawMessageContent")
}

_awsArgumentCompleterRegistration $WMMF_SelectCompleters $WMMF_SelectMap
# Argument completions for service Amazon WorkSpaces


$WKS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkSpaces.AccessPropertyValue
        {
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeAndroid") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeChromeOs") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeIos") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeLinux") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeOsx") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeWeb") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeWindows") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeZeroClient")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.WorkSpaces.CertificateBasedAuthStatusEnum
        "Edit-WKSCertificateBasedAuthProperty/CertificateBasedAuthProperties_Status"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WorkSpaces.Compute
        {
            ($_ -eq "New-WKSWorkspaceBundle/ComputeType_Name") -Or
            ($_ -eq "Edit-WKSWorkspaceProperty/WorkspaceProperties_ComputeTypeName")
        }
        {
            $v = "GRAPHICS","GRAPHICSPRO","GRAPHICSPRO_G4DN","GRAPHICS_G4DN","PERFORMANCE","POWER","POWERPRO","STANDARD","VALUE"
            break
        }

        # Amazon.WorkSpaces.DedicatedTenancySupportEnum
        "Edit-WKSAccount/DedicatedTenancySupport"
        {
            $v = "ENABLED"
            break
        }

        # Amazon.WorkSpaces.ImageType
        "Get-WKSWorkspaceImage/ImageType"
        {
            $v = "OWNED","SHARED"
            break
        }

        # Amazon.WorkSpaces.LogUploadEnum
        "Edit-WKSClientProperty/ClientProperties_LogUploadEnabled"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WorkSpaces.ReconnectEnum
        {
            ($_ -eq "Edit-WKSClientProperty/ClientProperties_ReconnectEnabled") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_ChangeComputeType") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_IncreaseVolumeSize") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_RebuildWorkspace") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_RestartWorkspace") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_SwitchRunningMode")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WorkSpaces.RunningMode
        "Edit-WKSWorkspaceProperty/WorkspaceProperties_RunningMode"
        {
            $v = "ALWAYS_ON","AUTO_STOP","MANUAL"
            break
        }

        # Amazon.WorkSpaces.SamlStatusEnum
        "Edit-WKSSamlProperty/SamlProperties_Status"
        {
            $v = "DISABLED","ENABLED","ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK"
            break
        }

        # Amazon.WorkSpaces.TargetWorkspaceState
        "Edit-WKSWorkspaceState/WorkspaceState"
        {
            $v = "ADMIN_MAINTENANCE","AVAILABLE"
            break
        }

        # Amazon.WorkSpaces.Tenancy
        "Register-WKSWorkspaceDirectory/Tenancy"
        {
            $v = "DEDICATED","SHARED"
            break
        }

        # Amazon.WorkSpaces.WorkspaceImageIngestionProcess
        "Import-WKSWorkspaceImage/IngestionProcess"
        {
            $v = "BYOL_GRAPHICS","BYOL_GRAPHICSPRO","BYOL_GRAPHICS_G4DN","BYOL_GRAPHICS_G4DN_BYOP","BYOL_REGULAR","BYOL_REGULAR_BYOP","BYOL_REGULAR_WSP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WKS_map = @{
    "CertificateBasedAuthProperties_Status"=@("Edit-WKSCertificateBasedAuthProperty")
    "ClientProperties_LogUploadEnabled"=@("Edit-WKSClientProperty")
    "ClientProperties_ReconnectEnabled"=@("Edit-WKSClientProperty")
    "ComputeType_Name"=@("New-WKSWorkspaceBundle")
    "DedicatedTenancySupport"=@("Edit-WKSAccount")
    "ImageType"=@("Get-WKSWorkspaceImage")
    "IngestionProcess"=@("Import-WKSWorkspaceImage")
    "SamlProperties_Status"=@("Edit-WKSSamlProperty")
    "SelfservicePermissions_ChangeComputeType"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_IncreaseVolumeSize"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_RebuildWorkspace"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_RestartWorkspace"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_SwitchRunningMode"=@("Edit-WKSSelfservicePermission")
    "Tenancy"=@("Register-WKSWorkspaceDirectory")
    "WorkspaceAccessProperties_DeviceTypeAndroid"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeChromeOs"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeIos"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeLinux"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeOsx"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeWeb"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeWindows"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeZeroClient"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceProperties_ComputeTypeName"=@("Edit-WKSWorkspaceProperty")
    "WorkspaceProperties_RunningMode"=@("Edit-WKSWorkspaceProperty")
    "WorkspaceState"=@("Edit-WKSWorkspaceState")
}

_awsArgumentCompleterRegistration $WKS_Completers $WKS_map

$WKS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WKS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WKS_SelectMap = @{
    "Select"=@("Register-WKSConnectionAlias",
               "Register-WKSIpGroup",
               "Approve-WKSIpRule",
               "Copy-WKSWorkspaceImage",
               "New-WKSConnectClientAddIn",
               "New-WKSConnectionAlias",
               "New-WKSIpGroup",
               "New-WKSTag",
               "New-WKSUpdatedWorkspaceImage",
               "New-WKSWorkspaceBundle",
               "New-WKSWorkspaceImage",
               "New-WKSWorkspace",
               "Remove-WKSClientBranding",
               "Remove-WKSConnectClientAddIn",
               "Remove-WKSConnectionAlias",
               "Remove-WKSIpGroup",
               "Remove-WKSTag",
               "Remove-WKSWorkspaceBundle",
               "Remove-WKSWorkspaceImage",
               "Unregister-WKSWorkspaceDirectory",
               "Get-WKSAccount",
               "Get-WKSAccountModification",
               "Get-WKSClientBranding",
               "Get-WKSClientProperty",
               "Get-WKSConnectClientAddIn",
               "Get-WKSConnectionAlias",
               "Get-WKSConnectionAliasPermission",
               "Get-WKSIpGroup",
               "Get-WKSTag",
               "Get-WKSWorkspaceBundle",
               "Get-WKSWorkspaceDirectory",
               "Get-WKSWorkspaceImagePermission",
               "Get-WKSWorkspaceImage",
               "Get-WKSWorkspace",
               "Get-WKSWorkspacesConnectionStatus",
               "Get-WKSWorkspaceSnapshot",
               "Unregister-WKSConnectionAlias",
               "Unregister-WKSIpGroup",
               "Import-WKSClientBranding",
               "Import-WKSWorkspaceImage",
               "Get-WKSAvailableManagementCidrRangeList",
               "Start-WKSWorkspaceMigration",
               "Edit-WKSAccount",
               "Edit-WKSCertificateBasedAuthProperty",
               "Edit-WKSClientProperty",
               "Edit-WKSSamlProperty",
               "Edit-WKSSelfservicePermission",
               "Edit-WKSWorkspaceAccessProperty",
               "Edit-WKSWorkspaceCreationProperty",
               "Edit-WKSWorkspaceProperty",
               "Edit-WKSWorkspaceState",
               "Restart-WKSWorkspace",
               "Reset-WKSWorkspace",
               "Register-WKSWorkspaceDirectory",
               "Restore-WKSWorkspace",
               "Revoke-WKSIpRule",
               "Start-WKSWorkspace",
               "Stop-WKSWorkspace",
               "Remove-WKSWorkspace",
               "Update-WKSConnectClientAddIn",
               "Update-WKSConnectionAliasPermission",
               "Update-WKSRulesOfIpGroup",
               "Update-WKSWorkspaceBundle",
               "Update-WKSWorkspaceImagePermission")
}

_awsArgumentCompleterRegistration $WKS_SelectCompleters $WKS_SelectMap
# Argument completions for service Amazon WorkSpaces Web


$WSW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkSpacesWeb.EnabledType
        {
            ($_ -eq "New-WSWUserSetting/CopyAllowed") -Or
            ($_ -eq "Update-WSWUserSetting/CopyAllowed") -Or
            ($_ -eq "New-WSWUserSetting/DownloadAllowed") -Or
            ($_ -eq "Update-WSWUserSetting/DownloadAllowed") -Or
            ($_ -eq "New-WSWUserSetting/PasteAllowed") -Or
            ($_ -eq "Update-WSWUserSetting/PasteAllowed") -Or
            ($_ -eq "New-WSWUserSetting/PrintAllowed") -Or
            ($_ -eq "Update-WSWUserSetting/PrintAllowed") -Or
            ($_ -eq "New-WSWUserSetting/UploadAllowed") -Or
            ($_ -eq "Update-WSWUserSetting/UploadAllowed")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.WorkSpacesWeb.IdentityProviderType
        {
            ($_ -eq "New-WSWIdentityProvider/IdentityProviderType") -Or
            ($_ -eq "Update-WSWIdentityProvider/IdentityProviderType")
        }
        {
            $v = "Facebook","Google","LoginWithAmazon","OIDC","SAML","SignInWithApple"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WSW_map = @{
    "CopyAllowed"=@("New-WSWUserSetting","Update-WSWUserSetting")
    "DownloadAllowed"=@("New-WSWUserSetting","Update-WSWUserSetting")
    "IdentityProviderType"=@("New-WSWIdentityProvider","Update-WSWIdentityProvider")
    "PasteAllowed"=@("New-WSWUserSetting","Update-WSWUserSetting")
    "PrintAllowed"=@("New-WSWUserSetting","Update-WSWUserSetting")
    "UploadAllowed"=@("New-WSWUserSetting","Update-WSWUserSetting")
}

_awsArgumentCompleterRegistration $WSW_Completers $WSW_map

$WSW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WSW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WSW_SelectMap = @{
    "Select"=@("Register-WSWBrowserSetting",
               "Register-WSWNetworkSetting",
               "Register-WSWTrustStore",
               "Register-WSWUserAccessLoggingSetting",
               "Register-WSWUserSetting",
               "New-WSWBrowserSetting",
               "New-WSWIdentityProvider",
               "New-WSWNetworkSetting",
               "New-WSWPortal",
               "New-WSWTrustStore",
               "New-WSWUserAccessLoggingSetting",
               "New-WSWUserSetting",
               "Remove-WSWBrowserSetting",
               "Remove-WSWIdentityProvider",
               "Remove-WSWNetworkSetting",
               "Remove-WSWPortal",
               "Remove-WSWTrustStore",
               "Remove-WSWUserAccessLoggingSetting",
               "Remove-WSWUserSetting",
               "Unregister-WSWBrowserSetting",
               "Unregister-WSWNetworkSetting",
               "Unregister-WSWTrustStore",
               "Unregister-WSWUserAccessLoggingSetting",
               "Unregister-WSWUserSetting",
               "Get-WSWBrowserSetting",
               "Get-WSWIdentityProvider",
               "Get-WSWNetworkSetting",
               "Get-WSWPortal",
               "Get-WSWPortalServiceProviderMetadata",
               "Get-WSWTrustStore",
               "Get-WSWTrustStoreCertificate",
               "Get-WSWUserAccessLoggingSetting",
               "Get-WSWUserSetting",
               "Get-WSWBrowserSettingList",
               "Get-WSWIdentityProviderList",
               "Get-WSWNetworkSettingList",
               "Get-WSWPortalList",
               "Get-WSWResourceTag",
               "Get-WSWTrustStoreCertificateList",
               "Get-WSWTrustStoreList",
               "Get-WSWUserAccessLoggingSettingList",
               "Get-WSWUserSettingList",
               "Add-WSWResourceTag",
               "Remove-WSWResourceTag",
               "Update-WSWBrowserSetting",
               "Update-WSWIdentityProvider",
               "Update-WSWNetworkSetting",
               "Update-WSWPortal",
               "Update-WSWTrustStore",
               "Update-WSWUserAccessLoggingSetting",
               "Update-WSWUserSetting")
}

_awsArgumentCompleterRegistration $WSW_SelectCompleters $WSW_SelectMap
# Argument completions for service AWS X-Ray


$XR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.XRay.EncryptionType
        "Write-XREncryptionConfig/Type"
        {
            $v = "KMS","NONE"
            break
        }

        # Amazon.XRay.SamplingStrategyName
        "Get-XRTraceSummary/SamplingStrategy_Name"
        {
            $v = "FixedRate","PartialScan"
            break
        }

        # Amazon.XRay.TimeRangeType
        "Get-XRTraceSummary/TimeRangeType"
        {
            $v = "Event","TraceId"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$XR_map = @{
    "SamplingStrategy_Name"=@("Get-XRTraceSummary")
    "TimeRangeType"=@("Get-XRTraceSummary")
    "Type"=@("Write-XREncryptionConfig")
}

_awsArgumentCompleterRegistration $XR_Completers $XR_map

$XR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.XR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$XR_SelectMap = @{
    "Select"=@("Get-XRTraceBatch",
               "New-XRGroup",
               "New-XRSamplingRule",
               "Remove-XRGroup",
               "Remove-XRResourcePolicy",
               "Remove-XRSamplingRule",
               "Get-XREncryptionConfig",
               "Get-XRGroup",
               "Get-XRGroupSummary",
               "Get-XRInsight",
               "Get-XRInsightEvent",
               "Get-XRInsightImpactGraph",
               "Get-XRInsightSummary",
               "Get-XRSamplingRule",
               "Get-XRSamplingStatisticSummary",
               "Get-XRSamplingTarget",
               "Get-XRServiceGraph",
               "Get-XRTimeSeriesServiceStatistic",
               "Get-XRTraceGraph",
               "Get-XRTraceSummary",
               "Get-XRResourcePolicyList",
               "Get-XRResourceTag",
               "Write-XREncryptionConfig",
               "Write-XRResourcePolicy",
               "Write-XRTelemetryRecord",
               "Write-XRTraceSegment",
               "Add-XRResourceTag",
               "Remove-XRResourceTag",
               "Update-XRGroup",
               "Update-XRSamplingRule")
}

_awsArgumentCompleterRegistration $XR_SelectCompleters $XR_SelectMap


$AWS_RegionCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	$regionHash = @{ }

    # Similar to Get-AWSRegion
	$regions = [Amazon.RegionEndpoint]::EnumerableAllRegions
	foreach ($r in $regions)
	{
		$regionHash.Add($r.SystemName, $r.DisplayName)
	}

	$regionHash.Keys |
	Sort-Object |
	Where-Object { $_ -like "$wordToComplete*" } |
	ForEach-Object {
		New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $regionHash[$_]
	}
}

_awsArgumentCompleterRegistration $AWS_RegionCompleter @{ "Region"=@() }

$AWS_ProfileNameCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	# allow for new user with no profiles set up yet
	$profiles = Get-AWSCredentials -ListProfileDetail | select -expandproperty ProfileName
	if ($profiles)
	{
		$profiles |
		Sort-Object |
		Where-Object { $_ -like "$wordToComplete*" } |
		ForEach-Object {
			New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_
		}
	}
}

_awsArgumentCompleterRegistration $AWS_ProfileNameCompleter @{ "ProfileName"=@() }
$AWS_EC2ImageByNameCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	$keys = [Amazon.EC2.Util.ImageUtilities]::ImageKeys

	$keys |
	Sort-Object -Descending |
	Where-Object { $_ -like "$wordToComplete*" } |
	ForEach-Object {
		New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_
	}
}

_awsArgumentCompleterRegistration $AWS_EC2ImageByNameCompleter @{ "Name"=@("Get-EC2ImageByName") }

# The attribute name parameter for EC2 apis such as ModifyImageAttribute is modeled as a string
# in the service model rather than an enum type, which means by default we cannot auto-generate
# an argument completer. Api's use as DescribeImageAttribute do use an enum type (ImageAttributeName)
# and so don't have this problem.
$AWS_EC2ImageAttributeCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Taken from Amazon.EC2.ImageAttributeName
        "Edit-EC2ImageAttribute/Attribute"
        {
            $v = "description","kernel","ramdisk","launchPermission","productCodes","blockDeviceMapping","sriovNetSupport"
            break
        }
    }

    $v |
    Where-Object { $_ -like "$wordToComplete*" } |
    ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

_awsArgumentCompleterRegistration $AWS_EC2ImageAttributeCompleter @{ "Attribute"=@("Edit-EC2ImageAttribute") }